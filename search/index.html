<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="Search - https://lovemjh.vercel.app/search/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>Search</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    <link rel="stylesheet" href="https://lovemjh.vercel.app/style.min.ef012369a26adc2a21396230b3395dfcd5975a3082a65b82785cbc0b446f2a2c.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate cool">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"hasFoldAllCodeBlocks": false,
		"svgColor": "#6c757d",
		"en": false,
		"dark": false
	}
</div>
    <h1 class="title">
        
            搜索
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill=#6c757d p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill=#6c757d></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill=#6c757d></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill=#6c757d p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill=#6c757d p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill=#6c757d p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill=#6c757d p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill=#6c757d></path></svg></a></div>
        
    </div>

    
</div>

    
    
</div>
</div>
        <div id="content">












<div class="container-main 
     container-search 
    ">

    <div class="desc">
        
    </div>
    
    <div class="toc">
        
        <nav id="TableOfContents"></nav>
    </div>

    <div class='content  content '>
        
    </div>

    <div class="container-search">
    <div id="data" style="display: none;">
        
            
                [{"content":"刷入debian 系统介绍 内核版本5.18.0 微调了cpu频率，最大1.36ghz(性能提升一般) 将板子置于fastboot模式下，运行flash.bat即可刷入 boot镜像适用于ufi001w/qrzl903主板 加入了sim卡槽切换支持，使用systemctl enable sim1/esim1 重启后即可切换卡槽 加入了modem支持(由于放入错误的modem固件会导致cpu异常发热，所以没有放固件，固件请自行从non-hlos.bin中提取后放到/lib/firmware下) 加入了wifi支持，sudo nmtui即可管理 加入了usb rndis、usb虚拟串口设备与usb存储设备支持，刷入后插上电脑出现一个u盘，使用里面的putty工具连接虚拟串口即可登录系统 加入了开机自动扩容支持 加入了ssh支持，apt源已配置为清华源，系统语言环境已配置为中文，时区配置至cst 加入了带cpu温度显示的htop支持，sudo htop即可查看当前系统状态 用户名ufi，密码ufi，已启用sudo sudo passwd\n配置交换分区 创建交换空间文件 在此教程中，我们将创建2 gb大小的交换空间文件。如果要添加更多交换空间，请将2g替换为你所需交换空间的大小。 创建一个指定大小文件的方式在debian 9中有两种，分别fallocate和dd命令。但是可使用你喜欢创建文件的方式创建交换空间文件， fallocate和dd命令都可以帮助快速创建指定大小的文件，fallocate比dd命令更易于理解。具体选择取决于你。 如果您的系统上没有fallocate命令，或者您收到一条错误消息，提示fallocate failed: operation not supported操作不支持。 你可使用dd命令创建swap交换空间文件。以下fallocate和dd命令将会在你debian 9 linux的根目录中创建交换空间文件swapfile，大小是2g。\nsudo fallocate -l 2g /swapfile sudo dd if=/dev/zero of=/swapfile bs=1024 count=2097152 默认交换空间文件的权限只有root用户才能写入和读取交换文件的数据。因此我们需要修改交换空间文件的权限为600。\n在linux中可使用chmod修改文件权限，除此之外你还需要格式化交换空间的文件。交换空间文件所使用的文件系统与普通文件系统不一样，\n交换空间它有自己的文件系统格式和专用个格式化工具mkswap。以下命令将修改交换空间文件的权限为600，并使用mkswap格式化文件：\nsudo chmod 600 /swapfile sudo mkswap /swapfile 启用交换空间 当你格式化完成后，为了让系统识别交换空间文件，因此还需要手动启用交换空间文件。\n在debian 9 linux中你可以使用swapon命令启用交换空间文件，它将会在自动挂载到系统中。运行以下swapon命令启用交换空间\nsudo swapon /swapfile swapon命令启用交换空间仅此次会话可用，重启后将不会自动挂载。为了让交换空间永久启用，并在开机启动时自动挂载。\n要在linux系统启动时自动挂载分区，你需要在/etc/fstab文件中定义挂载配置选项。\n/etc/fstab文件存储着文件系统的静态挂载信息，可用于定义磁盘分区，各种其他块设备或远程文件系统，告知linux内核如何在挂载这些设备文件。\n以下命令使用echo，tee命令以及管道追加行/swapfile swap swap defaults 0 0到将/etc/fstab文件文件：\necho \u0026#34;/swapfile swap swap defaults 0 0\u0026#34; | sudo tee -a /etc/fstab 当计算机在重启时，交换空间将会自动启用。通过使用swapon或free命令验证交换空间是否处于活动状态。\nsudo swapon --show sudo free -h swappiness swappiness是一个linux内核属性，用于定义系统使用交换空间的频率。swappiness可以是0到100之间的值。\nswappiness=0的时候表示最大限度使用物理内存，然后才是swap空间，swappiness＝100的时候表示积极的使用交换空间。\n如果你不能确定该值大小，请参考我们的教程：linux性能：为什么你应该添加交换空间swap和空闲内存与可用内存的区别。\nlinux的初始默认设置为60， 你可以使用[cat](https://www.myfreax.com/linux-cat-command/) /proc/sys/vm/swappiness命令查看当前swappiness值的大小。\n如果你需要对swappiness的值作出更改，请运行sudo sysctl -w vm.swappiness=10命令。\nsysctl命令用于在运行时配置linux内核的参数，更改仅在当前会话中可用，即重启会恢复为默认值。\n为让swappiness的值持久化，则需要将值写入到/etc/sysctl.conf文件中。sysctl.conf是linux内核的配置文件。在linux内核启动是将会次配置文件的参数。\n运行以下命令持久化linux内核参数swappiness的值：\necho \u0026#34;/swapfile swap swap defaults 0 0\u0026#34; | sudo tee -a /etc/sysctl.conf 删除交换空间 如果你因某些原因需要关闭并且删除交换文件。你必须首先使用swapoff命令关闭交换空间。\n如果你的交换空间文件还启用fstab方式的自动挂载，你还需要删除/etc/fstab文件中定义的自动挂载配置。\nsudo swapoff -v /swapfile 接着，使用你喜欢的编辑器打开文件/etc/fstab，并移除行定义交换空间自动挂载的行。在本教程中，我们将使用vim命令打开文件。\nsudo vim /etc/fstab 最后保存并退出。最后的一步是使用命令删除交换空间文件。你将使用rm命令删除文件：sudo rm /swapfile\n结论 我们向您展示了如何在debian 9系统上创建交换文件以及激活和配置交换空间。如果您遇到问题或有反馈，请在下面发表评论。\n增加开机自启脚本 在低版本的debian系linux系统中，增加开机自启脚本比较简单，直接修改/etc/rc.local文件，在exit 0之前增加需要运行的脚本即可。但是现在在高版本的linux中默认没有开启该功能，接下来我们通过设置来开启该功能。\n首先，我们到/lib/systemd/system目录下\ncd /lib/systemd/system 在该目录下，可以发现有个rc-local.service文件，使用文本编辑器，在最后加上下列信息即可。\n[install] wantedby=multi-user.target 由于没有/etc/rc.local文件，所以我们需要手动创建它，并写入以下信息\n#!/bin/sh -e # 在这里输入需要自启的脚本 exit 0 创建完成后需要给其赋予运行权限\nsudo chmod +x /etc/rc.local 启动该服务\nsudo systemctl enable rc-local # 启用 sudo systemctl start rc-local.service # 开始运行 sudo systemctl status rc-local.service # 查看状态 这个时候，我们的开机自启服务就完成了。\ndocker环境配置 连接wifi sudo nmtui\n选2 连接wifi 选不了wifi 卧槽 请你大声说操你妈 sim 取出来就能 连wifi了 真尼玛神奇\n更新apt sudo apt-get update\n安装docker 安装命令如下： curl -fssl https://get.docker.com | bash -s docker --mirror aliyun\n也可以使用国内 daocloud 一键安装命令： curl -ssl https://get.daocloud.io/docker | sh\n以上二选一即可\n建议docker开机自启 systemctl enable docker\n启动docker systemctl start docker\ndocker可视化管理器\n将已经集成好的docker可视化管理下载下来，在服务器上运行即可。命令如下：\ndocker run --restart always -p 8081:8081 -d -v /var/run/docker.sock:/var/run/docker.sock -v /etc/docker/:/etc/docker/ wangbinxingkong/fast:latest\ndocker切换源\n千次阅读\n2019-05-08 16:46:25\n创建或修改 /etc/docker/daemon.json 文件，修改为如下形式\n# vi /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;http://hub-mirror.c.163.com\u0026#34;] } systemctl restart docker.service 国内加速地址有：\ndocker中国区官方镜像\nhttps://registry.docker-cn.com\n网易\nhttp://hub-mirror.c.163.com\nustc https://docker.mirrors.ustc.edu.cn\n中国科技大学\nhttps://docker.mirrors.ustc.edu.cn\n阿里云容器 服务\nhttps://cr.console.aliyun.com/\n首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址，类似于“https://1234abcd.mirror.aliyuncs.com”\n青龙面板安装 docker pull whyour/qinglong:latest\n","date":"2022-08-07","permalink":"https://lovemjh.vercel.app/posts/blog/20220807155029/","summary":"刷入Debian 系统介绍 内核版本5.18.0 微调了CPU频率，最大1.36GHz(性能提升一般) 将板子置于fastboot模式下，运行flash.bat即可刷入","title":"ufi001b刷入debian部署青龙"},{"content":"路径修改 默认转换路径 hugo 静态站点生成器不支持文件的相对链接。相反，它希望您使用[ 和短代码]链接到其他页面。ref``relref\n因此，使用黑曜石导出从黑曜石导出的笔记无法开箱即用，因为 hugo 无法正确解析这些链接。\nmarkdown 渲染钩子（仅使用默认渲染器支持）允许您解决此问题，但是，在进行一些一次性设置工作后，使导出的笔记与 hugo 一起使用。goldmark\n创建包含以下内容的文件：\n对于文件：layouts/_default/_markup/render-link.html\n{{- $url := urls.parse .destination -}} {{- $scheme := $url.scheme -}} \u0026lt;a href=\u0026#34; {{- if eq $scheme \u0026#34;\u0026#34; -}} {{- if strings.hassuffix $url.path \u0026#34;.md\u0026#34; -}} {{- relref .page .destination | safeurl -}} {{- else -}} {{- .destination | safeurl -}} {{- end -}} {{- else -}} {{- .destination | safeurl -}} {{- end -}}\u0026#34; {{- with .title }} title=\u0026#34;{{ . | safehtml }}\u0026#34;{{- end -}}\u0026gt; {{- .text | safehtml -}} \u0026lt;/a\u0026gt; {{- /* whitespace stripped here to avoid trailing newline in rendered result caused by file eol */ -}} 对于图像：layouts/_default/_markup/render-image.html\n{{- $url := urls.parse .destination -}} {{- $scheme := $url.scheme -}} \u0026lt;img src=\u0026#34; {{- if eq $scheme \u0026#34;\u0026#34; -}} {{- if strings.hassuffix $url.path \u0026#34;.md\u0026#34; -}} {{- relref .page .destination | safeurl -}} {{- else -}} {{- printf \u0026#34;/%s%s\u0026#34; .page.file.dir .destination | safeurl -}} {{- end -}} {{- else -}} {{- .destination | safeurl -}} {{- end -}}\u0026#34; {{- with .title }} title=\u0026#34;{{ . | safehtml }}\u0026#34;{{- end -}} {{- with .text }} alt=\u0026#34;{{ . | safehtml }}\u0026#34; {{- end -}} /\u0026gt; {{- /* whitespace stripped here to avoid trailing newline in rendered result caused by file eol */ -}} 有了这些钩子，指向笔记和文件附件的链接现在应该可以正常工作。 注意：如果您使用的是带有自己的渲染钩子的主题，则可能需要做一些额外的工作，或自定义上面的片段，以避免与主题中的钩子发生冲突。\n修改后的路径 由于windows 获取到的路径\\是这样的，而url是/这样的，所以上面的方式不起作用。 参考hugopath.dir | hugo (gohugo.io)官方文档， 做出修改，获得以下内容\n对于文件\n{{- $url := urls.parse .destination -}} {{- $scheme := $url.scheme -}} {{- $str := .page.file.dir -}} {{- $path := path.dir $str -}} \u0026lt;a href=\u0026#34; {{- if eq $scheme \u0026#34;\u0026#34; -}} {{- if strings.hassuffix $url.path \u0026#34;.md\u0026#34; -}} {{- relref .page .destination | safeurl -}} {{- else -}} {{- printf \u0026#34;/%s/%s\u0026#34; $path .destination | safeurl -}} {{- end -}} {{- else -}} {{- .destination | safeurl -}} {{- end -}}\u0026#34; {{- with .title }} title=\u0026#34;{{ . | safehtml }}\u0026#34;{{- end -}}\u0026gt; {{- .text | safehtml -}} \u0026lt;/a\u0026gt; {{- /* whitespace stripped here to avoid trailing newline in rendered result caused by file eol */ -}} 对于图像\n{{- $url := urls.parse .destination -}} {{- $scheme := $url.scheme -}} {{- $str := .page.file.dir -}} {{- $path := path.dir $str -}} \u0026lt;img src=\u0026#34; {{- if eq $scheme \u0026#34;\u0026#34; -}} {{- if strings.hassuffix $url.path \u0026#34;.md\u0026#34; -}} {{- relref .page .destination | safeurl -}} {{- else -}} {{- printf \u0026#34;/%s/%s\u0026#34; $path .destination | safeurl -}} {{- end -}} {{- else -}} {{- .destination | safeurl -}} {{- end -}}\u0026#34; {{- with .title }} title=\u0026#34;{{ . | safehtml }}\u0026#34;{{- end -}} {{- with .text }} alt=\u0026#34;{{ . | safehtml }}\u0026#34; {{- end -}} /\u0026gt; {{- /* whitespace stripped here to avoid trailing newline in rendered result caused by file eol */ -}} 懒加载策略 参考主题hugo-theme-stack 中的懒加载策略\n对于文件：layouts/_default/_markup/render-link.html\n\u0026lt;a class=\u0026#34;link\u0026#34; href=\u0026#34;{{ .destination | safeurl }}\u0026#34; {{ with .title}} title=\u0026#34;{{ . }}\u0026#34; {{ end }}{{ if strings.hasprefix .destination \u0026#34;http\u0026#34; }} target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34; {{ end }}\u0026gt;{{ .text | safehtml }}\u0026lt;/a\u0026gt; 对于图像：layouts/_default/_markup/render-image.html\n{{- $image := .page.resources.getmatch (printf \u0026#34;%s\u0026#34; (.destination | safeurl)) -}} {{- $permalink := .destination | relurl | safeurl -}} {{- $alt := .plaintext | safehtml -}} {{- $width := 0 -}} {{- $height := 0 -}} {{- $srcset := \u0026#34;\u0026#34; -}} {{/* svg and external images won\u0026#39;t work with gallery layout, because their width and height attributes are unknown */}} {{- $galleryimage := false -}} {{- if $image -}} {{- $notsvg := ne (path.ext .destination) \u0026#34;.svg\u0026#34; -}} {{- $permalink = $image.relpermalink -}} {{- if $notsvg -}} {{- $width = $image.width -}} {{- $height = $image.height -}} {{- $galleryimage = true -}} {{- if (default true .page.site.params.imageprocessing.content.enabled) -}} {{- $small := $image.resize `480x` -}} {{- $big := $image.resize `1024x` -}} {{- $srcset = printf `%s 480w, %s 1024w` $small.relpermalink $big.relpermalink -}} {{- end -}} {{- end -}} {{- end -}} \u0026lt;img src=\u0026#34;{{ $permalink }}\u0026#34; {{ with $width }}width=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $height }}height=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $srcset }}srcset=\u0026#34;{{ . }}\u0026#34;{{ end }} loading=\u0026#34;lazy\u0026#34; {{ with $alt }} alt=\u0026#34;{{ . }}\u0026#34; {{ end }} {{ if $galleryimage }} class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;{{ div (mul $image.width 100) $image.height }}\u0026#34; data-flex-basis=\u0026#34;{{ div (mul $image.width 240) $image.height }}px\u0026#34; {{ end }} \u0026gt; 最终得到懒加载和路径修改后的 对于文件：layouts/_default/_markup/render-link.html\n{{- $str := .page.file.dir -}} {{- $path := path.dir $str -}} \u0026lt;a class=\u0026#34;link\u0026#34; href=\u0026#34;{{ printf \u0026#34;/%s/%s\u0026#34; $path .destination | safeurl }}\u0026#34; {{ with .title}} title=\u0026#34;{{ . }}\u0026#34; {{ end }}{{ if strings.hasprefix .destination \u0026#34;http\u0026#34; }} target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34; {{ end }}\u0026gt;{{ .text | safehtml }}\u0026lt;/a\u0026gt; 对于图像：layouts/_default/_markup/render-image.html\n{{- $str := .page.file.dir -}} {{- $path := path.dir $str -}} {{- $image := .page.resources.getmatch (printf \u0026#34;%s\u0026#34; (.destination | safeurl)) -}} {{- $permalink := printf \u0026#34;/%s/%s\u0026#34; $path .destination | relurl | safeurl -}} {{- $alt := .plaintext | safehtml -}} {{- $width := 0 -}} {{- $height := 0 -}} {{- $srcset := \u0026#34;\u0026#34; -}} {{/* svg and external images won\u0026#39;t work with gallery layout, because their width and height attributes are unknown */}} {{- $galleryimage := false -}} {{- if $image -}} {{- $notsvg := ne (path.ext .destination) \u0026#34;.svg\u0026#34; -}} {{- $permalink = $image.relpermalink -}} {{- if $notsvg -}} {{- $width = $image.width -}} {{- $height = $image.height -}} {{- $galleryimage = true -}} {{- if (default true .page.site.params.imageprocessing.content.enabled) -}} {{- $small := $image.resize `480x` -}} {{- $big := $image.resize `1024x` -}} {{- $srcset = printf `%s 480w, %s 1024w` $small.relpermalink $big.relpermalink -}} {{- end -}} {{- end -}} {{- end -}} \u0026lt;img src=\u0026#34;{{ $permalink }}\u0026#34; {{ with $width }}width=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $height }}height=\u0026#34;{{ . }}\u0026#34;{{ end }} {{ with $srcset }}srcset=\u0026#34;{{ . }}\u0026#34;{{ end }} loading=\u0026#34;lazy\u0026#34; {{ with $alt }} alt=\u0026#34;{{ . }}\u0026#34; {{ end }} {{ if $galleryimage }} class=\u0026#34;gallery-image\u0026#34; data-flex-grow=\u0026#34;{{ div (mul $image.width 100) $image.height }}\u0026#34; data-flex-basis=\u0026#34;{{ div (mul $image.width 240) $image.height }}px\u0026#34; {{ end }} \u0026gt; 文件\n","date":"2022-07-13","permalink":"https://lovemjh.vercel.app/posts/blog/20220713223482/","summary":"路径修改 默认转换路径 Hugo 静态站点生成器不支持文件的相对链接。相反，它希望您使用[ 和短代码]链接到其他页面。ref``relref 因此，使用黑曜石导出从黑曜石导出的","title":"hugo图片和链接的问题"},{"content":"第七章 题库微信小程序端功能开发 优就业.java教研室 学习目标 了解 微信小程序项目创建及初始化配置 掌握用户登录注册功能开发 掌握题库分类功能开发 掌握题库列表功能开发 掌握题目详情功能开发 掌握内网穿透 一、项目创建及初始化配置 1.1、创建项目 新建项目优学题库，开发模式选择 小程序， 语言 选中 javascript 创建好的项目结构及目录 1.2、拷贝相关样式、配图等静态资源 把样式、配图等静态资源拷贝到项目的根目录 拷贝后目录 1.3、配置基础样式 修改app.wxss\n/**app.wxss**/ /**app.wxss**/ @import \u0026#34;colorui/main.wxss\u0026#34;; @import \u0026#34;colorui/icon.wxss\u0026#34;; .container { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box; } .text-row { display: flex; flex-direction: row; align-items: center; } .text-column { display: flex; flex-direction: column; align-items: center; } .scrollpage { height: 100vh; -webkit-overflow-scrolling: touch; } .page_bottom { position:fixed; width: 100%; height: 50px; bottom: 0px; display: flex; color: black; text-align: center; font-size: 20px; } .page_bottom_left { position: fixed; left: 0px; bottom: 0px; width: 58px; height: 48px; line-height: 49px; border: 1px solid; border-color: #000; border-right-color: #888; } .page_bottom_msg { position: fixed; left: 70px; bottom: 0px; width: 120px; height: 25px; line-height: 24px; font-size: 19px; text-align:left; } .page_bottom_star { position: fixed; right: 125px; bottom: 0px; width: 25px; height: 25px; font-size: 19px; line-height: 24px; } .page_bottom_last { position: fixed; right: 60px; bottom: 0px; width: 58px; height: 48px; line-height: 49px; border: 1px solid; border-color: #000; border-left-color: #888; } .page_bottom_next { position: fixed; right: 0px; bottom: 0px; width: 58px; height: 48px; line-height: 49px; border: 1px solid; border-color: #000; border-left-color: #888; } 1.4、配置和后端服务接口调用地址 修改配置文件app.js\nglobaldata: { userinfo: null, baseurl: \u0026#34;http://localhost:8888/wx\u0026#34; } baseurl地址即为和后端服务器接口调用地址\n1.5、创建对应的页面 修改配置文件app.json，修改对应的pages数组，修改内容如下：\n\u0026#34;pages/account/account\u0026#34;, \u0026#34;pages/register/register\u0026#34;, \u0026#34;pages/index/index\u0026#34;, \u0026#34;pages/type/type\u0026#34;, \u0026#34;pages/item/item\u0026#34;, \u0026#34;pages/info/info\u0026#34; 注意默认主页为登录页面！\n页面设计规划功能如下：\n页面名称 页面路径 说明 登录页面 pages/account/account 账号登录，在tabbar有定义（默认主页） 注册页面 pages/register/register 账号注册 用户信息 pages/index/index 获取用户微信账号 ，tabbar有定义 题库分类 pages/type/type 获取题库分类 具体分类实体列表页 pages/item/item 显示选定分类的试题列表 题目详情页面 pages/info/info 显示题目详情信息 配置好，保存，即可自动生成对应的页面！ 1.6、配置tabbar 修改配置文件app.json\n\u0026#34;tabbar\u0026#34;:{ \u0026#34;color\u0026#34;: \u0026#34;#dbdbdb\u0026#34;, \u0026#34;selectedcolor\u0026#34;: \u0026#34;#1296db\u0026#34;, \u0026#34;backgroundcolor\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;borderstyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;list\u0026#34;: [{ \u0026#34;pagepath\u0026#34;:\u0026#34;pages/account/account\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;img/login.png\u0026#34;, \u0026#34;selectediconpath\u0026#34;: \u0026#34;img/login-select.png\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;登录\u0026#34; },{ \u0026#34;pagepath\u0026#34;:\u0026#34;pages/type/type\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;img/icon_component.png\u0026#34;, \u0026#34;selectediconpath\u0026#34;: \u0026#34;img/icon_component_hl.png\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;题库分类\u0026#34; },{ \u0026#34;pagepath\u0026#34;:\u0026#34;pages/index/index\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;img/user.png\u0026#34;, \u0026#34;selectediconpath\u0026#34;: \u0026#34;img/user-select.png\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;我的信息\u0026#34; }] }, tabbar效果： 二、用户登录注册功能开发 2.1、创建用户登录页面 2.1.1、修改页面文件：pages\\account\\account.wxml \u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;login-icon\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;login-img\u0026#34; src=\u0026#34;../../img/loginlogo.png\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;login-from\u0026#34;\u0026gt; \u0026lt;!--账号--\u0026gt; \u0026lt;view class=\u0026#34;inputview\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;nameimage\u0026#34; src=\u0026#34;../../img/name.png\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;label class=\u0026#34;loginlab\u0026#34;\u0026gt;账号\u0026lt;/label\u0026gt; \u0026lt;input class=\u0026#34;inputtext\u0026#34; placeholder=\u0026#34;请输入账号\u0026#34; bindinput=\u0026#34;usernameinput\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;line\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;!--密码--\u0026gt; \u0026lt;view class=\u0026#34;inputview\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;keyimage\u0026#34; src=\u0026#34;../../img/key.png\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;label class=\u0026#34;loginlab\u0026#34;\u0026gt;密码\u0026lt;/label\u0026gt; \u0026lt;input class=\u0026#34;inputtext\u0026#34; password=\u0026#34;true\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; bindinput=\u0026#34;passwordinput\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;!--按钮--\u0026gt; \u0026lt;view class=\u0026#34;loginbtnview\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;loginbtn\u0026#34; type=\u0026#34;primary\u0026#34; bindtap=\u0026#34;login\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view\u0026gt; \u0026lt;button class=\u0026#34;loginbtn\u0026#34; type=\u0026#34;primary\u0026#34; \u0026gt;开始注册\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; 2.1.2、修改页面样式文件：pages\\account\\account.wxss page{ height: 100%; } .container { height: 100%; display: flex; flex-direction: column; padding: 0; box-sizing: border-box; /* background-color: rgb(156, 23, 78) */ } /*登录图片*/ .login-icon{ flex: none; } .login-img{ width: 750rpx; } /*表单内容*/ .login-from { margin-top: 20px; flex: auto; height:100%; } .inputview { /* background-color: #fff; */ line-height: 45px; border-radius:20px; border:1px solid #999999; } /*输入框*/ .nameimage, .keyimage { margin-left: 22px; width: 18px; height: 16px } .loginlab { margin: 15px 15px 15px 10px; color: #545454; font-size: 14px } .inputtext { flex: block; float: right; text-align: right; margin-right: 22px; margin-top: 11px; color: #cccccc; font-size: 14px } .line { margin-top: 8px; } /* .line { width: 100%; height: 1px; background-color: #cccccc; margin-top: 1px; } */ /*按钮*/ .loginbtnview { width: 100%; height: auto; /* background-color:#dcdcdc; */ margin-top: 0px; margin-bottom: 0px; padding-bottom: 0px; } .loginbtn { width: 90%; margin-top: 40px; border-radius:10px; } .operate{ display: flex; flex-direction: row; } .operate view{ margin: 0 auto; margin-top: 40px; font-size: 14px; color: #333333; } 2.1.3、登录页面运行效果： 2.2、创建用户注册页面 2.2.1、修改页面文件：pages\\register\\register.wxml \u0026lt;!--pages/register/register.wxml--\u0026gt; \u0026lt;form bindsubmit=\u0026#34;formsubmit\u0026#34; bindreset=\u0026#34;formreset\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;content\u0026#34; \u0026gt; \u0026lt;view class=\u0026#34;items\u0026#34;\u0026gt; 欢迎{{userinfo.nickname}}注册优学刷题系统 \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; placeholder=\u0026#34;请设置4-20位用户名\u0026#34; placeholder-class=\u0026#34;holder\u0026#34; bingblur=\u0026#34;accountblur\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;item flex\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; password name=\u0026#34;password\u0026#34; placeholder=\u0026#34;请设置5-20位登录密码\u0026#34; placeholder-class=\u0026#34;holder\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;nickname\u0026#34; placeholder=\u0026#34;昵称\u0026#34; placeholder-class=\u0026#34;holder\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;phone\u0026#34; placeholder=\u0026#34;手机号\u0026#34; placeholder-class=\u0026#34;holder\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;mobileinfo\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;mobile\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34; placeholder=\u0026#34;请输入邮箱\u0026#34; placeholder-class=\u0026#34;holder\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;items\u0026#34;\u0026gt; 性别: \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;birth\u0026#34; placeholder=\u0026#34;生日(1979-12-20)\u0026#34; placeholder-class=\u0026#34;holder\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;city\u0026#34; placeholder=\u0026#34;通信地址\u0026#34; placeholder-class=\u0026#34;holder\u0026#34;/\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;button class=\u0026#34;btn\u0026#34; form-type=\u0026#34;submit\u0026#34;\u0026gt;注册\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/form\u0026gt; 2.2.2、修改页面样式文件：pages\\register\\register.wxss /* pages/company/company.wxss */ .content{ width: 100%; height: 700px; background-color: #f2f2f2; } .hr{ padding-top: 40px; } .item{ margin: 0 auto; border: 1px solid #cccccc; height: 40px; width: 90%; border-radius: 3px; background-color: #ffffff; margin-bottom: 15px; } .items{ margin: 0 auto; border: 1px solid #cccccc; height: 40px; width: 90%; border-radius: 3px; margin-bottom: 15px; } .item input{ height: 40px; line-height: 40px; margin-left: 10px; } .holder{ font-size: 14px; color: #999999; } .flex{ display: flex; flex-direction: row; } .flex input{ width: 300px; } item switch{ margin-top: 5px; margin-right: 5px; } .mobileinfo{ display: flex; flex-direction: row; } .mobile{ margin: 0 auto; border: 1px solid #cccccc; height: 40px; width: 90%; border-radius: 3px; background-color: #ffffff; margin-bottom: 15px; display: flex; flex-direction: row; margin-left: 5%; } .mobile input{ margin-top: 8px; margin-left: 10px; } .code{ border: 1px solid #cccccc; height: 40px; width: 35%; background-color: #edeeec; border-radius: 3px; text-align: center; margin-left: 10px; line-height: 40px; color: #999999; font-size: 15px; margin-bottom: 15px; margin-right: 5%; } .btn{ width: 90%; color: #999999; margin-top: 40px; } 2.2.3、配置从用户登录页面点击注册按钮，跳转到用户注册页面 2.2.3.1、修改pages\\account\\account.js 定义获取应用实例\n//获取应用实例 const app = getapp() 增加获取用户信息方法，跳转到注册页面方法\nhttps://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getuserprofile.html\ngetuserprofile(e) { // 推荐使用wx.getuserprofile获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认 // 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗 wx.getuserprofile({ desc: \u0026#39;用于完善会员资料\u0026#39;, // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写 success: (res) =\u0026gt; { console.log(res.userinfo) //设置全局属性 app.globaldata.userinfo = res.userinfo //跳转到注册页码 this.register() } }) }, //注册跳转 register:function(){ //跳转到注册页面 wx.redirectto({ url: \u0026#39;../register/register\u0026#39;, }) } 2.2.3.2、修改pages\\account\\account.wxml页面\n修改页面上的注册按钮，触发调用获取用户信息方法，然后跳转到注册页面\n\u0026lt;button class=\u0026#34;loginbtn\u0026#34; type=\u0026#34;primary\u0026#34; bindtap=\u0026#34;getuserprofile\u0026#34;\u0026gt;开始注册\u0026lt;/button\u0026gt; 注意：用户点击该按钮时，会返回获取到的用户信息 2.2.4、配置在注册页面获取到微信用户信息 2.2.4.1、修改pages\\register\\register.js 定义获取应用实例\n//获取应用实例 const app = getapp() 修改生命周期函数\u0026ndash;监听页面加载 onload 增加获取微信用户信息方法\n/** * 生命周期函数--监听页面加载 */ onload: function (options) { //从全局变量获取用户信息 if (app.globaldata.userinfo) { console.log(app.globaldata.userinfo) this.setdata({ userinfo: app.globaldata.userinfo }) } } 设置性别数据：\ndata: { //设置性别选择数据 sex: [{ id: 1, value: \u0026#39;男\u0026#39; }, { id: 0, value: \u0026#39;女\u0026#39; }] }, 修改register.wxml增加显示性别\n\u0026lt;view class=\u0026#34;items\u0026#34;\u0026gt; 性别: \u0026lt;radio-group class=\u0026#34;radio-group\u0026#34; bindchange=\u0026#34;radiochange\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;radio\u0026#34; wx:for=\u0026#34;{{sex}}\u0026#34; wx:key=\u0026#34;key\u0026#34;\u0026gt; \u0026lt;radio value=\u0026#34;{{item.id}}\u0026#34; checked=\u0026#34;{{item.checked}}\u0026#34;/\u0026gt;{{item.value}} \u0026lt;/label\u0026gt; \u0026lt;/radio-group\u0026gt; \u0026lt;/view\u0026gt; 修改register.js增加性别选择处理方法radiochange\n/** * * 捕获单选框的选中值 */ radiochange: function(e){ console.log(\u0026#39;radio发生change事件，携带value值为：\u0026#39;, e.detail.value) //设置性别值给本地变量 this.setdata({ gender: e.detail.value }) } 2.2.5、测试运行效果： 在登录页面点击 注册 按钮，即可弹出获取微信用户信息是否允许窗口，选择允许，即可跳转到注册页面 注册页面： 2.3、完成用户注册 2.3.1、修改pages\\register\\register.js formsubmit: function(e) { console.log(\u0026#39;表单被提交\u0026#39;) var that= e.detail.value let baseurl = app.globaldata.baseurl; wx.request({ url: baseurl+\u0026#39;/member/member/save\u0026#39;, method:\u0026#39;post\u0026#39;, header:{\u0026#39;content-type\u0026#39;:\u0026#39;application/json\u0026#39;}, data:{ username: that.username, password: that.password, nickname: that.nickname, phone: that.phone, email: that.email, gender:this.data.gender,//从本地变量获取性别 birth: that.birth, city: that.city }, success:function(res){ console.log(res); if(res.data.code==0){ console.log(\u0026#34;注册成功\u0026#34;) wx.showtoast({ title: \u0026#34;注册成功\u0026#34;, icon: \u0026#39;none\u0026#39;, duration: 1000, success:function(){ console.log(\u0026#39;haha\u0026#39;); settimeout(function () { //要延时执行的代码 wx.switchtab({ url: \u0026#39;../account/account\u0026#39; }) }, 1000) //延迟时间 } }) }else{ console.log(res.data.msg) wx.showtoast({ title: res.data.msg, icon: \u0026#39;none\u0026#39;, duration: 2000 }) } } }) } 2.3.2、修改pages\\register\\register.wxml \u0026lt;form bindsubmit=\u0026#34;formsubmit\u0026#34; bindreset=\u0026#34;formreset\u0026#34;\u0026gt; 表单提交绑定formsubmit方法\n2.3.3、用户注册演示效果 点击注册按钮，注册成功，跳转到用户登录页面 等待1秒钟，跳转到登录页面\n注意控制台如果报错： vm1540 asdebug.js:1 http://localhost:8888 不在以下 request 合法域名列表中，请参考文档：https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html 解决方案： 2.4、完成用户登录 2.4.1、修改pages\\account\\account.js // 获取输入账号 usernameinput: function (e) { this.setdata({ username: e.detail.value }) }, // 获取输入密码 passwordinput: function (e) { this.setdata({ password: e.detail.value }) }, // 登录处理 login: function () { var that = this; console.log(\u0026#39;用户登录\u0026#39;) if (that.data.username.length == 0 || that.data.password.length == 0) { wx.showtoast({ title: \u0026#39;账号或密码不能为空\u0026#39;, icon: \u0026#39;none\u0026#39;, duration: 2000 }) } else { let baseurl = app.globaldata.baseurl; wx.request({ url: baseurl+\u0026#39;/member/member/login\u0026#39;, method:\u0026#39;post\u0026#39;, header:{\u0026#39;content-type\u0026#39;:\u0026#39;application/json\u0026#39;}, data:{ username: that.data.username, password: that.data.password }, success:function(res){ console.log(res); if(res.data.code==0){ console.log(\u0026#34;登录成功\u0026#34;) //登录成功，存储token到本地存储 类似于cookie wx.setstoragesync(\u0026#39;token\u0026#39;, res.data.token); wx.setstoragesync(\u0026#39;refreshtoken\u0026#39;, res.data.refreshtoken); //显示登录成功提示，跳转到题库分类页面 wx.showtoast({ title: \u0026#34;登录成功\u0026#34;, icon: \u0026#39;none\u0026#39;, duration: 1000, success:function(){ console.log(\u0026#39;haha\u0026#39;); settimeout(function () { //要延时执行的代码 wx.switchtab({ url: \u0026#39;../type/type\u0026#39; }) }, 1000) //延迟时间 } }) }else{ console.log(res.data.msg) wx.showtoast({ title: res.data.msg, icon: \u0026#39;none\u0026#39;, duration: 2000 }) } } }) } }, 注意：用户登录传递给后端的是json格式的数据，所有后代代码要调整能接收json数据\n//用户登录方法 @postmapping(\u0026#34;login\u0026#34;) public r login(@requestbody map\u0026lt;string, string\u0026gt; map){ //调用服务，根据用户名、密码获取用户信息 memberentity memberentity = memberservice.login(map.get(\u0026#34;username\u0026#34;), map.get(\u0026#34;password\u0026#34;)); 2.4.2、修改pages\\account\\account.wxml \u0026lt;button class=\u0026#34;loginbtn\u0026#34; type=\u0026#34;primary\u0026#34; bindtap=\u0026#34;login\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; 2.4.3、演示登录效果 输入账号密码错误，提示 账号密码正确，提示登录成功，稍后跳转到分类列表页 三、题库分类功能开发 3.1、创建广告轮播图模板页面 pages/template/head.wxml\n\u0026lt;view class=\u0026#39;haibao\u0026#39;\u0026gt; \u0026lt;swiper indicator-dots=\u0026#39;true\u0026#39; autoplay=\u0026#39;true\u0026#39; interval=\u0026#39;3000\u0026#39; duration=\u0026#39;1000\u0026#39; circular=\u0026#39;true\u0026#39; \u0026gt; \u0026lt;block wx:for=\u0026#34;{{imgurls}}\u0026#34; wx:key=\u0026#34;key\u0026#34;\u0026gt; \u0026lt;swiper-item\u0026gt; \u0026lt;image src=\u0026#34;{{item.imgurl}}\u0026#34; class=\u0026#34;side-image\u0026#34; style=\u0026#34;width:100%\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;/swiper-item\u0026gt; \u0026lt;/block\u0026gt; \u0026lt;/swiper\u0026gt; \u0026lt;/view\u0026gt; 3.2、创建题库分类页面 pages/type/type.wxml\n\u0026lt;!--pages/type/type.wxml--\u0026gt; \u0026lt;include src=\u0026#34;../template/head.wxml\u0026#34; /\u0026gt; \u0026lt;view class=\u0026#34;cu-list menu sm-border solid-bottom card-menu margin-top\u0026#34; wx:for=\u0026#34;{{exams}}\u0026#34; wx:for-item=\u0026#34;item\u0026#34; id=\u0026#34;{{itemtap}}\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;cu-item \u0026#34;\u0026gt; \u0026lt;view bindtap=\u0026#34;getitem\u0026#34; data-id=\u0026#34;{{item.id}}\u0026#34; class=\u0026#34;action text-bold text-black text-lg\u0026#34;\u0026gt; \u0026lt;image src=\u0026#34;{{item.logourl}}\u0026#34; class=\u0026#34;img\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;text class=\u0026#34;cu-title\u0026#34;\u0026gt;\u0026lt;/text\u0026gt; {{item.type}} \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; 注意:点击分类名称跳转到题目列表方法 bindtap=\u0026ldquo;getitem\u0026rdquo; 传递分类编号 data-id=\u0026quot;{{item.id}}\u0026quot;\n3.3、编写题库样式 修改type.wxss\n.top_title{ font-family: neue; color: #888; position: absolute; left: 15px; bottom: 0px; height: 26px; } .img{ width: 100rpx; height: 100rpx; padding: 10rpx; } .scroll_item_name { margin-left: 10rpx; line-height: 150rpx; text-align: left; font-size: 36rpx; } .alter_name { position: fixed; top: 460rpx; background-color: #000; height: 200rpx; width: 500rpx; left: 125rpx; } .input_name { display: flex; margin-top: 10rpx; height: 80rpx; } .alter_btn { width: 100%; margin-top: 20rpx; height: 80rpx; bottom: 20rpx; display: flex; } .flex-item { width: 150rpx; height: 80rpx; background-color: #fff; color: #000; display: flex; justify-content: center; align-items: center; } .round-click { height: 120rpx; width: 120rpx; background-color:#fec432; border-radius: 100%; position: fixed; bottom: 150rpx; right: 20rpx; display: flex; align-items: center; justify-content: center; z-index: 9; } .round-click view { font-size: 32rpx; max-width: 80rpx; color: #fff; text-align: center; } 3.4、修改js文件 //获取应用实例 const app = getapp() 编写获取分类数据方法、获取广告轮播图数据方法、设置页面加载时调用2个方法\nonshow:function(){ wx.showtabbar({ animation: true, }) //读取全部分类数据 this.loadalltype() //读取广告轮播图数据 this.loadconext() }, //读取全部分类数据 loadalltype:function() { let baseurl = app.globaldata.baseurl; var t = this; wx.request({ url: baseurl+\u0026#39;/question/type/findall\u0026#39;, method:\u0026#39;get\u0026#39;, header:{\u0026#39;authorization\u0026#39;:wx.getstoragesync(\u0026#39;token\u0026#39;)}, success:function(res){ console.log(res.data); t.setdata({ exams:res.data.data }) console.log(res.data); } }) }, //读取广告轮播图 loadconext:function(){ let baseurl = app.globaldata.baseurl; var t = this; wx.request({ url: baseurl+\u0026#39;/context/banner/list?page=1\u0026amp;limit=5\u0026#39;, method:\u0026#39;get\u0026#39;, header:{\u0026#39;authorization\u0026#39;:wx.getstoragesync(\u0026#39;token\u0026#39;)}, success:function(res){ console.log(\u0026#34;log ： \u0026#34;+res.data.page.list); t.setdata({ imgurls: res.data.page.list }) console.log(\u0026#34;log ： \u0026#34;); } }) } 3.5、演示效果 3.6、编写从分类跳转到题目列表页面 修改type.js\n//点击分类，跳转到题目列表页 getitem:function(e){ var id = e.currenttarget.dataset.id console.log(\u0026#34;key : \u0026#34;+id); wx.navigateto({ url: \u0026#39;../item/item?id=\u0026#39;+id, }) }, 对应type.wxml调用跳转方法\n\u0026lt;view bindtap=\u0026#34;getitem\u0026#34; data-id=\u0026#34;{{item.id}}\u0026#34; class=\u0026#34;action text-bold text-black text-lg\u0026#34;\u0026gt; \u0026lt;image src=\u0026#34;{{item.logourl}}\u0026#34; class=\u0026#34;img\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;text class=\u0026#34;cu-title\u0026#34;\u0026gt;\u0026lt;/text\u0026gt; {{item.type}} \u0026lt;/view\u0026gt; 四、题目列表功能开发 4.1、创建题目列表页面 pages/item/item.wxml\n\u0026lt;include src=\u0026#34;../template/head.wxml\u0026#34; /\u0026gt; \u0026lt;view class=\u0026#34;cu-list menu sm-border solid-bottom card-menu margin-top\u0026#34; wx:for=\u0026#34;{{items}}\u0026#34; wx:for-item=\u0026#34;item\u0026#34; \u0026gt; \u0026lt;view class=\u0026#34;cu-item \u0026#34;\u0026gt; \u0026lt;view bindtap=\u0026#34;getinfo\u0026#34; data-id=\u0026#34;{{item.id}}\u0026#34; class=\u0026#34;action text-bold text-black text-lg\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;cuicon-title text-blue\u0026#34;\u0026gt;\u0026lt;/text\u0026gt; {{item.title}} \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; 4.2、创建题目列表样式 pages/item/item.wxss\n.page_op{ width: 100%; height: 75px; display:flex; /*flex-direction:row;*/ } .btn_op{ width: 125px; height: 75px; color: #000; font-size: 40px; display: flex; justify-content: center; align-items: center; } .page_line{ width: 100%; display:flex; /*flex-direction:row;*/ } .line1{ position: relative; left: 188rpx; width: 1px; background-color: #000; } .line2{ position: relative; left: 562rpx; width: 1px; background-color: #000; } 4.3、创建题目列表js文件 pages/item/item.js\n//获取应用实例 const app = getapp() 设置页面初始化数据\n/** * 页面的初始数据 */ data: { pageno: 1, id: 1, limit: 7, totalpages: 1, items: [] }, 编写当页面加载的时候，获取题目列表数据、广告轮播图数据\n/** * 生命周期函数--监听页面加载 */ onload: function (options) { //捕获分类列表页传递过来的分类id this.setdata({ id: options.id }) //获取对应分类题目列表数据 this.getitemlist() //读取广告轮播图数据 this.loadconext() }, //读取题目分类数据 getitemlist:function(){ var t = this; let baseurl = app.globaldata.baseurl; wx.request({ url: baseurl+\u0026#39;/question/question/list?page=\u0026#39;+this.data.pageno+\u0026#39;\u0026amp;limit=\u0026#39;+this.data.limit+\u0026#39;\u0026amp;key=\u0026#39;+this.data.id, method:\u0026#39;get\u0026#39;, header:{\u0026#39;authorization\u0026#39;:wx.getstoragesync(\u0026#39;token\u0026#39;)}, success:function(res){ console.log(res.data.page); t.setdata({ items: res.data.page.list, totalpages: res.data.page.totalpage }) console.log(\u0026#34;log ： \u0026#34;); } }) }, //获取广告轮播图数据 loadconext:function(){ let baseurl = app.globaldata.baseurl; var t = this; wx.request({ url: baseurl+\u0026#39;/context/banner/list?page=1\u0026amp;limit=5\u0026#39;, method:\u0026#39;get\u0026#39;, header:{\u0026#39;authorization\u0026#39;:wx.getstoragesync(\u0026#39;token\u0026#39;)}, success:function(res){ console.log(\u0026#34;log ： \u0026#34;+res.data.page.list); t.setdata({ imgurls: res.data.page.list }) console.log(\u0026#34;log ： \u0026#34;); } }) }, 注意调整后端代码 u-question模块的\u0026mdash;questionserviceimpl的querypage方法，增加如下代码：\n//获取分类编号 string type= (string) params.get(\u0026#34;type\u0026#34;); if(!stringutils.isempty(type)){ querywrapper.eq(\u0026#34;type\u0026#34;,type); } 4.4、题目列表演示效果 4.5、题目列表下拉获取更多数据处理 修改pages/item/item.js\n增加上拉触底获取下一页数据方法\n/** * 页面上拉触底事件的处理函数 */ onreachbottom: function () { var t=this; console.log(\u0026#39; 页面上拉触底事件的处理函数\u0026#39;); //判断当前页码小于总页码，就把当前页加1，获取下一页内容 if(t.data.pageno\u0026lt;t.data.totalpages){ t.setdata({ pageno: t.data.pageno+1 }) console.log(t.data.pageno); let baseurl = app.globaldata.baseurl; wx.request({ url: baseurl+\u0026#39;/question/question/list?page=\u0026#39;+this.data.pageno+\u0026#39;\u0026amp;limit=\u0026#39;+this.data.limit+\u0026#39;\u0026amp;key=\u0026#39;+this.data.id, method:\u0026#39;get\u0026#39;, header:{\u0026#39;authorization\u0026#39;:wx.getstoragesync(\u0026#39;token\u0026#39;)}, success:function(res){ //合并下一页的数据到当前集合 合并数组是把后一个数组的值依次push进前一个数组，使前一个数组发生改变 t.data.items.push.apply(t.data.items.list,res.data.page.list) t.setdata({ items: t.data.items }) } }) }else{ wx.showtoast({ title: \u0026#39;我是最后一页了！\u0026#39;, icon: \u0026#39;none\u0026#39;, duration: 1000 }) } }, newvideolist.concat(videolist),\n演示效果，题目列表到了最后，上拉，即可自动加载显示更多数据\n注意：数据必须铺满，才能演示下拉触底方法，可以用鼠标向下滚轮。 拉倒最后一页，提示 4.6、编写点击题目标题跳转到题目详情页 修改pages/item/item.js\n//跳转到题目详情页 getinfo:function(e){ var id = e.currenttarget.dataset.id console.log(\u0026#34;key : \u0026#34;+id); wx.navigateto({ url: \u0026#39;../info/info?id=\u0026#39;+id, }) }, 修改页面item.wxml\n\u0026lt;view bindtap=\u0026#34;getinfo\u0026#34; data-id=\u0026#34;{{item.id}}\u0026#34; class=\u0026#34;action text-bold text-black text-lg\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;cuicon-title text-blue\u0026#34;\u0026gt;\u0026lt;/text\u0026gt; {{item.title}} \u0026lt;/view\u0026gt; 五、题目详情开发 5.1、创建题目详情页面 pages/info/info.wxml\n\u0026lt;include src=\u0026#34;../template/head.wxml\u0026#34; /\u0026gt; \u0026lt;view class=\u0026#34;news-detail-container\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;author-time\u0026#34;\u0026gt; \u0026lt;text class=\u0026#34;const-text\u0026#34;\u0026gt;发表于\u0026lt;/text\u0026gt; \u0026lt;text class=\u0026#34;time\u0026#34;\u0026gt;{{ question.createtime }}\u0026lt;/text\u0026gt; \u0026lt;text class=\u0026#34;const-text\u0026#34;\u0026gt;评分:{{question.level}}\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;text class=\u0026#34;title\u0026#34;\u0026gt;{{ question.title }}\u0026lt;/text\u0026gt; \u0026lt;view class=\u0026#34;tool\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;horizon\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;text class=\u0026#34;detail\u0026#34;\u0026gt;{{ question.answer }}\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; 5.2、创建题目详情样式 pages/info/info.wxss\n.news-detail-container{ display: flex; flex-direction: column; } .head-img{ width: 100%; } .author-time{ flex-direction: row; margin-left: 30rpx; margin-top: 20rpx; } .author-avatar{ height: 64rpx; width: 64rpx; border-radius: 50%; vertical-align: middle; } .author-name{ font-size: 30rpx; font-weight: 700; margin-left: 20rpx; vertical-align: middle; color:#666; } .const-text{ font-size: 24rpx; color:#999; margin-left: 20rpx; } .time{ font-size: 24rpx; margin-left: 30rpx; vertical-align: middle; color: #999; } .title{ margin-left: 40rpx; font-size: 36rpx; font-weight: 700; margin-top: 30rpx; letter-spacing: 2px; color: #4b556c; } .tool{ margin-top: 20rpx; } .circle-img{ float: right; margin-right: 40rpx; vertical-align: middle; } .circle-img image{ width: 50rpx; height: 50rpx; } .share-img{ margin-left: 30rpx; } .horizon{ width: 660rpx; height: 1px; background-color: #e5e5e5; vertical-align: middle; position: relative; top: 46rpx; margin: 0 auto; z-index: -99; } .detail{ color:#666; margin-top: 20rpx; margin-right: 30rpx; margin-left: 30rpx; line-height: 44rpx; letter-spacing: 2px; font-size: 24rpx; } .playermusic{ width: 60rpx; height: 60rpx; vertical-align: middle; margin-left: 40rpx; } 5.3、编写题目详情js文件 pages/info/info.js\n//获取应用实例 const app = getapp() 页面加载获取详细数据、轮播图数据\n/** * 生命周期函数--监听页面加载 */ onload: function (options) { //获取跳转传递过来的题目编号 var id=options.id //读取广告轮播图 this.loadcontext(); //读取题目信息 this.loadquestioninfo(id); }, //读取题目信息 loadquestioninfo:function(id){ var baseurl=app.globaldata.baseurl var t=this //发错请求读取题目信息 wx.request({ url: baseurl+\u0026#39;/question/question/info/\u0026#39;+id, method: \u0026#39;get\u0026#39;, header:{ \u0026#39;authorization\u0026#39;:wx.getstoragesync(\u0026#39;token\u0026#39;) }, success:function(res){ //把服务器响应数据设置到本地变量 t.setdata({ question: res.data.question }) } }) }, //获取广告轮播图数据 loadcontext:function(){ var baseurl=app.globaldata.baseurl var t=this //发出请求 wx.request({ url: baseurl+\u0026#39;/context/banner/list\u0026#39;, method: \u0026#39;get\u0026#39;, header:{ \u0026#39;authorization\u0026#39;:wx.getstoragesync(\u0026#39;token\u0026#39;) }, success:function(res){ t.setdata({ imgurls: res.data.page.list }) } }) } 5.4、题目详情演示效果 六、内网穿透（选学） 6.1. 内网穿透 支付异步通知需要独立ip使阿里支付成功后可以回调我们的接口，所以前提条件就是内网穿透。\n哲西云：https://cloud.zhexi.tech\ncpolar：https://www.cpolar.com/\n哲西云浏览器客户端配置隧道，映射网关的8888端口： 具体配置如下： 测试内网穿透：访问登录接口\nhttp://bumzmoegy0.52http.tech/member/member/login?username=test\u0026password=123 6.2、修改微信小程序对接地址 修改文件app.js\nglobaldata: { userinfo: null, baseurl: \u0026#34;http://bumzmoegy0.52http.tech\u0026#34; } 启动真机调试： 微信扫描即可在手机端展开调试\n","date":"2022-05-29","permalink":"https://lovemjh.vercel.app/posts/project/20220529001925/","summary":"第七章 题库微信小程序端功能开发 优就业.JAVA教研室 学习目标 了解 微信小程序项目创建及初始化配置 掌握用户登录注册功能开发 掌握题库分类功能开发 掌握题库列表功能开发 掌","title":"tk-题库微信小程序端功能开发"},{"content":"第六章 微信小程序开发入门 优就业.java教研室 学习目标 了解 微信小程序介绍 掌握微信小程序开发环境准备 掌握微信小程序入门 掌握微信小程序配置文件 掌握微信小程序视图及渲染 掌握微信小程序事件 掌握微信小程序多页面 掌握微信小程序底部导航栏 掌握微信小程序页面跳转及传递参数 一、微信小程序介绍 1.1 什么是微信小程序？ 1.2、小程序和移动应用的区别 一、下载 app 从应用商店（如 app store）里下载；小程序 通过微信（扫描二维码、搜索）直接获得；\n二、安装 app 安装在手机内存中，就像自己买了辆车放在车库里随时开；小程序不需要安装，就像免费用嘀嘀打车，召之即来用完拜拜；\n三、占用空间 app 会一直存在手机中占用空间，太多的 app 可能会导致内存不足；小程序因为不需要安装，占用内存空间忽略不计；\n四、广告推送 app 会隔三差五给用户推送广告，太多未读提示会逼死强迫症；小程序不允许主动给用户发送广告，仅能回复模版消息；\n五、机会 app市场已经饱和，几乎所有的领域都已经被覆盖；小程序是一片蓝海，在新的使用场景下有很多瓜分蛋糕的好机会；\n六、开发 app 需要适配市场上很多款的主流手机，开发成本大；小程序 一次开发就可以自动适配所有手机；\n七、发布 app 需要向十几个应用商店提交审核，且每个应用商店要求的资料都不一样，非常繁琐；小程序 只需要提交到微信公众平台审核 ；\n八、用户群 app 面向所有智能手机用户，截止2015年约19亿台；小程序面向所有微信用户，约8亿人 ；\n九、开发周期 一款完善的双平台 app 平均的开发周期约3个月；小程序 平均开发周期约2周，仅为app的六分之一；\n十、功能 app 可以实现完整功能 ；小程序 仅限微信提供的接口功能；\n1.3 什么样的app适合用微信小程序开发？ a、使用频率高而且还很重要不适合用微信小程序，应该用原生的app开发 b、使用频率低而且很重要应该用微信小程序开发 c、使用频率高但是不重要应该用小程序为入口导向原生app d、使用频率不高也不重要优选小程序开发\n1.4、微信小程序用到的技术点 a、并不是html5/css3技术实现 b、抛弃了臃肿的webview c、采用了javascriptcore动态解析 d、大量借鉴react.js + reactnative.js思想 1.5、小程序开发的api https://developers.weixin.qq.com/miniprogram/dev/api/ 二、微信小程序的开发准备 2.1、注册微信小程序账号 访问https://mp.weixin.qq.com/cgi-bin/wx进入微信公众平台，点击前往注册 然后根据提示，依次完成以下操作，就注册成功了。注意：一个邮箱只能注册一个小程序。\n1、激活邮箱\n2、信息登记\n3、登录小程序管理后台\n4、完善小程序信息\n5、绑定开发者\n2.2、开发工具使用 2.2.1、微信小程序开发工具下载地址 https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 下载完成以后直接安装即可使用，使用时需要用微信扫描二维码 2.2.2、开发工具使用 打开工具后选择小程序开发，然后点击添加项目，会出现如下页面 点击 + 号，新建小程序 点击 新建按钮，即可新建一个小程序项目 2.2.3、 项目的结构如下 pages/index文件夹下三个文件之间交互（文件夹下的文件要同名) index.js和index.wxml交互 三、第一个入门程序（helloword） 1、新建项目 2、删除生成的全部项目文件 3、新建文件夹在项目下创建src目录，在src下创建pages目录，pages目录下创建index目录 src/pages/index\n在该目录下依次创建4个文件\nindex.js\npage({ d ata:{}, onload:function(options){ //页面初始化调用本方法 options为页面跳转所带来的参数 }, onready:function(){ //页面渲染完成 }, onshow:function(){ //页面显示 }, onhide:function(){ //页面隐藏 }, onunload:function(){ //页面关闭调用 } }) index.json\n{} index.wxml\nhello world! index.wxss\n/* index.wxss */ 4、在项目根目录下创建2个文件 app.js\n// app.js app.json\n{ \u0026#34;pages\u0026#34;: [ \u0026#34;src/pages/index/index\u0026#34; ] } 5、然后编译调试 四、微信小程序的配置文件 4.1、app.json app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。以下是一个包含了所有配置选项的app.json\napp.json配置项列表： 4.1.1、pages pages接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对pages数组进行修改。 文件名不需要写文件后缀，因为框架会自动去寻找路径下.json、.js、.wxml、.wxss四个文件进行整合。在创建新页面时，不需要手动新建页面，只需要在pages配置项中新建配置项即可。\n注意：\n新建页面时，在pages项中添加新建页面配置项，将会自动创建页面。小程序页面文件夹名与文件名相同。 app.json配置文件中不可以使用单引号，必须用双引号。 配置文件中不能写注释，只能是代码。 4.1.2、window 用于设置小程序的状态栏、导航条、标题、窗口背景色\n4.1.3、tabbar 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabbar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。\ntip： 当设置 position 为 top 时，将不会显示 icon tabbar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。\n属性说明： 其中list接收一个数组，数组中的每个项都是一个对象，属性如下： 4.1.4、networktimeout 可以设置各种网络请求的超时时间 属性说明： 4.1.5、dubug 可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有page的注册，页面路由，数据更新，事件触发 。 可以帮助开发者快速定位一些常见的问题\n4.2、page.json 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键。例如： 五、视图与渲染 1、组件的基本使用 简单的添加button组件实例，在wxml中添加button组件\n\u0026lt;!-- 白色按钮--\u0026gt; \u0026lt;button type=\u0026#34;default\u0026#34; hover-class=\u0026#34;test\u0026#34;\u0026gt;default\u0026lt;/button\u0026gt; \u0026lt;!-- 绿色按钮--\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34;\u0026gt;primary\u0026lt;/button\u0026gt; \u0026lt;!-- 红色按钮--\u0026gt; \u0026lt;button type=\u0026#34;warn\u0026#34; \u0026gt;warn\u0026lt;/button\u0026gt; 效果： 2、数据绑定 2.1、{{}}绑定数据 数据是通过{{}}来绑定的，在index.js中定义数据\npage({ data:{ text:\u0026#34;这里是内容\u0026#34; }, 然后在index.wxml中获取数据\n\u0026lt;text\u0026gt;{{text}}\u0026lt;/text\u0026gt; 获取数据的效果 3、渲染标签 微信小程序为我们提供了两种类型的渲染标签，一种是条件标签，一种是循环标签\n3.1、条件标签 1、定义if标签\nindex.wxml\n\u0026lt;view wx:if=\u0026#34;{{show}}\u0026#34;\u0026gt;{{textif}}\u0026lt;/view\u0026gt; index.js\npage({ data:{ text:\u0026#34;这里是内容\u0026#34;, textif:\u0026#34;if判断\u0026#34;, show:true }, 当show的值为true，显示 ，为fasle不显示 3.2、循环标签 1、创建数组数据\n编辑index.js\ndata:{ text:\u0026#34;这里是内容\u0026#34;, textif:\u0026#34;if判断\u0026#34;, show:false, news: [\u0026#39;aaa\u0026#39;,\u0026#39;bbb\u0026#39;,\u0026#39;ccc\u0026#39;,\u0026#39;ddd\u0026#39;] } 2、循环遍历显示数据\n编辑index.wxml\n\u0026lt;view wx:for=\u0026#34;{{news}}\u0026#34;\u0026gt;这是循环的内容\u0026lt;/view\u0026gt; 3、最终效果 4、如果需要显示for中的内容\n\u0026lt;view wx:for=\u0026#34;{{news}}\u0026#34; wx:for-item=\u0026#34;item\u0026#34;\u0026gt; 这是循环的内容 {{item}}--{{index}} \u0026lt;/view\u0026gt; 通过：wx:for-item 获取遍历的各个节点元素，通过index获取索引\n显示效果： 4、模板的使用 我们的小程序中，可能很多页面都是使用同一个顶部与同一个底部，这一部分的代码就可以被很多页面所共用，这种情况下，我们就可以把这部分内容单独提取成一个模板，每个页面都将其加载进来即可。 在pages目录下新建一个目录名为template，在其下新建一个wxml文件，我们在这个文件里写我们的模板。模板的使用有两种方式\n4.1、通过include引入 1、在pages下新建template文件，然后在template中创建header.wxml\n\u0026lt;text\u0026gt;这是头布局\u0026lt;/text\u0026gt; 2、然后在index.wxml中引入\n\u0026lt;include src=\u0026#34;../template/header.wxml\u0026#34;/\u0026gt; 3、效果 4.2、通过import引入 1、在template下创建footer.wxml文件\n\u0026lt;template name=\u0026#34;footer\u0026#34;\u0026gt;这是底部布局\u0026lt;/template\u0026gt; \u0026lt;template name=\u0026#34;head\u0026#34;\u0026gt;这是底部布局\u0026lt;/template\u0026gt; 2、在index.wxml中引入\n\u0026lt;import src=\u0026#34;../template/footer.wxml\u0026#34;/\u0026gt; \u0026lt;template is=\u0026#34;footer\u0026#34;/\u0026gt; \u0026lt;template is=\u0026#34;head\u0026#34;/\u0026gt; 3、效果 六、微信小程序事件 1、什么是事件 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 事件对象可以携带额外信息，如id, dataset, touches。\n2、事件的类别 2.1、点击事件 tap 定义单击事件\n修改index.wxml\n\u0026lt;button type=\u0026#34;primary\u0026#34; bindtap=\u0026#34;tapclick\u0026#34;\u0026gt;点击事件\u0026lt;/button\u0026gt; 修改index.js\ntapclick:function(){ console.log(\u0026#39;响应点击事件\u0026#39;) } 点击按钮效果： 2.2、长按事件longpress（手指触摸后，超过350ms离开） 定义长按事件\n修改index.wxml\n\u0026lt;button type=\u0026#34;primary\u0026#34; bindlongpress=\u0026#34;longclick\u0026#34;\u0026gt;长按事件\u0026lt;/button\u0026gt; 修改index.js\nlongclick:function(){ console.log(\u0026#39;长按事件\u0026#39;) } 效果： 2.3、触摸事件 2.3.1、touchstart 开始触摸 2.3.2、touchmove 手指触摸后移动 2.3.3、touchcansce：取消触摸（只能在真机模拟，在开发工具中没有效果） 2.3.4、touchend：触摸结束 修改index.wxml定义触摸事件\n\u0026lt;button type=\u0026#34;primary\u0026#34; bindtouchstart=\u0026#34;touchstartclick\u0026#34;\u0026gt;开始触摸\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; bindtouchmove=\u0026#34;touchmoveclick\u0026#34;\u0026gt;触摸后移动\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; bindtouchcancel=\u0026#34;touchcancelclick\u0026#34;\u0026gt;取消触摸\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; bindtouchend=\u0026#34;touchendclick\u0026#34;\u0026gt;触摸结束\u0026lt;/button\u0026gt; 修改index.js增加对应触摸事件处理方法\ntouchstartclick:function(){ console.log(\u0026#39;开始触摸\u0026#39;) }, touchmoveclick:function(){ console.log(\u0026#39;触摸后移动\u0026#39;) }, touchcancelclick:function(){ console.log(\u0026#39;取消触摸\u0026#39;) }, touchendclick:function(){ console.log(\u0026#39;触摸结束\u0026#39;) } 运行效果： 3、事件冒泡 3.1、什么是事件冒泡 点击、长按、触摸都属于冒泡事件，冒泡事件的触发是从子级依次向父级传递\n新建页面:demo2.wxml\n\u0026lt;view id=\u0026#34;parent\u0026#34; bindtap=\u0026#34;parentfn\u0026#34;\u0026gt; \u0026lt;view id=\u0026#34;child\u0026#34; bindtap=\u0026#34;childfn\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; js文件demo2.js\n/* 父级触发*/ parentfn(event){ console.log(\u0026#39;父级被调用\u0026#39;) }, /* 子级触发 */ childfn(event){ console.log(\u0026#39;子级被调用\u0026#39;) }, 样式文件demo2.wxss\n/* src/pages/demo2/demo2.wxss */ #parent{ width: 200rpx; height:200rpx; background: red; } #child{ width: 100rpx; height:100rpx; background: blue; } 测试运行：\n点击红色区域，只会调用父级方法 点击蓝色区域，子级和父级方法都被调用 3.2、如何防止事件冒泡 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡\n3.2.1、bind绑定； bindtap bindlongtap bingtouchstart bindtouchmove bindtouchcansce\nbindtouchend\n3.2.2、catch绑定；（能阻止事件冒泡） catchtap catchlongtap catchtouchstart catchtouchmove catchtouchcansce catchtouchend\n修改文件demo2.wxml\n\u0026lt;view id=\u0026#34;parent\u0026#34; bindtap=\u0026#34;parentfn\u0026#34;\u0026gt; \u0026lt;view id=\u0026#34;child\u0026#34; catchtap=\u0026#34;childfn\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; 再次测试运行，点击蓝色区域，只会触发调用子级方法 七、微信小程序多页面 7.1、编辑项目文件app.json 新增一个页面test1：\n{ \u0026#34;pages\u0026#34;:[ \u0026#34;pages/index/index\u0026#34;, \u0026#34;pages/test1/test1\u0026#34;, \u0026#34;pages/logs/logs\u0026#34; ], 保存文件，自动在pages目录下生成test1目录，下面创建了对应的页面和js样式的相关文件 7.2、编辑test1.wxml \u0026lt;!--pages/test1/test1.wxml--\u0026gt; \u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;text\u0026gt;这是我的test页面哦哦！！！\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; 7.3、在首页加入跳转连接 \u0026lt;view class=\u0026#34;btn-area\u0026#34;\u0026gt; \u0026lt;navigator url=\u0026#34;/pages/test1/test1\u0026#34; hover-class=\u0026#34;navigator-hover\u0026#34;\u0026gt;跳转test页面\u0026lt;/navigator\u0026gt; \u0026lt;/view\u0026gt; 点击 跳转test页面，即可跳转到test页面 7.4、设置页面标题 设置页面标题 ，是非常简单的一个步骤哦，找到所在页面的目录，找到对应的test1.json\n{ \u0026#34;navigationbartitletext\u0026#34;: \u0026#34;详情页\u0026#34; } navigationbartitletext属性值及时页面标题 八、微信小程序底部导航栏 底部导航栏，即点击底部的导航，会实现不同对应页面之间的切换。\n我们先来看个我们要实现的底部导航栏的效果图：（三个导航图标示例，微信小程序最多能加5个） 8.1、图标准备 阿里图标库 http://www.iconfont.cn/collections/show/29\n在这个网站上下载一些自己要用到的图标，比如人员头像，home主页等一些常用的图标，直接点击下载保存到本地，修改一下命名。也可以使用ui准备好的图标。\n回到项目里，新建一个images文件夹，将刚刚下载好的图标放在文件夹底下备用，将上述起好名字的图标 保存到 小程序 项目目录中 新创建的 images 文件夹中，准备工作就做好了。 8.2、添加底部导航栏配置文件 我们找到项目根目录中的配置文件 app.json 加入如下配置信息\n\u0026#34;tabbar\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#a9b7b7\u0026#34;, \u0026#34;selectedcolor\u0026#34;: \u0026#34;#11cd6e\u0026#34;, \u0026#34;borderstyle\u0026#34;: \u0026#34;white\u0026#34;, \u0026#34;list\u0026#34;: [ { \u0026#34;selectediconpath\u0026#34;: \u0026#34;images/0.png\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;images/0.png\u0026#34;, \u0026#34;pagepath\u0026#34;: \u0026#34;pages/index/index\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;首页\u0026#34; }, { \u0026#34;selectediconpath\u0026#34;: \u0026#34;images/1.png\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;images/1.png\u0026#34;, \u0026#34;pagepath\u0026#34;: \u0026#34;pages/logs/logs\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;日志\u0026#34; }, { \u0026#34;selectediconpath\u0026#34;: \u0026#34;images/2.png\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;images/2.png\u0026#34;, \u0026#34;pagepath\u0026#34;: \u0026#34;pages/test1/test1\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;测试\u0026#34; } ] }, 8.3、测试效果如下 点击各个图标，即可切换到各个页面 注意添加了tabbar原理的页面链接跳转，需要增加设置tabbar属性\n\u0026lt;view class=\u0026#34;btn-area\u0026#34;\u0026gt; \u0026lt;navigator url=\u0026#34;/pages/test1/test1\u0026#34; open-type=\u0026#34;switchtab\u0026#34; hover-class=\u0026#34;navigator-hover\u0026#34;\u0026gt;跳转test页面\u0026lt;/navigator\u0026gt; 设置属性：open-type=\u0026ldquo;switchtab\u0026rdquo; 表示是tabbar切换\n九、微信小程序页面跳转及传递参数 1、navigator 跳转时传参 在wxml页面跳转时候，可以在跳转地址后，传递参数：\n\u0026lt;view class=\u0026#34;btn-area\u0026#34;\u0026gt; \u0026lt;navigator url=\u0026#34;/pages/test2/test2?id=1001\u0026amp;name=张三\u0026#34; hover-class=\u0026#34;navigator-hover\u0026#34;\u0026gt;跳转test页面\u0026lt;/navigator\u0026gt; \u0026lt;/view\u0026gt; 注意：不能tabbar地址传参\n在对应跳转到的页面的test2.js的\nonload: function (options) { var id=options.id var name=options.name console.log(\u0026#39;id:\u0026#39;+id+\u0026#34; name:\u0026#34;+name) }, 演示效果： 2、在js代码里navigator 跳转时 修改index.js\ntotest2: function(){ wx.navigateto({ url: \u0026#39;../test2/test2?id=1001\u0026amp;name=张三\u0026#39;, }) } 修改index.wxml\n\u0026lt;view\u0026gt; \u0026lt;button bindtap=\u0026#34;totest2\u0026#34;\u0026gt;点击跳转\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; 对应test.js接收参数\nonload: function (options) { var id=options.id var name=options.name console.log(\u0026#39;id:\u0026#39;+id+\u0026#34; name:\u0026#34;+name) }, 测试效果： 3、在js代码里redirectto跳转时 修改index.wxml\n\u0026lt;view\u0026gt; \u0026lt;button bindtap=\u0026#34;totest22\u0026#34;\u0026gt;点击跳转2\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; 修改index.js\ntotest22: function(){ wx.redirectto({ url: \u0026#39;../test2/test2?id=1001\u0026amp;name=张三\u0026#39;, }) } 测试效果： 4、带有tagbar的页面跳转 需要用到switchtab(object)来实现\n修改index.wxml\n\u0026lt;view\u0026gt; \u0026lt;button bindtap=\u0026#34;tolog\u0026#34;\u0026gt;点击跳转tagbar查看日志\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; 修改index.js\ntolog: function(){ wx.switchtab({ url: \u0026#39;../logs/logs\u0026#39;, }) }, 注意需要配置app.json配置对应的tagbar\n\u0026#34;tabbar\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#a9b7b7\u0026#34;, \u0026#34;selectedcolor\u0026#34;: \u0026#34;#11cd6e\u0026#34;, \u0026#34;borderstyle\u0026#34;: \u0026#34;white\u0026#34;, \u0026#34;list\u0026#34;: [ { \u0026#34;selectediconpath\u0026#34;: \u0026#34;images/0.png\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;images/0.png\u0026#34;, \u0026#34;pagepath\u0026#34;: \u0026#34;pages/index/index\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;首页\u0026#34; }, { \u0026#34;selectediconpath\u0026#34;: \u0026#34;images/1.png\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;images/1.png\u0026#34;, \u0026#34;pagepath\u0026#34;: \u0026#34;pages/logs/logs\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;日志\u0026#34; }, { \u0026#34;selectediconpath\u0026#34;: \u0026#34;images/2.png\u0026#34;, \u0026#34;iconpath\u0026#34;: \u0026#34;images/2.png\u0026#34;, \u0026#34;pagepath\u0026#34;: \u0026#34;pages/test1/test1\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;测试\u0026#34; } ] }, 5、使用全局变量共享参数 修改app.js\napp({ globaldata: { userinfo: null, id: null } }) 在js里面可以给全局变量赋值：\n修改index.js 在onload方法中增加给全局变量赋值代码：\nvar app = getapp(); app.globaldata.id = 2 修改test2.js获取全局变量的值\nvar app = getapp(); //获取全局变量 console.log(\u0026#34;全局变量id:\u0026#34;+app.globaldata.id) 演示： 6、列表index下标取值 修改页面index.wxml\n\u0026lt;view\u0026gt; \u0026lt;button bindtap=\u0026#39;clickme\u0026#39; data-id=\u0026#39;1\u0026#39;\u0026gt;点击\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; 注意：通过wxml设置data-[参数名]传递参数，[参数名]只能是小写，不能有大写\n修改index.js\nclickme: function(e){ var id = e.currenttarget.dataset.id console.log(\u0026#34;获取到传递参数:\u0026#34;+id); } 演示效果： 十、微信小程序发出网络请求 1、网络请求对象wx.request wx.request（object）发起的是https请求。一个微信小程序，同时只能有5个网络请求连接。 object参数说明： wx.request({ url: \u0026#39;http://192.168.1.137:80/app/guanggao\u0026#39;, method: \u0026#39;post\u0026#39;, data: { type: \u0026#34;1\u0026#34; }, header: { \u0026#39;accept\u0026#39;: \u0026#39;application/json\u0026#39; }, success: function (res) { that.setdata({ images: res.data.data.guanggao }) } fail:function(err){ console.log(err) } }) 上面的代码会发送一个http get请求，其中的参数也比较容易理解。\nurl 服务器的url地址 data 请求的参数可以采用string data:”xxx=xxx\u0026amp;xxx=xxx”的形式或者object data:{“userid”:1}的形式 header 设置请求的header method http的方法,默认为get请求 success 接口成功的回调 fail 接口失败的回调 注意首先配置本地微信开发工具，不校验合法域名\n在页面增加一个按钮：\n\u0026lt;!-- 发出网络请求 --\u0026gt; \u0026lt;view\u0026gt; \u0026lt;button bindtap=\u0026#34;clicknetwork\u0026#34;\u0026gt;点我发出网络请求\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; 编写请求方法：\nclicknetwork:function(){ wx.request({ url: \u0026#39;http://localhost:10001/context/banner/list\u0026#39;, method: \u0026#39;post\u0026#39;, success:function(res){ console.log(res) } }) } 测试结果： ","date":"2022-05-29","permalink":"https://lovemjh.vercel.app/posts/project/_20220529000803/","summary":"第六章 微信小程序开发入门 优就业.JAVA教研室 学习目标 了解 微信小程序介绍 掌握微信小程序开发环境准备 掌握微信小程序入门 掌握微信小程序配置文件 掌握微信小程序视图及渲","title":"微信小程序开发入门"},{"content":"第十一章 springsecurity oauth2.0用户认证 优就业.java教研室 学习目标 用户认证分析\n认证技术方案了解\nspringsecurity oauth2.0入门\n用户授权认证开发\n1 用户认证分析 上面流程图描述了用户要操作的各个微服务，用户查看个人信息需要访问客户微服务，下单需要访问订单微服务，秒杀抢购商品需要访问秒杀微服务。每个服务都需要认证用户的身份，身份认证成功后，需要识别用户的角色然后授权访问对应的功能。\n1.1 认证与授权 身份认证\n用户身份认证即用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问。常见的用户身份认证表现形式有：用户名密码登录，指纹打卡等方式。说通俗点，就相当于校验用户账号密码是否正确。\n用户授权\n用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的权限，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫用户授权。\n1.2 单点登录 用户访问的项目中，至少有3个微服务需要识别用户身份，如果用户访问每个微服务都登录一次就太麻烦了，为了提高用户的体验，我们需要实现让用户在一个系统中登录，其他任意受信任的系统都可以访问，这个功能就叫单点登录。\n单点登录（single sign on），简称为 sso，是目前比较流行的企业业务整合的解决方案之一。 sso的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统\n1.3 第三方账号登录 1.3.1 第三方登录介绍 随着国内及国外巨头们的平台开放战略以及移动互联网的发展，第三方登录已经不是一个陌生的产品设计概念了。 所谓的第三方登录，是说基于用户在第三方平台上已有的账号和密码来快速完成己方应用的登录或者注册的功能。而这里的第三方平台，一般是已经拥有大量用户的平台，国外的比如facebook，twitter等，国内的比如微博、微信、qq等。 1.3.2 第三方登录优点 1.相比于本地注册，第三方登录一般来说比较方便、快捷，能够显著降低用户的注册和登录成本，方便用户实现快捷登录或注册。 2.不用费尽心思地应付本地注册对账户名和密码的各种限制，如果不考虑昵称的重复性要求，几乎可以直接一个账号走遍天下，再也不用在大脑或者什么地方记住n多不同的网站或app的账号和密码，整个世界一下子清静了。 3.在第一次绑定成功之后，之后用户便可以实现一键登录，使得后续的登录操作比起应用内的登录来容易了很多。 4.对于某些喜欢社交，并希望将更多自己的生活内容展示给朋友的人来说，第三方登录可以实现把用户在应用内的活动同步到第三方平台上，省去了用户手动发布动态的麻烦。但对于某些比较注重个人隐私的用户来说，则会有一些担忧，所以这个优点是有前提的。 5.因为降低了用户的注册或登录成本，从而减少由于本地注册的繁琐性而带来的隐形用户流失，最终提高注册转化率。 6.对于某些应用来说，使用第三方登录完全可以满足自己的需要，因此不必要设计和开发一套自己的账户体系。 7.通过授权，可以通过在第三方平台上分享用户在应用内的活动在第三方平台上宣传自己，从而增加产品知名度。 8.通过授权，可以获得该用户在第三方平台上的好友或粉丝等社交信息，从而后续可以针对用户的社交关系网进行有目的性的营销宣传，为产品的市场推广提供另一种渠道。 1.3.3 第三方认证 当需要访问第三方系统的资源时需要首先通过第三方系统的认证（例如：微信认证），由第三方系统对用户认证通过，并授权资源的访问权限。 2 认证技术方案 2.1 单点登录技术方案 分布式系统要实现单点登录，通常将认证系统独立抽取出来，并且将用户身份信息存储在单独的存储介质，比如： mysql、redis，考虑性能要求，通常存储在redis中，如下图： 单点登录的特点是：\n1、认证系统为独立的系统。 2、各子系统通过http或其它协议与认证系统通信，完成用户认证。 3、用户身份信息存储在redis集群。 java中有很多用户认证的框架都可以实现单点登录：\n1、apache shiro. 2、cas 3、spring security cas 2.2 oauth2认证 oauth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，oauth2.0是oauth协议的延续版本。\n2.2.1 oauth2认证流程 第三方认证技术方案最主要是解决认证协议的通用标准 问题，因为要实现 跨系统认证，各系统之间要遵循一定的接口协议。 oauth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用oauth认证服务，任何服务提供商都可以实现自身的oauth认证服务，因而oauth是开放的。业界提供了oauth的多种实现如php、javascript，java，ruby等各种语言开发包，大大节约了程序员的时间，因而oauth是简易的。互联网很多服务都open api，很多大公司如google，yahoo，microsoft等都提供了oauth认证服务，这些都足以说明oauth标准逐渐成为开放资源授权的标准。 oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。 参考：https://baike.baidu.com/item/oauth/7153134?fr=aladdin oauth协议：https://tools.ietf.org/html/rfc6749 下边分析一个oauth2认证的例子，网站使用微信认证的过程： 1.客户端请求第三方授权\n用户进入登录页面，点击qq的图标以微信账号登录系统，用户是自己在qq信息的资源拥有者。 点击“用qq账号登录”出现一个二维码，此时用户扫描二维码，开始给优就业官网授权。 2.资源拥有者同意给客户端授权\n资源拥有者扫描二维码表示资源拥有者同意给客户端授权，qq会对资源拥有者的身份进行验证， 验证通过后，qq会询问用户是否给授权优就业官网访问自己的qq数据，用户点击“确认登录”表示同意授权，qq认证服务器会 颁发一个授权码，并重定向到优就业官网。\n3.客户端获取到授权码，请求认证服务器申请令牌 此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。\n4.认证服务器向客户端响应令牌 认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。 此交互过程用户看不到，当客户端拿到令牌后，用户在优就业官网看到已经登录成功。\n5.客户端请求资源服务器的资源 客户端携带令牌访问资源服务器的资源。 优就业官网携带令牌请求访问微信服务器获取用户的基本信息。\n6.资源服务器返回受保护资源 资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。 注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证 服务器来校验令牌的合法性。\noauth2.0认证流程如下： 引自oauth2.0协议rfc6749 https://tools.ietf.org/html/rfc6749 oauth2包括以下角色：\n1、客户端 本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：东易买ios客户端、东易买web客户端（浏览器端）、微信客户端等。\n2、资源拥有者 通常为用户，也可以是应用程序，即该资源的拥有者。\n3、授权服务器（也称认证服务器） 用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授 权后方可访问。\n4、资源服务器 存储资源的服务器，比如，东易买商城用户管理服务器存储了东易买的用户信息等。客户端最终访问资源服务器获取资源信息。\n2.2.2 oauth2在项目的应用 oauth2是一个标准的开放的授权协议，应用程序可以根据自己的要求去使用oauth2，本项目使用oauth2实现如 下目标：\n1、东易买访问第三方系统的资源\n2、外部系统访问东易买商城的资源\n3、东易买前端（客户端） 访问东易买微服务的资源。\n4、东易买微服务之间访问资源，例如：微服务a访问微服务b的资源，b访问a的资源。\n2.3 spring security oauth2认证解决方案 本项目采用 spring security + oauth2完成用户认证及用户授权，spring security 是一个强大的和高度可定制的身份验证和访问控制框架，spring security 框架集成了oauth2协议，下图是项目认证架构图： 1、用户请求认证服务完成认证。\n2、认证服务下发用户身份令牌，拥有身份令牌表示身份合法。\n3、用户携带令牌请求资源服务，请求资源服务必先经过网关。\n4、网关校验用户身份令牌的合法，不合法表示用户没有登录，如果合法则放行继续访问。\n5、资源服务获取令牌，根据令牌完成授权。\n6、资源服务完成授权则响应资源信息。\n3 security oauth2.0入门 3.1 学习知识点说明 本项目认证服务基于spring security oauth2进行构建，并在其基础上作了一些扩展，采用jwt令牌机制，并自定义了用户身份信息的内容。 本教程的主要目标是学习在项目中集成spring security oauth2的方法和流程，通过 spring security oauth2的研究需要达到以下目标：\n1、理解oauth2的授权码认证流程及密码认证的流程。\n2、理解spring security oauth2的工作流程。\n3、掌握资源服务集成spring security框架完成oauth2认证的流程。\n3.2 搭建认证服务器 3.2.1 创建认证模块 创建认证服务器模块dongyimai-user-oauth的模块，如下图： 3.2.2 pom.xml配置 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 3.2.3 application.yml配置 server: port: 9100 spring: application: name: user-auth eureka: client: service-url: defaultzone: http://localhost:8761/eureka 3.2.4 编写springsecurity配置类websecurityconfig package com.offcn.config; @configuration @enablewebsecurity public class websecurityconfig extends websecurityconfigureradapter { //配置springsecurity拦截规则 @override protected void configure(httpsecurity http) throws exception { http.requestmatchers() .anyrequest()//任何请求都要拦截 .and() .formlogin()//登录界面 .and() .csrf().disable();//跨站攻击防御禁用 } //认证管理器 @bean @override public authenticationmanager authenticationmanagerbean() throws exception { return super.authenticationmanagerbean(); } //声明自定义认证对象 @bean(name = \u0026#34;userdetailsservice\u0026#34;) @override public userdetailsservice userdetailsservicebean() throws exception { return this.createuserdetailsservice(); } @override protected userdetailsservice userdetailsservice() { //启用自定义认证对象进行认证 return this.createuserdetailsservice(); } //自定义认证，声明用户登录账号、密码 private userdetailsservice createuserdetailsservice(){ list\u0026lt;userdetails\u0026gt; users=new arraylist\u0026lt;\u0026gt;(); userdetails adminuser = user.withusername(\u0026#34;admin\u0026#34;).password(passwordencoder().encode(\u0026#34;123\u0026#34;)).authorities(\u0026#34;admin\u0026#34;, \u0026#34;user\u0026#34;).build(); userdetails oneuser = user.withusername(\u0026#34;user1\u0026#34;).password(passwordencoder().encode(\u0026#34;123\u0026#34;)).authorities(\u0026#34;admin\u0026#34;, \u0026#34;user\u0026#34;).build(); userdetails towuser = user.withusername(\u0026#34;user2\u0026#34;).password(passwordencoder().encode(\u0026#34;456\u0026#34;)).authorities(\u0026#34;user\u0026#34;).build(); users.add(adminuser); users.add(oneuser); users.add(towuser); return new inmemoryuserdetailsmanager(users); } //声明密码加密器 @bean public passwordencoder passwordencoder(){ return new bcryptpasswordencoder(); } } 注意：@enablewebsecurity启用springsecurity\n3.2.5 编写springsecurityoauth2认证服务器配置类authorizationserverconfiguration package com.offcn.config; @configuration @enableauthorizationserver public class authorizationserverconfiguration extends authorizationserverconfigureradapter { //注入密码加密器 @autowired private passwordencoder passwordencoder; //注入自定义认证对象 @autowired private userdetailsservice userdetailsservice; //注入认证管理器 @autowired private authenticationmanager authenticationmanager; //授权服务器端点访问权限验证方式 @override public void configure(authorizationserversecurityconfigurer security) throws exception { security.allowformauthenticationforclients()//访问服务器端点需要进行客户端身份验证 .passwordencoder(passwordencoder)//设置客户端密码加密机制 .tokenkeyaccess(\u0026#34;permitall()\u0026#34;)//开启token生成功能 .checktokenaccess(\u0026#34;permitall()\u0026#34;);//开启token校验功能 } //spring security oauth2会公开了两个端点，用于检查令牌（/oauth/check_token和/oauth/token_key），这些端点默认受保护denyall()。tokenkeyaccess（）和checktokenaccess（）方法会打开这些端点以供使用。 //客户端账号配置 @override public void configure(clientdetailsserviceconfigurer clients) throws exception { //在内存中创建账号 clients.inmemory() // admin，授权码认证、密码认证、客户端认证、简单认证、刷新token .withclient(\u0026#34;admin\u0026#34;) //账号名称 .secret(passwordencoder.encode(\u0026#34;admin\u0026#34;))//密码，要设置加密 .resourceids(\u0026#34;oauth2-resource\u0026#34;,\u0026#34;dongyimai-user\u0026#34;, \u0026#34;dongyimai-goods\u0026#34;)//资源编号 .scopes(\u0026#34;server\u0026#34;,\u0026#34;app\u0026#34;)//作用范围 .authorizedgranttypes(\u0026#34;authorization_code\u0026#34;, \u0026#34;password\u0026#34;, \u0026#34;refresh_token\u0026#34;, \u0026#34;client_credentials\u0026#34;,\u0026#34;implicit\u0026#34;)//登录授权模式 .redirecturis(\u0026#34;http://localhost\u0026#34;);//登录成功跳转地址 } //端点令牌存储方式、关联自定义认证对象、认证管理器 @override public void configure(authorizationserverendpointsconfigurer endpoints) throws exception { endpoints.tokenstore(new inmemorytokenstore()) //令牌存储到内存 .authenticationmanager(authenticationmanager)//认证管理器 .userdetailsservice(userdetailsservice)//自定义认证类 .allowedtokenendpointrequestmethods(httpmethod.get,httpmethod.post);//允许端点访问方法 } } 注意：@enableauthorizationserver 启用oauth2授权服务器\n注意：资源编号需要填写默认的：oauth2-resource\n3.2.6 编写主启动类 @springbootapplication @enablediscoveryclient public class useroauth2application { public static void main(string[] args) { springapplication.run(useroauth2application.class,args); } } 3.2.7 启动授权认证服务 启动之前，记得先启动eureka，再启动该授权认证工程。\n3.3 oauth2授权模式 3.3.1 oauth2授权模式 oauth2有以下授权模式：\n1.授权码模式（authorization code） 2.密码模式（resource owner password credentials） 3.客户端模式（client credentials） 4.隐式授权模式（implicit） 3.3.2 授权码授权实现 上边例举的优就业官网使用qq认证的过程就是授权码模式，流程如下：\n1、客户端请求第三方授权\n2、用户(资源拥有者)同意给客户端授权\n3、客户端获取到授权码，请求认证服务器申请 令牌\n4、认证服务器向客户端响应令牌\n5、客户端请求资源服务器的资源，资源服务校验令牌合法性，完成授权\n6、资源服务器返回受保护资源\n(1)申请授权码\n请求认证服务获取授权码：\nget请求： http://localhost:9100/oauth/authorize?client_id=admin\u0026amp;response_type=code\u0026amp;scop=app\u0026amp;redirect_uri=http://localhost 参数列表如下：\nclient_id：客户端id，和授权配置类中设置的客户端id一致。 response_type：授权码模式固定为code scop：客户端范围，和授权配置类中设置的scop一致。 redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码） 首先跳转到登录页面： 输入账号和密码，点击login。 spring security在websecurityconfig类的createuserdetailsservice方法配置了用户和密码。 接下来进入授权页面： 点击authorize,接下来返回授权码： 认证服务携带授权码跳转redirect_uri,code=vi2kwa就是返回的授权码 (2)申请令牌\n拿到授权码后，申请令牌。 post请求：http://localhost:9100/oauth/token 参数如下：\ngrant_type：授权类型，填写authorization_code，表示授权码模式 code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。 redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。 此链接需要使用 http basic认证。 什么是http basic认证？ http协议定义的一种认证方式，将客户端id和客户端密码按照“客户端id:客户端密码”的格式拼接，并用base64编 码，放在header中请求服务端，一个例子： authorization：basic wgnxzwjbcha6wgnxzwjbcha=wgnxzwjbcha6wgnxzwjbcha= 是用户名:密码的base64编码。 认证失败服务端返回 401 unauthorized。\n以上测试使用postman完成：\nhttp basic认证： body参数：\ngrant_type: authorization_code\ncode:y7o1pf //注意code值，从前面登录获取到的授权码获取\nredirect_uri: http://localhost\n点击发送： 申请令牌成功 返回信如下:\naccess_token：访问令牌，携带此令牌访问资源 token_type：有mac token与bearer token两种类型，两种的校验算法不同，rfc 6750建议oauth2采用 bearer token（http://www.rfcreader.com/#rfc6750）。 refresh_token：刷新令牌，使用此令牌可以延长访问令牌的过期时间。 expires_in：过期时间，单位为秒。 scope：范围，与定义的客户端范围一致。 (3)令牌校验\nspring security oauth2提供校验令牌的端点，如下：\nget: http://localhost:9100/oauth/check_token?token= [access_token]\n参数：\ntoken：令牌\n使用postman测试如下: 如果令牌校验失败，会出现如下结果： 如果令牌过期了，会如下如下结果： (4)刷新令牌\n刷新令牌是当令牌快过期时重新生成一个令牌，它于授权码授权和密码授权生成令牌不同，刷新令牌不需要授权码 也不需要账号和密码，只需要一个刷新令牌、客户端id和客户端密码。\n测试如下： post：http://localhost:9100/oauth/token\n参数：\ngrant_type： 固定为 refresh_token\nrefresh_token：刷新令牌（注意值不是access_token，而是refresh_token） 3.3.3 密码授权实现 (1)认证\n密码模式（resource owner password credentials）与授权码模式的区别是申请令牌不再使用授权码，而是直接 通过用户名和密码即可申请令牌。\n测试如下：\npost请求：http://localhost:9100/oauth/token\n参数：\ngrant_type：密码模式授权填写password\nusername：账号\npassword：密码\n注意首先要设置http basic认证： 然后在设置账号密码 3.3.4 客户端模式授权实现 (1)认证\n密码模式（resource owner password credentials）与授权码模式的区别是申请令牌不再使用授权码，而是直接 通过用户名和密码即可申请令牌。\n测试如下：\npost请求：http://localhost:9100/oauth/token\n参数：\ngrant_type：密码模式授权填写client_credentials\n注意首先要设置http basic认证： 3.3.5 隐式授权实现 隐式授权模式要求：用户登录并对第三方应用进行授权，直接返回访问token，通过token访问资源\n相比授权码模式，它少了一次授权码的颁发与客户端使用授权码换取token的过程。\n隐式授权模式适用场景 适用场景有以下几个条件：\n用户参与：使用隐式授权需要与用户交互，用户对授权服务器进行登录与授权 单页应用：spa前端，没有后端或者后端属于授权方 客户端密码：访问授权时，不需要带第三方应用secret，前提是资源服务校验token使用的client信息与客户端（第三方应用）不同，且配置了secret 前端：必须要有前端，否则无法使用授权功能 客户端后端：options，仅当应用前后端不分离mvc场景 资源所属方：授权方 获取token\n请求认证服务获取授权码：\nget请求： http://localhost:9100/oauth/authorize?client_id=admin\u0026amp;redirect_uri=http://localhost\u0026amp;response_type=token\u0026amp;scope=app 参数列表如下：\nclient_id：客户端id，和授权配置类中设置的客户端id一致。 response_type：隐式模式固定为token scop：客户端范围，和授权配置类中设置的scop一致。 redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上access_token（令牌） 首先跳转到登录页面： 输入账号和密码，点击login。 spring security在websecurityconfig类的createuserdetailsservice方法配置了用户和密码。\n接下来进入授权页面： 点击authorize,接下来返回令牌 4 授权服务生成jwt令牌及资源服务授权流程 4.1 资源服务授权流程 (1)传统授权流程 资源服务器授权流程如上图，客户端先去授权服务器申请令牌，申请令牌后，携带令牌访问资源服务器，资源服务器访问授权服务校验令牌的合法性，授权服务会返回校验结果，如果校验成功会返回用户信息给资源服务器，资源服务器如果接收到的校验结果通过了，则返回资源给客户端。\n传统授权方法的问题是用户每次请求资源服务，资源服务都需要携带令牌访问认证服务去校验令牌的合法性，并根 据令牌获取用户的相关信息，性能低下。\n(2)公钥私钥授权流程 传统的授权模式性能低下，每次都需要请求授权服务校验令牌合法性，我们可以利用公钥私钥完成对令牌的加密，如果加密解密成功，则表示令牌合法，如果加密解密失败，则表示令牌无效不合法，合法则允许访问资源服务器的资源，解密失败，则不允许访问资源服务器资源。\n上图的业务流程如下:\n1、客户端请求认证服务申请令牌 2、认证服务生成令牌认证服务采用非对称加密算法，使用私钥生成令牌。 3、客户端携带令牌访问资源服务客户端在http header 中添加： authorization：bearer 令牌。 4、资源服务请求认证服务校验令牌的有效性资源服务接收到令牌，使用公钥校验令牌的合法性。 5、令牌有效，资源服务向客户端响应资源信息 4.2 公钥私钥 在对称加密的时代，加密和解密用的是同一个密钥，这个密钥既用于加密，又用于解密。这样做有一个明显的缺点，如果两个人之间传输文件，两个人都要知道密钥，如果是三个人呢，五个人呢？于是就产生了非对称加密，用一个密钥进行加密（公钥），用另一个密钥进行解密（私钥）。\n4.2.1 公钥私钥原理 张三有两把钥匙，一把是公钥，另一把是私钥。 张三把公钥送给他的朋友们\u0026mdash;-李四、王五、赵六\u0026mdash;-每人一把。 李四要给张三写一封保密的信。她写完后用张三的公钥加密，就可以达到保密的效果。 张三收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要张三的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。 张三给李四回信，决定采用\u0026quot;数字签名\u0026quot;。他写完后先用hash函数，生成信件的摘要（digest）。张三将这个签名，附在信件下面，一起发给李四。 李四收信后，取下数字签名，用张三的公钥解密，得到信件的摘要。由此证明，这封信确实是张三发出的。李四再对信件本身使用hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 4.2.2 生成私钥公钥 spring security 提供对jwt的支持，本节我们使用spring security 提供的jwthelper来创建jwt令牌，校验jwt令牌 等操作。 这里jwt令牌我们采用非对称算法进行加密，所以我们要先生成公钥和私钥。\n(1)生成密钥证书 下边命令生成密钥证书，采用rsa 算法每个证书包含公钥和私钥\n在centos7服务器安装配置好java环境：\n创建一个文件夹\ncd /root mkdir key cd key 在该文件夹下执行如下命令行：\nkeytool -genkeypair -alias dongyimai -keyalg rsa -keypass dongyimai -keystore dongyimai.jks -storepass dongyimai keytool 是一个java提供的证书管理工具\n-alias：密钥的别名 -keyalg：使用的hash算法 -keypass：密钥的访问密码 -keystore：密钥库文件名，xc.keystore保存了生成的证书 -storepass：密钥库的访问密码 (2)查询证书信息\nkeytool -list -keystore dongyimai.jks (3)删除别名\nkeytool -delete -alias dongyimai -keystore dongyimai.jks 4.2.3 导出公钥 openssl是一个加解密工具包，这里使用openssl来导出公钥信息。\nopenssl：https://www.openssl.org/\n进入秘钥所在目录\ncd /root/key 进入dongyimai.jks文件所在目录执行如下命令\nkeytool -list -rfc --keystore dongyimai.jks | openssl x509 -inform pem -pubkey 下面段内容是公钥\n-----begin public key----- miibijanbgkqhkig9w0baqefaaocaq8amiibcgkcaqeam79wjnlsh41wt+j3k44rafuwyvhez5ii2zxkda+tx5/mfq7ilbbpoc6c2ol+o+wvjvmv3y1qaydygymwiojpfwggc+t4cmznlcdxkewwdb0ic63urghtz5vf9luaclugc+gu5o++czljnurrqyrjjgnewx8bkavirnazn1i3vtozdkyhqd6ev8pycci5ngo5e4pz3vj6f7hvrtjj7fkci3j5iaxwaf9oixjyijpbb1+ebawksofsf5malbwbme22rj6fntghjynxhqfzmvip/x5jswl5fcajybs0wzcertchyjcwh2tlwctp4e6tjq23c98bg42nf+i2eqko6o90sqidaqab -----end public key----- 将上边的公钥拷贝到文本public.key文件中，**注意：**合并为一行,可以将它放到需要实现授权认证的工程中。\n4.3 使用私钥公钥生成、解析jwt令牌 (1)创建令牌数据\n在dongyimai-user-oauth工程中创建测试类com.offcn.token.createjwttest，使用它来创建令牌信息，代码如下：\npackage com.dongyimai.oauth; import com.alibaba.fastjson.json; import com.thoughtworks.xstream.core.util.base64encoder; import org.junit.jupiter.api.test; import org.springframework.core.io.classpathresource; import org.springframework.security.jwt.jwt; import org.springframework.security.jwt.jwthelper; import org.springframework.security.jwt.crypto.sign.rsasigner; import org.springframework.security.rsa.crypto.keystorekeyfactory; import java.security.keypair; import java.security.interfaces.rsaprivatekey; import java.security.interfaces.rsapublickey; import java.util.base64; import java.util.hashmap; import java.util.map; public class createjwttest { /*** * 创建令牌测试 */ @test public void testcreatetoken(){ //证书文件路径 string key_location=\u0026#34;dongyimai.jks\u0026#34;; //秘钥库密码 string key_password=\u0026#34;dongyimai\u0026#34;; //秘钥密码 string keypwd = \u0026#34;dongyimai\u0026#34;; //秘钥别名 string alias = \u0026#34;dongyimai\u0026#34;; //访问证书路径 classpathresource resource = new classpathresource(key_location); //创建秘钥工厂 keystorekeyfactory keystorekeyfactory = new keystorekeyfactory(resource,key_password.tochararray()); //读取指定别名秘钥对(公钥、私钥) keypair keypair = keystorekeyfactory.getkeypair(alias,keypwd.tochararray()); //获取公钥 // rsapublickey rsapublickey= (rsapublickey) keypair.getpublic(); // base64encoder base64encoder = new base64encoder(); // string encode = base64encoder.encode(rsapublickey.getencoded()); // system.out.println(\u0026#34;公钥:-----begin public key-----\u0026#34;+encode+\u0026#34;-----end public key-----\u0026#34;); //获取私钥 rsaprivatekey rsaprivate = (rsaprivatekey) keypair.getprivate(); //定义payload载荷 map\u0026lt;string, object\u0026gt; tokenmap = new hashmap\u0026lt;\u0026gt;(); tokenmap.put(\u0026#34;id\u0026#34;, \u0026#34;1\u0026#34;); tokenmap.put(\u0026#34;name\u0026#34;, \u0026#34;ujiuye\u0026#34;); tokenmap.put(\u0026#34;roles\u0026#34;, \u0026#34;role_vip,role_user\u0026#34;); //使用私钥生成jwt令牌 jwt jwt = jwthelper.encode(json.tojsonstring(tokenmap), new rsasigner(rsaprivate)); //取出令牌 string encoded = jwt.getencoded(); system.out.println(\u0026#34;token:\u0026#34;+encoded); } } 运行后的结果如下：\ntoken:eyjhbgcioijsuzi1niisinr5cci6ikpxvcj9.eyjyb2xlcyi6iljptevfvklqlfjptevfvvnfuiisim5hbwuioij1aml1ewuilcjpzci6ijeifq.g7hiujv4a9pihury4gfcdkqzqe0g9brwu5l5py0x1kv8lat_-otdi4rylxgo2im0fui9got_lnggx3fsf-u3eaiu-pphyrvo2raz9kiwxen_xliw-z3ghg05poahje2owf6y-uyd3j1ngc3wmepdenufrglljxw9d3fsalk5pc3fbbk4a6rktrjvelerzxg58vp856xtrathnml6hsft37mwvmm-ttl1vzjgyyo5jm6px38b9l4jpbsn5r1hx1jdve5rrfsbjhogrycy2crj_bm6jbwm-3jgj0w0n1mja1jh86-dxeuncibgmjz9bwrudoe8q8uhzjuwpvcklzmcxw (2)解析令牌\n上面创建令牌后，我们可以对jwt令牌进行解析，这里解析需要用到公钥，我们可以将之前生成的公钥public.key拷贝出来用字符串变量token存储，然后通过公钥解密。\n在dongyimai-user-oauth创建测试类com.offcn.token.parsejwttest实现解析校验令牌数据，代码如下：\npublic class parsejwttest { /*** * 校验令牌 */ @test public void testparsetoken(){ //令牌 string token = \u0026#34;eyjhbgcioijsuzi1niisinr5cci6ikpxvcj9.eyjyb2xlcyi6iljptevfvklqlfjptevfvvnfuiisim5hbwuioijpdghlaw1hiiwiawqioiixin0.ir9qu9zqyz2gu2qgaziyt38uheel4oi69ko-dzc_p9-vjz40hwzdqxl8wz-w2waw1ewgihv1eydjg0-eilogjz5uikyww1bewxcpvlm-zrtyqqqhftlfdivcfetytayaskwa-x_bvs4ptwaskiaikbkr4kcme2e5o1reek-3ypkqaiz6wp1uompacjdaafsdninqg0gzscugvlug40x0ngpfk7mpoecsii5cbjelpdyuscr9oxc53royfvyphjzv7c2d5eizu3leupxrvvvapjfecsbiisxuseeigpmuqhafzd1g-yj1wqrixfvehmelx2xu6w1nll5artpqf_jjiw\u0026#34;; //公钥 string publickey = \u0026#34;-----begin public key-----miibijanbgkqhkig9w0baqefaaocaq8amiibcgkcaqeavfseialvij9c1mz+oyamt47whaarkru/8kepm+x8760ugu0rmwgti6z9y3lq0rvk6i0brxmbgb/rsn38pvnhcp8zfxguh26kx0rk+tlrxcrg+hkpyoh4xpal8q1lu1n9x3tlcipxq8zztuiykyemolkymsvtvig5fltpdprt25unwge4md1kthrwxonfwhatvy7y/r4obiol1ms5bea/inkotqnnviaktjbm4rlidwma6dmz+lhtltqdd2lf1qwoisihi75lqz/cnyahcfzsxtoydpnkq8eb1/pgilnold4la2zf0/1dlcr5mkesv570nxrmu1tfm8zd3mzlzmyv9qidaqab-----end public key-----\u0026#34;; //校验jwt jwt jwt = jwthelper.decodeandverify(token, new rsaverifier(publickey)); //获取jwt原始令牌内容 string claims = jwt.getclaims(); system.out.println(claims); //获取jwt令牌解码内容 string encoded = jwt.getencoded(); system.out.println(encoded); } } 运行结果： 4.4、配置oauth2认证服务器实现jwt令牌 4.4.1、拷贝私钥到资源目录 拷贝私钥dongyimai.jks到resources目录 4.4.2、修改配置文件application.yml配置秘钥相关参数 encrypt: key-store: location: classpath:dongyimai.jks #秘钥文件名 alias: dongyimai #别名 password: dongyimai #密码 secret: dongyimai #密钥库的访问密码 4.4.3、修改配置类authorizationserverconfiguration 秘钥证书读取方法：\n//创建证书读取工具类 @bean(name = \u0026#34;keyprop\u0026#34;) public keyproperties keyproperties(){ return new keyproperties(); } //引用证书读取工具类，根据对象名引用避免引用其他的对象失败 @resource(name = \u0026#34;keyprop\u0026#34;) private keyproperties keyproperties; //读取证书方法 private keypair keypair(){ return new keystorekeyfactory(keyproperties.getkeystore().getlocation(), keyproperties.getkeystore().getsecret().tochararray()).getkeypair(keyproperties.getkeystore().getalias(),keyproperties.getkeystore().getsecret().tochararray()); } 编写普通令牌转换成jwt格式令牌的转换方法\n//创建jwtaccesstokenconverter用来生成jwt令牌 private jwtaccesstokenconverter jwtaccesstokenconverter(){ jwtaccesstokenconverter jwtaccesstokenconverter = new jwtaccesstokenconverter(); //关联私钥 jwtaccesstokenconverter.setkeypair(keypair()); return jwtaccesstokenconverter; } 修改配置方法public void configure(authorizationserverendpointsconfigurer endpoints)指定令牌按照jwt令牌生成\n//端点令牌存储方式、关联自定义认证对象、认证管理器 @override public void configure(authorizationserverendpointsconfigurer endpoints) throws exception { endpoints.tokenstore(new jwttokenstore(jwtaccesstokenconverter())) //令牌存储格式jwt .accesstokenconverter(jwtaccesstokenconverter())//使用jwt令牌转换器处理请求令牌 .authenticationmanager(authenticationmanager)//认证管理器 .userdetailsservice(userdetailsservice)//自定义认证类 .allowedtokenendpointrequestmethods(httpmethod.get,httpmethod.post);//允许端点访问方法 } 4.4.4、测试生成令牌 生成令牌，就变成了jwt格式的了！ 4.4.5、配置获取公钥端点 修改配置类authorizationserverconfiguration,增加配置获取公钥的方法\n//获取公钥的端点访问 @bean public tokenkeyendpoint tokenkeyendpoint(){ return new tokenkeyendpoint(jwtaccesstokenconverter()); } 测试获取公钥：\n访问地址：http://localhost:9100/oauth/token_key 5 认证开发 5.1 需求分析 用户登录的流程图如下： 执行流程：\n1、用户登录，请求认证服务 2、认证服务认证通过，生成jwt令牌，将jwt令牌及相关信息写入cookie 3、用户访问资源页面，带着cookie到网关 4、网关从cookie获取token，如果存在token，则校验token合法性，如果不合法则拒绝访问，否则放行 5、用户退出，请求认证服务，删除cookie中的token 5.2 认证服务 5.2.1 认证需求分析 认证服务需要实现的功能如下：\n1、登录接口\n前端post提交账号、密码等，用户身份校验通过，生成令牌，并将令牌写入cookie。\n2、退出接口 校验当前用户的身份为合法并且为已登录状态。 将令牌从cookie中删除。 5.2.2 工具封装 在dongyimai-user-oauth工程中添加如下工具对象，方便操作令牌信息。\n创建com.offcn.oauth.util.authtoken类，存储用户令牌数据，代码如下：\npublic class authtoken implements serializable{ //令牌信息 string accesstoken; //刷新token(refresh_token) string refreshtoken; //jwt短令牌 string jti; //...get...set } 创建com.offcn.oauth.util.cookieutil类，操作cookie,代码如下：\npackage com.offcn.util; import javax.servlet.http.cookie; import javax.servlet.http.httpservletrequest; import javax.servlet.http.httpservletresponse; import java.util.hashmap; import java.util.map; public class cookieutil { /** * 设置cookie * * @param response * @param name cookie名字 * @param value cookie值 * @param maxage cookie生命周期 以秒为单位 */ public static void addcookie(httpservletresponse response, string domain, string path, string name, string value, int maxage, boolean httponly) { cookie cookie = new cookie(name, value); cookie.setdomain(domain); cookie.setpath(path); cookie.setmaxage(maxage); cookie.sethttponly(httponly); response.addcookie(cookie); } /** * 根据cookie名称读取cookie * @param request * @return map\u0026lt;cookiename,cookievalue\u0026gt; */ public static map\u0026lt;string,string\u0026gt; readcookie(httpservletrequest request, string ... cookienames) { map\u0026lt;string,string\u0026gt; cookiemap = new hashmap\u0026lt;string,string\u0026gt;(); cookie[] cookies = request.getcookies(); if (cookies != null) { for (cookie cookie : cookies) { string cookiename = cookie.getname(); string cookievalue = cookie.getvalue(); for(int i=0;i\u0026lt;cookienames.length;i++){ if(cookienames[i].equals(cookiename)){ cookiemap.put(cookiename,cookievalue); } } } } return cookiemap; } } 5.2.3 配置文件 修改配置文件application.yml增加认证相关配置\nauth: ttl: 3600 #token过期时间 clientid: admin #客户端账号 clientsecret: admin #客户端密码 cookiedomain: localhost #cookie域名 cookiemaxage: -1 #cookie有效期 5.2.4 业务层 如上图，我们现在实现一个认证流程，用户从页面输入账号密码，到认证服务的controller层，controller层调用service层，service层调用oauth2.0的认证地址，进行密码授权认证操作，如果账号密码正确了，就返回令牌信息给service层，service将令牌信息给controller层，controller层将数据存入到cookie中，再响应用户。\n创建com.offcn.oauth.service.authservice接口，并添加授权认证方法：\npublic interface authservice { /*** * 授权认证方法 */ authtoken login(string username, string password, string clientid, string clientsecret); } 创建com.offcn.oauth.service.impl.authserviceimpl实现类，实现获取令牌数据，这里认证获取令牌采用的是密码授权模式，用的是resttemplate向oauth服务发起认证请求，代码如下：\n@service public class authserviceimpl implements authservice { @autowired private loadbalancerclient loadbalancerclient; @autowired private resttemplate resttemplate; /*** * 授权认证方法 * @param username * @param password * @param clientid * @param clientsecret * @return */ @override public authtoken login(string username, string password, string clientid, string clientsecret) { //申请令牌 authtoken authtoken = applytoken(username,password,clientid, clientsecret); if(authtoken == null){ throw new runtimeexception(\u0026#34;申请令牌失败\u0026#34;); } return authtoken; } /**** * 认证方法 * @param username:用户登录名字 * @param password：用户密码 * @param clientid：配置文件中的客户端id * @param clientsecret：配置文件中的秘钥 * @return */ private authtoken applytoken(string username, string password, string clientid, string clientsecret) { //选中认证服务的地址 serviceinstance serviceinstance = loadbalancerclient.choose(\u0026#34;user-auth\u0026#34;); if (serviceinstance == null) { throw new runtimeexception(\u0026#34;找不到对应的服务\u0026#34;); } //获取令牌的url string path = serviceinstance.geturi().tostring() + \u0026#34;/oauth/token\u0026#34;; //定义body multivaluemap\u0026lt;string, string\u0026gt; formdata = new linkedmultivaluemap\u0026lt;\u0026gt;(); //授权方式 formdata.add(\u0026#34;grant_type\u0026#34;, \u0026#34;password\u0026#34;); //账号 formdata.add(\u0026#34;username\u0026#34;, username); //密码 formdata.add(\u0026#34;password\u0026#34;, password); //定义头 必须声明为string，string泛型，要不然做basic auth会失败 multivaluemap\u0026lt;string, string\u0026gt; header = new linkedmultivaluemap\u0026lt;\u0026gt;(); header.add(\u0026#34;authorization\u0026#34;, httpbasic(clientid, clientsecret)); //指定 resttemplate当遇到400或401响应时候也不要抛出异常，也要正常返回值 //内部类重写快捷键 alt+insert resttemplate.seterrorhandler(new defaultresponseerrorhandler() { @override public void handleerror(clienthttpresponse response) throws ioexception { ////当发生错误的时候只有状态码不是400或者401才返回错误,其他情况正常响应 if (response.getrawstatuscode() != 400 \u0026amp;\u0026amp; response.getrawstatuscode() != 401) { super.handleerror(response); } } }); map map = null; try { //http请求spring security的申请令牌接口 responseentity\u0026lt;map\u0026gt; mapresponseentity = resttemplate.exchange(path, httpmethod.post,new httpentity\u0026lt;multivaluemap\u0026lt;string, string\u0026gt;\u0026gt;(formdata, header), map.class); //获取响应数据 map = mapresponseentity.getbody(); } catch (restclientexception e) { throw new runtimeexception(e); } if(map == null || map.get(\u0026#34;access_token\u0026#34;) == null || map.get(\u0026#34;refresh_token\u0026#34;) == null || map.get(\u0026#34;jti\u0026#34;) == null) { //jti是jwt令牌的唯一标识作为用户身份令牌 throw new runtimeexception(\u0026#34;创建令牌失败！\u0026#34;); } //将响应数据封装成authtoken对象 authtoken authtoken = new authtoken(); authtoken.setaccesstoken(map.get(\u0026#34;access_token\u0026#34;).tostring()); authtoken.setrefreshtoken(map.get(\u0026#34;refresh_token\u0026#34;).tostring()); authtoken.setjti(map.get(\u0026#34;jti\u0026#34;).tostring()); return authtoken; } /*** * base64编码 * @param clientid * @param clientsecret * @return */ private string httpbasic(string clientid,string clientsecret){ //将客户端id和客户端密码拼接，按“客户端id:客户端密码” string string = clientid+\u0026#34;:\u0026#34;+clientsecret; //进行base64编码 byte[] encode = base64utils.encode(string.getbytes()); return \u0026#34;basic \u0026#34;+new string(encode); } } 注意：httpbasic协议验证规则 ,在请求头传递 authorization 值为 basic+半角空格+base64encode客户端id:客户端密码\n5.2.5 控制层 创建控制层com.offcn.oauth.controller.authcontroller，编写用户登录授权方法，代码如下：\n@restcontroller @requestmapping(value = \u0026#34;/user\u0026#34;) public class authcontroller { //客户端id @value(\u0026#34;${auth.clientid}\u0026#34;) private string clientid; //秘钥 @value(\u0026#34;${auth.clientsecret}\u0026#34;) private string clientsecret; //cookie存储的域名 @value(\u0026#34;${auth.cookiedomain}\u0026#34;) private string cookiedomain; //cookie生命周期 @value(\u0026#34;${auth.cookiemaxage}\u0026#34;) private int cookiemaxage; @autowired authservice authservice; //登录方法 @postmapping(\u0026#34;login\u0026#34;) public result login(string username, string password, httpservletresponse response){ //判断用户是否为空 if(stringutils.isempty(username)){ throw new runtimeexception(\u0026#34;用户名不能为空\u0026#34;); } //判断密码是否为空 if(stringutils.isempty(password)){ throw new runtimeexception(\u0026#34;密码不能为空\u0026#34;); } //调用服务，申请令牌 //注意客户端id：clientid、客户端密码，从配置文件读取，一定要保持和数据库中的一致 authtoken authtoken = authservice.login(username, password, clientid, clientsecret); //保存令牌到cookie cookieutil.addcookie(response,cookiedomain,\u0026#34;/\u0026#34;,\u0026#34;authorization\u0026#34;,authtoken.getaccesstoken(),cookiemaxage,false); return new result(true, statuscode.ok,\u0026#34;登录成功\u0026#34;); } } 修改主启动类，声明resttemplate\n@bean public resttemplate resttemplate(){ return new resttemplate(); } 5.2.7 测试认证接口 使用postman测试：\npost请求：http://localhost:9100/user/login 可以看到本cookie已经写入了token\n","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project-0/20220528165279/","summary":"第十一章 SpringSecurity OAuth2.0用户认证 优就业.JAVA教研室 学习目标 用户认证分析 认证技术方案了解 SpringSecurity Oauth2.0入门 用户授权认证开发 1 用户认证分析 上面流程图描述了","title":"springsecurity oauth2.0用户认证"},{"content":"第一章 springcloudalibaba 优就业.java教研室 学习目标 了解 springcloudalibaba介绍、所包含组件 理解nacos介绍 理解nacos下载及安装 理解nacos服务启动 掌握基于nacos搭建服务注册发现演示 掌握基于nacos搭建配置中心 0.springcloudalibaba 简介 spring cloud alibaba 是阿里巴巴提供的微服务开发一站式解决方案，是阿里巴巴开源中间件与 spring cloud 体系的融合。\n同 spring cloud 一样，spring cloud alibaba 也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过 spring cloud 编程模型轻松使用这些组件来开发分布式应用服务。\n依托 spring cloud alibaba，您只需要添加一些注解和少量配置，就可以将 spring cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n作为 spring cloud 体系下的新实现，spring cloud alibaba 跟官方的组件或其它的第三方实现如 netflix, consul，zookeeper 等对比，具备了更多的功能:\n这幅图是 spring cloud alibaba 系列组件，其中包含了阿里开源组件，阿里云商业化组件，以及集成spring cloud 组件。\n阿里开源组件\nnacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\nsentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\nrocketmq：开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。\ndubbo：这个就不用多说了，在国内应用非常广泛的一款高性能 java rpc 框架。\nseata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。\narthas：开源的java动态追踪工具，基于字节码增强技术，功能非常强大。\n1. nacos概述 官方地址：https://nacos.io/zh-cn/\ngithub地址：https://github.com/alibaba/nacos\n1.1. 什么是 nacos nacos 是阿里巴巴推出来的一个新开源项目，这是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\nnacos 致力于帮助您发现、配置和管理微服务。nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。\nnacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。\n1.2. 为什么是nacos 常见的注册中心：\neureka（原生，2.0遇到性能瓶颈，停止维护） zookeeper（支持，专业的独立产品。例如：dubbo） consul（原生，go语言开发） nacos 相对于 spring cloud eureka 来说，nacos 更强大。\nnacos = spring cloud eureka + spring cloud config\nnacos 可以与 spring, spring boot, spring cloud 集成，并能代替 spring cloud eureka, spring cloud config。\n通过 nacos server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。\n通过 nacos server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。\n1.3. 可以干什么 nacos是以服务为主要服务对象的中间件，nacos支持所有主流的服务发现、配置和管理。\nnacos主要提供以下四大功能：\n服务发现和服务健康监测 动态配置服务 动态dns服务 服务及其元数据管理 2. nacos快速开始 结构图：\nnacos 依赖 java 环境来运行。如果您是从代码开始构建并运行nacos，还需要为此配置 maven环境，请确保是在以下版本环境中安装使用:\n64 bit os，支持 linux/unix/mac/windows，推荐选用 linux/unix/mac。 64 bit jdk 1.8+ maven 3.2.x+ 2.1. 下载及安装 你可以通过源码和发行包两种方式来获取 nacos。\n您可以从 最新稳定版本 下载 nacos-server-$version.zip 包。\nunzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz cd nacos/bin 2.2. 启动nacos服务 linux/unix/mac\n启动命令(standalone代表着单机模式运行，非集群模式):\nsh startup.sh -m standalone windows\n启动命令：\nstartup.cmd -m standalone 或者双击startup.cmd运行文件。(可能报异常 建议执行命令)\n访问：http://localhost:8848/nacos\n用户名密码：nacos/nacos\n出现naocs不能正常使用解决办法：\n检测nacos状态：http://localhost:8848/nacos/v1/ns/instance\n如果提示：server is down now, please try again later!\n解决办法：（1）、停止naocos （2）、删除naocs安装程序，data目录下的protocol文件夹，重启服务即可\n2.3. 注册中心 首先创建两个工程：nacos-provider、nacos-consumer 创建生产者： 创建消费者： 然后，一路下一步或者ok。效果如下：\n2.3.1. 生产者基本代码 providercontroller代码如下：\n@restcontroller public class providercontroller { @value(\u0026#34;${myname}\u0026#34;) private string name; @getmapping(\u0026#34;hello\u0026#34;) public string hello(){ return \u0026#34;hello \u0026#34; + name; } } application.yml配置如下：\nserver: port: 18070 myname: nacos 2.3.2. 生产者注册到nacos 生产者注册到nacos注册中心，步骤：\n添加依赖：spring-cloud-starter-alibaba-nacos-discovery及springcloud\n\u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.3.7.release\u0026lt;/version\u0026gt; \u0026lt;relativepath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.junit.vintage\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit-vintage-engine\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- springcloud的依赖 --\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;hoxton.sr2\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2.0.release\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; 在 application.yml 中配置nacos服务地址和应用名\nmyname: nacos server: port: 18070 spring: application: name: nacos-provider cloud: nacos: discovery: server-addr: 192.168.188.138:8848 通过spring cloud原生注解 @enablediscoveryclient 开启服务注册发现功能\n@springbootapplication @enablediscoveryclient public class nacosproviderapplication { public static void main(string[] args) { springapplication.run(nacosproviderapplication.class, args); } } 效果：\n2.3.3. 消费端基本代码 consumercontroller代码：\n@restcontroller public class consumercontroller { @getmapping(\u0026#34;hi\u0026#34;) public string hi() { return \u0026#34;hi provider!\u0026#34;; } } application.yml:\nserver: port: 18080 2.3.4. 消费者注册到nacos 消费者注册到nacos跟生产者差不多，也分3步：\n添加依赖：同生产者\n在application.yml中配置nacos的服务名及服务地址：同生产者\n在引导类（nacosconsumerapplication.java）中添加@enablediscoveryclient注解：同生产者\n效果： 2.3.5. 使用feign调用服务 以前我们使用feign来远程调用，这里也一样。引入feign的依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 在nacosconsumerapplication类上添加@enablefeignclients注解：\n@springbootapplication @enablediscoveryclient @enablefeignclients public class nacosconsumerapplication { public static void main(string[] args) { springapplication.run(nacosconsumerapplication.class, args); } } 编写feignclient： 内容：\n@feignclient(\u0026#34;nacos-provider\u0026#34;) public interface providerfeign { @requestmapping(\u0026#34;hello\u0026#34;) public string hello(); } 在controller中使用feignclient：\n@restcontroller public class consumercontroller { @autowired private providerfeign providerfeign; @getmapping(\u0026#34;hi\u0026#34;) public string hi() { system.out.println(system.currenttimemillis()); return this.providerfeign.hello(); } } 测试访问：http://localhost:18080/hi 2.4. 配置中心 ​\t在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 war，jar 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。\n如果微服务架构中没有使用统一配置中心时，所存在的问题：\n配置文件分散在各个项目里，不方便维护 配置内容安全与权限 更新配置后，项目需要重启 nacos配置中心：系统配置的集中管理（编辑、存储、分发）、动态更新不重启、回滚配置（变更管理、历史版本管理、变更审计）等所有与配置相关的活动。\n案例：改造生产者中的动态配置项，由配置中心统一管理。 2.4.1. nacos中创建统一配置 dataid 的完整格式如下：\n${prefix}-${spring.profile.active}.${file-extension} prefix 默认为所属工程配置spring.application.name 的值（即：nacos-provider），也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 spring.profile.active 即为当前环境对应的 profile，详情可以参考 spring boot文档。 注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataid 的拼接格式变成 ${prefix}.${file-extension} file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。 总结：配置所属工程的spring.application.name的值 + \u0026ldquo;.\u0026rdquo; + properties/yml\n配置内容：\n项目中易变的内容。例如：myname\n当前案例中，nacos-provider工程的spring.application.name=nacos-provider，没有配置spring.profiles.active。所以这里的dataid填写的是nacos-provider.properties\n2.4.2. 从配置中心读取配置 从配置中心读取配置，分以下3步：\n引入依赖\n在生产者中引入依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 在 bootstrap.yml 中配置 nacos server 的地址和应用名\nspring: cloud: nacos: config: server-addr: 127.0.0.1:8848 application: name: nacos-provider 说明：之所以需要配置 spring.application.name ，是因为它是构成 nacos 配置管理 dataid字段的一部分。\n在springboot工程中，bootstrap.yml的加载优先级更高。\n通过 spring cloud 原生注解 @refreshscope 实现配置自动更新：\n@restcontroller @refreshscope public class providercontroller { @value(\u0026#34;${myname}\u0026#34;) private string name; @requestmapping(\u0026#34;hello\u0026#34;) public string hello(){ return \u0026#34;hello \u0026#34; + name; } } 测试：http://localhost:18080/hi\n2.4.3. 名称空间切换环境 在实际开发中，通常有多套不同的环境（默认只有public），那么这个时候可以根据指定的环境来创建不同的 namespce，例如，开发、测试和生产三个不同的环境，那么使用一套 nacos 集群可以分别建以下三个不同的 namespace。以此来实现多环境的隔离。\n切换到配置列表：\n可以发现有四个名称空间：public（默认）以及我们自己添加的3个名称空间（prod、dev、test），可以点击查看每个名称空间下的配置文件，当然现在只有public下有一个配置。\n默认情况下，项目会到public下找 服务名.properties文件。\n接下来，在dev名称空间中也添加一个nacos-provider.properties配置。这时有两种方式：\n切换到dev名称空间，添加一个新的配置文件。缺点：每个环境都要重复配置类似的项目 直接通过clone方式添加配置，并修改即可。推荐 点击编辑：修改配置内容，以作区分 在服务提供方nacos-provider中切换命名空间，修改bootstrap.yml添加如下配置\nspring: cloud: nacos: config: server-addr: 192.168.188.138:8848 namespace: dd56a978-fb42-45c7-9e3d-31d9fbb35815 namespace的值为： 重启服务提供方服务，在浏览器中访问测试： 2.4.4. 加载多配置文件 偶尔情况下需要加载多个配置文件。假如现在dev名称空间下有三个配置文件：nacos-provider.properties、redis.properties、jdbc.properties。 jdbc.properties:\njdbc.url=xxxxxx redis.properties:\nredis.url=yyyy nacos-provider.properties默认加载，怎么加载另外两个配置文件？\n在bootstrap.yml文件中添加如下配置：\nspring: cloud: nacos: config: server-addr: 192.168.188.138:8848 namespace: dd56a978-fb42-45c7-9e3d-31d9fbb35815 extension-configs[0]: data-id: redis.properties refresh: true extension-configs[1]: data-id: jdbc.properties refresh: true application: name: nacos-provider 注意老版本：是用ext-config\n修改providercontroller使用redis.properties和jdbc.properties配置文件中的参数：\n@restcontroller @refreshscope public class providercontroller { @value(\u0026#34;${myname}\u0026#34;) private string name; @value(\u0026#34;${jdbc.url}\u0026#34;) private string jdbcurl; @value(\u0026#34;${redis.url}\u0026#34;) private string redisurl; @requestmapping(\u0026#34;hello\u0026#34;) public string hello(){ return \u0026#34;hello \u0026#34; + name + \u0026#34;, redis-url=\u0026#34; + redisurl + \u0026#34;, jdbc-url=\u0026#34; + jdbcurl; } } 测试效果： 问题：\n​\t修改一下配置中心中redis.properties中的配置，不重启服务。能否动态加载配置信息\n​\t删掉spring.cloud.nacos.config.ext-config[0].refresh=true，再修改redis.properties中的配置试试\n2.4.6. 配置的分组 在实际开发中，除了不同的环境外。不同的微服务或者业务功能，可能有不同的redis及mysql数据库。\n区分不同的环境我们使用名称空间（namespace），区分不同的微服务或功能，使用分组（group）。\n当然，你也可以反过来使用，名称空间和分组只是为了更好的区分配置，提供的两个维度而已。\n新增一个redis.properties，所属分组为provider： 现在开发环境中有两个redis.propertis配置文件，一个是默认分组（default_group），一个是provider组\n默认情况下从default_group分组中读取redis.properties，如果要切换到provider分组下的redis.properties，需要添加如下配置：\n# 指定分组 spring: cloud: nacos: config: server-addr: 192.168.188.138:8848 namespace: dd56a978-fb42-45c7-9e3d-31d9fbb35815 extension-configs[0]: group: provider data-id: redis.properties refresh: true 缺点：\n​\t将来每个分组下会有太多的配置文件，不利于维护。\n最佳实践：\n​\t命名空间区分业务功能，分组区分环境。\n","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project/20220528222829/","summary":"第一章 SpringCloudAlibaba 优就业.JAVA教研室 学习目标 了解 SpringCloudAlibaba介绍、所包含组件 理解Nacos介绍 理解Nacos下载及安装 理解Nacos服务启动 掌","title":"tk-springcloudalibaba"},{"content":"第2章 服务网关、sentinel、sleuth 优就业.java教研室 学习目标 了解 springcloudgateway 理解 springcloudgateway路由配置 理解springcloudgateway全局过滤 理解sentinel介绍 掌握sentinel快速开始 掌握sentinel整合feign 掌握sentinel流量控制 掌握sentinel熔断降级 掌握sentinel规则持久化 掌握sleth介绍 掌握sleth基本使用 1. 服务网关gateway api 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：\n破坏了服务无状态特点。\n为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中rest api无状态的特点。\n从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 无法直接复用既有接口。\n当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。\n以上这些问题可以借助 api 网关解决。api 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 api 网关这一层。也就是说，api 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 api 网关来做，这样既提高业务灵活性又不缺安全性，典型的架构图如图所示： 1.1. 快速开始 创建网关module： 完成后： 1.1.1. 引入依赖 已引入，如下。pom.xml中的依赖：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;hoxton.sr2\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; 1.1.2. 编写路由规则 为了演示路由到不同服务，这里把消费者和生产者都配置在网关中\napplication.yml\nserver: port: 18090 spring: cloud: gateway: routes: - id: nacos-consumer uri: http://127.0.0.1:18080 predicates: - path=/hi - id: nacos-provider uri: http://127.0.0.1:18070 predicates: - path=/hello 1.1.3. 启动测试 通过网关路径访问消费者或者生产者。 1.2. 路由规则详解 基本概念：\nroute：路由网关的基本构建块。它由id，目的uri，断言（predicate）集合和过滤器（filter）集合组成。如果断言聚合为真，则匹配该路由。 predicate：这是一个 java 8函数式断言。允许开发人员匹配来自http请求的任何内容，例如请求头或参数。 过滤器：可以在发送下游请求之前或之后修改请求和响应。 路由根据断言进行匹配，匹配成功就会转发请求给uri，在转发请求之前或者之后可以添加过滤器。\n1.2.1. 断言工厂 spring cloud gateway包含许多内置的route predicate工厂。所有这些断言都匹配http请求的不同属性。多路由断言工厂通过and组合。\n官方提供的路由工厂： 这些断言工厂的配置方式，参照官方文档：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.release/single/spring-cloud-gateway.html 这里重点掌握请求路径路由断言的配置方式： spring: cloud: gateway: routes: - id: host_route uri: http://example.org predicates: - path=/foo/{segment},/bar/{segment} 这个路由匹配以/foo或者/bar开头的路径，转发到http:example.org。例如 /foo/1 or /foo/bar or /bar/baz.\n/foo/1 \u0026mdash;\u0026mdash;\u0026gt;转发地址 http://example.org/foo/1\n/foo/bar\u0026mdash;\u0026ndash;\u0026gt;转发地址 http://example.org/foo/bar\n1.2.2. 过滤器工厂 路由过滤器允许以某种方式修改传入的http请求或传出的http响应。路径过滤器的范围限定为特定路由。spring cloud gateway包含许多内置的gatewayfilter工厂。 这些过滤器工厂的配置方式，同样参照官方文档：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.release/single/spring-cloud-gateway.html 过滤器 有 20 多个 实现类,根据过滤器工厂的用途来划分，可以分为以下几种：header、parameter、path、body、status、session、redirect、retry、ratelimiter和hystrix 这里重点掌握prefixpath gatewayfilter factory 上面的配置中，所有的`/foo/**`开始的路径都会命中配置的router，并执行过滤器的逻辑，在本案例中配置了rewritepath过滤器工厂，此工厂将`/foo/(?.*)`重写为{segment}，然后转发到http://example.org。比如在网页上请求localhost:8090/foo/forezp，此时会将请求转发到http://example.org/forezp的页面 (?\u0026lt;segment\u0026gt;/?.*)：匹配 /任意字符，此处/出现0次或1次。将匹配到的结果捕获到名称为segment的组中 $\\{segment}：将 segment所捕获到的文本置换到此处，注意，\\的出现是由于避免yaml认为这是一个变量，在gateway进行解析时，会被替换为${segment} ​\t在开发中由于所有微服务的访问都要经过网关，为了区分不同的微服务，通常会在路径前加上一个标识，例如：访问服务提供方：`http://localhost:18090/provider/hello` ；访问服务消费方：`http://localhost:18090/consumer/hi` 如果不重写地址，直接转发的话，转发后的路径为：`http://localhost:18070/provider/hello`和`http://localhost:18080/consumer/hi`明显多了一个provider或者consumer，导致转发失败。 这时，我们就用上了路径重写，配置如下：\nserver: port: 18090 spring: cloud: gateway: routes: - id: nacos-consumer uri: http://127.0.0.1:18080 predicates: - path=/consumer/** filters: - rewritepath=/consumer/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - id: nacos-provider uri: http://127.0.0.1:18070 predicates: - path=/provider/** filters: - rewritepath=/provider/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} # - stripprefix=1 注意：path=/consumer/**及path=/provider/**的变化\nrewritepath可以实现原来的zuul的stripprefix的效果，而且功能更强大!\n测试： 1.3. 面向服务的路由 如果要做到负载均衡，则必须把网关工程注册到nacos注册中心，然后通过服务名访问。\n1.3.1. 把网关服务注册到nacos 引入nacos的相关依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- springcloud的依赖 --\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;hoxton.sr2\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 在依赖管理中加入springcloud-alibaba组件的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2.0.release\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; 配置nacos服务地址及服务名： application.yml中的配置：\nserver: port: 18090 spring: application: name: gateway cloud: nacos: discovery: server-addr: 127.0.0.1:8848 gateway: routes: - id: nacos-consumer uri: http://127.0.0.1:18080 predicates: - path=/consumer/** filters: - rewritepath=/consumer/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - id: nacos-provider uri: http://127.0.0.1:18070 predicates: - path=/provider/** filters: - rewritepath=/provider/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} 把网关注入到nacos\n@springbootapplication @enablediscoveryclient public class gatewaydemoapplication { public static void main(string[] args) { springapplication.run(gatewaydemoapplication.class, args); } } 1.3.2. 修改配置，通过服务名路由 server: port: 18090 spring: application: name: gateway cloud: nacos: discovery: server-addr: 127.0.0.1:8848 gateway: routes: - id: nacos-consumer uri: lb://nacos-consumer predicates: - path=/consumer/** filters: - rewritepath=/consumer/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - id: nacos-provider uri: lb://nacos-provider predicates: - path=/provider/** filters: - rewritepath=/provider/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} 语法：lb://服务名\nlb：loadbalance，代表负载均衡的方式\n服务名取决于nacos的服务列表中的服务名 1.4. 路由的java代码配置方式（了解） 参见官方文档：\n代码如下：\n@configuration public class routelocatorconfig { @bean public routelocator customroutelocator(routelocatorbuilder builder){ return builder.routes() .route(r -\u0026gt; r.path(\u0026#34;/api/hello/**\u0026#34;) .filters(f -\u0026gt; f.stripprefix(1)) .uri(\u0026#34;lb://nacos-provider\u0026#34;)) .route(r -\u0026gt; r.path(\u0026#34;/ujiuye/hello/**\u0026#34;) .filters(f -\u0026gt; f.rewritepath(\u0026#34;/ujiuye/(?\u0026lt;segment\u0026gt;.*)\u0026#34;, \u0026#34;/${segment}\u0026#34;)) .uri(\u0026#34;lb://nacos-provider\u0026#34;)) .build(); } } 1.5. 网关全局过滤（了解） 全局过滤器作用于所有的路由，不需要单独配置，我们可以用它来实现很多统一化处理的业务需求，比如权限认证，ip 访问限制等等。\n1.5.1 过滤器生命周期 1.5.2 创建全局过滤器 实现 globalfilter, ordered 接口并在类上增加 @component 注解就可以使用过滤功能了，非常简单方便\npackage com.offcn.filter; import com.fasterxml.jackson.core.jsonprocessingexception; import com.fasterxml.jackson.databind.objectmapper; import com.google.common.collect.maps; import org.springframework.cloud.gateway.filter.gatewayfilterchain; import org.springframework.cloud.gateway.filter.globalfilter; import org.springframework.core.ordered; import org.springframework.core.io.buffer.databuffer; import org.springframework.http.httpstatus; import org.springframework.http.server.reactive.serverhttpresponse; import org.springframework.stereotype.component; import org.springframework.web.server.serverwebexchange; import reactor.core.publisher.mono; import java.util.map; @component public class authfilter implements globalfilter, ordered { @override public mono\u0026lt;void\u0026gt; filter(serverwebexchange exchange, gatewayfilterchain chain) { string token = exchange.getrequest().getqueryparams().getfirst(\u0026#34;token\u0026#34;); if (token == null || token.isempty()) { serverhttpresponse response = exchange.getresponse(); // 封装错误信息 map\u0026lt;string, object\u0026gt; responsedata = maps.newhashmap(); responsedata.put(\u0026#34;code\u0026#34;, 401); responsedata.put(\u0026#34;message\u0026#34;, \u0026#34;非法请求\u0026#34;); responsedata.put(\u0026#34;cause\u0026#34;, \u0026#34;token is empty\u0026#34;); try { // 将信息转换为 json objectmapper objectmapper = new objectmapper(); byte[] data = objectmapper.writevalueasbytes(responsedata); // 输出错误信息到页面 databuffer buffer = response.bufferfactory().wrap(data); response.setstatuscode(httpstatus.unauthorized); response.getheaders().add(\u0026#34;content-type\u0026#34;, \u0026#34;application/json;charset=utf-8\u0026#34;); return response.writewith(mono.just(buffer)); } catch (jsonprocessingexception e) { e.printstacktrace(); } } return chain.filter(exchange); } @override public int getorder() { return 1; } } 1.5.3 测试全局过滤器 测试访问地址：http://localhost:18090/consumer/hi 增加token测试访问地址：http://localhost:18090/consumer/hi?token=aaaa 2. sentinel 分布式系统的流量防卫兵\n2.1、服务雪崩、容错方案 分布式系统面临许多问题，其中服务雪崩、容错都是常问到的问题。\n分布式体系结构中的应用程序有很多依赖关系，每个依赖关系在某些时候将不可避免地失败。\n2.1.1、服务雪崩 当服务a的流量突然增加，服务a扛得住请求，服务b和服务c未必能扛得住这突发的请求。\n如果服务c因为抗不住请求，变得不可用。那么服务b的请求也会阻塞，慢慢耗尽服务b的线程资源，服务b就会变得不可用。紧接着，服务 a也会不可用 一个服务失败，导致整条链路的服务都失败的情形，我们称之为服务雪崩\n对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和，为了对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\n2.1.2、容错方案 想要防止雪崩的扩散，就要做好服务的容错，容错说白了就是保护自己不被其他队友坑！那我们有哪些容错的思路呢？\n1）隔离方案 它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相互独立，无强依赖。当有故障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不涉及其他模块，不影响整体的系统服务。常见的隔离方式有：线程隔离 和信号量隔离：\n2）超时方案 在上游服务调用下游服务的时候，设置一个最大响应时间，如果超过这个时间下游服务还没响应，那么就断开连接，释放掉线程\n3）限流方案 限流就是限制系统的输入和输出流量已达到保护系统的目的。为了保证系统的稳固运行，一旦达到需要限制的阈值，就需要限制流量并采用少量措施完成限制流量的目的\n限流策略有很多：稍后我们详细介绍！\n4）熔断方案 在互联网系统中，当下游服务因访问压力过大而相应变慢或失败的时候，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断\n其中熔断有分为三种状态：\n熔断关闭状态（closed） 服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制\n熔断开启状态（open） 后续对该服务接口的调用不再经过网络，直接执行本地的 fallback 方法\n半熔断状态（half-open） 尝试恢复服务调用，允许有限的流量调用该服务，并监控成功率。如果成功率达到预期，则说明服务已经恢复，进入熔断关闭状态；如果成功率依然很低，则重新进入熔断关闭状态\n5）降级方案 降级其实就是为服务提供一个 b计划，一旦服务无法正常，就启用 b计划\n方案其实有很多，但是很难说明那种方案是最好的。在开发者的世界中，没有最好，只有最适合。那如果自己写一个容错方案往往是比较容易出错的（功力高深者除外），那么为了解决这个问题，我们不妨用第三方已经为我实现好的组件！\n2.2. sentinel 是什么？ 随着微服务的流行，服务和服务之间的稳定性变得越来越重要。sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\nsentinel 的历史：\n2012 年，sentinel 诞生，主要功能为入口流量控制。 2013-2017 年，sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。sentinel 也因此积累了大量的流量归整场景以及生产实践。 2018 年，sentinel 开源，并持续演进。 2019 年，sentinel 朝着多语言扩展的方向不断探索，推出 c++ 原生版本，同时针对 service mesh 场景也推出了 envoy 集群流量控制支持，以解决 service mesh 架构下多语言限流的问题。 2020 年，推出 sentinel go 版本，继续朝着云原生方向演进。 sentinel 分为两个部分:\n核心库（java 客户端）不依赖任何框架/库，能够运行于所有 java 运行时环境，同时对 dubbo / spring cloud 等框架也有较好的支持。 控制台（dashboard）基于 spring boot 开发，打包后可以直接运行，不需要额外的 tomcat 等应用容器。 sentinel 可以简单的分为 sentinel 核心库和 dashboard。核心库不依赖 dashboard，但是结合 dashboard 可以取得最好的效果。\n2.3. 基本概念及作用 基本概念：\n资源：是 sentinel 的关键概念。它可以是 java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。\n只要通过 sentinel api 定义的代码，就是资源，能够被 sentinel 保护起来。大部分情况下，可以使用方法签名，url，甚至服务名称作为资源名来标示资源。\n规则：围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。\n主要作用：\n流量控制 熔断降级 系统负载保护 我们说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 sentinel 来进行资源保护，主要分为几个步骤:\n定义资源 定义规则 检验规则是否生效 先把可能需要保护的资源定义好，之后再配置规则。也可以理解为，只要有了资源，我们就可以在任何时候灵活地定义各种流量控制规则。在编码的时候，只需要考虑这个代码是否需要保护，如果需要保护，就将之定义为一个资源。\n2.4. 快速开始 官方文档：https://github.com/alibaba/spring-cloud-alibaba/wiki/sentinel\n2.4.1. 搭建dashboard控制台 您可以从 release 页面 下载最新版本的控制台 jar 包。\nhttps://github.com/alibaba/sentinel/releases\n下载的jar包（课前资料已下发），copy到一个没有空格或者中文的路径下，打开dos窗口切换到jar包所在目录。\n执行：java -jar sentinel-dashboard-xxx.jar\n在浏览器中访问sentinel控制台，默认端口号是8080。\n进入登录页面(http://localhost:8080/#/dashboard)，\n管理页面用户名和密码：sentinel/sentinel\n此时页面为空，这是因为还没有监控任何服务。另外，sentinel是懒加载的，如果服务没有被访问，也看不到该服务信息。\n2.4.2. 改造nacos-consumer 引入 sentinel 依赖 使用 group id 为 com.alibaba.cloud 和 artifact id 为 spring-cloud-starter-alibaba-sentinel 的 starter。\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 在application.yml中添加配置 spring: cloud: sentinel: transport: dashboard: 192.168.188.138:8080 port: 8719 # 暴露/actuator/sentinel端点 management: endpoints: web: exposure: include: \u0026#39;*\u0026#39; 注意：必须暴露 /actuator/sentinel端点；（http://localhost:8000/actuator/sentinel）\n重启nacos-consumer工程，在浏览器中反复访问：http://localhost:18080/hi\n再次查看sentinel控制台页面：\n了解一下控制台的使用原理：\n当 sentinel应用启动后，我们需要将我们的微服务程序注册到控制台上，也就是在配置文件中指定控制台的地址，这个是肯定的。但是所谓用来跟控制台交流的端口，也就是我们每个服务都会通过这个端口跟控制台传递数据，控制台也可以通过此端口调用微服务中的监控程序来获取微服务的各种信息。\n2.5. 整合feign组件 sentinel 适配了 feign 组件。使用分三步：\n引入依赖： 引入feign及sentinel的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 注意：springcloud的版本兼容问题使用的是hoxton.sr2 兼容的cloud alibaba版本是:2.2.0.release\n注意:spring-cloud-starter-openfeign 2.2.6release 最高不能超过\n开启sentinel监控功能 feign: sentinel: enabled: true 代码实现 添加feign接口的熔断类providerfallback：\n@component public class providerfallback implements providerclient { @override public string hello() { return \u0026#34;现在服务器忙，请稍后再试！\u0026#34;; } } 在feign接口providerclient中指定熔断类： 测试之前，先在服务提供方的controller方法中添加异常： 再重启nacos-provider和nacos-consumer服务。在浏览器中地址栏访问消费方测试： 2.6. 流量控制 2.6.1. 什么是流量控制 流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示： 流量控制有以下几个角度:\n资源的调用关系，例如资源的调用链路，资源和资源之间的关系； 运行指标，例如 qps、线程数等； 控制的效果，例如直接限流（快速失败）、冷启动（warm up）、匀速排队（排队等待）等。 sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。\n配置如下： 2.6.2. qps流量控制 qps：每秒钟处理请求次数.\n当 qps 超过某个阈值的时候，则采取措施进行流量控制。流量控制的效果包括以下几种：直接拒绝、warm up、匀速排队。\n2.6.2.1. 直接拒绝 直接拒绝（ruleconstant.control_behavior_default）方式是默认的流量控制方式，当qps超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出flowexception。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。\n这里做一个最简单的配置：\n​ 阈值类型选择：qps\n​ 单机阈值：2\n综合起来的配置效果就是，该接口的限流策略是每秒最多允许2个请求进入。\n点击新增按钮之后，可以看到如下界面： 在浏览器访问：http://localhost:18080/hi，并疯狂刷新，出现如下信息： 2.6.2.2. warm up（预热） warm up（ruleconstant.control_behavior_warm_up）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过\u0026quot;冷启动\u0026quot;，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。 疯狂访问：http://localhost:18080/hi 可以发现前几秒会发生熔断，几秒钟之后就完全没有问题了 2.6.2.3. 匀速排队 匀速排队（ruleconstant.control_behavior_rate_limiter）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。\n测试配置如下：1s处理一个请求，排队等待，等待时间20s。\n在postman中，新建一个collection（这里collection名称是sentinel），并把一个请求添加到该collection\n请求添加成功后，点击run按钮：\n配置每隔100ms发送一次请求，一共发送20个请求： 点击“run sentinel”按钮\n查看控制台，效果如下：可以看到基本每隔1s打印一次 注意，在消费者打印当前毫秒值。system.out.println(system.currenttimemillis());\n2.6.3. 关联限流 关联限流：当关联的资源请求达到阈值时，就限流自己。\n配置如下：/hi2的关联资源/hi，并发数超过/hi的限流时，/hi2就限流自己 给消费者添加一个controller方法：\n由于对/hi2的限流控制采用qps关联，所以直接访问不会被限流，会发现一直刷新/hi2不会出现限流\n测试访问/hi，超过限流阀值，在浏览器访问/hi2发现限流了：\npostman配置如下：每个400ms发送一次请求，一共发送50个。每秒钟超过了2次\n在浏览器中访问/hi2 已经被限流。 2.6.4. 链路限流 一棵典型的调用树如下图所示：\nmachine-root / \\ / \\ entrance1 entrance2 / \\ / \\ defaultnode(nodea) defaultnode(nodea) 上图中来自入口 entrance1 和 entrance2 的请求都调用到了资源 nodea，sentinel 允许只根据某个入口的统计信息对资源限流。\n配置如下：表示只针对entrance1进来的请求做限流限制 2.6.5. 线程数限流 **并发线程数限流用于保护业务线程数不被耗尽。**例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对太多线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离）。这种隔离方案虽然隔离性比较好，但是代价就是线程数目太多，线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。sentinel 并发线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目，如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离。\n配置如下：如果请求的并发数超过一个就限流 改造controller中的hi方法： 测试\npostmain配置如下： 同时在浏览器访问：\n2.7. 熔断降级 sentinel除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。\nsentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 degradeexception）。\nsentinel 和 hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。\n限流降级指标有三个，如下图：\n平均响应时间（rt）\n异常比例\n异常数 2.7.1. 平均响应时间（rt） 平均响应时间 (degrade_grade_rt)：当资源的平均响应时间超过阈值（degraderule 中的 count，以 ms 为单位，默认上限是4900ms）之后，资源进入准降级状态。如果1s之内持续进入 5 个请求，它们的 rt 都持续超过这个阈值，那么在接下来的时间窗口（degraderule 中的 timewindow，以 s 为单位）之内，对这个方法的调用都会自动地返回（抛出 degradeexception）。在下一个时间窗口到来时, 会接着再放入5个请求, 再重复上面的判断。\n配置如下：超时时间100ms，熔断时间10s\n代码中依然睡了1s\n也就是说请求肯定都会超时。\n先执行postmain，配置如下：\n再次见到了熟悉的界面：\n10s之内，都是熔断界面\n2.7.2. 异常比例 异常比例 (degrade_grade_exception_ratio)：当资源的每秒请求量 \u0026gt;= 5，且每秒异常总数占通过量的比值超过阈值（degraderule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（degraderule中的 timewindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。\n2.7.3. 异常数 异常数 (degrade_grade_exception_count)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。\n2.8. 规则持久化 无论是通过硬编码的方式来更新规则，还是通过接入 sentinel dashboard 后，在页面上操作更新规则，都无法避免一个问题，那就是服务重启后，规则就丢失了，因为默认情况下规则是保存在内存中的。\n我们在 dashboard 上为客户端配置好了规则，并推送给了客户端。这时由于一些因素客户端出现异常，服务不可用了，当客户端恢复正常再次连接上 dashboard 后，这时所有的规则都丢失了，我们还需要重新配置一遍规则，这肯定不是我们想要的。\n持久化配置分以下3步：\n引入依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.csp\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;sentinel-datasource-nacos\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置： spring: cloud: sentinel: transport: dashboard: 192.168.188.138:8080 port: 8719 datasource: consumer: nacos: server-addr: 192.168.188.138:8848 dataid: ${spring.application.name}-sentinel-rules groupid: sentinel_group data-type: json rule_type: flow nacos中创建流控规则 配置内容如下：\n[ { \u0026#34;resource\u0026#34;: \u0026#34;/hi\u0026#34;, \u0026#34;limitapp\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;grade\u0026#34;: 1, \u0026#34;count\u0026#34;: 2, \u0026#34;strategy\u0026#34;: 0, \u0026#34;controlbehavior\u0026#34;: 0, \u0026#34;clustermode\u0026#34;: false } ] resource：资源名称\nlimitapp：限流应用，就是用默认就可以\ngrade：阈值类型，0表示线程数，1表示qps\ncount：单机阈值\nstrategy：流控模式，0-直接，1-关联， 2-链路\ncontrolbehavior：流控效果。0-快速失败，1-warm up 2-排队等待\nclustermode：是否集群\n重启consumser，并多次访问：http://localhost:18080/hi。\n查看sentinel客户端：就有了限流配置了\n现在你可以尝试测试一下限流配置了\n3. sleuth ​\tspring cloud sleuth为springcloud实现了一个分布式链路追踪解决方案，大量借鉴了dapper，zipkin和htrace等链路追踪技术。对于大多数用户而言，sleuth应该是不可见的，并且您与外部系统的所有交互都应自动进行检测。您可以简单地在日志中捕获数据，也可以将其发送到远程收集器服务。\n​\t随着分布式系统越来越复杂，你的一个请求发过发过去，各个微服务之间的跳转，有可能某个请求某一天压力太大了，一个请求过去没响应，一个请求下去依赖了三四个服务，但是你去不知道哪一个服务出来问题，这时候我是不是需要对微服务进行追踪呀？监控一个请求的发起，从服务之间传递之间的过程，我最好记录一下，记录每一个的耗时多久，一旦出了问题，我们就可以针对性的进行优化，是要增加节点，减轻压力，还是服务继续拆分，让逻辑更加简单点呢？这时候springcloud-sleuth集成zipkin能帮我们解决这些服务追踪问题。\n3.1. zipkin分布式监控客户端 zipkin是一种分布式跟踪系统。它有助于收集解决微服务架构中的延迟问题所需的时序数据。它管理这些数据的收集和查找。zipkin的设计基于google dapper论文。应用程序用于向zipkin报告时序数据。zipkin ui还提供了一个依赖关系图，显示了每个应用程序通过的跟踪请求数。如果要解决延迟问题或错误，可以根据应用程序，跟踪长度，注释或时间戳对所有跟踪进行筛选或排序。选择跟踪后，您可以看到每个跨度所需的总跟踪时间百分比，从而可以识别有问题的应用程序。\n通过docker安装：docker run -d -p 9411:9411 openzipkin/zipkin\n通过jar包安装：java -jar zipkin-server-*exec.jar\njar包下载地址：https://search.maven.org/remote_content?g=io.zipkin\u0026amp;a=zipkin-server\u0026amp;v=latest\u0026amp;c=exec\n课前资料有已下载的jar包\n在浏览器端访问：http://localhost:9411\n3.2. 改造consumer/provider工程 对consumer和provider工程分别做如下操作：\n引入sleuth的依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-zipkin\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; zipkin的启动器包含了sleuth的依赖。\n配置zipkin的相关信息 spring: zipkin: base-url: http://192.168.188.138:9411 discovery-client-enabled: false sender: type: web 重启consumer/provider服务后，访问消费者：http://localhost:18080/hi。查看zipkin客户端如下 这时候我们可以在zipkin的ui控制界面看看效果，可以发现，服务之间的调用关系，服务名称已经清晰展现出来了，同时包括服务之间的调用时常等详细信息以及更细的信息都可以通过控制台看到。 还可以查看调用关系图： 3.3. 基本概念 span：基本工作单元。发送一个远程请求就会产生一个span，span通过一个64位id唯一标识，trace以另一个64位id表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的id、以及进度id(通常是ip地址)。span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。\ntrace：一系列spans组成的一个树状结构。例如：发送一个请求，需要调用多个微服务，每调用一个微服务都会产生一个span，这些span组成一个trace\nannotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束\ncs - client sent -客户端发起一个请求，这个annotion描述了这个span的开始 sr - server received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟 ss - server sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间 cr - client received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间 例如一个请求如下： 使用zipkin跟踪整个请求过程如下： 上图表示一请求链路，一条链路通过trace id唯一标识，span标识发起的请求信息，各span通过parent id 关联起来，如图 ","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project/20220528224436/","summary":"第2章 服务网关、Sentinel、Sleuth 优就业.JAVA教研室 学习目标 了解 SpringCloudGateWay 理解 SpringCloudGateWay路由配置 理解SpringCloudGa","title":"tk-服务网关、sentinel、sleuth"},{"content":"第三章 优学题库项目基本框架搭建 优就业.java教研室 学习目标 了解优学题库项目介绍 理解项目搭建 理解搭建管理后台 理解逆向生成代码 掌握模块工程配置 掌握搭建nacos注册中心 掌握注册各个微服务到nacos 掌握搭建网关服务 1. 优学在线考试题库系统介绍 1.1 项目介绍 中公教育集团作为一家上市培训企业，每天服务于几千万学员，涉及题库类型丰富多样，具有海量的题目信息。\n优学题库项目正是基于这样的背景下诞生的一套题库系统，系统支持自定义题库类型，可以满足广大学员对于各类型题型的学习使用。优学题库系统采用springcloud alibaba分布式架构体系，基于vue前后端分离技术实现后台管理，基于微信小程序实现移动端应用。\n1.2 系统界面 1、用户移动端 2、系统管理端 2. 搭建项目 功能架构 技术架构图 2.1 项目结构说明 核心是microservice这块儿，它分两类微服务：\n后台crud微服务\ncontent：内容管理系统（product） 10001\nmember：会员管理系统（user）10002\nquestion：题库管理系统（warehouse） 10003\n后端采用:springboot+springcloud gateway+mybatis plus+nacos\n前端采用：vue+element ui+node.js\n数据层：mysql、redis、rabbitmq、阿里oss\n后台管理前端：uxue-admin（1000）\n网关：uxue-gateway（8888）\n2.2 数据准备 把课前资料中的数据文件导入数据库： 导入数据库之后： uxue_admin:管理后台数据库\nuxue_cms:广告内容服务数据库\nuxue_qms:题目服务数据库\nuxue_ums:会员服务数据库\n注意数据库版本：5.7\n2.3. git安装和配置 2.3.1 什么是git git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 git 是 linus torvalds 为了帮助管理 linux 内核开发而开发的一个开放源码的版本控制软件。\n2.3.2 git相关软件下载 git的下载页面： https://git-scm.com/ 目前最新版：git-2.13.0 注意下载对应操作系统位数的安装包。\n2.3.3 git安装与配置 1、选中git安装包，git-2.13.0-64-bit.exe 单击右键，弹出对话框，点击【解除锁定】。 2、双击git安装包，git-2.13.0-64-bit.exe 开始安装（如有安全告警，点击运行） 3、出现授权信息页面，点击下一步即可 4、接下来逐步点击【next】即可安装成功 2.3.4 git成功 在命令行输入命令\ngit --version 屏幕显示：git version 2.13.0.windows.1 出现上面的版本号提示表示git安装成功。\n2.3.5 git配置 配置当前开发者名称、邮箱、默认推送方式\ngit config --global user.name \u0026#34;offcn-java\u0026#34; git config --global user.email \u0026#34;myqq@qq.com\u0026#34; git config --global push.default simple 注意\u0026ndash;global 参数 表示全局配置。\n查看配置是否生效：\ngit config -l 查看配置是否正确 2.3. 使用gitee创建仓库 2.3.1 申请gitee账号 访问地址：https://gitee.com/signup 注册账号 2.3.2.登录gitee创建仓库 2.3.3 克隆项目到本地： 找到项目克隆地址： 在命令执行命令克隆项目到本地:\ngit clone https://gitee.com/hk109/uxue.git 2.4. 项目初始创建 把资料/基础工程中的文件 copy到 clone下来的uxue工程中 接下来在idea中导入uxue工程： 点击“ok”，一路下一步：项目成功导入到idea 2.4.1 在idea的terminal窗口，查看git状态： git status 2.4.2 把当前项目新增文件添加到待处理列表 git add . 2.4.3 提交当前项目到git本地仓库 git commit -m \u0026#34;优学题库系统\u0026#34; 2.4.4 推送到远程仓库： git push origin master 效果：\n2.5. 创建项目模块 2.5.1. 创建广告内容服务模块 创建完成： 项目统一定义springcloud和spring cloud alibaba版本及初始化依赖：\n\u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;spring-cloud-alibaba.version\u0026gt;2.2.0.release\u0026lt;/spring-cloud-alibaba.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;hoxton.release\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.junit.vintage\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit-vintage-engine\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 2.5.2. 创建会员服务模块 新建模块： 其他项，参考广告内容服务模块。\n2.5.3. 创建题目服务模块 其他项参考广告内容服务模块\n2.5.4. 完整工程 设置uxue父工程管理相关子模块，修改pom.xml\n\u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;u-context\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;u-member\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;u-question\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 修改后刷新maven 接下来把这些新模块push到gitee。\ngit add . git commit -m \u0026#34;创建后台工程\u0026#34; git push origin master 3、搭建管理后台 管理后台使用人人开源的后台管理框架，完成快速搭建。\n3.1、下载人人开源后台管理框架 renren-fast 管理后台后端（服务端） https://gitee.com/renrenio/renren-fast.git\nrenren-fast-vue 管理后台前端（vue前端界面） https://gitee.com/renrenio/renren-fast-vue.git\n3.2、添加人人开源管理后端代码到java项目 拷贝文件夹renren-fast到uxue根目录 pom文件 添加模块管理\n\u0026lt;module\u0026gt;renren-fast\u0026lt;/module\u0026gt; 刷新项目maven 3.3、修改renren-fast 服务的配置文件 文件路径：src/main/resources/application-dev.yml\n修改数据库连接为自己的mysql数据库连接\nspring: datasource: type: com.alibaba.druid.pool.druiddatasource druid: driver-class-name: com.mysql.cj.jdbc.driver url: jdbc:mysql://localhost:3306/uxue_admin?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=asia/shanghai username: root password: root initial-size: 10 max-active: 100 min-idle: 10 max-wait: 60000 pool-prepared-statements: true max-pool-prepared-statement-per-connection-size: 20 time-between-eviction-runs-millis: 60000 min-evictable-idle-time-millis: 300000 #oracle需要打开注释 #validation-query: select 1 from dual test-while-idle: true test-on-borrow: false test-on-return: false stat-view-servlet: enabled: true url-pattern: /druid/* #login-username: admin #login-password: admin filter: stat: log-slow-sql: true slow-sql-millis: 1000 merge-sql: false wall: config: multi-statement-allow: true 3.4、启动renren-fast服务 运行renren-fast后台 启动运行成功： 3.5、测试服务运行状态 浏览器输入：http://localhost:8080/renren-fast/\n显示结果： 结果如上所示，则表示服务运行正常。另外结果里面的invalid token说明权限不足，不是指服务不正常。\n4. 逆向工程生成代码 4.1、下载代码生成器框架 git clone https://gitee.com/renrenio/renren-generator.git 4.2、导入生成器代码到uxue项目 拷贝文件夹renren-fast到uxue项目根目录 pom文件 添加依赖\n\u0026lt;module\u0026gt;renren-generator\u0026lt;/module\u0026gt; 最终uxue项目结构： 4.3、逆向生成管理前后端代码 下面以生成context广告内容服务的代码为例，其他模块操作类似！！！！！！！\n4.3.1. 修改配置 （1）、修改application.yml，把数据库及其连接信息改成广告的数据库：uxue_cms （2）、修改generator.properties： （3）、修改controller模板文件\nsrc/main/resources/template/controller.java.vm\n暂时删除引入的包，后面再引入\n//import org.apache.shiro.authz.annotation.requirespermissions; 注释requirespermissions注解，后面再引入\n//@requirespermissions(\u0026#34;${modulename}:${pathname}:list\u0026#34;) 4.3.2. 启动逆向工程 启动renrenapplication： 启动成功，监听端口号为80。浏览器访问，点击renren-fast,出现生成界面，可以看到数据表 选中全部表，点击生成代码按钮，即可生成一个压缩包，被下载下来： 找到压缩包。\n4.3.3. 把文件copy到对应工程 打开压缩包，压缩包/main/java下的com目录，copy到u-context模块的src/main/java： 效果如下：\n把压缩包/main/resources下的mapper目录，copy到ucontext模块的src/java/resources目录下： 如下：\n4.4、添加common 模块 因为自动生成的代码引用了一些工具类，而我们的项目中没有，所以需要加个common模块添加一些工具类 在uxue项目新建子模块u-common\nnew module: 选择maven 4.4.1、修改u-common模块的依赖 \u0026lt;dependencies\u0026gt; \u0026lt;!--mybatis-plus dao层工具 https://mp.baomidou.com/--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis-plus整合springboot依赖包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--添加mysql驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.32\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--lombok 不需要写getter,setter方法了--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.projectlombok\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;lombok\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.18.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--httpcore 依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.httpcomponents\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;httpcore\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--commons-lang 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;commons-lang\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;commons-lang\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 导入servlet-api 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;javax.servlet\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;servlet-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 4.4.2、u-common模块添加工具类 添加包:com.offcn.common.utils\n从renren-fast项目copy文件:\nconstans.java、pageutils.java、query.java、r.java、rrexception.java 添加包:com.offcn.common.xss\n从renren-fast项目copy文件: htmlfilter.java、sqlfilter.java 修改sqlfilter引入的rrexception类所在的包为common下的。\nimport com.offcn.common.utils.rrexception; 修改类query,把引入类sqlfilter,修改所在包为common下的：\nimport com.offcn.common.xss.sqlfilter; 最终u-common目录结构如下： 4.4.3、u-context模块引入u-common依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;u-common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4.4.4、解决u-common编译错误 执行mvn install 出现下面的错误： 解决方案，修改模块pom.xml增加maven编译插件，指定jdk版本为1.8\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.apache.maven.plugins\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;maven-compiler-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.7.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;utf-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 4.5、生成其他服务的代码 参考u-context的代码生成方式，生成其他模块的代码\n服务名称 对应数据库名称 模块名称 监听端口 广告内容服务 uxue_cms u-context 10001 会员服务 uxue_ums u-member 10002 题目服务 uxue_qms u-question 10003 5、模块工程的配置 后台管理模块，每个工程的配置方式基本一样。下面还是以u-context工程为例：\n5.1、配置依赖 每个服务到要依赖u-common包\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;u-common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 5.2、 工程参数配置 application.yml配置文件：\nserver: port: 10001 spring: datasource: url: jdbc:mysql://localhost:3306/uxue_cms?servertimezone=gmt%2b8\u0026amp;characterencoding=utf-8 username: root password: root driver-class-name: com.mysql.jdbc.driver mybatis-plus: mapper-locations: classpath:/mapper/**/*.xml global-config: db-config: id-type: auto 5.3、在引导类上添加注解 在u-context工程的主启动类（ucontextapplication）上添加注解：\n@springbootapplication @mapperscan(\u0026#34;com.offcn.context.dao\u0026#34;) public class ucontextapplication { public static void main(string[] args) { springapplication.run(ucontextapplication.class, args); } } 5.4、测试 启动主启动类，访问地址：http://localhost:10001/context/news/list 5.5、 参照u-context完成其他模块 其他模块都按照u-context的方式完成搭建。(其中学习服务和渠道服务省略)\n服务名称 对应数据库名称 模块名称 监听端口 广告内容服务 uxue_cms u-context 10001 会员服务 uxue_ums u-member 10002 题目服务 uxue_qms u-question 10003 全部服务测试地址：\nhttp://localhost:10001/context/banner/list http://localhost:10002/member/member/list http://localhost:10003/question/question/list\n6、搭建注册中心nacos 6.1 启动nacos服务 linux/unix/mac\n启动命令(standalone代表着单机模式运行，非集群模式):\nsh startup.sh -m standalone windows\n启动命令：\ncmd startup.cmd -m standalone 或者双击startup.cmd运行文件。\n访问：http://localhost:8848/nacos\n用户名密码：nacos/nacos 7、注册各个微服务到nacos 7.1、修改u-context服务的pom.xml引入注册到nacos所需依赖包 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 7.2、修改配置文件application.yml spring: application: name: u-context cloud: nacos: discovery: server-addr: localhost:8848 7.3、修改主启动类，添加注解 @springbootapplication @mapperscan(\u0026#34;com.offcn.context.dao\u0026#34;) @enablediscoveryclient public class ucontextapplication { public static void main(string[] args) { springapplication.run(ucontextapplication.class, args); } } 7.4、启动主启动类，查看nacos管理控制台，成功注册 7.5、注册人人管理后台服务到nacos 配置模块renren-fast模块注册到nacos\n7.5.1、引入nacos客户端依赖 修改模块renren-fast的pom.xml\n首先定义spring cloud alibaba的版本\n\u0026lt;properties\u0026gt;\t\u0026lt;spring-cloud-alibaba.version\u0026gt;2.2.0.release\u0026lt;/spring-cloud-alibaba.version\u0026gt;\t\u0026lt;/properties\u0026gt; 引入spring cloud alibaba的依赖管理：\n\u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; 最后引入springcloudalibaba 注册到nacos的客户端依赖包\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 7.5.2、修改配置文件 修改配置文件application.yml声明应用名称\nspring: application: name: renren-fast 修改配置文件application-dev.yml，指定nacos服务器地址\nspring: cloud: nacos: discovery: server-addr: http://localhost:8848 7.5.3、修改主启动类renrenapplication，增加允许注册发现注解 @springbootapplication @enablediscoveryclient public class renrenapplication { public static void main(string[] args) { springapplication.run(renrenapplication.class, args); } } 7.5.4、启动主启动类，查看服务是否注册到nacos 7.6、注册其他微服务到nacos 其他微服务和u-context服务一样的配置，全部注册到nacos 7.7、注册到nacos失败 有的时候nacos服务器已经启动了，但是依然注册失败，\n访问http://localhost:8848/nacos/v1/ns/instance 地址 提示如下： 解决办法：把nacos服务器停掉，删除 nacos/data/protocol 目录 然后重启nacos即可\n8、 搭建网关服务 nacos容器内的所有服务，可以直接相互访问。nacos外的服务，为了保证安全，必须通过网关访问后台各个管理模块 8.1、网关依赖配置文件pom.xml: \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.3.7.release\u0026lt;/version\u0026gt; \u0026lt;relativepath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;cloud-gateway\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;cloud-gateway\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;demo project for spring boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;hoxton.sr9\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;spring-cloud-alibaba.version\u0026gt;2.2.3.release\u0026lt;/spring-cloud-alibaba.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.junit.vintage\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit-vintage-engine\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 8.2、application.yml配置路由转发： server: port: 8888 spring: cloud: nacos: discovery: server-addr: localhost:8848 gateway: routes: - id: cms-route uri: lb://u-context predicates: - path=/context/** filters: - rewritepath=/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - id: qms-route # 题目微服务路由 uri: lb://u-question predicates: - path=/question/** filters: - rewritepath=/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - id: ums-route # 用户微服务路由 uri: lb://u-member predicates: - path=/member/** filters: - rewritepath=/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - id: renrenfast-route # 人人后台服务路由 uri: lb://renren-fast predicates: - path=/renren-fast/** filters: - rewritepath=/renren-fast/(?\u0026lt;segment\u0026gt;.*),/renren-fast/$\\{segment} application: name: gateway 8.3、测试网关转发 测试各个微服务经过网关转发调用是否正常\n服务名称 测试地址 内容微服务 http://localhost:8888/context/banner/list 题目微服务 http://localhost:8888/question/question/list 用户微服务 http://localhost:8888/member/member/list 人人后台服务 http://localhost:8888/renren-fast/captcha.jpg?uuid=84d36089-07ae-4201-85c0-8217b032f21c ","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project/20220528231163/","summary":"第三章 优学题库项目基本框架搭建 优就业.JAVA教研室 学习目标 了解优学题库项目介绍 理解项目搭建 理解搭建管理后台 理解逆向生成代码 掌握模块工程配置 掌握搭建Nacos注","title":"tk-题库项目基本框架搭建"},{"content":"第四章 优学题库项目开发2 优就业.java教研室 学习目标 了解启动开源管理前端框架 掌握开发配置题目分类服务及前端维护管理功能 掌握开发配置题目维护后端服务及前端维护管理功能 掌握完成题目导入、导出功能开发 掌握echarts图表入门 掌握统计分析功能开发 1、启动人人开源管理前端 1.1、确认本地已经安装好node.js 输入指令，确认：\nnode -v node.js安装教程\nhttps://www.runoob.com/nodejs/nodejs-install-setup.html\n1.2、安装前端开发工具vscode 下载前端代码：\nrenren-fast-vue 管理后台前端 https://gitee.com/hk109/renren-fast-vue.git\n1.2.1 打开人人开源管理前端代码所在目录 1.2.2 选中人人开源前端代码的目录， 1.2.3打开目录效果。 1.2.4保存工作区： 1.2.5选中工作区保存位置 1.2.6 最终保存为工作区 1.2.7、禁用eslint插件 1.3、启动前端项目 1.3.1 进入vscode终端 终端界面\nnpm -v 1.3.2 配置cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org 1.3.3 安装node_modules依赖包 cnpm install 注意安装的饿时候，需要修改package.json，里面的node-sass的依赖版本号:^4.14.1 1.3.4 打包运行前端项目 npm run dev 1.3.5 浏览器访问 注意：renren-fast项目要先启动 浏览后台：http://localhost:8001 登录后台\n账号：admin\n密码：admin 1.4、配置前端使用api网关-请求后端api接口调用地址 修改配置文件对接后端api地址：\n文件：renren-fast-vue\\static\\config\\index.js\napi接口请求地址替换为题目微服务的地址\nwindow.site_config[\u0026#39;baseurl\u0026#39;] = \u0026#39;http://localhost:8080/renren-fast\u0026#39;; 替换为 window.site_config[\u0026#39;baseurl\u0026#39;] = \u0026#39;http://localhost:8888/api\u0026#39;; // 网关地址 配置cloud-gateway转发到renren-fast的路由：\nspring: cloud: gateway: routes: - id: renrenfast-route # 人人后台服务路由 uri: lb://renren-fast predicates: - path=/api/** filters: - rewritepath=/api/(?\u0026lt;segment\u0026gt;.*),/renren-fast/$\\{segment} 刷新登录页面，可以正常获取验证码，请求路径为网关地址 + /api/captcha.jpg?uuid=xxxxx\nhttp://localhost:8888/api/captcha.jpg?uuid=84d36089-07ae-4201-85c0-8217b032f23e 1.5、登录跨域问题 点击登录，控制台报错，登录失败：\naccess to xmlhttprequest at \u0026#39;http://localhost:8888/api/sys/login\u0026#39; from origin \u0026#39;http://localhost:8001\u0026#39; has been blocked by cors policy: response to preflight request doesn\u0026#39;t pass access control check: no \u0026#39;access-control-allow-origin\u0026#39; head is present on the requested resource 登录页面url：http://localhost:8001，点击登录访问的请求url：http://localhost:8888/api/sys/login，两个url的端口号不一样，产生了跨域问题。\n什么是跨域？ 跨域资源共享(cors) 是一种机制，它使用额外的 http 头来告诉浏览器 让运行在一个 origin (domain) 上的web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 http 请求。\n比如，站点 http://domain-a.com 的某 html 页面通过 的 src 请求 http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的css样式表，图像和脚本等资源。\n出于安全原因，浏览器限制从脚本内发起的跨源http请求。 例如，xmlhttprequest和fetch api遵循同源策略。 这意味着使用这些api的web应用程序只能从加载应用程序的同一个域请求http资源，除非响应报文包含了正确cors响应头。 1.6、解决跨域问题 添加响应头，配置当次请求允许跨域\naccess-control-allow-origin：支持哪些来源的请求跨域 access-control-allow-methods：支持哪些方法跨域 access-control-allow-credentials：跨域请求默认不包含cookie，设置为true可以包含cookie access-control-expose-headers：跨域请求暴露的字段cors请求时，xmlhttprequest对象的getresponseheader()方法只能拿到6个基本字段：cache-control、content-language、content-type、expires、last-modified、pragma。如果想拿到其他字段，就必须在access-control-expose-headers里面指定。 access-control-max-age：表明该响应的有效时间为多少秒。在有效时间内，浏览器无 须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果 该首部字段的值超过了最大有效时间，将不会生效。\n1.6.1 添加跨域配置 在cloud-gateway模块添加解决跨域的配置文件gatewaycorsconfiguration\nimport org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; import org.springframework.web.cors.corsconfiguration; import org.springframework.web.cors.reactive.corswebfilter; import org.springframework.web.cors.reactive.urlbasedcorsconfigurationsource; @configuration public class gatewaycorsconfiguration { @bean public corswebfilter corswebfilter() { urlbasedcorsconfigurationsource source = new urlbasedcorsconfigurationsource(); corsconfiguration corsconfiguration = new corsconfiguration(); // 配置跨域 corsconfiguration.addallowedheader(\u0026#34;*\u0026#34;); // 允许所有请求头跨域 corsconfiguration.addallowedmethod(\u0026#34;*\u0026#34;); // 允许所有请求方法跨域 corsconfiguration.addallowedorigin(\u0026#34;*\u0026#34;); // 允许所有请求来源跨域 corsconfiguration.setallowcredentials(true); //允许携带cookie跨域，否则跨域请求会丢失cookie信息 source.registercorsconfiguration(\u0026#34;/**\u0026#34;, corsconfiguration); return new corswebfilter(source); } } 也可以采用配置方式，修改application.yml:\nspring: cloud: gateway: globalcors: #跨域配置 cors-configurations: \u0026#39;[/**]\u0026#39;: allowcredentials: true #允许跨域读取cookie allowedorigins: \u0026#34;*\u0026#34; #允许发出跨域请求主机域名 * 任意主机 allowedmethods: \u0026#34;*\u0026#34; #请求方法 allowedheaders: \u0026#34;*\u0026#34; #允许发出跨域的请求头 1.6.2、注释renren-fast跨域配置 注释renren-fast里面的跨域配置\n文件路径：src/main/java/io/renren/config/corsconfig.java\n重启各个服务及网关，测试即可成功登录。 1.6.3 前后端联调登录 登录成功\n查看后端服务日志\n说明前端登录请求发送到了后端服务，并验证了用户名和密码是否正确。\n2、开发配置题目分类服务前端维护管理功能 2.1、添加题目管理目录（一级菜单） 选择管理界面\u0026ndash;系统管理\u0026ndash;菜单管理，点击 新增按钮 刷新页面,就可以看到题目中心菜单 2.2、添加题目类型维护菜单(二级菜单) 选择管理界面\u0026ndash;系统管理\u0026ndash;菜单管理，点击 新增按钮\n选择类型：菜单 刷新，可以看到菜单 可以看到数据库uxeu_admin的表sys_menu中新增了两条记录,分别对应两个菜单 点击类型维护菜单,打开了链接:http://localhost:8001/#/question-type,页面显示空白页面.\n2.3、自动生成类型维护前端页面 用renren-generator自动生成前端代码\n注意配置数据库连接文件application.yml,指向数据库 uxue_qms\n修改模板生成属性配置文件generator.properties\n配置模块名和包名： 重启服务，打开生成页面选择表，点击生成 2.4、拷贝前端代码到 前端工程renren-fast-vue 拷贝\\main\\resources\\src\\views\\modules\\question目录到前端目录 renren-fast-vue\\src\\views\\modules 2.5、测试类型维护 点击类型维护菜单,可以看到请求报404\nhttp://localhost:8001/#/question-type 因为页面的请求都访问到renren-fast服务了,所以要修改为访问题目微服务。\n修改colud-gateway网关配置，配置转发题目微服务：\n（注意：qms-route的路由配置一定要配置在renrenfast-route之前，拥有加载顺序。）\nspring: cloud: nacos: discovery: server-addr: http://localhost:8848 gateway: routes: - id: qms-route # 题目微服务路由 uri: lb://u-question predicates: - path=/api/question/** filters: - rewritepath=/api/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - id: renrenfast-route # 人人后台服务路由 uri: lb://renren-fast predicates: - path=/api/** filters: - rewritepath=/api/(?\u0026lt;segment\u0026gt;.*),/renren-fast/$\\{segment} 重启网关服务，再次刷新访问地址：http://localhost:8001/#/question-type\n即可正常访问题目类型列表页：\n数据库插入3条测试数据 测试查询列表，可以看到有三条记录查询出来了 点击 修改：\n点击 确定 即可完成修改。\n点击删除即可删除记录\n弹出删除确认提示：\n确定即可删除对应记录\n2.6、开启类型维护新增、批量删除权限 打开前端工程renren-fast-vue找到配置文件src\\utils\\index.js\n/** * 是否有权限 * @param {*} key */ export function isauth (key) { // return json.parse(sessionstorage.getitem(\u0026#39;permissions\u0026#39;) || \u0026#39;[]\u0026#39;).indexof(key) !== -1 || false return true } 暂时不判断权限，全部返回true\n再次访问类型维护列表页，即可看到新增按钮\n去除新增创建时间、更新时间必须输入限制：\n修改文件src/views/modules/question/type-add-or-update.vue\ndatarule: { type: [ { required: true, message: \u0026#39;类型名称不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ], comments: [ { required: true, message: \u0026#39;备注不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ], logourl: [ { required: true, message: \u0026#39;类型logo路径不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ], delflag: [ { required: true, message: \u0026#39;删除标记（0-正常，1-删除）不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ], createtime: [ { required: false, message: \u0026#39;创建时间不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ], updatetime: [ { required: false, message: \u0026#39;更新时间不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ] } 把createtime、updatetime required: true改成 required: false\n点击新增按钮，即可弹出新增界面\n批量删除测试\n2.7、配置逻辑删除 前面进行的删除都是物理删除，页可以进行逻辑删除，就是不直接把数据记录从数据库删除，而是采用设置删除标记来标识数据记录被删除。\n2.7.1、所有表字段添加del_flag字段 字段属性\ndel_flag tinyint(1) default 0 comment \u0026#39;删除标记（0-正常，1-删除）\u0026#39;, 2.7.2、修改mybatisplus配置逻辑删除 mybatis-plus: mapper-locations: classpath:/mapper/**/*.xml global-config: db-config: id-type: auto logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) logic-delete-field: delflag #全局逻辑删除字段值 3.3.0开始支持，详情看下面。 2.7.3、配置springboot打印mybatis执行sql 修改配置文件application.yml\nlogging: level: com.offcn.question: debug 再次测试访问列表和执行删除，可以看到控制台打印sql指令\n查询指令：\nselect id,type,comments,logo_url,del_flag,create_time,update_time from qms_type where del_flag=0 删除指令：\nupdate qms_type set del_flag=1 where id in ( 1 ) and del_flag=0 查看数据库记录：\n2.8、模糊查询类型功能 修改实现类typeserviceimpl的方法querypage\n@override public pageutils querypage(map\u0026lt;string, object\u0026gt; params) { //1、获取查询关键字 string key= (string) params.get(\u0026#34;key\u0026#34;); //2、创建查询条件对象 querywrapper\u0026lt;typeentity\u0026gt; querywrapper = new querywrapper\u0026lt;\u0026gt;(); //3、设置查询条件 if(!stringutils.isempty(key)){ querywrapper.eq(\u0026#34;id\u0026#34;,key).or().like(\u0026#34;type\u0026#34;,key); } ipage\u0026lt;typeentity\u0026gt; page = this.page( new query\u0026lt;typeentity\u0026gt;().getpage(params), querywrapper ); return new pageutils(page); } 设置id或者类型名称模糊查询的条件\n前端访问测试： 2.9、配置分页 修改u-question配置分页插件配置类：\n@configuration public class mybatisconfig { //引入分页插件 @bean public paginationinterceptor paginationinterceptor() { paginationinterceptor paginationinterceptor = new paginationinterceptor(); // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false paginationinterceptor.setoverflow(true); // 设置最大单页限制数量，默认 500 条，-1 不受限制 paginationinterceptor.setlimit(1000); return paginationinterceptor; } } 添加分页插件后的显示:\n3、开发配置题目前端维护管理功能 3.1、添加题目维护菜单（二级菜单） 刷新后台管理页面，就可以看到题目维护菜单\n3.2、拷贝代码生成器生成的题目维护的前端源码 拷贝题目维护源码到前端工程renren-fast-vue\n3.3、测试题目维护 访问题目维护菜单，可以正常浏览到题目数据。\n3.4、新增题目\u0026ndash;处理题目类型下拉菜单 打开新增题目，发现里面涉及到题目类型，需要下拉选择已经存在的题目类型。\n3.4.1．获取根据分类获取题库列表数据接口 3.4.1.1、编写获取题库分类接口及实现类 接口：typeservice 增加获取全部分类方法\npublic interface typeservice extends iservice\u0026lt;typeentity\u0026gt; { //获取全部分类 list\u0026lt;typeentity\u0026gt; findall(); } 实现类：typeserviceimpl\n@service(\u0026#34;typeservice\u0026#34;) public class typeserviceimpl extends serviceimpl\u0026lt;typedao, typeentity\u0026gt; implements typeservice { @override public list\u0026lt;typeentity\u0026gt; findall() { return this.list(); } } 3.4.1.2、编写获取题库分类控制器 修改typecontroller，增加获取全部分类接口\n@restcontroller @requestmapping(\u0026#34;question/type\u0026#34;) public class typecontroller { @autowired private typeservice typeservice; //获取全部分类 @getmapping(\u0026#34;findall\u0026#34;) public r findall(){ list\u0026lt;typeentity\u0026gt; all = typeservice.findall(); return r.ok().put(\u0026#34;data\u0026#34;,all); } } 3.4.2、前端代码编写 修改question-add-or-update.vue\n修改数据结构，定义题目类型下拉菜单数据\nexport default { data () { return { options: [], 修改方法，当用户点击打开新增、或者修改页面的时候，调用后台接口获取全部题目类型数据\nmethods: { init (id) { this.dataform.id = id || 0 this.visible = true this.$nexttick(() =\u0026gt; { this.$refs[\u0026#39;dataform\u0026#39;].resetfields() //向服务器端发出一个请求，获取全部题目分类数据 this.$http({ url: this.$http.adornurl(`/question/type/findall`), method: \u0026#39;get\u0026#39; }).then(({data}) =\u0026gt; { this.options = data.data }) \u0026lt;el-form-item label=\u0026#34;题目类型\u0026#34; prop=\u0026#34;type\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;dataform.type\u0026#34; placeholder=\u0026#34;请选择\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in options\u0026#34; :key=\u0026#34;item.id\u0026#34; :label=\u0026#34;item.type\u0026#34; :value=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; 点击新增、或者修改，可以看到题目类型下拉菜单成功显示\n3.5、新增题目\u0026ndash;处理是否显示、是否删除 修改页面question-add-or-update.vue\n\u0026lt;el-form-item label=\u0026#34;是否显示\u0026#34; prop=\u0026#34;enable\u0026#34;\u0026gt; \u0026lt;el-radio v-model=\u0026#34;dataform.enable\u0026#34; label=\u0026#34;0\u0026#34;\u0026gt;不显示\u0026lt;/el-radio\u0026gt; \u0026lt;el-radio v-model=\u0026#34;dataform.enable\u0026#34; label=\u0026#34;1\u0026#34;\u0026gt;显示\u0026lt;/el-radio\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;删除标记\u0026#34; prop=\u0026#34;delflag\u0026#34;\u0026gt; \u0026lt;el-radio v-model=\u0026#34;dataform.delflag\u0026#34; label=\u0026#34;0\u0026#34;\u0026gt;不删除\u0026lt;/el-radio\u0026gt; \u0026lt;el-radio v-model=\u0026#34;dataform.delflag\u0026#34; label=\u0026#34;1\u0026#34; \u0026gt;删除\u0026lt;/el-radio\u0026gt; \u0026lt;/el-form-item\u0026gt; 修改数据结构，定义是否显示初始化值\n修改从后台接口获取数据赋值方法，把后台响应数据转换为字符串\n关键点：data.question.enable + ''\n​ data.question.delflag + ''\n点击新增或者修改，可以看到是否显示、是否删除成功已单选框显示\n3.6、模糊查询题目 修改实现类questionserviceimpl的方法querypage\n@override public pageutils querypage(map\u0026lt;string, object\u0026gt; params) { //1、获取查询关键字 string key= (string) params.get(\u0026#34;key\u0026#34;); //2、创建查询条件对象 querywrapper\u0026lt;questionentity\u0026gt; querywrapper = new querywrapper\u0026lt;\u0026gt;(); //3、设置查询条件 if(!stringutils.isempty(key)){ querywrapper.eq(\u0026#34;id\u0026#34;,key).or().like(\u0026#34;title\u0026#34;,key); } ipage\u0026lt;questionentity\u0026gt; page = this.page( new query\u0026lt;questionentity\u0026gt;().getpage(params), querywrapper ); return new pageutils(page); } 测试输入id或者标题包含的关键字查询\n3.7、快速设置是否显示 想要将是否显示改为快速开关\n修改页面question.vue添加更新状态方法\nmethods: { // 更新题目是否显示 updatequestionstatus (data) { console.log(data) let {id, enable} = data this.$http({ url: this.$http.adornurl(\u0026#39;/question/question/update\u0026#39;), method: \u0026#39;post\u0026#39;, data: this.$http.adorndata({id, enable}, false) }).then(({ data }) =\u0026gt; { this.$message({ type:\u0026#39;success\u0026#39;, message: \u0026#39;状态更新成功\u0026#39; }) }); }, 修改页面question.vue\n\u0026lt;el-table-column prop=\u0026#34;enable\u0026#34; header-align=\u0026#34;center\u0026#34; align=\u0026#34;center\u0026#34; label=\u0026#34;是否显示\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;el-switch v-model=\u0026#34;scope.row.enable\u0026#34; :active-value=1 :inactive-value=0 active-color=\u0026#34;#13ce66\u0026#34; inactive-color=\u0026#34;#ff4949\u0026#34; @change=\u0026#34;updatequestionstatus(scope.row)\u0026#34;\u0026gt; \u0026lt;/el-switch\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; 测试页面效果\n3.8、校验排序不能是小数或者小于0的数字 修改前端页面question-add-or-update.vue\nvar validateorder = (rule, value, callback) =\u0026gt; { if (value === \u0026#39;\u0026#39;) { callback(new error(\u0026#39;请输入排序\u0026#39;)); } else { if (!(value%1 === 0)||(value\u0026lt;0)) { callback(new error(\u0026#39;排序应该是整数且大于0\u0026#39;)); } callback(); } }; return { …………略 datarule: { ………… displayorder: [ { validator: validateorder, trigger: \u0026#39;blur\u0026#39; } ], ………… }, } 测试 只有输入整数才能验证通过。\n3.9、修改题目答案为多行文本框 \u0026lt;el-form-item label=\u0026#34;题目解答\u0026#34; prop=\u0026#34;answer\u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; :rows=\u0026#34;2\u0026#34; v-model=\u0026#34;dataform.answer\u0026#34; placeholder=\u0026#34;题目解答\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; 效果：\n4、完成题目导入、导出功能 4.1、java操作excel类库poi 12.1.1 什么是poi？ apache poi是apache软件基金会的开放源码函式库，poi提供api给java程序对microsoft office格式档案读和写的功能。\n· hssf － 提供读写microsoft excel格式档案的功能。（.xls）\n· xssf － 提供读写microsoft excel ooxml格式档案的功能。（.xlsx）\n· hwpf － 提供读写microsoft word格式档案的功能。\n· hslf － 提供读写microsoft powerpoint格式档案的功能。\n· hdgf － 提供读写microsoft visio格式档案的功能。\n12.1.2 poi官网 http://poi.apache.org/\n官网可以找到文档和每个版本的下载地址\n4.2、poi入门demo 4.2.1．创建一个普通的maven项目 项目名：excel-poi\n4.2.2．pom中引入xml相关依赖 \u0026lt;dependencies\u0026gt; \u0026lt;!--xls--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.poi\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;poi\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--xlsx--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.poi\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;poi-ooxml\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--test--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 4.2.3．java写入excel 2003版写文件 package com.excel.poi; public class exceltest { @test public void testwrite03() throws ioexception { // 创建新的excel 工作簿 workbook workbook = new hssfworkbook(); // 在excel工作簿中建一工作表，其名为缺省值 sheet0 //sheet sheet = workbook.createsheet(); // 如要新建一名为\u0026#34;会员登录统计\u0026#34;的工作表，其语句为： sheet sheet = workbook.createsheet(\u0026#34;会员登录统计\u0026#34;); // 创建行（row 1） row row1 = sheet.createrow(0); // 创建单元格（col 1-1） cell cell11 = row1.createcell(0); cell11.setcellvalue(\u0026#34;今日人数\u0026#34;); // 创建单元格（col 1-2） cell cell12 = row1.createcell(1); cell12.setcellvalue(666); // 创建行（row 2） row row2 = sheet.createrow(1); // 创建单元格（col 2-1） cell cell21 = row2.createcell(0); cell21.setcellvalue(\u0026#34;统计时间\u0026#34;); //创建单元格（第三列） cell cell22 = row2.createcell(1); string datetime = new datetime().tostring(\u0026#34;yyyy-mm-dd hh:mm:ss\u0026#34;); cell22.setcellvalue(datetime); // 新建一输出文件流（注意：要先创建文件夹） fileoutputstream out = new fileoutputstream(\u0026#34;d:/excel-poi/test-write03.xls\u0026#34;); // 把相应的excel 工作簿存盘 workbook.write(out); // 操作结束，关闭文件 out.close(); system.out.println(\u0026#34;文件生成成功\u0026#34;); } } 2007版写文件 @test public void testwrite07() throws ioexception { // 创建新的excel 工作簿 workbook workbook = new xssfworkbook(); // 在excel工作簿中建一工作表，其名为缺省值 sheet0 //sheet sheet = workbook.createsheet(); // 如要新建一名为\u0026#34;会员登录统计\u0026#34;的工作表，其语句为： sheet sheet = workbook.createsheet(\u0026#34;会员登录统计\u0026#34;); // 创建行（row 1） row row1 = sheet.createrow(0); // 创建单元格（col 1-1） cell cell11 = row1.createcell(0); cell11.setcellvalue(\u0026#34;今日人数\u0026#34;); // 创建单元格（col 1-2） cell cell12 = row1.createcell(1); cell12.setcellvalue(666); // 创建行（row 2） row row2 = sheet.createrow(1); // 创建单元格（col 2-1） cell cell21 = row2.createcell(0); cell21.setcellvalue(\u0026#34;统计时间\u0026#34;); //创建单元格（第三列） cell cell22 = row2.createcell(1); string datetime = new datetime().tostring(\u0026#34;yyyy-mm-dd hh:mm:ss\u0026#34;); cell22.setcellvalue(datetime); // 新建一输出文件流（注意：要先创建文件夹） fileoutputstream out = new fileoutputstream(\u0026#34;d:/excel-poi/test-write07.xlsx\u0026#34;); // 把相应的excel 工作簿存盘 workbook.write(out); // 操作结束，关闭文件 out.close(); system.out.println(\u0026#34;文件生成成功\u0026#34;); } 注意：如果针对不同版本的excel使用了不适合的类库，则会报告异常 org.apache.poi.poixmlexception: org.apache.poi.openxml4j.exceptions.invalidformatexception: package should contain a content type part [m1.13]\n4.2.4．java读取excel 2003版读文件 package com.excel.poi; public class excelreadtest { @test public void testread03() throws exception{ inputstream is = new fileinputstream(\u0026#34;d:/excel-poi/test-write03.xls\u0026#34;); workbook workbook = new hssfworkbook(is); sheet sheet = workbook.getsheetat(0); // 读取第一行第一列 row row = sheet.getrow(0); cell cell = row.getcell(0); // 输出单元内容 system.out.println(cell.getstringcellvalue()); // 操作结束，关闭文件 is.close(); } } 2007版读文件 @test public void testread07() throws exception{ inputstream is = new fileinputstream(\u0026#34;d:/excel-poi/test-write07.xlsx\u0026#34;); workbook workbook = new xssfworkbook(is); sheet sheet = workbook.getsheetat(0); // 读取第一行第一列 row row = sheet.getrow(0); cell cell = row.getcell(0); // 输出单元内容 system.out.println(cell.getstringcellvalue()); // 操作结束，关闭文件 is.close(); } 4.3、java后端代码编写 4.3.1修改项目u-question的接口questionservice增加导入、导出接口定义 public interface questionservice extends iservice\u0026lt;questionentity\u0026gt; { pageutils querypage(map\u0026lt;string, object\u0026gt; params); //导入 public map importexcel(multipartfile file); //导出 public workbook exportexcel(); } 4.3.2 修改实现类questionserviceimpl实现导入、导出方法 @override public map importexcel(multipartfile file) { map result=new hashmap(); //获取上传文件名称 string filename = file.getoriginalfilename(); string extname = filename.substring(filename.lastindexof(\u0026#34;.\u0026#34;)+1); //2、判断文件扩展名是否等于xlsx,xls if(!extname.equals(\u0026#34;xls\u0026#34;) \u0026amp;\u0026amp;!extname.equals(\u0026#34;xlsx\u0026#34;) ){ result.put(\u0026#34;result\u0026#34;,false); result.put(\u0026#34;msg\u0026#34;,\u0026#34;文件扩展名不正确，导入失败\u0026#34;); result.put(\u0026#34;num\u0026#34;,0); } try { inputstream inputstream = file.getinputstream(); //初始化创建工作簿对象 workbook workbook = workbookfactory.create(inputstream); //获取第一张工作表 sheet sheet = workbook.getsheetat(0); //获取工作表里面有数据行数 int rows = sheet.getphysicalnumberofrows(); //循环表格行 for (int i = 1; i \u0026lt;rows ; i++) { questionentity questionentity = new questionentity(); //获取当前行 row row = sheet.getrow(i); //获取第一个单元格的内容 标题 string title= row.getcell(0).getstringcellvalue(); //设置到题目对象标题属性 questionentity.settitle(title); system.out.println(\u0026#34;title:\u0026#34;+title); //获取第二个单元格的内容 答案 string answer = row.getcell(1).getstringcellvalue(); questionentity.setanswer(answer); system.out.println(\u0026#34;answer:\u0026#34;+answer); //获取第三个单元格的内容 题目难度等级 double level = row.getcell(2).getnumericcellvalue(); questionentity.setlevel((int)level); //获取第四个单元格的内容 paix questionentity.setdisplayorder((int)row.getcell(3).getnumericcellvalue()); //获取副标题 questionentity.setsubtitle(row.getcell(4).getstringcellvalue()); //题目类型 questionentity.settype((long)row.getcell(5).getnumericcellvalue()); //是否显示 questionentity.setenable((int)row.getcell(6).getnumericcellvalue()); //调用数据库保存方法，保存题目数据到书籍 this.save(questionentity); } result.put(\u0026#34;result\u0026#34;,true); result.put(\u0026#34;msg\u0026#34;,\u0026#34;导入成功\u0026#34;); system.out.println(\u0026#34;导入成功总条数:\u0026#34;+list.size()); } catch (exception e) { e.printstacktrace(); result.put(\u0026#34;result\u0026#34;,false); result.put(\u0026#34;msg\u0026#34;,\u0026#34;文件导入失败，\u0026#34;+e.getmessage()); result.put(\u0026#34;num\u0026#34;,0); } return result; } @override public workbook exportexcel() { // 创建新的excel 工作簿 workbook workbook = new hssfworkbook(); // 在excel工作簿中建一工作表，其名为缺省值 sheet0 //sheet sheet = workbook.createsheet(); // 创建工作表 sheet sheet = workbook.createsheet(\u0026#34;题库\u0026#34;); row row = sheet.createrow(0); row.createcell(0).setcellvalue(\u0026#34;题目标题\u0026#34;); row.createcell(1).setcellvalue(\u0026#34;题目解答\u0026#34;); row.createcell(2).setcellvalue(\u0026#34;题目难度等级\u0026#34;); row.createcell(3).setcellvalue(\u0026#34;排序\u0026#34;); row.createcell(4).setcellvalue(\u0026#34;副标题\u0026#34;); row.createcell(5).setcellvalue(\u0026#34;题目类型\u0026#34;); row.createcell(6).setcellvalue(\u0026#34;是否显示\u0026#34;); list\u0026lt;questionentity\u0026gt; list = this.list(); for (int i = 0; i \u0026lt; list.size(); i++) { row row2 = sheet.createrow(i + 1); //创建表格 row2.createcell(0).setcellvalue(list.get(i).gettitle()); row2.createcell(1).setcellvalue(list.get(i).getanswer()); row2.createcell(2).setcellvalue(list.get(i).getlevel()); row2.createcell(3).setcellvalue(list.get(i).getdisplayorder()); row2.createcell(4).setcellvalue(list.get(i).getsubtitle()); row2.createcell(5).setcellvalue(list.get(i).gettype()); row2.createcell(6).setcellvalue(list.get(i).getenable()); } return workbook; } 4.3.3 修改控制器questioncontroller实现导入、导出方法 //题目上传导入 @postmapping(\u0026#34;/upload\u0026#34;) public r upload(multipartfile file){ map result = questionservice.importexcel(file); return r.ok().put(\u0026#34;result\u0026#34;,result.get(\u0026#34;result\u0026#34;)).put(\u0026#34;msg\u0026#34;,result.get(\u0026#34;msg\u0026#34;)).put(\u0026#34;num\u0026#34;,result.get(\u0026#34;num\u0026#34;)); } //导出excel @getmapping(\u0026#34;exportexcel\u0026#34;) public void export(string tablename, httpservletresponse response){ system.out.println(\u0026#34;导出excele\u0026#34;); workbook workbook = questionservice.exportexcel(); if (workbook != null) { string filename = \u0026#34;uxue_\u0026#34; + new simpledateformat(\u0026#34;yyyymmddhhmmss\u0026#34;).format(new date()) + \u0026#34;.xlsx\u0026#34;; response.setheader(\u0026#34;content-disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + filename); response.setcontenttype(\u0026#34;application/octet-stream;charset=utf-8\u0026#34;); outputstream outputstream; try { outputstream = response.getoutputstream(); workbook.write(outputstream); outputstream.flush(); outputstream.close(); } catch (exception e) { e.printstacktrace(); } } else { try { response.getwriter().print(\u0026#34;error\u0026#34;); } catch (exception e) { e.printstacktrace(); } } } 4.4、前端代码编写 4.4.1 创建导入弹窗口视图页面 在renren-fast-vue前端工程/src/views/modules/question/ 目录下新增视图文件 question-import.vue\n\u0026lt;template\u0026gt; \u0026lt;el-dialog :title=\u0026#34;\u0026#39;导入题库\u0026#39;\u0026#34; :close-on-click-modal=\u0026#34;false\u0026#34; :visible.sync=\u0026#34;visible\u0026#34; \u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;div class=\u0026#34;el-form-item__content\u0026#34;\u0026gt; \u0026lt;el-upload ref=\u0026#34;upload\u0026#34; accept=\u0026#34;.xls,.xlsx\u0026#34; action=\u0026#34;#\u0026#34; :auto-upload=\u0026#34;false\u0026#34; :multiple=\u0026#34;false\u0026#34; :file-list=\u0026#34;filelist\u0026#34; :http-request=\u0026#34;uploadhttprequest\u0026#34; \u0026gt; \u0026lt;el-button size=\u0026#34;small\u0026#34; type=\u0026#34;primary\u0026#34;\u0026gt;选择文件\u0026lt;/el-button\u0026gt; \u0026lt;div slot=\u0026#34;tip\u0026#34; class=\u0026#34;el-upload__tip\u0026#34;\u0026gt;一次只能上传一个xls/xlsx文件，且不超过10m\u0026lt;/div\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;small\u0026#34; @click=\u0026#34;submitupload\u0026#34;\u0026gt;上 传\u0026lt;/el-button\u0026gt; \u0026lt;a type=\u0026#34;primary\u0026#34; href=\u0026#34;/test.xls\u0026#34; size=\u0026#34;small\u0026#34; \u0026gt;下载导入模板\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data () { return { visible: false, filelist: [], } }, methods: { init () { this.visible = true }, // param是默认参数，可以取得file文件信息，具体信息如下图 uploadhttprequest(param) { const formdata = new formdata() //formdata对象，添加参数只能通过append(\u0026#39;key\u0026#39;, value)的形式添加 formdata.append(\u0026#39;file\u0026#39;, param.file) //添加文件对象 formdata.append(\u0026#39;uploadtype\u0026#39;, this.rulestype) this.$http({ url: this.$http.adornurl(`/question/question/upload`), method: \u0026#39;post\u0026#39;, data: formdata, contenttype: \u0026#39;form\u0026#39; }).then( res =\u0026gt; { const { data: { code, mark, num, msg } } = res if(code === 0) { this.filelist = [] this.visible = false // param.onsuccess() // 上传成功的文件显示绿色的对勾 // this.uploadmark = mark //this.$message.info(\u0026#39;上传文件成功,导入条数:\u0026#39;+num) this.$message({ message: \u0026#39;上传文件成功,导入条数:\u0026#39;+num, type: \u0026#39;success\u0026#39;, duration: 1000, onclose: () =\u0026gt; { this.visible = false this.$emit(\u0026#39;refreshdatalist\u0026#39;) } }) }else { this.$message.error(msg) } }) .catch( err =\u0026gt; { console.log(\u0026#39;失败\u0026#39;, err) param.onerror() //上传失败的文件会从文件列表中删除 }) }, // 点击上传：手动上传到服务器，此时会触发组件的http-request submitupload() { this.$refs.upload.submit() } } } \u0026lt;/script\u0026gt; 4.4.2 修改题目维护页面question.vue 引入导入页面：\nimport importexcel from \u0026#39;./question-import\u0026#39; 注册导入窗口：\n\u0026lt;!-- 导入窗口--\u0026gt; \u0026lt;importexcel v-if=\u0026#34;importvisible\u0026#34; ref=\u0026#34;importexcel\u0026#34; @refreshdatalist=\u0026#34;getdatalist\u0026#34;\u0026gt;\u0026lt;/importexcel\u0026gt; 声明允许显示导入弹窗变量\ndata () { return { //是否允许显示导入窗口 importvisible: false } }, 把导入页面注册到当前页面组件：\ncomponents: { addorupdate, importexcel }, 添加导入导出点击触发方法：\n//导入 importexcelhandle () { this.importvisible = true this.$nexttick(() =\u0026gt; { this.$refs.importexcel.init() }) }, //导出 exportexcelhandle () { var dom=document.getelementbyid(\u0026#39;ifile\u0026#39;) dom.src= this.$http.adornurl(\u0026#39;/question/question/exportexcel\u0026#39;) }, 在页面模板区域，添加 导入、导出按钮：\n\u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;importexcelhandle()\u0026#34;\u0026gt;导入\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34; @click=\u0026#34;exportexcelhandle()\u0026#34;\u0026gt;导出\u0026lt;/el-button\u0026gt; \u0026lt;iframe id=\u0026#34;ifile\u0026#34; style=\u0026#34;display:none\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 导入、导出视图显示效果：\n点击 导入 按钮，弹出导入弹窗：\n下载导入模板，按照模板，填写数据，选中文件，点击上传，即可导入\n导入模板样式：\n导入成功，提示导入条数，关闭导入弹窗。\n5、echarts图表入门 5.1．echarts简介 ecahrs是百度的一个项目，用于图表展示，提供了常规的折线图、柱状图、散点图、饼图、k线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 bi 的漏斗图，仪表盘，并且支持图与图之间的混搭。 官方网站：https://echarts.apache.org/zh/index.html\n5.2．基本使用 入门参考：官网-\u0026gt;文档-\u0026gt;教程-\u0026gt;5分钟上手echarts\n5.2.1、柱状图创建 （1）创建html页面：柱图.html （2）引入echarts \u0026lt;!-- 引入 echarts 文件 --\u0026gt; \u0026lt;script src=\u0026#34;echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; （3）定义图表区域 \u0026lt;!-- 为echarts准备一个具备大小（宽高）的dom --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; （4）渲染图表 \u0026lt;script\u0026gt; var mychart = echarts.init(document.getelementbyid(\u0026#39;main\u0026#39;)); var option = { title: { text: \u0026#39;echarts 柱状图入门demo\u0026#39; }, tootip: {}, legend: { data: [\u0026#39;销量\u0026#39;] }, xaxis: { data: [\u0026#34;衬衫\u0026#34;,\u0026#34;羊毛衫\u0026#34;,\u0026#34;羽绒服\u0026#34;,\u0026#34;裤子\u0026#34;,\u0026#34;高跟鞋\u0026#34;] }, yaxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [1,6,7,4,15] }] }; mychart.setoption(option); \u0026lt;/script\u0026gt; 测试效果：\n5.2.2、折线图创建 \u0026lt;script\u0026gt; var mychart = echarts.init(document.getelementbyid(\u0026#39;main\u0026#39;)); var option = { title: { text: \u0026#39;echarts 折线图入门demo\u0026#39; }, tootip: {}, legend: { data: [\u0026#39;销量\u0026#39;] }, xaxis: { type: \u0026#39;category\u0026#39;, data: [\u0026#34;mon\u0026#34;,\u0026#34;tue\u0026#34;,\u0026#34;wed\u0026#34;,\u0026#34;thu\u0026#34;,\u0026#34;fri\u0026#34;,\u0026#34;sat\u0026#34;,\u0026#34;sun\u0026#34;] }, yaxis: { type: \u0026#39;value\u0026#39; }, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;line\u0026#39;, data: [820, 932, 901, 934, 1290, 1330, 1320] }] }; mychart.setoption(option); \u0026lt;/script\u0026gt; 6、统计分析 6.1．题库分类数量统计分析 6.1.1 编写java后端代码 打开java模块u-question ，编辑接口questionservice新增统计分类题目数量方法\npublic interface questionservice extends iservice\u0026lt;questionentity\u0026gt; { public list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; counttypequestion(); } 编辑接口实现类questionserviceimpl,编写统计分类题目数量实现方法\n@service(\u0026#34;questionservice\u0026#34;) public class questionserviceimpl extends serviceimpl\u0026lt;questiondao, questionentity\u0026gt; implements questionservice { @autowired private questiondao questiondao; @override public list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; counttypequestion() { querywrapper\u0026lt;questionentity\u0026gt; querywrapper = new querywrapper\u0026lt;questionentity\u0026gt;().select(\u0026#34;type,count(type) as num\u0026#34;).groupby(\u0026#34;type\u0026#34;); list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; maplist = questiondao.selectmaps(querywrapper); return maplist; } } 编辑questioncontroller,新增统计分类题目数量方法\n@restcontroller @requestmapping(\u0026#34;question/question\u0026#34;) public class questioncontroller { @autowired private questionservice questionservice; @autowired private typeservice typeservice; //获取按照题库分类的统计数据 @requestmapping(\u0026#34;counttypequestion\u0026#34;) public r counttypequestion(){ list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; maplist = questionservice.counttypequestion(); for (map\u0026lt;string, object\u0026gt; map : maplist) { //根据分类id，读取对应的分类数据 long typeid = (long) map.get(\u0026#34;type\u0026#34;); typeentity typeentity = typeservice.getbyid(typeid); //重新封装分类名称到map map.put(\u0026#34;name\u0026#34;,typeentity.gettype()); } return r.ok().put(\u0026#34;maplist\u0026#34;,maplist); } } 6.1.2 编写前端代码 前端项目renren-fast-vue/src/views/modules/question目录 新增统计注册用户数量页面 echarts.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;mod-demo-echarts\u0026#34;\u0026gt; \u0026lt;el-row :gutter=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34;\u0026gt; \u0026lt;el-card\u0026gt; \u0026lt;div id=\u0026#34;j_chartbarbox\u0026#34; class=\u0026#34;chart-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import echarts from \u0026#39;echarts\u0026#39; export default { data () { return { chartbar: null, begintime: \u0026#39;\u0026#39;, endtime: \u0026#39;\u0026#39;, maplist: [], xdata: [], ydata: [], btndisabled: false } }, mounted () { this.create() }, activated () { // 由于给echart添加了resize事件, 在组件激活时需要重新resize绘画一次, 否则出现空白bug if (this.chartbar) { this.chartbar.resize() } }, methods: { create () { this. getdatalist () this.initchartbar() }, // 获取数据列表 getdatalist () { this.datalistloading = true this.$http({ url: this.$http.adornurl(\u0026#39;/question/question/counttypequestion\u0026#39;), method: \u0026#39;get\u0026#39; }).then(({data}) =\u0026gt; { if (data \u0026amp;\u0026amp; data.code === 0) { this.maplist = data.maplist this.xdata = [] this.ydata = [] for(let j in this.maplist){ this.xdata.push(this.maplist[j].name) this.ydata.push(this.maplist[j].num) } console.log(this.xdata) console.log(this.ydata) this.chartbar.resize() // this.xdata= this.maplist.map(obj =\u0026gt; n.name); // this.ydata= this.maplist.map(obj =\u0026gt; n.value); this.chartbar.setoption({ xaxis: [ { type: \u0026#39;category\u0026#39;, data: this.xdata } ], yaxis: [ { type: \u0026#39;value\u0026#39; } ], series: [ { name: \u0026#39;题目数量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: this.ydata } ] }) } else { this.maplist = [] } }) }, // 柱状图 initchartbar () { var option = { tooltip: { trigger: \u0026#39;axis\u0026#39;, axispointer: { type: \u0026#39;shadow\u0026#39; } }, legend: { data: [\u0026#39;题目数量\u0026#39;] }, grid: { left: \u0026#39;3%\u0026#39;, right: \u0026#39;4%\u0026#39;, bottom: \u0026#39;3%\u0026#39;, containlabel: true }, xaxis: [ { type: \u0026#39;category\u0026#39;, data: this.xdata } ], yaxis: [ { type: \u0026#39;value\u0026#39; } ], series: [ { name: \u0026#39;每日注册用户数\u0026#39;, type: \u0026#39;bar\u0026#39;, data: this.ydata } ] } this.chartbar = echarts.init(document.getelementbyid(\u0026#39;j_chartbarbox\u0026#39;)) // this.chartbar.setoption(option) window.addeventlistener(\u0026#39;resize\u0026#39;, () =\u0026gt; { this.chartbar.resize() }) } } } \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34;\u0026gt; .mod-demo-echarts { \u0026gt; .el-alert { margin-bottom: 10px; } \u0026gt; .el-row { margin-top: -10px; margin-bottom: -10px; .el-col { padding-top: 10px; padding-bottom: 10px; } } .chart-box { min-height: 400px; } } \u0026lt;/style\u0026gt; 6.1.3 配置用户注册统计菜单 新增菜单后，刷新，即可查看菜单 点击题目数量统计可以查看按照题目分类统计的数量柱状图 ","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project/20220528232959/","summary":"第四章 优学题库项目开发2 优就业.JAVA教研室 学习目标 了解启动开源管理前端框架 掌握开发配置题目分类服务及前端维护管理功能 掌握开发配置题目维护后端服务及前端维护管","title":"tk-题库项目开发2"},{"content":"第五章 优学题库项目开发3 优就业.java教研室 学习目标 掌握oss云存储、账号开通、上传测试 掌握图片上传到oss云存储 掌握开发广告内容前端维护功能 掌握开发用户管理前端维护功能 掌握微信小程序登录及验证调用接口 掌握开发微信小程序分类、题库、广告轮播图调用接口 了解接口文档生成方式 1、oss云存储介绍，开通、上传测试 文件上传在系统中用的很频繁，所以我们需要将上传的文件进行存储，传统的将文件上传到本机已不适用分布式系统。自己搭建文件服务器有复杂性和维护成本。所以我们可以采用市面上成熟的文件存储服务，如阿里云的oss对象存储服务。\n1.1 登录阿里云开通oss存储 产品-\u0026gt;精选-\u0026gt;对象存储oss 立即开通 需要实名认证后才能开通 1.2、创建bucket 点击创建bucket按钮，弹出创建bucket界面\n特别强调这里的读写权限一定设置为“公共的”。 新建文件夹[pic,video],点击目录可以上传图片,并可以访问 1.3、accesskey申请 管理控制台，右上角，点击用户头像，弹出菜单： 选择：accesskey管理，弹出提示，选择： 开始使用子用户 accesskey 点击： 开始使用子用户accesskey\n出现创建用户界面：输入登录用户名、显示用户名，勾选 编程访问，点击 确定即可创建用户。 l 选择左边菜单的用户连接，进入用户列表 l 选择用户，点击左下角的 添加权限按钮，即可进入设置权限页面 点击确定，出现授权成功提示 l 选择用户，设置用户accesskey\n点击用户列表，中的用户名，进入用户设置界面 l 点击创建accesskey，弹出accesskey创建成功页面，复制并保存好相关秘钥 1.4、引入sdk https://help.aliyun.com/document_detail/32009.html\nsdk依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.aliyun.oss\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;aliyun-sdk-oss\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1.5、java编程方式上传文件到oss package com.offcn.utils; public class osstest { /** * oss 使用步骤 阿里云 * 1）、引入sdk * 2）、配置好相应的属性 */ public static void main(string[] args)throws ioexception { // endpoint以北京为例，其它region请按实际情况填写。 string endpoint = \u0026#34;http://oss-cn-beijing.aliyuncs.com\u0026#34;; // 云账号accesskey有所有api访问权限，建议遵循阿里云安全最佳实践，创建并使用ram子账号进行api访问或日常运维，请登录 https://ram.console.aliyun.com 创建。 string accesskeyid = \u0026#34;ltai4f***33p318bifwc\u0026#34;; string accesskeysecret = \u0026#34;epnr5qdcc44***bww4fw8p3uew\u0026#34;; // 创建ossclient实例。 oss ossclient = new ossclientbuilder().build(endpoint, accesskeyid, accesskeysecret); // 上传文件流。 inputstream inputstream = new fileinputstream(new file(\u0026#34;d:\\\\007.jpg\u0026#34;)); //要存放的存储桶名称，存储文件名 ，文件输入流 ossclient.putobject(\u0026#34;offcn20200330\u0026#34;, \u0026#34;pic/008.jpg\u0026#34;, inputstream); // 关闭ossclient。 ossclient.shutdown(); system.out.println(\u0026#34;测试完成\u0026#34;); } } 执行上传程序成功，查看oss服务器端 访问图片地址：\nbucket+域名 + 图片路径 + 文件名\nhttps://offcn20200330.oss-cn-beijing.aliyuncs.com/pic/008.jpg\n**\n2、实现图片上传到oss云存储 2.1、上传原理 2.1.1、通过应用服务器中转上传 每个 oss 的用户都会用到上传服务。web 端常见的上传方法是用户在浏览器或 app 端上传文件到应用服务器，应用服务器再把文件上传到 oss。具体流程如下图所示。 和数据直传到 oss 相比，以上方法有三个缺点：\n上传慢：用户数据需先上传到应用服务器，之后再上传到oss。网络传输时间比直传到oss多一倍。如果用户数据不通过应用服务器中转，而是直传到oss，速度将大大提升。而且oss采用bgp带宽，能保证各地各运营商之间的传输速度。 扩展性差：如果后续用户多了，应用服务器会成为瓶颈。 费用高：需要准备多台应用服务器。由于oss上传流量是免费的，如果数据直传到oss，不通过应用服务器，可以节省应用服务器\n2.1.2、直接javascript客户端上传到oss 采用javascript客户端直接签名（参见javascript客户端签名直传）时，accesskeyid和acesskeysecret会暴露在前端页面，因此存在严重的安全隐患。因此，oss提供了服务端签名后直传的方案。\n服务器端获取签名，客户端直接上传到oss原理 服务端签名后直传的原理如下：\n用户发送上传policy请求到应用服务器。\n应用服务器返回上传policy和签名给用户。\n用户直接上传数据到oss。 参考官方文档：https://help.aliyun.com/document_detail/31926.htm\n2.2、搭建获取oss签名微服务 2.2.1、创建新模块u-oss（标准springboot工程） 最终创建好模块 2.2.2、pom.xml引入依赖 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.3.6.release\u0026lt;/version\u0026gt; \u0026lt;relativepath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;u-oss\u0026lt;/artifactid\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;hoxton.sr9\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;spring-cloud-alibaba.version\u0026gt;2.2.0.release\u0026lt;/spring-cloud-alibaba.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alicloud-oss\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; \u0026lt;/project\u0026gt; 2.2.3、配置文件application.yml server: port: 14000 spring: application: name: u-oss cloud: nacos: discovery: server-addr: localhost:8848 alicloud: access-key: ltai4g7***xizdru secret-key: ashoxlmb\u0026amp;\u0026amp;\u0026amp;\u0026amp;gfseb5nslmjiytwf oss: endpoint: oss-cn-beijing.aliyuncs.com bucket: java0817-001 logging: level: com.offcn.oss: debug 14.2.4、编写获取oss服务器签名osscontroller\npackage com.offcn.oss.controller; import com.aliyun.oss.oss; import com.aliyun.oss.common.utils.binaryutil; import com.aliyun.oss.model.matchmode; import com.aliyun.oss.model.policyconditions; import org.springframework.beans.factory.annotation.autowired; import org.springframework.beans.factory.annotation.value; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; import java.text.simpledateformat; import java.util.date; import java.util.linkedhashmap; import java.util.map; @restcontroller @requestmapping(\u0026#34;/thirdparty/v1/admin/oss\u0026#34;) public class osscontroller { @autowired oss ossclient; @value(\u0026#34;${spring.cloud.alicloud.access-key}\u0026#34;) private string accessid; @value(\u0026#34;${spring.cloud.alicloud.oss.endpoint}\u0026#34;) private string endpoint; @value(\u0026#34;${spring.cloud.alicloud.oss.bucket}\u0026#34;) private string bucket; @requestmapping(\u0026#34;/getpolicy\u0026#34;) public map\u0026lt;string, string\u0026gt; getpolicy() { string host = \u0026#34;https://\u0026#34; + bucket + \u0026#34;.\u0026#34; + endpoint; // host的格式为 bucketname.endpoint string formatdate = new simpledateformat(\u0026#34;yyyy-mm-dd\u0026#34;).format(new date()); string dir = formatdate + \u0026#34;/\u0026#34;; // 用户上传文件时指定的前缀。 map\u0026lt;string, string\u0026gt; respmap = new linkedhashmap\u0026lt;string, string\u0026gt;(); try { long expiretime = 30; long expireendtime = system.currenttimemillis() + expiretime * 1000; date expiration = new date(expireendtime); policyconditions policyconds = new policyconditions(); //postobject请求最大可支持的文件大小为5 gb，即content_length_range为5*1024*1024*1024。 policyconds.addconditionitem(policyconditions.cond_content_length_range, 0, 1048576000); policyconds.addconditionitem(matchmode.startwith, policyconditions.cond_key, dir); //获取授权策略 string postpolicy = ossclient.generatepostpolicy(expiration, policyconds); byte[] binarydata = postpolicy.getbytes(\u0026#34;utf-8\u0026#34;); string encodedpolicy = binaryutil.tobase64string(binarydata); //获取授权策略签名 string postsignature = ossclient.calculatepostsignature(postpolicy); //封装accessid、签名等信息返回 respmap.put(\u0026#34;accessid\u0026#34;, accessid); respmap.put(\u0026#34;policy\u0026#34;, encodedpolicy); respmap.put(\u0026#34;signature\u0026#34;, postsignature); respmap.put(\u0026#34;dir\u0026#34;, dir); respmap.put(\u0026#34;host\u0026#34;, host); respmap.put(\u0026#34;expire\u0026#34;, string.valueof(expireendtime / 1000)); } catch (exception e) { // assert.fail(e.getmessage()); system.out.println(e.getmessage()); } finally { ossclient.shutdown(); } return respmap; } } 2.2.4、编写主启动类 @springbootapplication @enablediscoveryclient public class ossstartapplication { public static void main(string[] args) { springapplication.run(ossstartapplication.class,args); } } 2.2.5、启动服务，访问controller获取签名 访问地址：http://localhost:14000/thirdparty/v1/admin/oss/getpolicy 2.3、修改网关配置获取签名路由 打开java服务cloud-gateway，修改配置文件application.yml 增加到获取签名微服务的路由，注意配置顺序要在renren-fast 之前。 - id: oss-route # oss服务路由 uri: lb://u-oss predicates: - path=/api/thirdparty/** filters: - rewritepath=/api/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} http://localhost:8888/api/thirdparty/v1/admin/oss/getpolicy\n2.4、开发前端工程，配置上传 2.4.1、新建获取签名的js 在前端工程renren-fast-vue目录src/utils/ 新建获取签名js文件 policy.js\nimport http from \u0026#39;@/utils/httprequest.js\u0026#39; export function policy () { return new promise((resolve) =\u0026gt; { http({ url: http.adornurl(\u0026#39;/thirdparty/v1/admin/oss/getpolicy\u0026#39;), method: \u0026#39;get\u0026#39;, params: http.adornparams({}) }).then(({ data }) =\u0026gt; { resolve(data) }) }) } 2.4.2、新建文件上传控件页面 在前端工程renren-fast-vue目录src/views/modules/common目录下 创建上传页面 singleupload.vue\n注意：**修改下面 action属性 ** 指向oss存储桶地址：http://java0817-001.oss-cn-guangzhou.aliyuncs.com！\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-upload action=\u0026#34;http://java0817-001.oss-cn-guangzhou.aliyuncs.com\u0026#34; :data=\u0026#34;dataobj\u0026#34; list-type=\u0026#34;picture\u0026#34; :multiple=\u0026#34;false\u0026#34; :show-file-list=\u0026#34;showfilelist\u0026#34; :auto-upload=\u0026#34;true\u0026#34; :file-list=\u0026#34;filelist\u0026#34; :before-upload=\u0026#34;beforeupload\u0026#34; :on-remove=\u0026#34;handleremove\u0026#34; :on-success=\u0026#34;handleuploadsuccess\u0026#34; :on-preview=\u0026#34;handlepreview\u0026#34;\u0026gt; \u0026lt;el-button size=\u0026#34;small\u0026#34; type=\u0026#34;primary\u0026#34;\u0026gt;点击上传\u0026lt;/el-button\u0026gt; \u0026lt;div slot=\u0026#34;tip\u0026#34; class=\u0026#34;el-upload__tip\u0026#34;\u0026gt;只能上传jpg/png文件，且不超过10mb\u0026lt;/div\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;el-dialog :visible.sync=\u0026#34;dialogvisible\u0026#34;\u0026gt; \u0026lt;img width=\u0026#34;100%\u0026#34; :src=\u0026#34;filelist[0].url\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import {policy} from \u0026#39;@/utils/policy\u0026#39; import { getuuid } from \u0026#39;@/utils\u0026#39; export default { name: \u0026#39;singleupload\u0026#39;, props: { value: string }, computed: { imageurl() { return this.value; }, imagename() { if (this.value != null \u0026amp;\u0026amp; this.value !== \u0026#39;\u0026#39;) { return this.value.substr(this.value.lastindexof(\u0026#34;/\u0026#34;) + 1); } else { return null; } }, filelist() { return [{ name: this.imagename, url: this.imageurl }] }, showfilelist: { get: function () { return this.value !== null \u0026amp;\u0026amp; this.value !== \u0026#39;\u0026#39;\u0026amp;\u0026amp; this.value!==undefined; }, set: function (newvalue) { } } }, data() { return { dataobj: { policy: \u0026#39;\u0026#39;, signature: \u0026#39;\u0026#39;, key: \u0026#39;\u0026#39;, ossaccesskeyid: \u0026#39;\u0026#39;, dir: \u0026#39;\u0026#39;, host: \u0026#39;\u0026#39;, // callback:\u0026#39;\u0026#39;, }, dialogvisible: false }; }, methods: { emitinput(val) { this.$emit(\u0026#39;input\u0026#39;, val) }, handleremove(file, filelist) { this.emitinput(\u0026#39;\u0026#39;); }, handlepreview(file) { this.dialogvisible = true; }, beforeupload(file) { let _self = this; return new promise((resolve, reject) =\u0026gt; { policy().then(response =\u0026gt; { // console.log(response) _self.dataobj.policy = response.policy; _self.dataobj.signature = response.signature; _self.dataobj.ossaccesskeyid = response.accessid; _self.dataobj.key = response.dir + getuuid()+\u0026#39;_${filename}\u0026#39;; _self.dataobj.dir = response.dir; _self.dataobj.host = response.host; resolve(true) }).catch(err =\u0026gt; { console.log(err) reject(false) }) }) }, handleuploadsuccess(res, file) { console.log(\u0026#34;上传成功...\u0026#34;) this.showfilelist = true; this.filelist.pop(); this.filelist.push({name: file.name, url: this.dataobj.host + \u0026#39;/\u0026#39; + this.dataobj.key.replace(\u0026#34;${filename}\u0026#34;,file.name) }); this.emitinput(this.filelist[0].url); } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 2.4.3、修改题目分类新增页面，增加上传控件 在前端工程renren-fast-vue目录src/views/modules/question目录下 修改页面 type-add-or-update.vue\n引入上传控件\nimport singleupload from \u0026#34;../common/singleupload\u0026#34; // 引入单文件上传组件 注册上传组件：\nexport default { components:{ singleupload } }, 修改分类logo输入框，改成上传按钮\n\u0026lt;el-form-item label=\u0026#34;类型logo路径\u0026#34; prop=\u0026#34;logourl\u0026#34;\u0026gt; \u0026lt;single-upload v-model=\u0026#34;dataform.logourl\u0026#34;\u0026gt;\u0026lt;/single-upload\u0026gt; \u0026lt;/el-form-item\u0026gt; 2.4.4、测试上传 点击上传 按钮，选择要上传的图片 上传图片成功： 注意：oss服务器存储桶一定要设置允许跨域\n配置跨域访问\n登录oss管理控制台。 单击bucket列表，之后单击目标bucket名称。 单击权限管理 \u0026gt; 跨域设置，在跨域设置区域单击设置。 单击创建规则，配置如下图所示。 3、开发广告内容前端维护管理 3.1、添加广告内容管理目录（一级菜单） 选择管理界面\u0026ndash;系统管理\u0026ndash;菜单管理，点击 新增按钮 3.2、添加广告轮播图管理菜单（二级菜单） 3.3、添加广告资讯管理菜单（二级菜单） 3.4、生成广告前端页面 用renren-generator自动生成前端代码\n注意配置数据库连接文件application.yml,指向数据库 uxue_cms\nspring: datasource: type: com.alibaba.druid.pool.druiddatasource #mysql配置 driverclassname: com.mysql.cj.jdbc.driver url: jdbc:mysql://localhost:3306/uxue_cms?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;usessl=false\u0026amp;servertimezone=asia/shanghai username: root password: root 修改模板生成属性配置文件generator.properties\nmainpath=com.offcn #\\u5305\\u540d package=com.offcn modulename=context #\\u4f5c\\u8005 author=sunny #email email=hk109@126.com #\\u8868\\u524d\\u7f00(\\u7c7b\\u540d\\u4e0d\\u4f1a\\u5305\\u542b\\u8868\\u524d\\u7f00) tableprefix=cms_ 启动renren-generator\n3.5、拷贝前端代码到 前端工程renren-fast-vue 拷贝\\main\\resources\\src\\views\\modules\\context目录到前端目录 renren-fast-vue\\src\\views\\modules 3.6、配置网关转发 找到cloud-gateway,修改配置文件application.yml\n- id: cms-route # 广告微服务路由 uri: lb://u-context predicates: - path=/api/context/** filters: - rewritepath=/api/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} 3.7、测试广告轮播图、广告资讯基本管理 刷新页面，点击菜单 广告内容管理\u0026mdash;》广告轮播图 点击菜单 广告内容管理\u0026mdash;》广告资讯 分别测试增删改\n注意测试新增前，先把日期时间字段改成不是必须输入\n修改banner-add-or-update.vue、news-add-or-update.vue\ncreatetime: [ { required: false, message: \u0026#39;创建时间不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ], updatetime: [ { required: false, message: \u0026#39;更新时间不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ] 3.8、修改广告轮播图广告配图上传 在前端工程renren-fast-vue目录src/views/modules/context目录下 修改页面 banner-add-or-update.vue\n引入上传控件\nimport singleupload from \u0026#34;../common/singleupload\u0026#34; // 引入单文件上传组件 注册上传组件：\nexport default { components:{ singleupload } } 修改图片路径输入框，改成上传按钮\n\u0026lt;el-form-item label=\u0026#34;图片路径\u0026#34; prop=\u0026#34;imgurl\u0026#34;\u0026gt; \u0026lt;single-upload v-model=\u0026#34;dataform.imgurl\u0026#34;\u0026gt;\u0026lt;/single-upload\u0026gt; \u0026lt;/el-form-item\u0026gt; 实际运行效果： 3.9、修改广告资讯广告配图上传 在前端工程renren-fast-vue目录src/views/modules/context目录下 修改页面 news-add-or-update.vue\n具体修改方式和广告轮播相同\n4、开发用户管理前端维护管理 4.1、添加用户管理目录（一级菜单） 选择管理界面\u0026ndash;系统管理\u0026ndash;菜单管理，点击 新增按钮 4.2、添加用户列表管理菜单（二级菜单） 4.3、添加用户充值记录管理菜单（二级菜单） 4.4、生成用户服务相关前端页面 用renren-generator自动生成前端代码\n注意配置数据库连接文件application.yml,指向数据库 uxue_cms\nspring: datasource: type: com.alibaba.druid.pool.druiddatasource #mysql配置 driverclassname: com.mysql.cj.jdbc.driver url: jdbc:mysql://localhost:3306/uxue_ums?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;usessl=false\u0026amp;servertimezone=asia/shanghai username: root password: root 修改模板生成属性配置文件generator.properties\nmainpath=com.offcn #\\u5305\\u540d package=com.offcn modulename=member #\\u4f5c\\u8005 author=sunny #email email=hk109@126.com #\\u8868\\u524d\\u7f00(\\u7c7b\\u540d\\u4e0d\\u4f1a\\u5305\\u542b\\u8868\\u524d\\u7f00) tableprefix=ums_ 启动renren-generator\n4.5、拷贝前端代码到 前端工程renren-fast-vue 拷贝\\main\\resources\\src\\views\\modules\\member目录到前端目录 renren-fast-vue\\src\\views\\modules\n4.6、配置网关转发 找到cloud-gateway,修改配置文件application.yml\nspring: cloud: nacos: discovery: server-addr: http://localhost:8848 gateway: routes: - id: ums-route # 用户微服务路由 uri: lb://u-member predicates: - path=/api/member/** filters: - rewritepath=/api/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} 4.7、测试用户列表、充值记录基本管理 刷新页面，点击菜单用户管理\u0026mdash;》用户列表 点击菜单用户管理\u0026mdash;》用户充值记录 分别测试增删改\n注意测试新增前，先把日期时间字段改成不是必须输入\n修改member-add-or-update.vue、growthchangehistory-add-or-update.vue\ncreatetime: [ { required: false, message: \u0026#39;创建时间不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ], updatetime: [ { required: false, message: \u0026#39;更新时间不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; } ] 4.8．用户注册数量统计分析 4.8.1 编写java后端代码 打开java模块u-member ，编辑接口memberservice新增统计注册数量方法\npublic interface memberservice extends iservice\u0026lt;memberentity\u0026gt; { public list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; countbydatetime(string begintime, string endtime); } 编辑接口实现类memberserviceimpl,编写统计注册数量实现方法\n@autowired private memberdao memberdao; @override public list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; countbydatetime(string begintime, string endtime) { querywrapper\u0026lt;memberentity\u0026gt; querywrapper = new querywrapper\u0026lt;memberentity\u0026gt;().select(\u0026#34;date_format(create_time,\u0026#39;%y-%m-%d\u0026#39;) as name ,count(id) as value\u0026#34;).between(\u0026#34;create_time\u0026#34;, begintime+\u0026#34; 00:00:00\u0026#34;, endtime+\u0026#34; 23:59:59\u0026#34;).groupby(\u0026#34;name\u0026#34;); list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; maplist = memberdao.selectmaps(querywrapper); return maplist; } 编辑membercontroller,新增统计注册数量方法\n//根据开始时间，结束时间，统计每日注册账号 @requestmapping(\u0026#34;countaccountcreate\u0026#34;) public r countaccountcreate(string begintime,string endtime){ list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; maplist = memberservice.countbydatetime(begintime, endtime); return r.ok().put(\u0026#34;maplist\u0026#34;,maplist); } 4.8.2 编写前端代码 前端项目renren-fast-vue/src/views/modules/member目录 新增统计注册用户数量页面 echarts.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;mod-demo-echarts\u0026#34;\u0026gt; \u0026lt;!--表单--\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt;​ \u0026lt;el-form-item label=\u0026#34;开始日期\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;begintime\u0026#34; type=\u0026#34;date\u0026#34; placeholder=\u0026#34;选择要统计的开始日期\u0026#34; value-format=\u0026#34;yyyy-mm-dd\u0026#34; /\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;结束日期\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;endtime\u0026#34; type=\u0026#34;date\u0026#34; placeholder=\u0026#34;选择要统计的结束日期\u0026#34; value-format=\u0026#34;yyyy-mm-dd\u0026#34; /\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-button :disabled=\u0026#34;btndisabled\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;create()\u0026#34;\u0026gt;生成\u0026lt;/el-button\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;el-row :gutter=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;24\u0026#34;\u0026gt; \u0026lt;el-card\u0026gt; \u0026lt;div id=\u0026#34;j_chartbarbox\u0026#34; class=\u0026#34;chart-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import echarts from \u0026#39;echarts\u0026#39; export default { data () { return { chartbar: null, begintime: \u0026#39;\u0026#39;, endtime: \u0026#39;\u0026#39;, maplist: [], xdata: [], ydata: [], btndisabled: false } }, mounted () { }, activated () { // 由于给echart添加了resize事件, 在组件激活时需要重新resize绘画一次, 否则出现空白bug if (this.chartbar) { this.chartbar.resize() } }, methods: { create () { this. getdatalist () this.initchartbar() }, // 获取数据列表 getdatalist () { this.datalistloading = true this.$http({ url: this.$http.adornurl(\u0026#39;/member/member/countaccountcreate\u0026#39;), method: \u0026#39;get\u0026#39;, params: this.$http.adornparams({ \u0026#39;begintime\u0026#39;: this.begintime, \u0026#39;endtime\u0026#39;: this.endtime }) }).then(({data}) =\u0026gt; { if (data \u0026amp;\u0026amp; data.code === 0) { this.maplist = data.maplist this.xdata = [] this.ydata = [] for(let j in this.maplist){ this.xdata.push(this.maplist[j].name) this.ydata.push(this.maplist[j].value) } console.log(this.xdata) console.log(this.ydata) this.chartbar.resize() // this.xdata= this.maplist.map(obj =\u0026gt; n.name); // this.ydata= this.maplist.map(obj =\u0026gt; n.value); this.chartbar.setoption({ xaxis: [ { type: \u0026#39;category\u0026#39;, data: this.xdata } ], yaxis: [ { type: \u0026#39;value\u0026#39; } ], series: [ { name: \u0026#39;每日注册用户数\u0026#39;, type: \u0026#39;line\u0026#39;, data: this.ydata } ] }) } else { this.maplist = [] } }) }, // 柱状图 initchartbar () { var option = { tooltip: { trigger: \u0026#39;axis\u0026#39;, axispointer: { type: \u0026#39;shadow\u0026#39; } }, legend: { data: [\u0026#39;每日注册用户数\u0026#39;] }, grid: { left: \u0026#39;3%\u0026#39;, right: \u0026#39;4%\u0026#39;, bottom: \u0026#39;3%\u0026#39;, containlabel: true }, xaxis: [ { type: \u0026#39;category\u0026#39;, data: this.xdata } ], yaxis: [ { type: \u0026#39;value\u0026#39; } ], series: [ { name: \u0026#39;每日注册用户数\u0026#39;, type: \u0026#39;bar\u0026#39;, data: this.ydata } ] } this.chartbar = echarts.init(document.getelementbyid(\u0026#39;j_chartbarbox\u0026#39;)) // this.chartbar.setoption(option) window.addeventlistener(\u0026#39;resize\u0026#39;, () =\u0026gt; { this.chartbar.resize() }) } } } \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34;\u0026gt; .mod-demo-echarts { \u0026gt; .el-alert { margin-bottom: 10px; } \u0026gt; .el-row { margin-top: -10px; margin-bottom: -10px; .el-col { padding-top: 10px; padding-bottom: 10px; } } .chart-box { min-height: 400px; } } \u0026lt;/style\u0026gt; 4.8.3 配置用户注册统计菜单 新增菜单后，刷新，即可查看菜单 选中开始日期，结束日期，点击 生成按钮 出现统计折线图 5、开发微信小程序登录及验证调用接口 5.1．编写jwt工具类 5.1.1 打开模块u-common,编辑pom.xml 引入jwt依赖库\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.jsonwebtoken\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jjwt\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 5.1.2 jwt工具类 jwtutil package com.offcn.common.utils; import io.jsonwebtoken.*; import java.util.date; public class jwtutil { private static final string secret_key = \u0026#34;u-member-offcn123\u0026#34;; //秘钥 public static final long token_expire_time = 5 * 60 * 1000; //token过期时间 public static final long refresh_token_expire_time = 10 * 60 * 1000; //refreshtoken过期时间 private static final string issuer = \u0026#34;offcn\u0026#34;; //签发人 //生成签名 public static string generatetoken(string username){ date now = new date(); return jwts.builder() .setissuer(issuer) //签发人 .setissuedat(now)//签发时间 .setexpiration(new date(now.gettime()+token_expire_time))//过期时间 .claim(\u0026#34;username\u0026#34;,username)//用户名 .signwith(signaturealgorithm.hs256,secret_key)//签名算法、秘钥 .compact(); } //解析token private static claims parsetoken(string token){ return jwts.parser() .setsigningkey(secret_key) .parseclaimsjws(token).getbody(); } //验证签名 public static boolean verify(string token){ //尝试解析token try { claims claims = parsetoken(token); return true; } catch (exception e) { // e.printstacktrace(); system.out.println(\u0026#34;签名验证失败\u0026#34;); return false; } } //从token获取用户名 public static string getusername(string token){ try { claims claims = parsetoken(token); string username = (string) claims.get(\u0026#34;username\u0026#34;); return username; } catch (exception e) { // e.printstacktrace(); system.out.println(\u0026#34;解析令牌失败\u0026#34;); return \u0026#34;\u0026#34;; } } } 5.2．编写用户登录接口 打开模块u-member,memberservice增加登录接口\npublic interface memberservice extends iservice\u0026lt;memberentity\u0026gt; { public memberentity login(string username,string password); } 打开模块u-member,memberserviceimpl增加登录实现方法\n@override public memberentity login(string username, string password) { memberentity memberentity = this.getone(new querywrapper\u0026lt;memberentity\u0026gt;().eq(\u0026#34;user_name\u0026#34;, username).eq(\u0026#34;password\u0026#34;, password)); return memberentity; } 5.3．编写用户登录、刷新token控制器 u-member添加依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 在membercontroller\n@autowired private stringredistemplate stringredistemplate; //登录 @postmapping(\u0026#34;/login\u0026#34;) public r login(string username,string password){ memberentity memberentity = memberservice.login(username, password); if(memberentity!=null) { string token = jwtutil.generatetoken(memberentity.getusername()); //生成refreshtoken string refreshtoken = uuid.randomuuid().tostring().replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;); stringredistemplate.opsforhash().put(refreshtoken, \u0026#34;token\u0026#34;, token); stringredistemplate.opsforhash().put(refreshtoken, \u0026#34;username\u0026#34;, username); //设置token的过期时间 stringredistemplate.expire(refreshtoken, jwtutil.refresh_token_expire_time, timeunit.milliseconds); return r.ok().put(\u0026#34;token\u0026#34;,token).put(\u0026#34;refreshtoken\u0026#34;,refreshtoken); }else { return r.error(\u0026#34;账号密码错误\u0026#34;); } } //刷新token @postmapping(\u0026#34;/refreshtoken\u0026#34;) public r refreshtoken(string refreshtoken){ //根据refreshtoken从redis读取用户名 string username= (string) stringredistemplate.boundhashops(refreshtoken).get(\u0026#34;username\u0026#34;); if(stringutils.isempty(username)){ return r.error(\u0026#34;刷新token失败\u0026#34;); } //根据用户名生成新的token string token = jwtutil.generatetoken(username); //更新token到redis stringredistemplate.boundhashops(refreshtoken).put(\u0026#34;token\u0026#34;,token); //设置token的过期时间 stringredistemplate.expire(refreshtoken, jwtutil.refresh_token_expire_time, timeunit.milliseconds); return r.ok().put(\u0026#34;token\u0026#34;,token).put(\u0026#34;refreshtoken\u0026#34;,refreshtoken); } redis: host: localhost port: 6379 5.4．测试用户登录、刷新token 登录地址：http://localhost:10002/member/member/login\n传递参数: username 用户账号 password 密码 刷新token地址：http://localhost:10002/member/member/refreshtoken\n传递参数：refreshtoken\n返回结果： 5.5、配置网关路由转发 修改cloud-gateway模块，配置文件application.yml增加登录路由转发\n- id: weixin-login-ums-route # 提供微信客户端调用的，用户微服务路由 uri: lb://u-member predicates: - path=/member/member/login/** - id: weixin-register-ums-route # 提供微信客户端调用的，用户微服务路由 uri: lb://u-member predicates: - path=/member/member/save/** 测试网关访问地址：\nhttp://localhost:8888/member/member/login?username=test\u0026amp;password=123\n响应： 5.6、用户注册接口 http://localhost:8888/member/member/save\n请求参数：\n{ \u0026#34;miniopenid\u0026#34;: \u0026#34;1001\u0026#34;, \u0026#34;mpopenid\u0026#34;: \u0026#34;8877111\u0026#34;, \u0026#34;unionid\u0026#34;: \u0026#34;test001\u0026#34;, \u0026#34;levelid\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;test003\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;456\u0026#34;, \u0026#34;nickname\u0026#34;: \u0026#34;nickname\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;17562128765\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;hk109@139.com\u0026#34;, \u0026#34;avatar\u0026#34;: \u0026#34;1.jpg\u0026#34;, \u0026#34;gender\u0026#34;: 0, \u0026#34;city\u0026#34;: \u0026#34;北京\u0026#34;, \u0026#34;birth\u0026#34;: \u0026#34;1978-09-11\u0026#34;, \u0026#34;sourcetype\u0026#34;: 1, \u0026#34;integration\u0026#34;: 1 } 5.7、配置网关过滤器，拦截微信客户端请求验证token 5.7.1、修改pom.xml引入common依赖，排除不需要的mybatis-plus-boot-starter依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;u-common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 5.7.2、编写网关过滤器类 编写自定义过滤器实现类：innerfilter\npackage com.offcn.filter; import com.offcn.common.utils.jwtutil; import org.springframework.cloud.gateway.filter.gatewayfilter; import org.springframework.cloud.gateway.filter.gatewayfilterchain; import org.springframework.core.ordered; import org.springframework.core.io.buffer.databuffer; import org.springframework.http.httpheaders; import org.springframework.http.server.reactive.serverhttprequest; import org.springframework.http.server.reactive.serverhttpresponse; import org.springframework.util.stringutils; import org.springframework.web.server.serverwebexchange; import reactor.core.publisher.mono; public class innerfilter implements gatewayfilter, ordered { private jwtcheckgatewayfilterfactory.config config; innerfilter(jwtcheckgatewayfilterfactory.config config){ this.config=config; } @override public mono\u0026lt;void\u0026gt; filter(serverwebexchange exchange, gatewayfilterchain chain) { serverhttprequest request = exchange.getrequest(); serverhttpresponse response = exchange.getresponse(); //尝试从请求头获取令牌 string token = request.getheaders().getfirst(\u0026#34;authorization\u0026#34;); //判断令牌如果不为空 if(!stringutils.isempty(token)){ //调用令牌工具类，校验令牌 boolean verify = jwtutil.verify(token); //判断令牌校验失败 if(!verify){ //令牌校验失败，结束转发 mono mono = returnfail(response); return response.writewith(mono); }else { //令牌校验成功，放行 return chain.filter(exchange); } }else { //令牌不存在，结束转发 mono mono = returnfail(response); return response.writewith(mono); } } //返回失败方法 private mono returnfail(serverhttpresponse response){ //获取响应对象头 httpheaders headers = response.getheaders(); //设置响应头内容content-type 响应内容类型 headers.add(\u0026#34;content-type\u0026#34;,\u0026#34;application/json; charset=utf-8\u0026#34;); //禁止缓存 headers.add(\u0026#34;cache-control\u0026#34;, \u0026#34;no-store, no-cache, must-revalidate, max-age=0\u0026#34;); //设置响应内容 string body=\u0026#34;token验证失败\u0026#34;; databuffer databuffer = response.bufferfactory().wrap(body.getbytes()); //把内容写入到响应对象 return mono.just(databuffer); } @override public int getorder() { return 1; } } 编写自定义网关过滤器\npackage com.offcn.filter; import org.springframework.cloud.gateway.filter.gatewayfilter; import org.springframework.cloud.gateway.filter.factory.abstractgatewayfilterfactory; public class jwtcheckgatewayfilterfactory extends abstractgatewayfilterfactory\u0026lt;jwtcheckgatewayfilterfactory.config\u0026gt; { //要向父类传递配置类，要不然就会报类型转换错误 public jwtcheckgatewayfilterfactory() { super(config.class); } @override public gatewayfilter apply(config config) { return new innerfilter(config); } //定义一个内部类，配置过滤器属性,必须是静态的 public static class config{ } } 5.7.3、配置网关过滤器 package com.offcn.config; import com.offcn.filter.jwtcheckgatewayfilterfactory; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; import org.springframework.web.cors.corsconfiguration; import org.springframework.web.cors.reactive.corswebfilter; import org.springframework.web.cors.reactive.urlbasedcorsconfigurationsource; @configuration public class gatewaycorsconfiguration { @bean public jwtcheckgatewayfilterfactory jwtcheckgatewayfilterfactory(){ return new jwtcheckgatewayfilterfactory(); } } 5.7.4、修改网关配置 spring: cloud: nacos: discovery: server-addr: http://localhost:8848 gateway: routes: - id: weixin-login-ums-route # 提供微信客户端调用的，用户微服务路由 uri: lb://u-member predicates: - path=/member/member/login/** filters: - rewritepath=/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - id: weixin-test-ums-route # 提供微信客户端调用的，用户微服务路由 uri: lb://u-member predicates: - path=/member/member/refreshtoken/** filters: - rewritepath=/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - jwtcheck 刷新token接口，启用token校验过滤器，填上过滤器前缀就可以 jwtcheck\n5.7.5、测试 访问登录接口地址:http://localhost:8888/member/member/login?username=test\u0026amp;password=123\n不需要token验证。\n访问刷新token接口地址：http://localhost:8888/member/member/refreshtoken?refreshtoken=4257e35399db461ca0bfac3b6b3a61f9\n在请求头不带参数，提示toekn验证失败 在请求头带上参数 authorization 6、开发微信小程序分类、及题库、广告轮播图读取调用接口 6.1．获取题库分类接口 6.1.1、修改网关路由配置添加获取题库分类接口路由 修改application.yml\nspring: cloud: nacos: discovery: server-addr: http://localhost:8848 gateway: routes: - id: weixin-question-route # 提供微信客户端调用的，题库微服务路由 uri: lb://u-question predicates: - path=/question/** filters: - rewritepath=/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - jwtcheck 访问路径：http://localhost:8888/question/type/findall 6.2．获取题库数据接口 6.2.1．获取根据分类获取题库列表数据接口 访问路径：http://localhost:8888/question/question/list 可以传递参数：key 等于题库分类编号\nhttp://localhost:8888/question/question/list?key=6\n6.3．获取根据实体编号获取题目详情数据接口 http://localhost:8888/question/question/info/50\n6.4．获取广告轮播图数据接口 6.4.1．获取广告轮播图列表数据接口 - id: weixin-context-route # 提供微信客户端调用的，用户微服务路由 uri: lb://u-context predicates: - path=/context/** filters: - rewritepath=/(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - jwtcheck 访问路径：http://localhost:8888/context/banner/list?page=1\u0026amp;limit=5 7、接口文档 7.1、用户注册 \u0026lt;a id=用户注册\u0026gt; \u0026lt;/a\u0026gt;\n基本信息 path： /member/member/save\nmethod： post\n接口描述：\nrequest headers\n参数名称 参数值 是否必须 示例 备注 content-type application/json 是 body\n{ \u0026#34;miniopenid\u0026#34;: \u0026#34;1001\u0026#34;, //小程序openid \u0026#34;mpopenid\u0026#34;: \u0026#34;8877111\u0026#34;, //服务号openid \u0026#34;unionid\u0026#34;: \u0026#34;test001\u0026#34;, //微信unionid \u0026#34;levelid\u0026#34;: 1, //会员等级id 整数 \u0026#34;username\u0026#34;: \u0026#34;test003\u0026#34;, //用户登录账号 \u0026#34;password\u0026#34;: \u0026#34;456\u0026#34;, //用户密码 \u0026#34;nickname\u0026#34;: \u0026#34;nickname\u0026#34;,//用户昵称 \u0026#34;phone\u0026#34;: \u0026#34;17562128765\u0026#34;, //用户手机号 \u0026#34;email\u0026#34;: \u0026#34;hk109@139.com\u0026#34;,//用户邮箱 \u0026#34;avatar\u0026#34;: \u0026#34;1.jpg\u0026#34;,//用户头像 \u0026#34;gender\u0026#34;: 0, //性别 0 女 1男 \u0026#34;city\u0026#34;: \u0026#34;北京\u0026#34;, //用户地址 \u0026#34;birth\u0026#34;: \u0026#34;1978-09-11\u0026#34;,//用户生日 \u0026#34;sourcetype\u0026#34;: 1,//来源 1 微信 2 app \u0026#34;integration\u0026#34;: 1 //积分，初始化注册积分为1 } reponse { \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, //操作结果 \u0026#34;code\u0026#34;: 0 //状态码 0 成功 } 7.2、用户登录 \u0026lt;a id=用户登录\u0026gt; \u0026lt;/a\u0026gt;\n基本信息 path： /member/member/login\nmethod： get\n接口描述：\nrequest query\n参数名称 是否必须 示例 备注 username 是 test001 用户账号 password 是 123 密码 reponse { \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;,//响应成功消息 \u0026#34;code\u0026#34;: 0,//响应状态码 0 成功 //token ,注意后续访问 获取分类、题库数据接口 需要鉴权 请求头里面带 token //请求头参数 authorization token值 \u0026#34;token\u0026#34;: \u0026#34;eyj0exaioijkv1qilcjhbgcioijiuzi1nij9.eyjpc3mioijvzmzjbiisimv4cci6mtywody1mdmymywiawf0ijoxnja4njm4mzizlcj1c2vybmftzsi6inrlc3qifq.1jv-o3o7ixoutnjdzzjhkm5fiihrtviqy2cxey4dzb4\u0026#34;, //token失效，刷新token使用 \u0026#34;refreshtoken\u0026#34;: \u0026#34;2bd89f56c6ba4befae70fc7399edda44\u0026#34; } 7.3、刷新token \u0026lt;a id=刷新token\u0026gt; \u0026lt;/a\u0026gt;\n基本信息 path：/member/member/refreshtoken\nmethod： post\n接口描述：\nrequest headers\n参数名称 参数值 是否必须 示例 备注 content-type application/x-www-form-urlencoded 是 query\n参数名称 是否必须 示例 备注 refreshtoken 是 refreshtoken 登录成功后有返回 body\n参数名称 参数类型 是否必须 示例 备注 refreshtoken text 是 refreshtoken登录成功后有返回 reponse { \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;,//消息 \u0026#34;code\u0026#34;: 0,//状态码 0 成功 //最新的token \u0026#34;token\u0026#34;: \u0026#34;eyj0exaioijkv1qilcjhbgcioijiuzi1nij9.eyjpc3mioijvzmzjbiisimv4cci6mtywody1mdy4mywiawf0ijoxnja4njm4njgzlcj1c2vybmftzsi6inrlc3qifq.g_0wckrnwazcl4si-9ko3h-sj1wjgznuamxqegzmtdq\u0026#34;, //刷新token的值 \u0026#34;refreshtoken\u0026#34;: \u0026#34;9332b3bfd3ce46e590ae0720579b8bc1\u0026#34; } 7.4、获取广告轮播图 \u0026lt;a id=获取广告轮播图\u0026gt; \u0026lt;/a\u0026gt;\n基本信息 path： /context/banner/list\nmethod： get\n接口描述：\nrequest headers\n参数名称 参数值 是否必须 示例 备注 authorization 是 必须 登录获取到token query\n参数名称 是否必须 示例 备注 page 是 1 页码 limit 是 5 轮播图数量 reponse { \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;code\u0026#34;: 0, \u0026#34;page\u0026#34;: { \u0026#34;totalcount\u0026#34;: 0, \u0026#34;pagesize\u0026#34;: 5, \u0026#34;totalpage\u0026#34;: 0, \u0026#34;currpage\u0026#34;: 1, \u0026#34;list\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;imgurl\u0026#34;: \u0026#34;https://java0817-001.oss-cn-guangzhou.aliyuncs.com/2021-01-06/1533d9e1-d221-4c48-8804-118f32fdd173_6.png\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;github\u0026#34;, \u0026#34;displayorder\u0026#34;: 1, \u0026#34;enable\u0026#34;: 1, \u0026#34;rendertype\u0026#34;: 1, \u0026#34;renderurl\u0026#34;: \u0026#34;http://www.ujiuye.com\u0026#34;, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2021-01-06t04:30:29.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2021-01-06t04:30:29.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;imgurl\u0026#34;: \u0026#34;https://java0817-001.oss-cn-guangzhou.aliyuncs.com/2021-01-06/cb1fa277-1fce-4a1e-882d-a3c3cce551f2_7.png\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;displayorder\u0026#34;: 2, \u0026#34;enable\u0026#34;: 1, \u0026#34;rendertype\u0026#34;: 1, \u0026#34;renderurl\u0026#34;: \u0026#34;http://www.baidu.com\u0026#34;, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2021-01-06t04:38:04.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2021-01-06t04:38:04.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;imgurl\u0026#34;: \u0026#34;https://java0817-001.oss-cn-guangzhou.aliyuncs.com/2021-01-06/21cf3022-14f1-4a65-8889-acc196d84239_2.png\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;222\u0026#34;, \u0026#34;displayorder\u0026#34;: 3, \u0026#34;enable\u0026#34;: 1, \u0026#34;rendertype\u0026#34;: 1, \u0026#34;renderurl\u0026#34;: \u0026#34;http://www.offcn.com\u0026#34;, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2021-01-06t04:38:37.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2021-01-06t04:38:37.000+00:00\u0026#34; } ] } } 7.5、获取试题分类 \u0026lt;a id=获取试题分类\u0026gt; \u0026lt;/a\u0026gt;\n基本信息 path： /api/question/type/findall\nmethod： get\n接口描述：\nrequest headers\n参数名称 参数值 是否必须 示例 备注 authorization 是 必须 登录成功获取到的token reponse { \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;code\u0026#34;: 0, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 6, \u0026#34;type\u0026#34;: \u0026#34;java基础\u0026#34;, \u0026#34;comments\u0026#34;: \u0026#34;java基础\u0026#34;, \u0026#34;logourl\u0026#34;: \u0026#34;https://java0817-001.oss-cn-guangzhou.aliyuncs.com/2020-12-18/0cdabddd-3f3b-4b49-8cd5-e008b3e6ad08_1.jpg\u0026#34;, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:44:18.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:44:18.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 7, \u0026#34;type\u0026#34;: \u0026#34;多线程\u0026#34;, \u0026#34;comments\u0026#34;: \u0026#34;多线程\u0026#34;, \u0026#34;logourl\u0026#34;: \u0026#34;https://java0817-001.oss-cn-guangzhou.aliyuncs.com/2020-12-18/b4d68e14-7abe-4680-8645-e9d8584b6159_thread.png\u0026#34;, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:48:11.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:48:11.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 8, \u0026#34;type\u0026#34;: \u0026#34;分布式架构\u0026#34;, \u0026#34;comments\u0026#34;: \u0026#34;分布式架构\u0026#34;, \u0026#34;logourl\u0026#34;: \u0026#34;https://java0817-001.oss-cn-guangzhou.aliyuncs.com/2020-12-18/ccc99163-69a9-44f4-8ee4-75fbdced3291_jichu.png\u0026#34;, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:50:18.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:50:18.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 9, \u0026#34;type\u0026#34;: \u0026#34;业务逻辑\u0026#34;, \u0026#34;comments\u0026#34;: \u0026#34;业务逻辑\u0026#34;, \u0026#34;logourl\u0026#34;: \u0026#34;https://java0817-001.oss-cn-guangzhou.aliyuncs.com/2020-12-18/3478c4fe-80b6-412a-88f1-8788a09ff3c9_yewu.png\u0026#34;, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:51:09.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:51:09.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 10, \u0026#34;type\u0026#34;: \u0026#34;智能运维\u0026#34;, \u0026#34;comments\u0026#34;: \u0026#34;运维\u0026#34;, \u0026#34;logourl\u0026#34;: \u0026#34;https://java0817-001.oss-cn-guangzhou.aliyuncs.com/2020-12-18/8ab19994-c80f-4dce-8f85-7d4be876f073_运维.png\u0026#34;, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:51:45.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:51:45.000+00:00\u0026#34; } ] } 7.6、读取指定分类对应的试题列表 \u0026lt;a id=读取指定分类对应的试题\u0026gt; \u0026lt;/a\u0026gt;\n基本信息 path： /api/question/question/list\nmethod： get\n接口描述：\nrequest headers\n参数名称 参数值 是否必须 示例 备注 authorization 是 必须 登录成功获取到token query\n参数名称 是否必须 示例 备注 page 是 1 页码 limit 是 10 每页显示记录数 key 否 1 分类编号 reponse { \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;code\u0026#34;: 0, \u0026#34;page\u0026#34;: { \u0026#34;totalcount\u0026#34;: 8, \u0026#34;pagesize\u0026#34;: 10, \u0026#34;totalpage\u0026#34;: 1, \u0026#34;currpage\u0026#34;: 1, \u0026#34;list\u0026#34;: [ { \u0026#34;id\u0026#34;: 50, \u0026#34;title\u0026#34;: \u0026#34;请介绍一下springsecurity是做什么的？\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;springsecurity是一个能够为基于spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在spring应用上下文中配置的bean，充分利用了spring ioc，di（控制反转inversion of control ,di:dependency injection 依赖注入）和aop（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。\u0026#34;, \u0026#34;level\u0026#34;: 3, \u0026#34;displayorder\u0026#34;: 1, \u0026#34;subtitle\u0026#34;: \u0026#34;springsecurity\u0026#34;, \u0026#34;type\u0026#34;: 6, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:54:36.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:54:36.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 51, \u0026#34;title\u0026#34;: \u0026#34;介绍一下商品图片的上传流程？\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;客户端发送请求到trackerserver 由trackerserver去查询可用storageserver.返回给客户端.客户端找到storageserver进行文件上传.storageserver保存数据并且生产file_id.并将file_id(路径信息和文件名)返回给客户端.\u0026#34;, \u0026#34;level\u0026#34;: 4, \u0026#34;displayorder\u0026#34;: 2, \u0026#34;subtitle\u0026#34;: \u0026#34;图片的上传流程\u0026#34;, \u0026#34;type\u0026#34;: 6, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:55:33.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:55:33.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 52, \u0026#34;title\u0026#34;: \u0026#34;什么是富文本编辑器？\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;富文本编辑器，rich text editor, 简称 rte, 它提供类似于 microsoft word 的编辑功能。常用的富文本编辑器：\\nkindeditor http://kindeditor.net/\\nueditor http://ueditor.baidu.com/website/\\nckeditor http://ckeditor.com/\u0026#34;, \u0026#34;level\u0026#34;: 2, \u0026#34;displayorder\u0026#34;: 3, \u0026#34;subtitle\u0026#34;: \u0026#34;富文本编辑器\u0026#34;, \u0026#34;type\u0026#34;: 6, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:56:10.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:56:10.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 53, \u0026#34;title\u0026#34;: \u0026#34;什么是逻辑删除？\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;逻辑删除：顾名思义，就是“假删除”。在企业开发中，一般做真实的物理删除情况较少，我们大多数都是通过一些标记字段，来表示该数据是否被删除，这样后期的统计、分析、研究数据都比较方便，便于积累大量的用户数据。\u0026#34;, \u0026#34;level\u0026#34;: 4, \u0026#34;displayorder\u0026#34;: 4, \u0026#34;subtitle\u0026#34;: \u0026#34;逻辑删除\u0026#34;, \u0026#34;type\u0026#34;: 6, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:56:42.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:56:42.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 54, \u0026#34;title\u0026#34;: \u0026#34;简单说明redis存储的流程？\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;1.直接从reids中获取数据。\\n2.判断获取的数据是否为空\\n3.如果为空，则从数据库中获取数据，并将从数据库中获取的数据，存储到redis中，再返回。\\n4.如果不为空，则直接将redis中获取的数据返回\u0026#34;, \u0026#34;level\u0026#34;: 4, \u0026#34;displayorder\u0026#34;: 5, \u0026#34;subtitle\u0026#34;: \u0026#34;redis存储\u0026#34;, \u0026#34;type\u0026#34;: 6, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:57:15.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:57:15.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 55, \u0026#34;title\u0026#34;: \u0026#34;solr是什么？有什么优点？\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;基于lucene的全文搜索服务器。同时对其进行了扩展，提供了比\\nlucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎\u0026#34;, \u0026#34;level\u0026#34;: 2, \u0026#34;displayorder\u0026#34;: 6, \u0026#34;subtitle\u0026#34;: \u0026#34;solr\u0026#34;, \u0026#34;type\u0026#34;: 6, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:57:44.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:57:44.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 56, \u0026#34;title\u0026#34;: \u0026#34;activemq的作用以及原理\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;activemq 的作用就是系统之间进行通信。 当然可以使用其他方式进行系统间通信， 如果使用 activemq 的话可以对系统之间的调用进行解耦， 实现系统间的异步通信。 原理就是生产者生产消息， 把消息发送给activemq。 activemq 接收到消息， 然后查看有多少个消费者， 然后把消息转发给消费者， 此过程中生产者无需参与。 消费者接收到消息后做相应的处理和生产者没有任何关系\u0026#34;, \u0026#34;level\u0026#34;: 4, \u0026#34;displayorder\u0026#34;: 7, \u0026#34;subtitle\u0026#34;: \u0026#34;activemq\u0026#34;, \u0026#34;type\u0026#34;: 7, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:58:30.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:58:30.000+00:00\u0026#34; }, { \u0026#34;id\u0026#34;: 57, \u0026#34;title\u0026#34;: \u0026#34;什么是 freemarker\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;freemarker 是一个用 java 语言编写的模板引擎，它基于模板来生成文本输出。\\nfreemarker与 web 容器无关，即在 web 运行时，它并不知道 servlet 或 http。\\n它不仅可以用作表现层的实现技术，而且还可以用于生成 xml，jsp 或 java 等。\u0026#34;, \u0026#34;level\u0026#34;: 3, \u0026#34;displayorder\u0026#34;: 7, \u0026#34;subtitle\u0026#34;: \u0026#34; freemarker\u0026#34;, \u0026#34;type\u0026#34;: 7, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18t11:59:01.000+00:00\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:59:01.000+00:00\u0026#34; } ] } } 7.7、获取试题详情 \u0026lt;a id=获取试题详情\u0026gt; \u0026lt;/a\u0026gt;\n基本信息 path： /question/question/info/{id}\nmethod： get\n接口描述：\nrequest 路径参数\n参数名称 示例 备注 id 1 题目id reponse { \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;code\u0026#34;: 0, \u0026#34;question\u0026#34;: { \u0026#34;id\u0026#34;: 50, \u0026#34;title\u0026#34;: \u0026#34;请介绍一下springsecurity是做什么的？\u0026#34;, \u0026#34;answer\u0026#34;: \u0026#34;springsecurity是一个能够为基于spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在spring应用上下文中配置的bean，充分利用了spring ioc，di（控制反转inversion of control ,di:dependency injection 依赖注入）和aop（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。\u0026#34;, \u0026#34;level\u0026#34;: 3, \u0026#34;displayorder\u0026#34;: 1, \u0026#34;subtitle\u0026#34;: \u0026#34;springsecurity\u0026#34;, \u0026#34;type\u0026#34;: 6, \u0026#34;enable\u0026#34;: 1, \u0026#34;delflag\u0026#34;: 0, \u0026#34;createtime\u0026#34;: \u0026#34;2020-12-18 11:54:36\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2020-12-18t11:54:36.000+00:00\u0026#34; } } 具体参见线上接口文档\nhttps://www.25xt.com/html5css3/16782.html\nhttps://mock.yonyoucloud.com/ 账号:hk109@126.com 密码：offcn123\n","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project/20220528234610/","summary":"第五章 优学题库项目开发3 优就业.JAVA教研室 学习目标 掌握OSS云存储、账号开通、上传测试 掌握图片上传到OSS云存储 掌握开发广告内容前端维护功能 掌握开发用户管理","title":"tk-题库项目开发3"},{"content":"第十七章 分布式事务 优就业.java教研室 学习目标 理解什么是事务\n理解什么是分布式事务\n理解cap定理\n理解相关的分布式事务解决方案\n理解seata工作流程\n能实现seata案例\n作业：实现项目中分布式事务控制-下单-\u0026gt;用户微服务（增加积分）-\u0026gt;goods微服务(库存递减)\n一 分布式事务介绍 1.1 什么是事务 数据库事务(简称：事务，transaction)是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成[由当前业务逻辑多个不同操作构成]。\n事务拥有以下四个特性，习惯上被称为acid特性：\n1. 原子性(atomicity)：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n2. 一致性(consistency)：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到(这层语义也有说应该属于原子性)。\n3. 隔离性(isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。\n​\t全局修改，修改mysql.ini配置文件，在最后加上\n1 可选参数有：read-uncommitted, read-committed, repeatable-read, serializable. 2 [mysqld] 3 transaction-isolation = repeatable-read\t这里全局默认是repeatable-read,其实mysql本来默认也是这个级别。\n​\tread uncommitted (读取未提交内容)\n​\t等级是最低等级，也可以认为，事务之间完全不隔离\n​\teg. 事务a开始一个事务，接着事务b开始，事务b对数据c继续update，这时候，a读取了b未提交（commit）的数据，这种情况叫做脏读（dirty read）。这个时候要是事务b遇到错误必须rollback，那么a读取的数据就完全是错的。\n​\tread committed (读取提交内容)\n​\t事务读取的数据，都是别的事务已经提交了的\n​\teg. 事务a select了一条数据，接着事务b update 这条数据，然后commit，这时候a还未提交，a再回来读这条数据，发现数据居然变了\n​\trepeatable (可重读)\n​ 保证不会在一个事务内两次select同一条数据会出现变化，即是别的事务对你select的对象进行update操作不会影响。但是，如果是insert操作，在这个隔离级别还是会受到影响。\n​\teg. 事务a开启事务，并select一段有范围的数据，然后事务b开启事务，在先前a事务select的那段有范围的数据中insert一条数据，然后提交事务，接着事务a再select出来这段数据，发现数据多了一条，这种情况叫幻读（phantom read）\n​\tserializable (可串行化)\n​\t保证事务之间不会有任何踩踏，每个事务都可以认为只有它自己在操作数据库。\n4. 持久性(durability)：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。\n1.2 本地事务 起初，事务仅限于对单一数据库资源的访问控制,架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源,这类基于单个服务单一数据库资源访问的事务，被称为本地事务(local transaction)。 1.2.1 原子性和持久性都要通过undo和redo日志来实现 在数据库系统中，既有存放数据的文件，也有存放日志的文件。日志在内存中也是有缓存log buffer，也有磁盘文件log file。\nmysql中的日志文件，有这么两种与事务有关：undo日志与redo日志。\n1. undo日志 数据库事务具备原子性（atomicity），如果事务执行失败，需要把数据回滚。\n事务同时还具备持久性**(durability)**，事务对数据所做的变更就完全保存在了数据库，不能因为故障而丢失。\n原子性可以利用undo日志来实现。\nundo log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到undo log。然后进行数据的修改。如果出现了错误或者用户执行了rollback语句，系统可以利用undo log中的备份将数据恢复到事务开始之前的状态。\n数据库写入数据到磁盘之前，会把数据先缓存在内存中，事务提交时才会写入磁盘中。\n用undo log实现原子性和持久化的事务的简化过程：\n假设有a、b两个数据，值分别为1,2。\n​\ta. 事务开始.\n​\tb. 记录a=1到undo log.\n​\tc. 修改a=3. (内存)\n​\td. 记录b=2到undo log.\n​\te. 修改b=4. (内存)\n​\tf. 将undo log写到磁盘。\n​\tg. 将数据写到磁盘。\n​\th. 事务提交。\n如何保证持久性？ 事务提交前，会把修改数据到磁盘前，也就是说只要事务提交了，数据肯定持久化了。\n如何保证原子性? - 每次对数据库修改，都会把修改前数据记录在undo log，那么需要回滚时，可以读取undo log，恢复数据。\n- 若系统在g和h之间崩溃\n此时事务并未提交，需要回滚。而undo log已经被持久化，可以根据undo log来恢复数据\n- 若系统在g之前崩溃\n此时数据并未持久化到硬盘，依然保持在事务之前的状态\n缺陷：每个事务提交前将数据和undo log写入磁盘，这样会导致大量的磁盘io，因此性能很低。\n如果能够将数据缓存一段时间，就能减少io提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即redo log.\n2. redo日志 和undo log相反，redo log记录的是新数据的备份。在事务提交前，只要将redo log持久化即可，不需要将数据持久化，减少了io的次数。\n先来看下基本原理：\nundo + redo事务的简化过程\n假设有a、b两个数据，值分别为1,2\n​\ta. 事务开始.\n​\tb. 记录a=1到undo log buffer.\n​\tc. 修改a=3.\n​\td. 记录a=3到redo log buffer.\n​\te. 记录b=2到undo log buffer.\n​\tf. 修改b=4.\n​\tg. 记录b=4到redo log buffer.\n​\th. 将undo log写入磁盘 (写入redo log,既有原始数据，也有修改之后的数据)\n​\ti. 将redo log写入磁盘 (顺序写)\n​\tj. 事务提交\n随机写：写入数据是随机写。需要 寻址，在完成写入。寻址比写入花费更多的时间。\n顺序写：写入redo是顺序写，开辟一个连续的空间。不需要寻址。效率高。\n安全和性能问题 如何保证原子性？\n如果在事务提交前故障，通过undo log日志恢复数据。如果undo log都还没写入，那么数据就尚未持久化，无需回滚\n1.3 什么是分布式事务 分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上,且属于不同的应用，分布式事务需要保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。\n1.4 分布式事务应用架构 本地事务主要限制在单个会话内，不涉及多个数据库资源。但是在基于soa(service-oriented architecture，面向服务架构)的分布式应用环境下，越来越多的应用要求对多个数据库资源，多个服务的访问都能纳入到同一个事务当中，分布式事务应运而生。\n1.4.1 单一服务分布式事务 最早的分布式事务应用架构很简单，不涉及服务间的访问调用，仅仅是服务内操作涉及到对多个数据库资源的访问。 1.4.2 多服务分布式事务 当一个服务操作访问不同的数据库资源，又希望对它们的访问具有事务特性时，就需要采用分布式事务来协调所有的事务参与者。\n对于上面介绍的分布式事务应用架构，尽管一个服务操作会访问多个数据库资源，但是毕竟整个事务还是控制在单一服务的内部。如果一个服务操作需要调用另外一个服务，这时的事务就需要跨越多个服务了。在这种情况下，起始于某个服务的事务在调用另外一个服务的时候，需要以某种机制流转到另外一个服务，从而使被调用的服务访问的资源也自动加入到该事务当中来。下图反映了这样一个跨越多个服务的分布式事务： 1.4.3 多服务多数据源分布式事务 如果将上面这两种场景(一个服务可以调用多个数据库资源，也可以调用其他服务)结合在一起，对此进行延伸，整个分布式事务的参与者将会组成如下图所示的树形拓扑结构。在一个跨服务的分布式事务中，事务的发起者和提交均系同一个，它可以是整个调用的客户端，也可以是客户端最先调用的那个服务。 较之基于单一数据库资源访问的本地事务，分布式事务的应用架构更为复杂。在不同的分布式应用架构下，实现一个分布式事务要考虑的问题并不完全一样，比如对多资源的协调、事务的跨服务传播等，实现机制也是复杂多变。\n事务的作用：\n保证每个事务的数据一致性。 1.5 cap定理 cap 定理，又被叫作布鲁尔定理。对于设计分布式系统(不仅仅是分布式事务)的架构师来说，cap 就是你的入门理论。\n**c (一致性)：**对某个指定的客户端来说，读操作能返回最新的写操作。\n对于数据分布在不同节点上的数据来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。\n**a (可用性)：**非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。\n合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回 50，而不是返回 40。\n**p (分区容错性)：**当出现网络分区后，系统能够继续工作。打个比方，这里集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。\n熟悉 cap 的人都知道，三者不能共有，如果感兴趣可以搜索 cap 的证明，在分布式系统中，网络无法 100% 可靠，分区其实是一个必然现象。\n如果我们选择了 ca 而放弃了 p，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是 a 又不允许，所以分布式系统理论上不可能选择 ca 架构，只能选择 cp 或者 ap 架构。\n对于 cp 来说，放弃可用性，追求一致性和分区容错性，我们的 zookeeper 其实就是追求的强一致。\n对于 ap 来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性 eureka，这是很多分布式系统设计时的选择，后面的 base 也是根据 ap 来扩展。\n顺便一提，cap 理论中是忽略网络延迟，也就是当事务提交时，从节点 a 复制到节点 b 没有延迟，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。\n同时 cap 中选择两个，比如你选择了 cp，并不是叫你放弃 a。因为 p 出现的概率实在是太小了，大部分的时间你仍然需要保证 ca。\n就算分区出现了你也要为后来的 a 做准备，比如通过一些日志的手段，是其他机器回复至可用。\n在现有的技术方案中，注册中心主要分为两类，一类是cp类注册中心，另一类是ap类注册中心。在一个分布式系统中，consistency（一致性）、availability（可用性）、partition tolerance（分区容错性）无法同时满足，正所谓“鱼和熊掌与虾不可兼得也”。\ncp类注册中心更强调一致性，而ap类注册中心更强调可用性。\n1 eureka ap eureka 保证了可用性，实现最终一致性。\neureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而eureka的客户端在向某个eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)，其中说明了，eureka是不满足强一致性，但还是会保证最终一致性。\n2 zookeeper cp zookeeper在选举leader时，会停止服务，直到选举成功之后才会再次对外提供服务，这个时候就说明了服务不可用，但是在选举成功之后，因为一主多从的结构，zookeeper在这时还是一个高可用注册中心，只是在优先保证一致性的前提下，zookeeper才会顾及到可用性。\n二 分布式事务解决方案 1.xa两段提交(低效率)-21 xa jta分布式事务解决方案\n2.tcc三段提交(2段,高效率[不推荐(补偿代码)])\n3.本地消息(mq+table)\n4.事务消息(rocketmq[alibaba])\n5.seata(alibaba)\n2.1 基于xa协议的两阶段提交(2pc) 两阶段提交协议(two phase commitment protocol)中，涉及到两种角色\n==一个事务协调者==（coordinator）：负责协调多个参与者进行事务投票及提交(回滚) 多个==事务参与者==（participants）：即本地事务执行者\n总共处理步骤有两个 （1）投票阶段（voting phase）：协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功，但未提交）或取消（本地事务执行故障）； （2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；\n如果所示 1-2为第一阶段，2-3为第二阶段 如果任一资源管理器在第一阶段返回准备失败，那么事务管理器会要求所有资源管理器在第二阶段执行回滚操作。通过事务管理器的两阶段协调，最终所有资源管理器要么全部提交，要么全部回滚，最终状态都是一致的\n优点： 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。\n缺点： 牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .net 界还没有实现方案。\n1. 单点故障问题：如果事务管理器挂了，就会失败。 2. 阻塞问题：在准备阶段和提交阶段，每个事务参与者都会锁定本地资源，并等待其他事务的执行结果，阻塞时间较长，资源锁定时间太久，执行效率比较低。 2.2 补偿事务（tcc）3pc tcc 将事务提交分为 try(method1) - confirm(method2) - cancel(method3) 3个操作。其和两阶段提交有点类似，try为第一阶段，confirm - cancel为第二阶段，是一种应用层面侵入业务的两阶段提交。\n操作方法 含义 try 预留业务资源/数据效验 confirm 确认执行业务操作，实际提交数据，不做任何业务检查，try成功，confirm必定成功，需保证幂等 cancel 取消执行业务操作，实际回滚数据，需保证幂等 其核心在于将业务分为两个操作步骤完成。不依赖 rm 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。\n例如： a要向 b 转账，思路大概是：\n我们有一个本地方法，里面依次调用 1、首先在 try 阶段，要先调用远程接口把 b和 a的钱给冻结起来。 2、在 confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。 3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (cancel)。 假设用户user表中有两个字段：可用余额(available_money)、冻结余额(frozen_money) a扣钱对应服务a(servicea) b加钱对应服务b(serviceb) 转账订单服务(orderservice) 业务转账方法服务(businessservice) servicea，serviceb，orderservice都需分别实现try()，confirm()，cancle()方法，方法对应业务逻辑如下\n操作方法 servicea serviceb orderservice try() 校验余额(并发控制)冻结余额+1000余额-1000 冻结余额+1000 创建转账订单，状态待转账 confirm() 冻结余额-1000 状态变为转账成功 cancle() 冻结余额-1000余额+1000 状态变为转账失败 其中业务调用方businessservice中就需要调用 servicea.try() serviceb.try() orderservice.try()\n1、当所有try()方法均执行成功时，对全局事物进行提交，即由事物管理器调用每个微服务的confirm()方法\n2、 当任意一个方法try()失败(预留资源不足，抑或网络异常，代码异常等任何异常)，由事物管理器调用每个微服务的cancle()方法对全局事务进行回滚\n优点： 每个极端都会提交本地事务并释放锁，并不需要等待其他事务的执行结果。而如果其他事务执行失败，最后不是回滚，而是执行补偿操作。这样就避免了资源的长期锁定和阻塞等待，执行效率比较高，属于性能比较好的分布式事务方式。\n缺点：\n代码侵入： 需要人为编写代码实现 try, confirm, cancel, 代码侵入较多 开发成本高，一个业务需要拆分为3个阶段，分别编写业务实现，业务编写比较复杂 安全性考虑： cancel动作如果执行失败，资源就无法释放，需要引入重试机制，而重试可能导致重复执行，还要考虑重试的幂等问题。 2.3 本地消息表（异步确保） 本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。我们可以从下面的流程图中看出其中的一些细节： 基本思路就是：\n消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过mq发送到消息的消费方。如果消息发送失败，会进行重试发送。\n消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。\n生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。\n这种方案遵循base理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2pc那样复杂的实现(当调用链很长的时候，2pc的可用性是非常低的)，也不会像tcc那样可能出现确认或者回滚不了的情况。\n优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .net中 有现成的解决方案。\n缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。\n2.4 mq 事务消息（了解） 有一些第三方的mq是支持事务消息的，比如rocketmq，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的mq都是不支持事务消息的，比如 rabbitmq 和 kafka 都不支持。\n以阿里的 rocketmq 中间件为例，其思路大致为：\n第一阶段prepared消息，会拿到消息的地址。 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。\n也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了rocketmq会定期扫描消息集群中的事务消息，这时候发现了prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，rocketmq会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。 优点： 实现了最终一致性，不需要依赖本地数据库事务。\n缺点： 目前主流mq中只有rocketmq支持事务消息。\n2.5 seata 2pc-\u0026gt;改进 2019 年 1 月，阿里巴巴中间件团队发起了开源项目 fescar（fast \u0026amp; easy commit and rollback），和社区一起共建开源分布式事务解决方案。fescar 的愿景是让分布式事务的使用像本地事务的使用一样，简单和高效，并逐步解决开发者们遇到的分布式事务方面的所有难题。\nfescar 开源后，蚂蚁金服加入 fescar 社区参与共建，并在 fescar 0.4.0 版本中贡献了 tcc 模式。\n为了打造更中立、更开放、生态更加丰富的分布式事务开源社区，经过社区核心成员的投票，大家决定对 fescar 进行品牌升级，并更名为 seata，意为：simple extensible autonomous transaction architecture，是一套一站式分布式事务解决方案。\nseata 融合了阿里巴巴和蚂蚁金服在分布式事务技术上的积累，并沉淀了新零售、云计算和新金融等场景下丰富的实践经验。\n2.5.1 seata介绍 解决分布式事务问题，有两个设计初衷\n对业务无侵入：即减少技术架构上的微服务化所带来的分布式事务问题对业务的侵入 高性能：减少分布式事务解决方案所带来的性能消耗\nseata中有两种分布式事务实现方案，at及tcc\nat模式主要关注多 db 访问的数据一致性，当然也包括多服务下的多 db 数据访问一致性问题\ntcc 模式主要关注业务拆分，在按照业务横向扩展资源时，解决微服务间调用的一致性问题\n2.5.2 at模式 seata at模式是基于xa事务演进而来的一个分布式事务中间件，xa是一个基于数据库实现的分布式事务协议，本质上和两阶段提交一样，需要数据库支持，mysql5.6以上版本支持xa协议，其他数据库如oracle，db2也实现了xa接口 解释：\ntransaction coordinator (tc)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。 transaction manager（tm）： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。 resource manager (rm)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。\n协调执行流程如下： branch就是指的分布式事务中每个独立的本地局部事务。\n第一阶段\nseata 的 jdbc 数据源代理通过对业务 sql 的解析，把业务数据在更新前后的数据镜像组织成回滚日志，利用 本地事务 的 acid 特性，将业务数据的更新和回滚日志的写入在同一个 本地事务 中提交。\ncreate table `undo_log` ( `id` bigint(20) not null auto_increment, `branch_id` bigint(20) not null, `xid` varchar(100) not null, `rollback_info` longblob not null, `log_status` int(11) not null, `log_created` datetime not null, `log_modified` datetime not null, `ext` varchar(100) default null, primary key (`id`), key `idx_unionkey` (`xid`,`branch_id`) ) engine=innodb auto_increment=200 default charset=utf8; 这样，可以保证：任何提交的业务数据的更新一定有相应的回滚日志存在 基于这样的机制，分支的本地事务便可以在全局事务的第一阶段提交，并马上释放本地事务锁定的资源\n这也是seata和xa事务的不同之处，两阶段提交往往对资源的锁定需要持续到第二阶段实际的提交或者回滚操作，而有了回滚日志之后，可以在第一阶段释放对资源的锁定，降低了锁范围，提高效率，即使第二阶段发生异常需要回滚，只需找对undolog中对应数据并反解析成sql来达到回滚目的\n同时seata通过代理数据源将业务sql的执行解析成undolog来与业务数据的更新同时入库，达到了对业务无侵入的效果。\n第二阶段\n如果决议是全局提交，此时分支事务此时已经完成提交，不需要同步协调处理（只需要异步清理回滚日志），phase2 可以非常快速地完成. 如果决议是全局回滚，rm 收到协调器发来的回滚请求，通过 xid 和 branch id 找到相应的回滚日志记录，通过回滚记录生成反向的更新 sql 并执行，以完成分支的回滚 2.5.3 tcc模式 seata也针对tcc做了适配兼容，支持tcc事务方案，原理前面已经介绍过，基本思路就是使用侵入业务上的补偿及事务管理器的协调来达到全局事务的一起提交及回滚。 三 seata案例 3.1 需求分析 完成一个案例，用户下单的时候记录下单日志，完成订单添加，完成用户账户扣款，完成商品库存削减功能，稍后在任何一个微服务中制造异常，测试分布式事务。\n先将seata\\案例sql脚本数据库脚本导入到数据库中。 3.2 案例实现 3.2.1 父工程 搭建fescar-parent,为了适应东易买工程的分布式事务，我们这里的父工程引入和东易买工程一样的依赖包。\npom.xml依赖如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2.7.release\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!--跳过测试--\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;skiptests\u0026gt;true\u0026lt;/skiptests\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!--依赖包--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--测试包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--fastjson--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fastjson\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.51\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--web起步依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;hoxton.release\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; \u0026lt;/project\u0026gt; 3.2.2 公共工程 将所有数据库对应的pojo/feign抽取出一个公共工程fescar-api,在该工程中导入依赖:\npom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;fescar-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;description\u0026gt; api:model和feign \u0026lt;/description\u0026gt; \u0026lt;artifactid\u0026gt;fescar-api\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--openfeign--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatisplus --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql数据库驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.45\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 将pojo导入到工程中 3.2.3 商品微服务 创建fescar-item微服务，在该工程中实现库存削减。\n(1)pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;fescar-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;fescar-item\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; (2)dao\n创建com.offcn.dao.iteminfomapper,代码如下：\npublic interface iteminfomapper extends basemapper\u0026lt;iteminfo\u0026gt; { } (3)service\n创建com.offcn.service.iteminfoservice接口，并创建库存递减方法，代码如下：\npublic interface iteminfoservice { /** * 库存递减 * @param id * @param count */ void decrcount(int id, int count); } 创建com.offcn.service.impl.iteminfoserviceimpl实现库存递减操作，代码如下：\n@service @transactional(rollbackfor = exception.class) public class iteminfoserviceimpl implements iteminfoservice { @autowired private iteminfomapper iteminfomapper; /*** * 库存递减 * @param id * @param count */ @override public void decrcount(int id, int count) { //查询商品信息 iteminfo iteminfo = iteminfomapper.selectbyid(id); iteminfo.setcount(iteminfo.getcount()-count); int dcount = iteminfomapper.updatebyid(iteminfo); system.out.println(\u0026#34;库存递减受影响行数：\u0026#34;+dcount); } } (4)controller\n创建com.offcn.controller.iteminfocontroller，代码如下：\n@restcontroller @requestmapping(\u0026#34;/iteminfo\u0026#34;) @crossorigin public class iteminfocontroller { @autowired private iteminfoservice iteminfoservice; /** * 库存递减 * @param id * @param count * @return */ @postmapping(value = \u0026#34;/decrcount\u0026#34;) public string decrcount(@requestparam(value = \u0026#34;id\u0026#34;) int id, @requestparam(value = \u0026#34;count\u0026#34;) int count){ //库存递减 iteminfoservice.decrcount(id,count); return \u0026#34;success\u0026#34;; } } (5)启动类\n创建com.offcn.itemapplication代码如下：\n@springbootapplication @enableeurekaclient @enablefeignclients(basepackages = {\u0026#34;com.offcn.feign\u0026#34;}) @mapperscan(basepackages = {\u0026#34;com.offcn.dao\u0026#34;}) public class itemapplication { public static void main(string[] args) { springapplication.run(itemapplication.class,args); } } (6)application.yml\n创建applicatin.yml,配置如下：\nserver: port: 9001 spring: application: name: item datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/fescar-item?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=utc username: root password: 123456 main: allow-bean-definition-overriding: true eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true #hystrix 配置 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore 3.2.4 用户微服务 创建fescar-user微服务，并引入公共工程依赖。\n(1)pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;fescar-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;fescar-user\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/project\u0026gt; (2)dao\n创建com.offcn.dao.userinfomapper，代码如下：\npublic interface userinfomapper extends basemapper\u0026lt;userinfo\u0026gt; { } (3)service\n创建com.offcn.service.userinfoservice接口，代码如下：\npublic interface userinfoservice { /*** * 账户金额递减 * @param username * @param money */ void decrmoney(string username, int money); } 创建com.offcn.service.impl.userinfoserviceimpl实现用户账户扣款，代码如下：\n@service @transactional(rollbackfor = exception.class) public class userinfoserviceimpl implements userinfoservice { @autowired private userinfomapper userinfomapper; /*** * 账户金额递减 * @param username * @param money */ @override public void decrmoney(string username, int money) { userinfo userinfo = userinfomapper.selectbyid(username); userinfo.setmoney(userinfo.getmoney()-money); int count = userinfomapper.updatebyid(userinfo); system.out.println(\u0026#34;添加用户受影响行数：\u0026#34;+count); //int q=10/0; } } (4)controller\n创建com.offcn.controller.userinfocontroller代码如下：\n@restcontroller @requestmapping(\u0026#34;/userinfo\u0026#34;) @crossorigin public class userinfocontroller { @autowired private userinfoservice userinfoservice; /*** * 账户余额递减 * @param username * @param money */ @postmapping(value = \u0026#34;/add\u0026#34;) public string decrmoney(@requestparam(value = \u0026#34;username\u0026#34;) string username, @requestparam(value = \u0026#34;money\u0026#34;) int money){ userinfoservice.decrmoney(username,money); return \u0026#34;success\u0026#34;; } } (5)启动类\n创建com.offcn.userapplication，代码如下：\n@springbootapplication @enableeurekaclient @enablefeignclients(basepackages = {\u0026#34;com.offcn.feign\u0026#34;}) @mapperscan(basepackages = {\u0026#34;com.offcn.dao\u0026#34;}) public class userapplication { public static void main(string[] args) { springapplication.run(userapplication.class,args); } } (6)application.yml\n创建application.yml配置如下：\nserver: port: 9002 spring: application: name: user datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/fescar-item?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=utc username: root password: 123456 main: allow-bean-definition-overriding: true eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true #hystrix 配置 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore 3.2.5 订单微服务 在订单微服务中实现调用商品微服务递减库存。\n(1)pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;fescar-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;fescar-order\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; (2)dao\n创建com.offcn.dao.orderinfomapper，代码如下：\npublic interface orderinfomapper extends basemapper\u0026lt;orderinfo\u0026gt; { } (3)service\n创建com.offcn.service.orderinfoservice实现添加订单操作，代码如下：\npublic interface orderinfoservice { /*** * 添加订单 * @param username * @param id * @param count */ void add(string username, int id, int count); } 创建com.offcn.service.impl.orderinfoserviceimpl，代码如下：\n@service public class orderinfoserviceimpl implements orderinfoservice { @autowired private orderinfomapper orderinfomapper; @autowired private iteminfofeign iteminfofeign; /*** * 添加订单 * @param username * @param id * @param count */ @override public void add(string username, int id, int count) { //添加订单 orderinfo orderinfo = new orderinfo(); orderinfo.setmessage(\u0026#34;生成订单\u0026#34;); orderinfo.setmoney(10); int icount = orderinfomapper.insert(orderinfo); system.out.println(\u0026#34;添加订单受影响函数：\u0026#34;+icount); //递减库存 iteminfofeign.decrcount(id,count); } } (3)controller\n创建com.offcn.controller.orderinfocontroller调用下单操作，代码如下：\n@restcontroller @requestmapping(\u0026#34;/orderinfo\u0026#34;) @crossorigin public class orderinfocontroller { @autowired private orderinfoservice orderinfoservice; /** * 增加订单 * @param username * @param id * @param count */ @postmapping(value = \u0026#34;/add\u0026#34;) public string add(@requestparam(value = \u0026#34;name\u0026#34;) string username, @requestparam(value = \u0026#34;id\u0026#34;) int id, @requestparam(value = \u0026#34;count\u0026#34;) int count){ //添加订单 orderinfoservice.add(username,id,count); return \u0026#34;success\u0026#34;; } } (4)启动类\n创建com.offcn.orderapplication启动类，代码如下：\n@springbootapplication @enableeurekaclient @enablefeignclients(basepackages = {\u0026#34;com.offcn.feign\u0026#34;}) @mapperscan(basepackages = {\u0026#34;com.offcn.dao\u0026#34;}) public class orderapplication { public static void main(string[] args) { springapplication.run(orderapplication.class,args); } } (5)application.yml配置\nserver: port: 9003 spring: application: name: order datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/fescar-item?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=utc username: root password: 123456 main: allow-bean-definition-overriding: true eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true #hystrix 配置 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore 3.2.6 业务微服务 创建fescar-business业务微服务，在该微服务中实现分布式事务控制，下单入口从这里开始。\n（1）pom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;fescar-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;description\u0026gt;分布式事务业务控制\u0026lt;/description\u0026gt; \u0026lt;artifactid\u0026gt;fescar-business\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; (2)dao\n创建com.offcn.dao.loginfomapper代码如下：\npublic interface loginfomapper extends basemapper\u0026lt;loginfo\u0026gt; { } (3)service\n创建com.offcn.service.businessservice接口，代码如下：\npublic interface businessservice { /** * 下单 * @param username * @param id * @param count */ void add(string username, int id, int count); } 创建com.offcn.service.impl.businessserviceimpl，代码如下：\n@service public class businessserviceimpl implements businessservice { @autowired private orderinfofeign orderinfofeign; @autowired private userinfofeign userinfofeign; @autowired private loginfomapper loginfomapper; /*** * 下单 * @param username * @param id * @param count */ @override public void add(string username, int id, int count) { //添加订单日志 loginfo loginfo = new loginfo(); loginfo.setcontent(\u0026#34;添加订单数据---\u0026#34;+new date()); loginfo.setcreatetime(new date()); int logcount = loginfomapper.insert(loginfo); system.out.println(\u0026#34;添加日志受影响行数：\u0026#34;+logcount); //添加订单 orderinfofeign.add(username,id,count); //用户账户余额递减 userinfofeign.decrmoney(username,10); } } (4)controller\n创建com.offcn.controller.businesscontroller，代码如下：\n@restcontroller @requestmapping(value = \u0026#34;/business\u0026#34;) public class businesscontroller { @autowired private businessservice businessservice; /*** * 购买商品分布式事务测试 * @return */ @requestmapping(value = \u0026#34;/addorder\u0026#34;) public string order(){ string username=\u0026#34;zhangsan\u0026#34;; int id=1; int count=5; //下单 businessservice.add(username,id,count); return \u0026#34;success\u0026#34;; } } (5)启动类\n创建启动类com.offcn.businessapplication，代码如下：\n@springbootapplication @enableeurekaclient @enablefeignclients(basepackages = {\u0026#34;com.offcn.feign\u0026#34;}) @mapperscan(basepackages = {\u0026#34;com.offcn.dao\u0026#34;}) public class businessapplication { public static void main(string[] args) { springapplication.run(businessapplication.class,args); } } (6)application.yml配置\nserver: port: 9004 spring: application: name: business datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/fescar-item?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=utc username: root password: 123456 main: allow-bean-definition-overriding: true eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true #读取超时设置 ribbon: readtimeout: 30000 #hystrix 配置 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore 测试调用:\nhttp://localhost:9004/business/addorder\n查看各个微服务，控制台输出。\n3.3 分布式事务抽取 上面案例，并没有实现分布式事务，在我们以后工作中，也并非每个服务都需要实现分布式事务，我们可以将分布式事务抽取出来。\n3.3.1 分布式事务工程抽取搭建 创建fescar-transaction微服务工程，在该工程中实现分布式事务控制。\n(1)pom.xml依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;fescar-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;description\u0026gt;fescar分布式事务微服务\u0026lt;/description\u0026gt; \u0026lt;artifactid\u0026gt;fescar-transaction\u0026lt;/artifactid\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;fescar.version\u0026gt;0.4.2\u0026lt;/fescar.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--fescar依赖包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.fescar\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-tm\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${fescar.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.fescar\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-spring\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${fescar.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; (2)资源文件导入\n将seata\\资源包中的文件导入到该工程中。 相关概念讲解\nxid：全局事务的唯一标识，由 ip:port:sequence 组成； transaction coordinator (tc)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚； transaction manager (tm )：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议； resource manager (rm)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚； fescar 使用 xid 表示一个分布式事务，xid 需要在一次分布式事务请求所涉的系统中进行传递，从而向 feacar-server 发送分支事务的处理情况，以及接收 feacar-server 的 commit、rollback 指令。 3.3.2 配置讲解 fescar 的配置入口文件是 registry.conf, 查看代码 configurationfactory 得知目前还不能指定该配置文件，所以配置文件名称只能为 registry.conf。\n在 registry 中可以指定具体配置的形式，默认使用 file 类型，在 file.conf 中有 3 部分配置内容：\ntransport transport :用于定义 netty 相关的参数，tm、rm 与 fescar-server 之间使用 netty 进行通信。\nservice:\nservice { #vgroup-\u0026gt;rgroup vgroup_mapping.my_test_tx_group = \u0026#34;default\u0026#34; #only support single node 配置client连接tc的地址 default.grouplist = \u0026#34;127.0.0.1:8091\u0026#34; #degrade current not support enabledegrade = false #disable disable = false #是否启用seata分布式事务 disableglobaltransaction = false } client:\nclient { #rm接收tc的commit通知缓冲上限 async.commit.buffer.limit = 10000 lock { retry.internal = 10 retry.times = 30 } fescar 在 at 模式下需要创建数据库代理.在com.offcn.fescar.fescarautoconfiguration中代码如下：\n/*** * 创建代理数据库 * 会将und_log绑定到本地事务中 * @param environment * @return */ @bean public datasource datasource(environment environment){ //创建数据源对象 druiddatasource datasource = new druiddatasource(); //获取数据源链接地址 datasource.seturl(environment.getproperty(\u0026#34;spring.datasource.url\u0026#34;)); try { //设置数据库驱动 datasource.setdriver(drivermanager.getdriver(environment.getproperty(\u0026#34;spring.datasource.url\u0026#34;))); } catch (sqlexception e) { throw new runtimeexception(\u0026#34;无法识别驱动类型\u0026#34;); } //获取数据库名字 datasource.setusername(environment.getproperty(\u0026#34;spring.datasource.username\u0026#34;)); //获取数据库密码 datasource.setpassword(environment.getproperty(\u0026#34;spring.datasource.password\u0026#34;)); //将数据库封装成一个代理数据库 return new datasourceproxy(datasource); } /*** * 全局事务扫描器 * 用来解析带有@globaltransactional注解的方法，然后采用aop的机制控制事务 * @param environment * @return */ @bean public globaltransactionscanner globaltransactionscanner(environment environment){ //事务分组名称 string applicationname = environment.getproperty(\u0026#34;spring.application.name\u0026#34;); string groupname = environment.getproperty(\u0026#34;fescar.group.name\u0026#34;); if(applicationname == null){ return new globaltransactionscanner(groupname == null ? \u0026#34;my_test_tx_group\u0026#34; : groupname); }else{ return new globaltransactionscanner(applicationname, groupname == null ? \u0026#34;my_test_tx_group\u0026#34; : groupname); } } 使用 datasourceproxy 的目的是为了引入 connectionproxy ，fescar 无侵入的一方面就体现在 connectionproxy 的实现上，即分支事务加入全局事务的切入点是在本地事务的 commit 阶段，这样设计可以保证业务数据与 undo_log 是在一个本地事务中。\nundo_log 是需要在业务库上创建的一个表，fescar 依赖该表记录每笔分支事务的状态及二阶段 rollback 的回放数据。不用担心该表的数据量过大形成单点问题，在全局事务 commit 的场景下事务对应的 undo_log 会异步删除。\n所以在每个微服务对应的数据库中需要创建一张undo_log表。\ncreate table `undo_log` ( `id` bigint(20) not null auto_increment, `branch_id` bigint(20) not null, `xid` varchar(100) not null, `rollback_info` longblob not null, `log_status` int(11) not null, `log_created` datetime not null, `log_modified` datetime not null, `ext` varchar(100) default null, primary key (`id`), key `idx_unionkey` (`xid`,`branch_id`) ) engine=innodb auto_increment=1 default charset=utf8; 3.3.3 测试分布式事务 (1)添加依赖\n将上面所有工程都添加fescar-transaction的依赖。\n\u0026lt;!--分布式事务模块--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-transaction\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; (2)启动\n解压seata\\fescar-server-0.4.2.zip文件包，并点击bin\\fescar-server.bat启动seata的事务协调器。 (3)重新启动\n在业务微服务上添加@globaltransactional(name = \u0026quot;add\u0026quot;)注解，并重新启动其他微服务，测试测试数据正确。 3.3.4 测试分布式事务回滚 修改fescar-user模块的userinfoserviceimpl，模拟异常\n@service @transactional(rollbackfor = exception.class) public class userinfoserviceimpl implements userinfoservice { @autowired private userinfomapper userinfomapper; @override public void decrmoney(string username, int money) { //根据用户名获取用户信息 userinfo userinfo = userinfomapper.selectbyid(username); //扣减金额 userinfo.setmoney(userinfo.getmoney()-money); //更新保存扣减后的用户信息到数据库 int dcount = userinfomapper.updatebyid(userinfo); system.out.printf(\u0026#34;更新用户受影响行数:\u0026#34;+dcount); //模拟异常 int q=10/0; } } 重启user服务，再次测试，发现，订单、用户、日志数据都没有插入。\n注意：controller、service千万不能try catch处理异常，一定要抛出异常，要不然分布式事务不会生效。\n4 分布式事务实战(学员完成) 4.1 undolog表结构导入 核心在于对业务sql进行解析，转换成undolog,所以只要支持fescar分布式事务的微服务数据都需要导入该表结构，我们在每个微服务的数据库中都导入下面表结构：\ncreate table `undo_log` ( `id` bigint(20) not null auto_increment, `branch_id` bigint(20) not null, `xid` varchar(100) not null, `rollback_info` longblob not null, `log_status` int(11) not null, `log_created` datetime not null, `log_modified` datetime not null, `ext` varchar(100) default null, primary key (`id`), key `idx_unionkey` (`xid`,`branch_id`) ) engine=innodb auto_increment=200 default charset=utf8; 4.2 fescar工程搭建 在所有微服务工程中，不一定所有工程都需要使用分布式事务，我们可以创建一个独立的分布式事务工程，指定微服务需要支持分布式事务的时候，直接依赖独立的分布式工程即可。\n搭建一个dongyimai-transaction-fescar提供fescar分布式事务支持。\n4.2.1 pom.xml依赖 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai_transaction_fescar\u0026lt;/artifactid\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;fescar.version\u0026gt;0.4.2\u0026lt;/fescar.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai_common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.fescar\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-tm\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${fescar.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.fescar\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fescar-spring\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${fescar.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 4.2.2 引入配置 将fescar配置文件文件夹中的所有配置文件拷贝到resources工程下，如下图： 其中file.conf有2个配置 service.vgroup_mapping.my_test_tx_group 映射到相应的 fescar-server 集群名称，然后再根据集群名称.grouplist 获取到可用服务列表。\n4.3 tm和proxydatasource 核心在于对业务sql进行解析，转换成undolog，并同时入库，此时需要创建一个代理数据源，用代理数据源来实现。\n要想实现全局事务管理器，需要添加一个@globaltransactional注解,该注解需要创建一个解析器，globaltransactionscanner,它是一个全局事务扫描器，用来解析带有@globaltransactional注解的方法，然后采用aop的机制控制事务。\n每次微服务和微服务之间相互调用,要想控制全局事务，每次tm都会请求tc生成一个xid，每次执行下一个事务，也就是调用其他微服务的时候都需要将该xid传递过去,所以我们可以每次请求的时候，都获取头中的xid，并将xid传递到下一个微服务。\n4.3.1 tm和proxydatasource实现 创建fescarautoconfiguration类，代码如下：\n@configuration public class fescarautoconfiguration { public static final string fescar_xid = \u0026#34;fescarxid\u0026#34;; /*** * 创建代理数据库 * @param environment * @return */ @bean public datasource datasource(environment environment){ druiddatasource datasource = new druiddatasource(); datasource.seturl(environment.getproperty(\u0026#34;spring.datasource.url\u0026#34;)); try { datasource.setdriver(drivermanager.getdriver(environment.getproperty(\u0026#34;spring.datasource.url\u0026#34;))); } catch (sqlexception e) { throw new runtimeexception(\u0026#34;can\u0026#39;t recognize datasource driver\u0026#34;); } datasource.setusername(environment.getproperty(\u0026#34;spring.datasource.username\u0026#34;)); datasource.setpassword(environment.getproperty(\u0026#34;spring.datasource.password\u0026#34;)); return new datasourceproxy(datasource); } /*** * 全局事务扫描器 * 用来解析带有@globaltransactional注解的方法，然后采用aop的机制控制事务 * @param environment * @return */ @bean public globaltransactionscanner globaltransactionscanner(environment environment){ string applicationname = environment.getproperty(\u0026#34;spring.application.name\u0026#34;); string groupname = environment.getproperty(\u0026#34;fescar.group.name\u0026#34;); if(applicationname == null){ return new globaltransactionscanner(groupname == null ? \u0026#34;my_test_tx_group\u0026#34; : groupname); }else{ return new globaltransactionscanner(applicationname, groupname == null ? \u0026#34;my_test_tx_group\u0026#34; : groupname); } } /*** * 每次微服务和微服务之间相互调用 * 要想控制全局事务，每次tm都会请求tc生成一个xid，每次执行下一个事务，也就是调用其他微服务的时候都需要将该xid传递过去 * 所以我们可以每次请求的时候，都获取头中的xid，并将xid传递到下一个微服务 * @param resttemplates * @return */ @conditionalonbean({resttemplate.class}) @bean public object addfescarinterceptor(collection\u0026lt;resttemplate\u0026gt; resttemplates){ resttemplates.stream() .foreach(resttemplate -\u0026gt; { list\u0026lt;clienthttprequestinterceptor\u0026gt; interceptors = resttemplate.getinterceptors(); if(interceptors != null){ interceptors.add(fescarrestinterceptor()); } }); return new object(); } @bean public fescarrmrequestfilter fescarrmrequestfilter(){ return new fescarrmrequestfilter(); } @bean public fescarrestinterceptor fescarrestinterceptor(){ return new fescarrestinterceptor(); } } 注意：如果自定义fescar.group.name需要和file.conf中的名字保持一致。\n创建fescarrmrequestfilter，给每个线程绑定一个xid，代码如下;\npublic class fescarrmrequestfilter extends onceperrequestfilter { private static final logger logger = org.slf4j.loggerfactory.getlogger(fescarrmrequestfilter.class); /** * 给每次线程请求绑定一个xid * @param request * @param response * @param filterchain */ @override protected void dofilterinternal(httpservletrequest request, httpservletresponse response, filterchain filterchain) throws servletexception, ioexception { string currentxid = request.getheader(fescarautoconfiguration.fescar_xid); if(!stringutils.isempty(currentxid)){ rootcontext.bind(currentxid); logger.info(\u0026#34;当前线程绑定的xid :\u0026#34; + currentxid); } try{ filterchain.dofilter(request, response); } finally { string unbindxid = rootcontext.unbind(); if(unbindxid != null){ logger.info(\u0026#34;当前线程从指定xid中解绑 xid :\u0026#34; + unbindxid); if(!currentxid.equals(unbindxid)){ logger.info(\u0026#34;当前线程的xid发生变更\u0026#34;); } } if(currentxid != null){ logger.info(\u0026#34;当前线程的xid发生变更\u0026#34;); } } } } 创建fescarrestinterceptor过滤器，每次请求其他微服务的时候，都将xid携带过去。\npublic class fescarrestinterceptor implements requestinterceptor, clienthttprequestinterceptor { @override public void apply(requesttemplate requesttemplate) { string xid = rootcontext.getxid(); if(!stringutils.isempty(xid)){ requesttemplate.header(fescarautoconfiguration.fescar_xid, xid); } } @override public clienthttpresponse intercept(httprequest request, byte[] body, clienthttprequestexecution execution) throws ioexception { string xid = rootcontext.getxid(); if(!stringutils.isempty(xid)){ httpheaders headers = request.getheaders(); headers.put(fescarautoconfiguration.fescar_xid, collections.singletonlist(xid)); } return execution.execute(request, body); } } 4.4 分布式事务测试 4.4.1 微服务添加依赖 因为所有微服务都有可能使用分布式事务，所以我们可以在每个微服务工程中添加fescar的依赖，当然，搜索工程排除，因为它不需要依赖数据库，代码如下：\n\u0026lt;!--fescar依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-transaction-fescar\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 4.4.2 测试 在订单微服务的orderserviceimpl的add方法上增加@globaltransactional(name = \u0026ldquo;add\u0026rdquo;)注解\n在订单微服务的orderserviceimpl的add方法上增加@globaltransactional(name = \u0026ldquo;add\u0026rdquo;)注解，代码如下： 这里涉及到几个微服务的调用，我们先查询下数据库数据，然后再测试一次，如果输出添加订单完成和库存减少完毕则表明订单微服务和商品微服务的事务已经完成，这时候我们在添加积分的方法中制造一个异常，如果积分添加异常，而商品微服务中数据没发生变化，则表明分布式事务控制成功。\n修改用户微服务，在添加用户积分的地方制造异常，代码如下： 启动fescar-server，打开seata包/fescar-server-0.4.2/bin,双击fescar-server.bat启动fescar-server，如下： 测试前后结果一致\n","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project-0/20220528174166/","summary":"第十七章 分布式事务 优就业.JAVA教研室 学习目标 理解什么是事务 理解什么是分布式事务 理解CAP定理 理解相关的分布式事务解决方案 理解Seata工作流程 能实现Seat","title":"分布式事务"},{"content":"第十章 微服务网关和jwt令牌 优就业.java教研室 学习目标 掌握微服务网关的系统搭建\n了解什么是微服务网关以及它的作用\n掌握系统中心微服务的搭建\n掌握用户密码加密存储bcrypt\n了解jwt鉴权的介绍\n掌握jwt的鉴权的使用\n使用jwt令牌来存储用户登录信息，在微服务网关中识别登录信息(用户的身份)\n掌握网关使用jwt进行校验\n掌握网关限流\n1 微服务网关 1.1 微服务网关的概述 不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：\n客户端会多次请求不同的微服务，增加了客户端的复杂性 存在跨域请求，在一定场景下处理相对复杂 认证复杂，每个服务都需要独立认证 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施 某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定的困难 以上这些问题可以借助网关解决。\n网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过网关这一层。也就是说，api 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由网关来做，这样既提高业务灵活性又不缺安全性，典型的架构图如图所示： 优点如下：\n安全，只有网关系统对外进行暴露，微服务可以隐藏在内网，通过防火墙保护。 易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。 易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。 减少了客户端与各个微服务之间的交互次数 易于统一授权。 总结：微服务网关就是一个系统，通过暴露该微服务网关系统，方便我们进行相关的鉴权，安全控制，日志统一处理，易于监控的相关功能。\n1.2 微服务网关技术 实现微服务网关的技术有很多，\nnginx nginx (tengine x)是一个高性能的http和反向代理web服务器，同时也提供了imap/pop3/smtp服务 zuul ,zuul 是 netflix 出品的一个基于 jvm 路由和服务端的负载均衡器。 spring-cloud-gateway,是spring 出品的基于spring 的网关项目，集成断路器，路径重写，性能比zuul好。 我们使用gateway这个网关技术，无缝衔接到基于spring cloud的微服务开发中来。\ngateway官网：\nhttps://spring.io/projects/spring-cloud-gateway\n2 网关系统使用 2.1 需求分析 ​\t由于我们开发的系统有包括前台系统和后台系统，后台的系统给管理员使用。那么也需要调用各种微服务，所以我们针对系统管理搭建一个网关系统。分析如下： 2.2 搭建后台网关系统 2.2.1 搭建分析 由上可知道，由于需要有多个网关，所以为了管理方便。我们新建一个项目，打包方式为pom,在里面建立各种网关系统模块即可。如图所示： 2.2.2 工程搭建 (1)引入依赖\n修改dongyimai-gateway工程，打包方式为pom\npom.xml如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-gateway\u0026lt;/artifactid\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;dongyimai-gateway-web\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;!--网关依赖--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 在dongyimai-gateway工程中，创建 dongyimai-gateway-web工程，该网关主要用于对后台微服务进行一个调用操作，将多个微服务串联到一起。\npom.xml:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-gateway\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-gateway-web\u0026lt;/artifactid\u0026gt; \u0026lt;description\u0026gt; 普通web请求网关 \u0026lt;/description\u0026gt; \u0026lt;/project\u0026gt; (2)启动类\n在dongyimai-gateway-web中创建一个引导类com.offcn.gatewaywebapplication，代码如下：\n@springbootapplication @enableeurekaclient public class gatewaywebapplication { public static void main(string[] args){ springapplication.run(gatewaywebapplication.class,args); } } (3)application.yml配置\n在dongyimai-gateway-web的resources下创建application.yml,代码如下：\nspring: application: name: gateway-web server: port: 8001 eureka: client: service-url: defaultzone: http://localhost:8761/eureka management: endpoint: gateway: enabled: true web: exposure: include: true 2.3 跨域配置 有时候，我们需要对所有微服务跨域请求进行处理，则可以在gateway中进行跨域支持。修改application.yml,添加如下代码：\nspring: cloud: gateway: globalcors: cors-configurations: \u0026#39;[/**]\u0026#39;: allowcredentials: true allowedorigins: \u0026#34;*\u0026#34; allowedmethods: \u0026#34;*\u0026#34; allowedheaders: \u0026#34;*\u0026#34; 最终文件如下：\nspring: application: name: gateway-web cloud: gateway: globalcors: cors-configurations: \u0026#39;[/**]\u0026#39;: #匹配所有请求 allowedorigins: \u0026#34;*\u0026#34;#跨域处理允许所有的域 allowedmethods: #支持的方法 - get - post - put - delete server: port: 8001 eureka: client: service-url: defaultzone: http://localhost:8761/eureka 2.4 网关过滤配置 路由过滤器允许以某种方式修改传入的http请求或传出的http响应。路径过滤器的范围限定为特定路径。 spring cloud gateway包含许多内置的gatewayfilter工厂。如上图，根据请求路径路由到不同微服务去，这块可以使用gateway的路由过滤功能实现。\n过滤器有20 多个实现类，包括头部过滤器、路径类过滤器、 hystrix 过滤器和变更请求 url 的过滤器，还有参数和状态码等其他类型的过滤器。\n内置的过滤器工厂有22个实现类，包括头部过滤器、路径过滤器、hystrix 过滤器、请求url 变更过滤器，还有参数和状态码等其他类型的过滤器。根据过滤器工厂的用途来划分，可以分为以下几种：header、parameter、path、body、status、session、redirect、retry、ratelimiter和hystrix。\n2.4.1 host 路由 比如用户请求cloud.ujiuye.com的时候，可以将请求路由给http://localhost:9001服务处理，如下配置： 上图配置如下：\nroutes: - id: dongyimai_goods_route uri: http://localhost:9001 predicates: - host=cloud.ujiuye.com** 测试请求http://cloud.ujiuye.com:8001/brand,效果如下： 注意：此时要想让cloud.ujiuye.com访问本地计算机，要配置c:\\windows\\system32\\drivers\\etc\\hosts文件,映射配置如下：\n127.0.0.1 cloud.ujiuye.com 2.4.2 路径匹配过滤配置 我们还可以根据请求路径实现对应的路由过滤操作，例如请求中以/brand/路径开始的请求，都直接交给http://localhost:9001服务处理，如下配置： 上图配置如下：\nroutes: - id: dongyimai_goods_route uri: http://localhost:9001 predicates: - path=/brand** 测试请求http://localhost:8001/brand,效果如下： 2.4.3 prefixpath 过滤配置 用户每次请求路径的时候，我们可以给真实请求加一个统一前缀，例如用户请求http://localhost:8001的时候我们让它请求真实地址http://localhost:8001/brand，如下配置： 上图配置如下：\nroutes: - id: dongyimai_goods_route uri: http://localhost:9001 predicates: #- host=cloud.ujiuye.com** - path=/** filters: - prefixpath=/brand 测试请求http://localhost:8001/效果如下： 2.4.4 stripprefix 过滤配置 很多时候也会有这么一种请求，用户请求路径是/api/brand,而真实路径是/brand，这时候我们需要去掉/api才是真实路径，此时可以使用stripprefix功能来实现路径的过滤操作，如下配置： 上图配置如下：\nroutes: - id: dongyimai_goods_route uri: http://localhost:9001 predicates: - path=/api/brand** filters: - stripprefix=1 测试请求http://localhost:8001/api/brand,效果如下： 2.4.5 loadbalancerclient 路由过滤器(客户端负载均衡) 上面的路由配置每次都会将请求给指定的url处理，但如果在以后生产环境，并发量较大的时候，我们需要根据服务的名称判断来做负载均衡操作，可以使用loadbalancerclientfilter来实现负载均衡调用。loadbalancerclientfilter会作用在url以lb开头的路由，然后利用loadbalancer来获取服务实例，构造目标requesturl，设置到gateway_request_url_attr属性中，供nettyroutingfilter使用。\n修改application.yml配置文件，代码如下： 上图配置如下：\nroutes: - id: dongyimai_goods_route #uri: http://localhost:9001 uri: lb://goods predicates: #- host=cloud.ujiuye.com** - path=/** filters: #- prefixpath=/brand - stripprefix=1 测试请求路径http://localhost:8001/api/brand 2.5 网关限流 网关可以做很多的事情，比如，限流，当我们的系统被频繁的请求的时候，就有可能将系统压垮，所以为了解决这个问题，需要在每一个微服务中做限流操作，但是如果有了网关，那么就可以在网关系统做限流，因为所有的请求都需要先通过网关系统才能路由到微服务中。\n2.5.1 思路分析 2.5.2 令牌桶算法 令牌桶算法是比较常见的限流算法之一，大概描述如下： 1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理； 2）根据限流大小，设置按照一定的速率往桶里添加令牌； 3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝； 4）请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除； 5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流\n如下图： 这个算法的实现，有很多技术，guaua是其中之一，redis客户端也有其实现。\n2.5.3 使用令牌桶进行请求次数限流 spring cloud gateway 默认使用redis的ratelimter限流算法来实现。所以我们要使用首先需要引入redis的依赖\n(1)引入redis依赖\n在dongyimai-gateway的pom.xml中引入redis的依赖\n\u0026lt;!--redis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-data-redis-reactive\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; (2)定义keyresolver\n在applicatioin引导类中添加如下代码，keyresolver用于计算某一个类型的限流的key也就是说，可以通过keyresolver来指定限流的key。\n我们可以根据ip来限流，比如每个ip每秒钟只能请求一次，在gatewaywebapplication定义key的获取，获取客户端ip，将ip作为key，如下代码：\n/*** * ip限流 *@return */ @bean(name=\u0026#34;ipkeyresolver\u0026#34;) public keyresolver userkeyresolver(){ return new keyresolver(){ @override public mono\u0026lt;string\u0026gt; resolve(serverwebexchange exchange){ //获取远程客户端ip string hostname = exchange.getrequest().getremoteaddress().getaddress().gethostaddress(); system.out.println(\u0026#34;hostname:\u0026#34;+hostname); return mono.just(hostname); } }; } (3)修改application.yml中配置项，指定限制流量的配置以及redis的配置，如图\n修改如下图： 配置代码如下：\nspring: cloud: gateway: globalcors: cors-configurations: \u0026#39;[/**]\u0026#39;: # 匹配所有请求 allowedorigins: \u0026#34;*\u0026#34; #跨域处理 允许所有的域 allowedmethods: # 支持的方法 - get - post - put - delete routes: - id: dongyimai_goods_route uri: lb://dym-sellergoods predicates: # - host=cloud.ujiuye.com** - path=/api/album/**,/api/brand/** filters: - stripprefix=1 - name: requestratelimiter #请求数限流 名字不能随便写 ，使用默认的facatory args: key-resolver: \u0026#34;#{@ipkeyresolver}\u0026#34; redis-rate-limiter.replenishrate: 1 redis-rate-limiter.burstcapacity: 1 application: name: gateway-web #redis配置 redis: host: 192.168.188.129 port: 6379 server: port: 8001 eureka: client: service-url: defaultzone: http://localhost:8761/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: ${spring.application.name}:${server.port} management: endpoint: gateway: enabled: true web: exposure: include: true 解释：\nredis-rate-limiter.replenishrate是您希望允许用户每秒执行多少请求，而不会丢弃任何请求。这是令牌桶填充的速率\nredis-rate-limiter.burstcapacity是指令牌桶的容量，允许在一秒钟内完成的最大请求数,将此值设置为零将阻止所有请求。\nkey-resolver: \u0026ldquo;#{@ipkeyresolver}\u0026ldquo;用于通过spel表达式来指定使用哪一个keyresolver.\n如上配置：\n表示一秒内，允许一个请求通过，令牌桶的填充速率也是一秒钟添加一个令牌。\n最大突发状况也只允许一秒内有一次请求，可以根据业务来调整。\n3 用户登录 项目中有2个重要角色，分别为管理员和用户，下面几章我们将实现购物下单和支付，用户如果没登录是没法下单和支付的，所以我们这里需要实现一个登录功能。\n3.1 表结构介绍 tb_user表结构如下： 3.2 登录 登录的时候，需要进行密码校验，这里采用了bcryptpasswordencoder进行加密，需要将资料中的bcrypt导入到common工程中，其中bcrypt.checkpw(\u0026ldquo;明文\u0026rdquo;,\u0026ldquo;密文\u0026rdquo;)用于对比密码是否一致。\n修改dongyimai-service-user的com.offcn.user.service.userservice添加根据用户名查询用户方法，代码如下\nuser findbyusername(string username); 修改服务实现：\n@override public user findbyusername(string username) { user user = new user(); user.setusername(username); list\u0026lt;user\u0026gt; userlist = this.findlist(user); if(userlist!=null\u0026amp;\u0026amp;userlist.size()\u0026gt;0){ return userlist.get(0); }else { return null; } } 修改dongyimai-service-user的com.offcn.user.controller.usercontroller添加登录方法，代码如下：\n/*** *用户登录 */ @requestmapping(value = \u0026#34;/login\u0026#34;) public result login(string username,string password){ //查询用户信息 user user = userservice.findbyusername(username); if(user!=null \u0026amp;\u0026amp; bcrypt.checkpw(password,user.getpassword())){ return new result(true,statuscode.ok,\u0026#34;登录成功！\u0026#34;,user); } return new result(false,statuscode.loginerror,\u0026#34;账号或者密码错误！\u0026#34;); } 注意：这里密码进行了加密，使用bcrypt.checkpw比对密码。\n使用postman测试如下： 3.4 网关关联 在我们平时工作中，并不会直接将微服务暴露出去，一般都会使用网关对接，实现对微服务的一个保护作用，如上图，当用户访问/api/user/的时候我们再根据用户请求调用用户微服务的指定方法。当然，除了/api/user/还有/api/address/、/api/areas/、/api/cities/、/api/provinces/都需要由user微服务处理，修改网关工程dongyimai-gateway-web的application.yml配置文件，如下代码： 上图代码如下：\nspring: cloud: gateway: globalcors: cors-configurations: \u0026#39;[/**]\u0026#39;: #匹配所有请求 allowedorigins: \u0026#34;*\u0026#34;#跨域处理允许所有的域 allowedmethods: #支持的方法 - get - post - put - delete routes: - id: dongyimai_goods_route uri: lb://dym-sellergoods predicates: #- host=cloud.ujiuye.com** - path=/api/brand** filters: - stripprefix=1 - name: requestratelimiter #请求数限流名字不能随便写，使用默认的facatory args: key-resolver: \u0026#34;#{@ipkeyresolver}\u0026#34; redis-rate-limiter.replenishrate: 1 redis-rate-limiter.burstcapacity: 1 #用户微服务 - id: dongyimai_user_route uri: lb://dym-user predicates: - path=/api/user/**,/api/address/**,/api/areas/**,/api/cities/**,/api/provinces/** filters: - stripprefix=1 application: name: gateway-web #redis配置 redis: host: 192.168.188.129 port: 6379 server: port: 8001 eureka: client: service-url: defaultzone: http://localhost:8761/eureka instance: prefer-ip-address: true management: endpoint: gateway: enabled: true web: exposure: include: true 使用postman访问[http://localhost:8001/api/user/login](//根据登录用户名获取用户信息)?username=dongyimai\u0026amp;password=dongyimai，效果如下： 4 jwt讲解 4.1 需求分析 我们之前已经搭建过了网关，使用网关在网关系统中比较适合进行权限校验。 那么我们可以采用jwt的方式来实现鉴权校验。\n4.2 什么是jwt json web token（jwt）是一个非常轻巧的规范。这个规范允许我们使用jwt在用户和服务器之间传递安全可靠的信息。\n4.3 jwt的构成 一个jwt实际上就是一个字符串，它由三部分组成，头部、载荷与签名。\n头部（header）\n头部用于描述关于该jwt的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个json对象。\n{\u0026#34;typ\u0026#34;:\u0026#34;jwt\u0026#34;,\u0026#34;alg\u0026#34;:\u0026#34;hs256\u0026#34;} 在头部指明了签名算法是hs256算法。我们进行base64编码https://base64.us/，编码后的字符串如下：\neyj0exaioijkv1qilcjhbgcioijiuzi1nij9 小知识：base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个base64单元，即3个字节需要用4个可打印字符来表示。jdk 中提供了非常方便的 base64encoder 和 base64decoder，用它们可以非常方便的完成基于 base64 的编码和解码\n载荷（playload）\n载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分\n（1）标准中注册的声明（建议但不强制使用）\niss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 （2）公共的声明\n公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.\n（3）私有的声明\n私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。\n这个指的就是自定义的claim。比如下面面结构举例中的admin和name都属于自定的claim。这些claim跟jwt标准规定的claim区别在于：jwt规定的claim，jwt的接收方在拿到jwt之后，都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。\n定义一个payload:\n{\u0026#34;sub\u0026#34;:\u0026#34;1234567890\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;john doe\u0026#34;,\u0026#34;admin\u0026#34;:true} 然后将其进行base64加密，得到jwt的第二部分。\neyjzdwiioiixmjm0nty3odkwiiwibmftzsi6ikpvag4grg9liiwiywrtaw4ionrydwv9 签证（signature）\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\nheader (base64后的)\npayload (base64后的)\nsecret\n这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。\ntjva95orm7e2cbab30rmhrhdcefxjoyzgefonfh7hgq 将这三部分用.连接成一个完整的字符串,构成了最终的jwt:\neyjhbgcioijiuzi1niisinr5cci6ikpxvcj9.eyjzdwiioiixmjm0nty3odkwiiwibmftzsi6ikpvag4grg9liiwiywrtaw4ionrydwv9.tjva95orm7e2cbab30rmhrhdcefxjoyzgefonfh7hgq 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret,那就意味着客户端是可以自我签发jwt了。\n4.4 jjwt的介绍和使用 jjwt是一个提供端到端的jwt创建和验证的java库。永远免费和开源(apache license，版本2.0)，jjwt很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。\n官方文档：\nhttps://github.com/jwtk/jjwt\n4.4.1 创建token (1)依赖引入\n在dongyimai-parent项目中的pom.xml中添加依赖：\n\u0026lt;!--鉴权--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.jsonwebtoken\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jjwt\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; (2)创建测试\n在dongyimai-common的/test/java下创建测试类，并设置测试方法\npublic class jwttest { /**** *创建jwt令牌 */ @test public void testcreatejwt(){ jwtbuilder builder= jwts.builder() .setid(\u0026#34;888\u0026#34;)//设置唯一编号 .setsubject(\u0026#34;小白\u0026#34;)//设置主题可以是json数据 .setissuedat(new date())//设置签发日期 .signwith(signaturealgorithm.hs256,\u0026#34;ujiuye\u0026#34;);//设置签名使用hs256算法，并设置secretkey(字符串) //构建并返回一个字符串 system.out.println( builder.compact()); } } 运行打印结果：\neyjhbgcioijiuzi1nij9.eyjqdgkioii4odgilcjzdwiioillsi_nmb0ilcjpyxqioje2mti3odk0mjn9.adpntewlbnz-r6wur8fyrlxfj1kf6ppp2uqq_voxico 再次运行，会发现每次运行的结果是不一样的，因为我们的载荷中包含了时间。\n4.4.2 token解析 我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。\n/*** *解析jwt令牌数据 */ @test public void testparsejwt(){ string compactjwt=\u0026#34;eyjhbgcioijiuzi1nij9.eyjqdgkioii4odgilcjzdwiioillsi_nmb0ilcjpyxqioje1njiwnjiyodd9.rblpz79usmplqyfjczfd2muhv_klks7m1zsjtu6aez4\u0026#34;; claims claims = jwts.parser(). setsigningkey(\u0026#34;ujiuye\u0026#34;). parseclaimsjws(compactjwt). getbody(); system.out.println(claims); } 运行打印效果：\n{jti=888, sub=小白, iat=1562062287} 试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token.\n4.4.3 设置过期时间 有很多时候，我们并不希望签发的token是永久生效的，所以我们可以为token添加一个过期时间。\n4.4.3.1 token过期设置 解释：\n.setexpiration(date)//用于设置过期时间，参数为date类型数据 运行，打印效果如下：\neyjhbgcioijiuzi1nij9.eyjqdgkioii4odgilcjzdwiioillsi_nmb0ilcjpyxqioje1njiwnji5mjusimv4cci6mtu2mja2mjkynx0._vs4metapkcza52lun0-2nggwiio7v51xt40dhy1u1q 4.4.3.2 解析token /*** *解析jwt令牌数据 */ @test public void testparsejwt(){ string compactjwt=\u0026#34;eyjhbgcioijiuzi1nij9.eyjqdgkioii4odgilcjzdwiioillsi_nmb0ilcjpyxqioje1njiwnji5mjusimv4cci6mtu2mja2mjkynx0._vs4metapkcza52lun0-2nggwiio7v51xt40dhy1u1q\u0026#34;; claims claims = jwts.parser(). setsigningkey(\u0026#34;ujiuye\u0026#34;). parseclaimsjws(compactjwt). getbody(); system.out.println(claims); } 打印效果： 当前时间超过过期时间，则会报错。\n可以设置秘钥的过期时间：\n.setexpiration(new date(system.currenttimemillis()+100000));//设置过期时间 4.4.4 自定义claims 我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角色）可以定义自定义claims。\n创建测试类，并设置测试方法：\n创建token: 运行打印效果：\neyjhbgcioijiuzi1nij9.eyjqdgkioii4odgilcjzdwiioillsi_nmb0ilcjpyxqioje2mti3otayotasimv4cci6mtyxmjc5mdi5mcwiywrkcmvzcyi6iuwml-s6row4guacnemys-wmuus6loawueahpewfuuwcscisim5hbwuioilkuk3lhazkvjjlslhkujoifq.vwvrb-wuxb_bcllsn2gy_m8z2pwpdu-kdtkeay8gp5k 解析token:\n/*** *解析jwt令牌数据 */ @test public void testparsejwt(){ string compactjwt=\u0026#34;eyjhbgcioijiuzi1nij9.eyjqdgkioii4odgilcjzdwiioillsi_nmb0ilcjpyxqioje2mti3ota2ntasimfkzhjlc3mioilljjfkuqzluilmnj3pmlpljlrkuptmlrnmoaxln7rlnlailcjuyw1lijoi5lit5yws5lyy5bcx5liain0.zhma-my0wg-adsv9xrf16_exvxukcwnrtcsfsjfouuc\u0026#34;; claims claims = jwts.parser(). setsigningkey(\u0026#34;ujiuye\u0026#34;). parseclaimsjws(compactjwt). getbody(); system.out.println(claims); } 运行效果： 4.5 鉴权处理 4.5.1 思路分析 1.用户通过访问微服务网关调用微服务，同时携带头文件信息 2.在微服务网关这里进行拦截，拦截后获取用户要访问的路径 3.识别用户访问的路径是否需要登录，如果需要，识别用户的身份是否能访问该路径[这里可以基于数据库设计一套权限] 4.如果需要权限访问，用户已经登录，则放行 5.如果需要权限访问，且用户未登录，则提示用户需要登录 6.用户通过网关访问用户微服务，进行登录验证 7.验证通过后，用户微服务会颁发一个令牌给网关，网关会将用户信息封装到头文件中，并响应用户 8.用户下次访问，携带头文件中的令牌信息即可识别是否登录 4.5.2用户登录签发token (1)生成令牌工具类\n在dongyimai-common中创建类utils.jwtutil，主要辅助生成jwt令牌信息，代码如下：\npublic class jwtutil { //有效期为 public static final long jwt_ttl = 3600000l;//60 *60 *1000 一个小时 //jwt令牌信息 public static final string jwt_key = \u0026#34;ujiuye\u0026#34;; /** *生成token令牌方法 * **/ public static string createjwt(string id, string subject, long ttlmillis){ //指定签名算法 signaturealgorithm signaturealgorithm = signaturealgorithm.hs256; //当前系统时间 long nowmillis = system.currenttimemillis(); //令牌签发时间 date now = new date(nowmillis); //如果令牌有效期为null，则默认设置有效期1小时 if(ttlmillis==null){ ttlmillis=jwtutil.jwt_ttl; } //令牌过期时间设置 long expmillis = nowmillis + ttlmillis; date expdate = new date(expmillis); //生成秘钥 secretkey secretkey = generalkey(); //封装jwt令牌信息 jwtbuilder builder = jwts.builder() .setid(id)//唯一的id .setsubject(subject)//主题可以是json数据 .setissuer(\u0026#34;admin\u0026#34;)//签发者 .setissuedat(now)//签发时间 .signwith(signaturealgorithm, secretkey)//签名算法以及密匙 .setexpiration(expdate); //设置过期时间 return builder.compact(); } /** *生成加密 secretkey *@return */ public static secretkey generalkey(){ byte[] encodedkey = base64.getencoder().encode(jwtutil.jwt_key.getbytes()); secretkey key = new secretkeyspec(encodedkey,0, encodedkey.length,\u0026#34;aes\u0026#34;); return key; } /** *解析令牌数据 *@param jwt *@return *@throws exception */ public static claims parsejwt(string jwt) throws exception { secretkey secretkey = generalkey(); return jwts.parser() .setsigningkey(secretkey) .parseclaimsjws(jwt) .getbody(); } } (2)用户登录成功则签发token，修改登录的方法： 代码如下：\n/*** *用户登录 */ @requestmapping(value = \u0026#34;/login\u0026#34;) public result login(string username,string password){ //查询用户信息 user user = userservice.findbyid(username); if(user!=null \u0026amp;\u0026amp; bcrypt.checkpw(password,user.getpassword())){ //设置令牌信息 map\u0026lt;string,object\u0026gt; info = new hashmap\u0026lt;string,object\u0026gt;(); info.put(\u0026#34;role\u0026#34;,\u0026#34;user\u0026#34;); info.put(\u0026#34;success\u0026#34;,\u0026#34;success\u0026#34;); info.put(\u0026#34;username\u0026#34;,username); //生成令牌 string jwt = jwtutil.createjwt(uuid.randomuuid().tostring(), json.tojsonstring(info),null); return new result(true,statuscode.ok,\u0026#34;登录成功！\u0026#34;,jwt); } return new result(false,statuscode.loginerror,\u0026#34;账号或者密码错误！\u0026#34;); } 4.5.3 网关过滤器拦截请求处理 自定义全局过滤器，创建过滤器类，如图所示： authorizefilter代码如下：\n@component public class authorizefilter implements globalfilter, ordered { //令牌头名字 private static final string authorize_token = \u0026#34;authorization\u0026#34;; /*** *全局过滤器 *@param exchange *@param chain *@return */ @override public mono\u0026lt;void\u0026gt; filter(serverwebexchange exchange, gatewayfilterchain chain){ //获取request、response对象 serverhttprequest request = exchange.getrequest(); serverhttpresponse response = exchange.getresponse(); //获取请求的uri string path = request.geturi().getpath(); //如果是登录、goods等开放的微服务[这里的goods部分开放],则直接放行,这里不做完整演示，完整演示需要设计一套权限系统 if (path.startswith(\u0026#34;/api/user/login\u0026#34;)|| path.startswith(\u0026#34;/api/brand/search/\u0026#34;)){ //放行 mono\u0026lt;void\u0026gt; filter = chain.filter(exchange); return filter; } //获取头文件中的令牌信息 string tokent = request.getheaders().getfirst(authorize_token); //如果头文件中没有，则从请求参数中获取 if (stringutils.isempty(tokent)){ tokent = request.getqueryparams().getfirst(authorize_token); } //如果为空，则输出错误代码 if (stringutils.isempty(tokent)){ //设置方法不允许被访问，405错误代码 response.setstatuscode(httpstatus.method_not_allowed); return response.setcomplete(); } //解析令牌数据 try { claims claims = jwtutil.parsejwt(tokent); } catch (exception e){ e.printstacktrace(); //解析失败，响应401错误 response.setstatuscode(httpstatus.unauthorized); return response.setcomplete(); } //放行 return chain.filter(exchange); }\t/*** *过滤器执行顺序 *@return */ @override public int getorder(){ return 0; } } 需要在dongyimai-gateway-web引入dongyimai-common的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 注意：需要排除spring-boot-starter-web的依赖\n引入之后，启动网关会包一个错误，和springmvc冲突 4.5.4 配置过滤规则 修改网关系统的yml文件： 上述代码如下：\nspring: cloud: gateway: globalcors: corsconfigurations: \u0026#39;[/**]\u0026#39;: #匹配所有请求 allowedorigins: \u0026#34;*\u0026#34;#跨域处理允许所有的域 allowedmethods: #支持的方法 - get - post - put - delete routes: - id: dongyimai_goods_route uri: lb://goods predicates: - path=/api/album/**,/api/brand/**,/api/cache/**,/api/categorybrand/**,/api/category/**,/api/para/**,/api/pref/**,/api/sku/**,/api/spec/**,/api/spu/**,/api/stockback/**,/api/template/** filters: - stripprefix=1 - name: requestratelimiter #请求数限流名字不能随便写，使用默认的facatory args: key-resolver: \u0026#34;#{@ipkeyresolver}\u0026#34; redis-rate-limiter.replenishrate: 1 redis-rate-limiter.burstcapacity: 1 #用户微服务 - id: dongyimai_user_route uri: lb://user predicates: - path=/api/user/**,/api/address/**,/api/areas/**,/api/cities/**,/api/provinces/** filters: - stripprefix=1 application: name: gateway-web #redis配置 redis: host: 192.168.188.129 port: 6379 server: port: 8001 eureka: client: service-url: defaultzone: http://localhost:8761/eureka instance: prefer-ip-address: true management: endpoint: gateway: enabled: true web: exposure: include: true 测试访问http://localhost:8001/api/user/login?username=dongyimai\u0026amp;password=dongyimai，效果如下： 测试访问 http://localhost:8001/api/user，效果如下：\n用postman在请求头加入token，在测试，可以正常访问 参考官方手册：\nhttps://cloud.spring.io/spring-cloud-gateway/spring-cloud-gateway.html#_stripprefix_gatewayfilter_factory\n4.6 会话保持 用户每次请求的时候，我们都需要获取令牌数据，方法有多重，可以在每次提交的时候，将数据提交到头文件中，也可以将数据存储到cookie中，每次从cookie中校验数据，还可以每次将令牌数据以参数的方式提交到网关，这里面采用cookie的方式比较容易实现。\n4.6.1 登录封装cookie 修改user微服务，每次登录的时候，添加令牌信息到cookie中，修改dongyimai-user-service的com.offcn.user.controller.usercontroller的login方法，代码如下： /*** *用户登录 */ @requestmapping(value = \u0026#34;/login\u0026#34;) public result login(string username, string password, httpservletresponse response){ //查询用户信息 user user = userservice.findbyusername(username); if(user!=null \u0026amp;\u0026amp; bcrypt.checkpw(password,user.getpassword())){ //设置令牌信息 map\u0026lt;string,object\u0026gt; info=new hashmap\u0026lt;\u0026gt;(); info.put(\u0026#34;role\u0026#34;,\u0026#34;user\u0026#34;); info.put(\u0026#34;success\u0026#34;,\u0026#34;success\u0026#34;); info.put(\u0026#34;username\u0026#34;,username); //生成令牌 string jwt = jwtutil.createjwt(uuid.randomuuid().tostring(), json.tojsonstring(info), null); //创建cookie对象 cookie cookie = new cookie(\u0026#34;authorization\u0026#34;,jwt); //设置cookie的路径 cookie.setpath(\u0026#34;/\u0026#34;); //把cookie使用响应头设置给浏览器 response.addcookie(cookie); return new result(true,statuscode.ok,\u0026#34;登录成功！\u0026#34;,jwt); } return new result(false,statuscode.loginerror,\u0026#34;账号或者密码错误！\u0026#34;); } 4.6.2 过滤器获取令牌数据 每次在网关中通过过滤器获取cookie中的令牌，然后对令牌数据进行解析，修改微服务网关dongyimai-gateway-web中的authorizefilter，代码如下： 登录后测试，可以识别用户身份，不登录无法识别。如下访问http://localhost:8001/api/user会携带令牌数据： 4.6.3 添加header信息 我们还可以在gateway的全局过滤器中添加请求头信息，例如可以将令牌信息添加到请求头中，在微服务中获取头信息，如下代码：\n修改微服务网关中的过滤器，在令牌信息校验那块将令牌加入到请求头中，如下代码： claims claims = jwtutil.parsejwt(token); //把解析出来的令牌添加到头文件中 request.mutate().header(authorize_token,claims.tostring()); 在dongyimai-service-user微服务的usercontroller的findall方法中获取请求头测试，代码如下： //获取请求头中封装的令牌 string token = request.getheader(\u0026#34;authorization\u0026#34;); system.out.println(\u0026#34;令牌信息:\u0026#34;+token); 测试请求地址:\nhttp://localhost:8001/api/user/\n后台输出令牌数据如下： ","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project-0/20220528162731/","summary":"第十章 微服务网关和Jwt令牌 优就业.JAVA教研室 学习目标 掌握微服务网关的系统搭建 了解什么是微服务网关以及它的作用 掌握系统中心微服务的搭建 掌握用户密码加密存储b","title":"微服务网关和jwt令牌"},{"content":"第十三章 提交订单 优就业.java教研室 学习目标 登录页的配置 登录成功跳转实现 结算页查询实现 下单实现 变更库存 增加积分 1 登录页面配置 前面使用的都是采用postman实现登录，接着我们实现一次oauth自定义登录。\n1.1 准备工作 (1)静态资源导入\n将资料/页面/前端登录相关的静态资源导入到dongyimai-user-oauth中,如下图。 注意：为了测试在static目录编写一个测试页success.html\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登录成功\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;登录成功\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (2)引入thymeleaf\n修改dongyimai-user-oauth，引入thymeleaf模板引擎\n\u0026lt;!--thymeleaf--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; (3)登录配置\n修改dongyimai-user-oauth,编写一个控制器com.offcn.oauth.controller.loginredirect，实现登录页跳转，代码如下：\n@controller @requestmapping(value = \u0026#34;/oauth\u0026#34;) public class loginredirect { /*** * 跳转到登录页面 * @return */ @getmapping(value = \u0026#34;/login\u0026#34;) public string login(){ return \u0026#34;login\u0026#34;; } } (4)登录页配置\n针对静态资源和登录页面，我们需要实现忽略安全配置，并且要指定登录页面。修改com.offcn.oauth.config.websecurityconfig的2个configure方法，代码如下：\n第1个configure配置: 第2个configure配置： 测试\nhttp://localhost:9100/oauth/login 1.2 登录实现 点击登录按钮，访问之前的登录方法实现登录，我们需要对登录页做一下调整。\n(1)引入thymeleaf命名空间\n修改login.html，引入命名空间\n\u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; (2)登录脚本\n点击登录按钮，使用vue+axios实现登录，我们需要定义脚本访问后台登录方法。\n先添加vue入口标签：修改login.html，在73行左右的标签上添加id=\u0026ldquo;app\u0026rdquo;,代码如下：\n\u0026lt;div class=\u0026#34;login-box\u0026#34; id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!--head--\u0026gt; \u0026lt;div class=\u0026#34;py-container logoarea\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;logo\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; …………略 \u0026lt;/div\u0026gt; 引入js\n\u0026lt;script src=\u0026#34;/js/vue.js\u0026#34; th:src=\u0026#34;@{/js/vue.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/js/axios.js\u0026#34; th:src=\u0026#34;@{/js/axios.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 登录脚本实现：\n\u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; var app = new vue({ el:\u0026#34;#app\u0026#34;, data:{ username:\u0026#39;\u0026#39;, password:\u0026#39;\u0026#39; }, methods:{ login:function () { axios.post(\u0026#39;/user/login?username=\u0026#39;+this.username+\u0026#39;\u0026amp;password=\u0026#39;+this.password).then( function (response) { if(response.data.flag){//登录成功 alert(\u0026#34;登录成功\u0026#34;); location.href=\u0026#34;/success.html\u0026#34;; }else{ alert(response.data.message); } } ) } } }) \u0026lt;/script\u0026gt; (3)表单修改\n\u0026lt;div class=\u0026#34;sui-form\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-prepend\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;add-on loginname\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;prependedinput\u0026#34; v-model=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;邮箱/用户名/手机号\u0026#34; class=\u0026#34;span2 input-xfat\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;input-prepend\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;add-on loginpwd\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;prependedinput\u0026#34; v-model=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; class=\u0026#34;span2 input-xfat\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;setting\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;checkbox inline\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;m1\u0026#34; type=\u0026#34;checkbox\u0026#34; value=\u0026#34;2\u0026#34; checked=\u0026#34;\u0026#34;\u0026gt; 自动登录 \u0026lt;/label\u0026gt; \u0026lt;span class=\u0026#34;forget\u0026#34;\u0026gt;忘记密码？\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;logined\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;sui-btn btn-block btn-xlarge btn-danger\u0026#34; @click=\u0026#34;login()\u0026#34;\u0026gt; 登\u0026amp;nbsp;\u0026amp;nbsp;录 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 注意表单:\u0026lt;form\u0026gt;改成\u0026lt;div\u0026gt;避免出现点击登录按钮默认提交表单的情况。\n（4）测试 输入账号：dongyimai 密码: 123\n登录成功，跳转到测试主页： 1.3 登录跳转 用户没有登录的时候，我们直接访问购物车，效果如下：\nhttp://localhost:8001/api/cart/findcartlist 我们可以发现，返回的只是个错误状态码，不方便测试，我们可以重定向到登录页面，让用户登录，我们可以修改网关的头文件，让用户每次未登录的时候，都跳转到登录页面。\n修改dongyimai-gateway-web的com.offcn.filter.authorizefilter，代码如下： 修改判断token为空的代码，把原来响应405，修改成跳转到登录网关登录页地址 单独编写跳转方法：needauthorization //设置跳转方法 private mono\u0026lt;void\u0026gt; needauthorization(string url, serverwebexchange exchange){ serverhttpresponse response = exchange.getresponse(); response.setstatuscode(httpstatus.see_other); response.getheaders().set(\u0026#34;location\u0026#34;,url); return response.setcomplete(); } 此时再测试，就可以跳转到登录页面了。当然，在工作中，这里不能直接跳转到登录页，应该提示状态给页面，让页面根据判断跳转，这里只是为了方便测试。\n1.4 成功登录跳转到原访问页 上面虽然实现了登录跳转，但登录成功后却并没有返回到要访问的购物车页面，我们可以将用户要访问的页面作为参数传递给登录控制器，登录控制器记录下来，每次登录成功后，再跳转记录访问路劲参数指定的页面即可。\n(1)修改网关携带当前uri\n修改dongyimai-gateway-web的com.offcn.filter.authorizefilter，在之前的url后面添加from参数以及from参数的值为request.geturi()，代码如下： 注意：跳转地址，需要做urlencode编码处理\n(2)认证服务器获取from参数\n修改dongyimai-user-oauth的com.offcn.oauth.controller.loginredirect记录访问来源页，代码如下： 注意：接收过来的跳转url需要做urldecode解码\n代码如下：\n@controller @requestmapping(value = \u0026#34;/oauth\u0026#34;) public class loginredirect { /*** * 跳转到登录页面 * @return */ @getmapping(value = \u0026#34;/login\u0026#34;) public string login(@requestparam(value = \u0026#34;from\u0026#34;,required = false,defaultvalue = \u0026#34;\u0026#34;) string from, model model){ try { string decodeurl = urldecoder.decode(from, \u0026#34;utf-8\u0026#34;); model.addattribute(\u0026#34;from\u0026#34;,decodeurl); system.out.println(\u0026#34;form:\u0026#34;+decodeurl); } catch (unsupportedencodingexception e) { e.printstacktrace(); } return \u0026#34;login\u0026#34;; } } 修改页面，获取来源页信息，并存到from变量中，登录成功后跳转到该地址。 \u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; var app = new vue({ el: \u0026#34;#app\u0026#34;, data: { username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39; }, methods: { login: function () { axios.post(\u0026#39;/user/login?username=\u0026#39; + this.username + \u0026#39;\u0026amp;password=\u0026#39; + this.password).then( function (response) { if (response.data.flag) {//登录成功 location.href = [[$from]];//需要跳转到的地址 } else { response.data.message; } } ) } } }) \u0026lt;/script\u0026gt; 此时再测试，就可以识别未登录用户，跳转到登录页，然后根据登录状态，如果登录成功，则跳转到来源页。\n2 订单确认页 2.1 收件地址分析 用户从购物车页面点击结算，跳转到订单结算页，结算页需要加载用户对应的收件地址，如下图： 表结构分析： 我们可以根据用户登录名去tb_address表中查询对应的数据。\n2.2 实现用户收件地址查询 2.2.1 代码实现 (1)业务层\n业务层接口\n修改dongyimai-user-service微服务，需改com.offcn.user.service.addressservice接口，添加根据用户名字查询用户收件地址信息，代码如下：\n/** * 根据用户查询地址 * @param userid * @return */ public list\u0026lt;address\u0026gt; findlistbyuserid(string userid ); 业务层接口实现类\n修改dongyimai-service-user微服务，修改com.offcn.user.service.impl.addressserviceimpl类，添加根据用户查询用户收件地址信息实现方法，如下代码：\n/** * 根据用户查询地址 * * @param userid * @return */ @override public list\u0026lt;address\u0026gt; findlistbyuserid(string userid) { querywrapper\u0026lt;address\u0026gt; querywrapper = new querywrapper\u0026lt;\u0026gt;(); querywrapper.eq(\u0026#34;user_id\u0026#34;,userid); //根据构建的条件查询数据 return this.list(querywrapper); } (2)控制层\n修改dongyimai-user-service微服务，修改com.offcn.user.controller.addresscontroller，添加根据用户名查询用户收件信息方法，代码如下：\n@autowired private tokendecode tokendecode; /**** * 用户收件地址 */ @getmapping(value = \u0026#34;/user/list\u0026#34;) public result\u0026lt;list\u0026lt;address\u0026gt;\u0026gt; findlistbyuserid(){ //获取用户登录信息 map\u0026lt;string, string\u0026gt; usermap = tokendecode.getuserinfo(); string userid = usermap.get(\u0026#34;user_name\u0026#34;); //查询用户收件地址 list\u0026lt;address\u0026gt; addresslist = addressservice.findlistbyuserid(userid); return new result(true, statuscode.ok,\u0026#34;查询成功！\u0026#34;,addresslist); } 注意要在主启动类增加tokendecode的声明\npublic class userapplication { public static void main(string[] args) { springapplication.run(userapplication.class,args); } @bean public tokendecode gettokendecode(){ return new tokendecode(); } } 2.2.2 测试 访问 http://localhost:8001/api/address/user/list 2.2.3 运送清单【学员完成】 运送清单其实就是购物车列表，直接查询之前的购物车列表即可，这里不做说明了。\n3 下单 3.1 业务分析 点击结算页的时候，会立即创建订单数据，创建订单数据会将数据存入到2张表中，分别是订单表和订单明细表，此处还需要修改商品对应的库存数量。 订单表结构如下： 订单明细表结构如下： 3.2 下单实现 下单的时候，先添加订单往tb_order表中增加数据，再添加订单明细，往tb_order_item表中增加数据。\n3.2.1分布式id生成器 我们采用的是开源的twitter( 非官方中文惯称：推特.是国外的一个网站，是一个社交网络及微博客服务) 的snowflake算法。 这里先修改dongyimai-order-service微服务，实现下单操作，这里会生成订单号，我们首先需要在启动类中创建一个idworker对象。\n在com.offcn.orderapplication中创建idworker，代码如下：\n@bean public idworker idworker(){ return new idworker(1,1); } 修改pojo下的order、orderitem id生成方式： (1)业务层\n修改dongyimai-order-service微服务，修改com.offcn.order.service.impl.orderserviceimpl,代码如下：\n//注入redis操作类 @autowired private redistemplate redistemplate; @autowired private orderitemmapper orderitemmapper; @autowired private idworker idworker; /** * 增加order * @param order */ @override public void add(order order){ // 得到购物车数据 list\u0026lt;cart\u0026gt; cartlist = (list\u0026lt;cart\u0026gt;) redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).get(order.getuserid()); for (cart cart : cartlist) { long orderid = idworker.nextid(); system.out.println(\u0026#34;sellerid:\u0026#34; + cart.getsellerid()); order tborder = new order();// 新创建订单对象 //复制前端传递过来的订单的属性值，到新创建订单对象 beanutils.copyproperties(order,tborder); tborder.setorderid(orderid);// 订单id（一定要在复制属性后设置） tborder.setstatus(\u0026#34;1\u0026#34;);// 状态：未付款 tborder.setcreatetime(new date());// 订单创建日期 tborder.setupdatetime(new date());// 订单更新日期 tborder.setsellerid(cart.getsellerid());// 商家id // 循环购物车明细 double money = 0; for (orderitem orderitem : cart.getorderitemlist()) { orderitem.setid(idworker.nextid()); orderitem.setorderid(orderid);// 订单id orderitem.setsellerid(cart.getsellerid()); money += orderitem.gettotalfee().doublevalue();// 金额累加 //保存购物明细 orderitemmapper.insert(orderitem); } tborder.setpayment(new bigdecimal(money)); //保存订单 this.save(tborder); } //下单成功，清空redis购物车数据 redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).delete(order.getuserid()); } (2)控制层\n修改dongyimai-order-service微服务，修改com.offcn.order.controller.ordercontroller类，代码如下：\n@autowired private tokendecode tokendecode; /*** * 新增order数据 * @param order * @return */ @apioperation(value = \u0026#34;order添加\u0026#34;,notes = \u0026#34;添加order方法详情\u0026#34;,tags = {\u0026#34;ordercontroller\u0026#34;}) @postmapping public result add(@requestbody @apiparam(name = \u0026#34;order对象\u0026#34;,value = \u0026#34;传入json数据\u0026#34;,required = true) order order){ //获取用户名 map\u0026lt;string, string\u0026gt; usermap = tokendecode.getuserinfo(); string username = usermap.get(\u0026#34;user_name\u0026#34;); //设置购买用户 order.setuserid(username); orderservice.add(order); return new result(true,statuscode.ok,\u0026#34;添加成功\u0026#34;); } 3.2.2 测试 使用postman 保存订单测试，表数据变化如下：\ntb_order表数据： tb_order_item表数据： 3.3 库存变更 3.3.1 业务分析 上面操作只实现了下单操作，但对应的库存还没跟着一起减少，我们在下单之后，应该调用商品微服务，将下单的商品库存减少，销量增加。每次订单微服务只需要将用户名传到商品微服务，商品微服务通过用户名到redis中查询对应的购物车数据，然后执行库存减少，库存减少需要控制当前商品库存\u0026gt;=销售数量。 如何控制库存数量\u0026gt;=销售数量呢？其实可以通过sql语句实现，每次减少数量的时候，加个条件判断。\nwhere num\u0026gt;=#{num}即可。\n3.3.2 代码实现 要调用其他微服务，需要将头文件中的令牌数据携带到其他微服务中取，所以我们不能使用hystrix的多线程模式，修改dongyimai-sellergoods\u0026ndash;service的applicatin.yml配置，代码如下：\n#hystrix 配置 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore #使用seamphore，你创建了多少线程，实际就会有多少线程进行执行，只是可同时执行的线程数量会受到限制 每次还需要使用拦截器添加头文件信息\n修改配置类com.offcn.sellergoodsapplication添加feign请求拦截器，代码如下：\n@bean public feigninterceptor feigninterceptor(){ return new feigninterceptor(); } (1)dao层\n修改dongyimai-sellergoods-service微服务的com.offcn.sellergoods.dao.itemmapper接口，增加库存递减方法,代码如下：\n/** * 递减库存 * @param orderitem * @return */ @update(\u0026#34;update tb_item set num=num-#{num} where id=#{itemid} and num\u0026gt;=#{num}\u0026#34;) int decrcount(orderitem orderitem); (2)业务层\n修改dongyimai-sellergoods-service微服务的com.offcn.sellergoods.service.itemservice接口，添加如下方法：\n/*** * 库存递减 * @param username */ void decrcount(string username); 修改dongyimai-sellergoods-service微服务的com.offcn.sellergoods.service.impl.itemserviceimpl实现类，添加一个实现方法，代码如下：\n@autowired private itemmapper itemmapper; @autowired private redistemplate redistemplate; /*** * 库存递减 * @param username */ @override public void decrcount(string username) { // 得到购物车数据 list\u0026lt;cart\u0026gt; cartlist = (list\u0026lt;cart\u0026gt;) redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).get(username); //遍历购物车集合 for (cart cart : cartlist) { //遍历购物明细 for (orderitem orderitem : cart.getorderitemlist()) { //递减库存 int count = itemmapper.decrcount(orderitem); if(count\u0026lt;=0){ throw new runtimeexception(\u0026#34;库存不足，递减失败！\u0026#34;); } } } } (3)控制层\n修改dongyimai-sellergoods-service的com.offcn.sellergoods.controller.itemcontroller类，添加库存递减方法，代码如下：\n/*** * 库存递减 * @param username * @return */ @postmapping(value = \u0026#34;/decr/count\u0026#34;) public result decrcount(string username){ //库存递减 itemservice.decrcount(username); return new result(true,statuscode.ok,\u0026#34;库存递减成功！\u0026#34;); } (4)创建feign\n同时在dongyimai-sellergoods-service-api工程添加com.offcn.sellergoods.feign.itemfeign的实现，代码如下：\n/*** * 库存递减 * @param username * @return */ @postmapping(value = \u0026#34;/decr/count\u0026#34;) result decrcount(@requestparam(value = \u0026#34;username\u0026#34;) string username); 3.3.3 调用库存递减 修改dongyimai-order-service微服务的com.offcn.order.service.impl.orderserviceimpl类的add方法，增加库存递减的调用。\n先注入itemfeign\n@autowired private itemfeign itemfeign; 再调用库存递减方法\n//减少库存 调用goods 微服务的 feign 减少库存 itemfeign.decrcount(order.getuserid()); 注意：调用减少库存方法，要放置在清除redis购物车数据之前。\n完整代码如下：\n/** * 增加order * @param order */ @override public void add(order order){ // 得到购物车数据 list\u0026lt;cart\u0026gt; cartlist = (list\u0026lt;cart\u0026gt;) redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).get(order.getuserid()); for (cart cart : cartlist) { long orderid = idworker.nextid(); system.out.println(\u0026#34;sellerid:\u0026#34; + cart.getsellerid()); order tborder = new order();// 新创建订单对象 //复制前端传递过来的订单的属性值，到新创建订单对象 beanutils.copyproperties(order,tborder); tborder.setorderid(orderid);// 订单id（一定要在复制属性后设置） tborder.setstatus(\u0026#34;1\u0026#34;);// 状态：未付款 tborder.setcreatetime(new date());// 订单创建日期 tborder.setupdatetime(new date());// 订单更新日期 tborder.setsellerid(cart.getsellerid());// 商家id // 循环购物车明细 double money = 0; for (orderitem orderitem : cart.getorderitemlist()) { orderitem.setid(idworker.nextid()); orderitem.setorderid(orderid);// 订单id orderitem.setsellerid(cart.getsellerid()); money += orderitem.gettotalfee().doublevalue();// 金额累加 //保存购物明细 orderitemmapper.insert(orderitem); } tborder.setpayment(new bigdecimal(money)); //保存订单 this.save(tborder); } //******************减少库存******************************** //减少库存 调用goods 微服务的 feign 减少库存 itemfeign.decrcount(order.getuserid()); redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).delete(order.getuserid()); } 需要设置开启feign熔断、设置熔断时间、连接超时时间\nribbon: readtimeout: 300000 #hystrix 配置 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore feign: hystrix: enabled: true 3.3.4 测试 库存减少前，查询数据库sku数据如下：个数9999，销量0 使用postman执行 http://localhost:8001/api/order/ 执行测试后，剩余库存9998，销量1 3.4 增加积分[学员完成] 比如每次下单完成之后，给用户增加10个积分，支付完成后赠送优惠券，优惠券可用于支付时再次抵扣。我们先完成增加积分功能。如tb_user表：points表示用户积分\n3.4.1 代码实现 (1)dao层\n修改dongyimai-user-service微服务的com.offcn.user.dao.usermapper接口，增加用户积分方法，代码如下：\n/*** * 增加用户积分 * @param username * @param point * @return */ @update(\u0026#34;update tb_user set points=points+#{point} where username=#{username}\u0026#34;) int adduserpoints(@param(\u0026#34;username\u0026#34;) string username, @param(\u0026#34;point\u0026#34;) integer point); (2)业务层\n修改dongyimai-user-service微服务的com.offcn.user.service.userservice接口，代码如下：\n/*** * 添加用户积分 * @param username * @param point * @return */ int adduserpoints(string username,integer point); 修改dongyimai-user-service微服务的com.offcn.user.service.impl.userserviceimpl，增加添加积分方法实现，代码如下：\n@autowired private usermapper usermapper; /*** * 添加用户积分 * @param username * @param point * @return */ @override public int adduserpoints(string username, integer point) { return usermapper.adduserpoints(username,point); } (3)控制层\n修改dongyimai-user-service微服务的com.offcn.user.controller.usercontroller，添加增加用户积分方法，代码如下：\n@autowired private tokendecode tokendecode; /*** * 增加用户积分 * @param points:要添加的积分 */ @getmapping(value = \u0026#34;/points/add\u0026#34;) public result addpoints(integer points){ //获取用户名 map\u0026lt;string, string\u0026gt; usermap = tokendecode.getuserinfo(); string username = usermap.get(\u0026#34;username\u0026#34;); //添加积分 userservice.adduserpoints(username,points); return new result(true,statuscode.ok,\u0026#34;添加积分成功！\u0026#34;); } (4)feign添加\n修改dongyimai-user-service-api工程，修改com.offcn.user.feign.userfeign，添加增加用户积分方法，代码如下：\n/*** * 添加用户积分 * @param points * @return */ @getmapping(value = \u0026#34;/points/add\u0026#34;) result addpoints(@requestparam(value = \u0026#34;points\u0026#34;)integer points); 3.4.2 增加积分调用 修改dongyimai-order-service，添加dongyimai-user-service-api的依赖，修改pom.xml,添加如下依赖：\n\u0026lt;!--user api 依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-user-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在增加订单的时候，同时添加用户积分，修改dongyimai-order-service微服务的com.offcn.order.service.impl.orderserviceimpl下单方法，增加调用添加积分方法，代码如下： 修改dongyimai-order-service的启动类com.offcn.orderapplication，添加feign的包路径： //注意要设置tb_user表的每个用户的积分初始值为0\n","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project-0/20220528171137/","summary":"第十三章 提交订单 优就业.JAVA教研室 学习目标 登录页的配置 登录成功跳转实现 结算页查询实现 下单实现 变更库存 增加积分 1 登录页面配置 前面使用的都是采用Postman实","title":"提交订单"},{"content":"第十四章 支付宝支付 优就业.java教研室 学习目标 目标1：掌握二维码生成插件qrious的使用\n目标2：能够说出支付宝支付开发的整体思路\n目标3：能够调用支付宝支付接口（预下单）生成支付二维码\n目标4：能够调用支付宝支付接口（查询订单）查询支付状态\n目标5：实现支付日志的生成与订单状态的修改\n一、二维码 1 什么是二维码 二维码又称qr code，qr全称quick response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的bar code条形码能存更多的信息，也能表示更多的数据类型。\n二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。 2 二维码优势 信息容量大, 可以容纳多达1850个大写字母或2710个数字或500多个汉字 应用范围广, 支持文字,声音,图片,指纹等等\u0026hellip; 容错能力强, 即使图片出现部分破损也能使用 成本低, 容易制作 3 二维码容错级别 l级（低） 7％的码字可以被恢复。\nm级（中） 的码字的15％可以被恢复。\nq级（四分）的码字的25％可以被恢复。\nh级（高） 的码字的30％可以被恢复。\n4 二维码生成插件qrious qrious是一款基于html5 canvas的纯js二维码生成插件。通过qrious.js可以快速生成各种二维码，你可以控制二维码的尺寸颜色，还可以将生成的二维码进行base64编码。\n官网地址：https://github.com/neocotic/qrious\nqrious.js二维码插件的可用配置参数如下：\n参数 类型 默认值 描述 background string \u0026ldquo;white\u0026rdquo; 二维码的背景颜色。 foreground string \u0026ldquo;black\u0026rdquo; 二维码的前景颜色。 level string \u0026ldquo;l\u0026rdquo; 二维码的误差校正级别(l, m, q, h)。 mime string \u0026ldquo;image/png\u0026rdquo; 二维码输出为图片时的mime类型。 size number 100 二维码的尺寸，单位像素。 value string \u0026quot;\u0026quot; 需要编码为二维码的值 下面的代码即可生成一张二维码\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;二维码入门小demo\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;qrious\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;qrious.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var qr = new qrious({ element:document.getelementbyid(\u0026#39;qrious\u0026#39;), size:250, level:\u0026#39;h\u0026#39;,\tvalue:\u0026#39;http://www.ujiuye.com\u0026#39; }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行效果：\n大家掏出手机，扫一下看看是否会看到优就业的官网呢？\n二、支付宝扫码支付业务介绍及开发、环境配置流程 1 支付宝扫码支付业务流程 支付宝扫码支付是商户系统按支付宝支付协议生成支付二维码，用户再用支付宝“扫一扫”完成支付的模式。该模式适用于pc网站支付、实体店单品或订单支付、媒体广告支付等场景。\n具体操作步骤：（了解）\n第一步：创建应用\n接入扫码支付能力，需要在开放平台创建一个应用，通过该应用来接入各种能力。\n点击如下链接即可开始创建应用:https://openhome.alipay.com/platform/appmanage.htm\n第二步：添加应用功能\n开发者在开发过程中，可以添加自己需要的功能到待申请功能列表。\n给应用添加当面付功能，这样就可以在你的应用里使用扫码支付能力。\n第三步：配置秘钥\n为了保证交易双方的身份和数据安全，需要配置双方密钥。\n第四步：沙箱环境调试使用\n支付能力直接涉及到交易与资金，为了方便开放者调试支付能力，支付宝已经准备好沙箱环境，包括沙箱环境账号和沙箱版支付宝钱包，这样就可以在沙箱环境调试了。\n第五步：签约\n在正式使用这些能力的时候，需要在开放平台里进行签约，这时候约定的合同就生效了。也可以代替商户签约。\n第六步：上线应用\n上线：商户本身应用上线时候，也要把支付宝开放平台的应用上线。\n验收：为了确保应用质量，开放平台提供了云验收平台，可以在线验收应用。\n第七步：监控应用\n在开放平台监控交易情况\n应用上线后还可以在开放平台，查看应用运行情况以及交易状态。\n2 扫码支付具体申请配置流程 2.1、登录支付宝开发者平台 打开支付宝官网：https://open.alipay.com\n选择我是开发者\n【注意】用自己的支付宝，扫描右边的扫码登录，在支付宝确认登录，即可登录支付宝开发者平台。初次登录进行身份验证\n选择：自研开发者\n同意协议，点击确定\n2.2、登录开发者平台界面 选择研发服务\n2.3、进入研发服务中心\u0026mdash;》沙箱环境 沙箱环境(beta)是协助开发者进行接口功能开发及主要功能联调的模拟环境。\n作为开发者使用沙箱完全可以用来入门学习如何对接扫码支付接口。\nappid是应用的id，后续再开发应用时要用到，请保存好！\n支付宝网关：https://openapi.alipaydev.com/gateway.do\n2.4、配置沙箱环境,配置rsa2公钥 (1)鼠标移动到设置\n处在弹出的文字介绍中，点击 生成方法\n(2)根据操作系统进行选择进行下载。\n在线生成：https://miniu.alipay.com/keytool/create\n下载成功后，直接点击安装\n安装成功\n双击打开程序\n依照图示选择\n​ 密码长度为 rsa2\n​ 密码格式为 pkcs8(java适用)\n然后点击生成密钥， 后 点击打开密钥文件路径\n回到沙箱配置界面，点击 查看\n点击更换应用公钥：\n选择公钥，打开刚才我们生成的应用公钥，拷贝粘贴到文本框中\n点击保存设置既可以把我们的公钥配置上去。\n3 支付宝支付sdk 支付宝支付提供了sdk，使用支付宝支付sdk,在maven工程中引入依赖\n\u0026lt;!-- 支付宝支付所需类库包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alipay.sdk\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;alipay-sdk-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.0.all\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.bouncycastle\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;bcprov-jdk15on\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 4 工程搭建与准备工作 （1）建立支付服务实现模块dongyimai-pay-service\n（2）dongyimai-pay-service下创建application.yml，配置文件代码如下：\nserver: port: 9009 spring: application: name: pay redis: host: 192.168.188.128 port: 6379 main: allow-bean-definition-overriding: true eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true # 配置sql打印日志 logging: level: com: offcn: debug #hystrix 配置 hystrix: command: default: execution: timeout: #如果enabled设置为false，则请求超时交给ribbon控制 enabled: true isolation: strategy: semaphore #支付宝支付信息配置 alipay: serverurl: https://openapi.alipaydev.com/gateway.do appid: 2016102600767650 privatekey: 用户私钥 format: json charset: utf-8 alipaypublickey: 阿里公钥 signtype: rsa2 alipayclient创建关键参数说明：\n配置参数 示例值解释 获取方式/示例值 url 支付宝网关（固定） https://openapi.alipay.com/gateway.do app_id appid即创建应用后生成 获取见上面创建应用并获取appid app_private_key 开发者应用私钥，由开发者自己生成 获取见上面配置密钥 format 参数返回格式，只支持json json（固定） charset 请求和签名使用的字符编码格式，支持gbk和utf-8 开发者根据实际工程编码配置 alipay_public_key 支付宝公钥，由支付宝生成 获取详见上面配置密钥 sign_type 商户生成签名字符串所使用的签名算法类型，目前支持rsa2和rsa，推荐使用rsa2 rsa2 接下来，就可以用alipayclient来调用具体的api了。alipayclient只需要初始化一次，后续调用不同的api都可以使用同一个alipayclient对象。\n（4）在com.offcn.pay.config包下，创建alipayconfig，代码如下：\n@configuration public class alipayconfig { @value(\u0026#34;${alipay.appid}\u0026#34;) private string appid; @value(\u0026#34;${alipay.serverurl}\u0026#34;) private string serverurl; @value(\u0026#34;${alipay.privatekey}\u0026#34;) private string privatekey; @value(\u0026#34;${alipay.alipaypublickey}\u0026#34;) private string alipaypublickey; @value(\u0026#34;${alipay.format}\u0026#34;) private string format; @value(\u0026#34;${alipay.charset}\u0026#34;) private string charset; @value(\u0026#34;${alipay.signtype}\u0026#34;) private string signtype; @bean public alipayclient getpayclient() { return new defaultalipayclient(serverurl, appid, privatekey, format, charset, alipaypublickey, signtype); } } （5）启动类创建\n在dongyimai-pay-service中创建com.offcn.pay.payapplication，代码如下：\n@springbootapplication(exclude={datasourceautoconfiguration.class}) @enableeurekaclient public class payapplication { public static void main(string[] args) { springapplication.run(payapplication.class); } } pom.xml引入如下依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 支付宝支付所需类库包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alipay.sdk\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;alipay-sdk-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.0.all\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.bouncycastle\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;bcprov-jdk15on\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 三 东易买-支付宝支付二维码生成 1 需求分析与实现思路 1.1需求分析 在支付页面上生成支付二维码，并显示订单号和金额\n用户拿出手机,打开支付宝扫描页面上的二维码,然后在支付宝中完成支付 1.2实现思路 商户系统通过alipayclient调用支付宝预下单接口alipay.trade.precreate，获得该订单二维码图片地址。\n构建参数发送给预下单接口 ，返回的信息中有支付url，根据url生成二维码，显示的订单号和金额也在返回的信息中。\n重要入参说明\nout_trade_no：商户订单号，需要保证商家系统不重复。 total_amount：订单金额。(单位：元) subject：商品的标题/交易标题/订单标题/订单关键字等。不可使用特殊字符，如 /,=,\u0026amp; 等。 store_id：商户门店编号。 timeout_express：交易超时时间。 重要出参说明\nqr_code：订单二维码（有效时间 2 小时）以字符串的格式返回，开发者需要自己使用工具根据内容生成二维码图片。 2 代码实现 2.1服务接口层 （1）在dongyimai-pay-service创建包com.offcn.pay.service ，包下建立接口\npublic interface alipayservice { /** * 生成支付宝支付二维码 * @param out_trade_no 订单号 * @param total_fee 金额(分) * @return */ public map createnative(string out_trade_no, string total_fee); } 2.2服务实现层 dongyimai-pay-service创建com.offcn.pay.service.impl包，新建类\n@service public class alipayserviceimpl implements alipayservice { @autowired private alipayclient alipayclient; /** * 生成支付宝支付二维码 * * @param out_trade_no 订单号 * @param total_fee 金额(分) * @return */ @override public map createnative(string out_trade_no, string total_fee) { map\u0026lt;string, string\u0026gt; map = new hashmap\u0026lt;string, string\u0026gt;(); //创建预下单请求对象 alipaytradeprecreaterequest request = new alipaytradeprecreaterequest(); //转换下单金额按照元 long total = long.parselong(total_fee); bigdecimal bigtotal = bigdecimal.valueof(total); bigdecimal cs = bigdecimal.valueof(100d); bigdecimal bigyuan = bigtotal.divide(cs); system.out.println(\u0026#34;预下单金额:\u0026#34; + bigyuan.doublevalue()); request.setbizcontent(\u0026#34;{\u0026#34; + \u0026#34; \\\u0026#34;out_trade_no\\\u0026#34;:\\\u0026#34;\u0026#34; + out_trade_no + \u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;total_amount\\\u0026#34;:\\\u0026#34;\u0026#34; + bigyuan.doublevalue() + \u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;subject\\\u0026#34;:\\\u0026#34;测试购买商品001\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;store_id\\\u0026#34;:\\\u0026#34;xa_001\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;timeout_express\\\u0026#34;:\\\u0026#34;90m\\\u0026#34;}\u0026#34;);//设置业务参数 //发出预下单业务请求 try { alipaytradeprecreateresponse response = alipayclient.execute(request); //从相应对象读取相应结果 string code = response.getcode(); system.out.println(\u0026#34;响应码:\u0026#34; + code); //全部的响应结果 string body = response.getbody(); system.out.println(\u0026#34;返回结果:\u0026#34; + body); if (code.equals(\u0026#34;10000\u0026#34;)) { map.put(\u0026#34;qrcode\u0026#34;, response.getqrcode()); map.put(\u0026#34;out_trade_no\u0026#34;, response.getouttradeno()); map.put(\u0026#34;total_fee\u0026#34;, total_fee); system.out.println(\u0026#34;qrcode:\u0026#34; + response.getqrcode()); system.out.println(\u0026#34;out_trade_no:\u0026#34; + response.getouttradeno()); system.out.println(\u0026#34;total_fee:\u0026#34; + total_fee); } else { system.out.println(\u0026#34;预下单接口调用失败:\u0026#34; + body); } } catch (alipayapiexception e) { e.printstacktrace(); } return map; } } 2.3控制层 dongyimai-pay-service创建com.offcn.pay.controller.paycontroller.java\n@restcontroller @requestmapping(\u0026#34;/pay\u0026#34;) public class paycontroller { @autowired private alipayservice alipayservice; /** * 生成二维码 * * @return */ @getmapping(\u0026#34;/createnative\u0026#34;) public map createnative() { idworker idworker = new idworker(); return alipayservice.createnative(idworker.nextid() + \u0026#34;\u0026#34;, \u0026#34;1\u0026#34;); } } 这里我们订单号通过分布式id生成器生成，金额暂时写死，后续开发我们再对接业务系统得到订单号和金额\n浏览器测试 http://localhost:9009/pay/createnative\n打开支付页面/pay.html，修改value路径，然后打开，会出现二维码，可以扫码试试 打开手机沙箱版支付宝，使用沙箱账号进行扫描。出现如下支付页面。\n四 东易买-检测支付状态 1 需求分析及实现思路 1.1 需求分析 当用户支付成功后跳转到成功页面 当返回异常时跳转到错误页面 1.2 实现思路 我们通过alipayclient实现对交易查询接口（alipay.trade.query）的调用。\n交易查询接口具体参数：\n关键入参：\n参数名称 参数说明 out_trade_no 支付时传入的商户订单号，与trade_no必填一个 trade_no 支付时返回的支付宝交易号，与out_trade_no必填一个 关键出参：\n参数名称 参数说明 trade_no 支付宝28位交易号 out_trade_no 支付时传入的商户订单号 trade_status 交易当前状态 我们在controller方法中轮询调用交易查询指定订单号（间隔3秒），当返回状态为success时，我们会在controller方法返回结果。前端代码收到结果后跳转到成功页面。\n2 检测支付状态-后端代码 2.1 服务接口层 在dongyimai-pay-service的alipayservice.java中新增方法定义\n/** * 查询支付状态 * @param out_trade_no */ public map querypaystatus(string out_trade_no); 2.2 服务实现层 在dongyimai-pay-service的alipayserviceimpl.java中实现方法\n/** * 交易查询接口alipay.trade.query： * 获取指定订单编号的，交易状态 * @throws alipayapiexception */ @override public map\u0026lt;string,string\u0026gt; querypaystatus(string out_trade_no){ map\u0026lt;string,string\u0026gt; map=new hashmap\u0026lt;string, string\u0026gt;(); alipaytradequeryrequest request = new alipaytradequeryrequest(); request.setbizcontent(\u0026#34;{\u0026#34; + \u0026#34; \\\u0026#34;out_trade_no\\\u0026#34;:\\\u0026#34;\u0026#34;+out_trade_no+\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;trade_no\\\u0026#34;:\\\u0026#34;\\\u0026#34;}\u0026#34;); //设置业务参数 //发出请求 try { alipaytradequeryresponse response = alipayclient.execute(request); string code=response.getcode(); system.out.println(\u0026#34;返回值1:\u0026#34;+response.getbody()); if(code.equals(\u0026#34;10000\u0026#34;)){ //system.out.println(\u0026#34;返回值2:\u0026#34;+response.getbody()); map.put(\u0026#34;out_trade_no\u0026#34;, out_trade_no); map.put(\u0026#34;tradestatus\u0026#34;, response.gettradestatus()); map.put(\u0026#34;trade_no\u0026#34;,response.gettradeno()); }\t} catch (alipayapiexception e) { e.printstacktrace(); } return map; } 2.3 控制层 在dongyimai-pay-service的paycontroller.java新增方法\n/** * 查询支付状态 * @param out_trade_no * @return */ @requestmapping(\u0026#34;/querypaystatus\u0026#34;) public result querypaystatus(string out_trade_no){ result result=null; while(true){ //调用查询接口 map\u0026lt;string, string\u0026gt; map = null; try { map = alipayservice.querypaystatus(out_trade_no); } catch (exception e1) { /*e1.printstacktrace();*/ system.out.println(\u0026#34;调用查询服务出错\u0026#34;); } if(map==null){//出错 result=new result(false, statuscode.error,\u0026#34;支付出错\u0026#34;); break; } if(map.get(\u0026#34;tradestatus\u0026#34;)!=null\u0026amp;\u0026amp;map.get(\u0026#34;tradestatus\u0026#34;).equals(\u0026#34;trade_success\u0026#34;)){//如果成功 result=new result(true,statuscode.ok,\u0026#34;支付成功\u0026#34;); break; } if(map.get(\u0026#34;tradestatus\u0026#34;)!=null\u0026amp;\u0026amp;map.get(\u0026#34;tradestatus\u0026#34;).equals(\u0026#34;trade_closed\u0026#34;)){//如果成功 result=new result(true, statuscode.ok,\u0026#34;未付款交易超时关闭，或支付完成后全额退款\u0026#34;); break; } if(map.get(\u0026#34;tradestatus\u0026#34;)!=null\u0026amp;\u0026amp;map.get(\u0026#34;tradestatus\u0026#34;).equals(\u0026#34;trade_finished\u0026#34;)){//如果成功 result=new result(true,statuscode.ok, \u0026#34;交易结束，不可退款\u0026#34;); break; } try { thread.sleep(3000);//间隔三秒 } catch (interruptedexception e) { e.printstacktrace(); } } return result; } 3 查询时间限制 3.1问题分析 如果用户到了二维码页面一直未支付，或是关掉了支付页面，我们的代码会一直循环调用支付宝接口，这样会对程序造成很大的压力。所以我们要加一个时间限制或是循环次数限制，当超过时间或次数时，跳出循环。\n3.2代码完善 （1）修改dongyimai-pay-service工程paycontroller.java的querypaystatus方法\n@requestmapping(\u0026#34;/querypaystatus\u0026#34;) public result querypaystatus(string out_trade_no){ result result=null;\tint x=0;\twhile(true){ //调用查询接口 .......\ttry { thread.sleep(3000);//间隔三秒 } catch (interruptedexception e) { e.printstacktrace(); }\t//为了不让循环无休止地运行，我们定义一个循环变量，如果这个变量超过了这个值则退出循环，设置时间为5分钟 x++; if(x\u0026gt;=100){ result=new result(false, statuscode.error, \u0026#34;二维码超时\u0026#34;); break; } } return result; } 访问：http://localhost:9009/pay/querypaystatus?out_trade_no=1394204936316682240，并扫描预下单时生成的二维码，进行支付。返回支付成功\n长时间没有返回结果返回二维码超时： 五 支付日志 1 需求分析 我们现在系统还有个问题需要解决：系统中无法查询到支付记录，支付后订单状态没有改变\n我们现在就来解决这两个问题。\n1.在用户下订单时，判断如果为支付宝支付，就向支付日志表添加一条记录，信息包括支付总金额、订单id（多个）、用户id 、下单时间等信息，支付状态为0（未支付） 2.生成的支付日志对象放入redis中，以用户id作为key，这样在生成支付二维码时就可以从redis中提取支付日志对象中的金额和订单号。 3.当用户支付成功后，修改支付日志的支付状态为1（已支付），并记录支付宝传递给我们的交易流水号。根据订单id（多个）修改订单的状态为2（已付款）。 2 表结构分析 tb_paylog 支付日志表\n字段 类型 长度 含义 out_trade_no varchar 30 支付订单号 create_time datatime 创建时间 pay_time datatime 支付完成时间 total_fee bigint 支付金额（分） transaction_id varchar 30 交易流水号 trade_state varchar 1 交易状态 pay_type varchar 1 支付类型：1:支付宝2:微信3:网银 order_list varchar 200 订单表id串，用逗号分隔 3 逆向工程 拷贝逆向工程中的相关日志的pojo、feign到dongyimai-order-service-api，拷贝 dao、service、controller到dongyimai-order-service中。 4 插入日志记录 修改dongyimai-order-service工程com.offcn.order.service.impl.orderserviceimpl 的add方法。\n内容：判断如果支付方式为支付宝支付，向数据库插入支付日志记录，并放入redis存储\n完整代码如下：\n@autowired private paylogmapper paylogmapper; /** * @author zdy * 增加order * 金额校验:后台校验 * @param order */ @override public void add(order order){ // 得到购物车数据 list\u0026lt;cart\u0026gt; cartlist = (list\u0026lt;cart\u0026gt;) redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).get(order.getuserid()); list\u0026lt;string\u0026gt; orderidlist=new arraylist\u0026lt;\u0026gt;();//订单id列表 double total_money=0;//总金额 （元） for (cart cart : cartlist) { long orderid = idworker.nextid(); system.out.println(\u0026#34;sellerid:\u0026#34; + cart.getsellerid()); system.out.println(\u0026#34;orderid:\u0026#34; + orderid); order tborder = new order();// 新创建订单对象 tborder.setorderid(orderid);// 订单id tborder.setuserid(order.getuserid());// 用户名 tborder.setpaymenttype(order.getpaymenttype());// 支付类型 tborder.setstatus(\u0026#34;1\u0026#34;);// 状态：未付款 tborder.setcreatetime(new date());// 订单创建日期 tborder.setupdatetime(new date());// 订单更新日期 tborder.setreceiverareaname(order.getreceiverareaname());// 地址 tborder.setreceivermobile(order.getreceivermobile());// 手机号 tborder.setreceiver(order.getreceiver());// 收货人 tborder.setsourcetype(order.getsourcetype());// 订单来源 tborder.setsellerid(cart.getsellerid());// 商家id // 循环购物车明细 double money = 0; for (orderitem orderitem : cart.getorderitemlist()) { orderitem.setid(idworker.nextid()); orderitem.setorderid(orderid);// 订单id orderitem.setsellerid(cart.getsellerid()); money += double.parsedouble(orderitem.gettotalfee());// 金额累加 system.out.println(\u0026#34;orderitem.getid():\u0026#34;+orderitem.getid()); //减少库存 调用goods 微服务的 feign 减少库存 itemfeign.decrcount(order.getuserid()); //保存订单明细到数据库中 orderitemmapper.insert(orderitem); } orderidlist.add(orderid+\u0026#34;\u0026#34;);//添加到订单列表 total_money+=money; tborder.setpayment(money+\u0026#34;\u0026#34;); ordermapper.insert(tborder); } //线上支付，记录订单 if (\u0026#34;1\u0026#34;.equals(order.getpaymenttype())) {//如果是支付宝支付 paylog paylog = new paylog(); string outtradeno = idworker.nextid() + \u0026#34;\u0026#34;;//支付订单号 paylog.setouttradeno(outtradeno);//支付订单号 paylog.setcreatetime(new date());//创建时间 //订单号列表，逗号分隔 string ids = orderidlist.tostring() .replace(\u0026#34;[\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34;]\u0026#34;, \u0026#34;\u0026#34;) .replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;); paylog.setorderlist(ids);//订单号列表，逗号分隔 paylog.setpaytype(order.getpaymenttype());//支付类型 //把元转换成分 system.out.println(\u0026#34;合计金额:\u0026#34; + total_money); bigdecimal total_money1 = bigdecimal.valueof(total_money); bigdecimal cj = bigdecimal.valueof(100d); //高精度乘法 推荐使用 bigdecimal bigdecimal = total_money1.multiply(cj); //低精度计算方式，不推荐使用 double hj = total_money * 100; system.out.println(\u0026#34;合计:\u0026#34; + hj); system.out.println(\u0026#34;高精度处理:\u0026#34; + bigdecimal.tobiginteger().longvalue()); paylog.settotalfee(bigdecimal.tobiginteger().longvalue()); paylog.settradestate(\u0026#34;0\u0026#34;);//支付状态 0 未支付 1已经支付 paylog.setuserid(order.getuserid());//用户id paylogmapper.insert(paylog);//插入到支付日志表 redistemplate.boundhashops(\u0026#34;paylog\u0026#34;).put(order.getuserid(), paylog);//放入缓存 } //增加积分，调用用户微服务的userfeign 增加积分 userfeign.addpoints(10); redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).delete(order.getuserid()); } 修改paylog.java中主键生成的方式为外界输入\n5 读取支付日志 5.1服务接口层 在dongyimai-order-service 工程中创建paylogservice.java, 新增方法\n/** * 根据用户查询paylog * @param userid * @return */ public paylog searchpaylogfromredis(string userid); 5.2服务实现层 dongyimai-order-service的paylogserviceimpl.java实现方法\n/** * 根据用户查询paylog * * @param userid * @return */ @override public paylog searchpaylogfromredis(string userid) { return (paylog) redistemplate.boundhashops(\u0026#34;paylog\u0026#34;).get(userid); } 5.3控制层paylogcontroller /*** * 查询用户的支付日志 * @return */ @apioperation(value = \u0026#34;根据登录用户从redis中查询支付日志\u0026#34;,notes = \u0026#34;查询用户支付日志\u0026#34;,tags = {\u0026#34;ordercontroller\u0026#34;}) @getmapping(\u0026#34;/searchpaylogfromredis\u0026#34;) public result\u0026lt;paylog\u0026gt; searchpaylogfromredis(string userid){ paylog paylog = orderservice.searchpaylogfromredis(userid); return new result\u0026lt;paylog\u0026gt;(true, statuscode.ok,\u0026#34;查询成功\u0026#34;,paylog) ; } 5.4修改paylogfegin @feignclient(name=\u0026#34;order\u0026#34;) public interface paylogfeign { /** 查询用户的支付日志 @return */ @getmapping(\u0026#34;/paylog/searchpaylogfromredis\u0026#34;) public result\u0026lt;paylog\u0026gt; searchpaylogfromredis(@requestparam(\u0026#34;userid\u0026#34;) string userid); .... 5.5引入依赖 在dongyimai-pay-service中引入dongyimai-order-service-api的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-order-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 5.6修改启动类 修改dongyimai-pay-service启动类 payapplication.java\n@springbootapplication(exclude={datasourceautoconfiguration.class}) @enablefeignclients(basepackages = {\u0026#34;com.offcn.order.feign\u0026#34;}) @enableeurekaclient public class payapplication { public static void main(string[] args) { springapplication.run(payapplication.class); } } 5.7 修改控制器paycontroller 修改dongyimai-pay-service工程paycontroller.java的createnative方法\n实现思路：调用获取支付日志对象的方法，得到订单号和金额\n@autowired private paylogfeign paylogfeign; /** * 生成二维码 * * @return */ @getmapping(\u0026#34;/createnative\u0026#34;) public map createnative() { //获取用户名 map\u0026lt;string, string\u0026gt; usermap = tokendecode.getuserinfo(); string username = usermap.get(\u0026#34;user_name\u0026#34;); system.out.println(\u0026#34;当前登录用户:\u0026#34;+username); //到redis查询支付日志 result\u0026lt;paylog\u0026gt; paylogresult = paylogfeign.searchpaylogfromredis(username); paylog paylog = paylogresult.getdata(); //判断支付日志存在 if(paylog!=null){ return alipayservice.createnative(paylog.getouttradeno(),paylog.gettotalfee()+\u0026#34;\u0026#34;); }else{ return new hashmap(); } } 6 修改订单状态 订单支付成功后，需要修改日志记录支付交易流水号并持久化到数据库，并且修改订单的支付状态，然后将redis中的订单删除：\n6.1服务接口层 修改com.offcn.order.service.orderservice，添加修改订单状态方法，代码如下：\n/*** * 根据订单id修改订单状态 * @param transactionid 交易流水号 * @param orderid */ public void updatestatus(string out_trade_no,string transactionid); 6.2服务实现层 修改com.offcn.order.service.impl.orderserviceimpl，添加修改订单状态实现方法，代码如下：\n/** * 修改订单状态 * * @param out_trade_no 支付订单号 * @param transaction_id 支付宝返回的交易流水号 */ @override public void updatestatus(string out_trade_no, string transaction_id) { //1.修改支付日志状态 paylog paylog = paylogmapper.selectbyid(out_trade_no); paylog.setpaytime(new date()); paylog.settradestate(\u0026#34;1\u0026#34;);//已支付 paylog.settransactionid(transaction_id);//交易号 paylogmapper.updatebyid(paylog); //2.修改订单状态 string orderlist = paylog.getorderlist();//获取订单号列表 string[] orderids = orderlist.split(\u0026#34;,\u0026#34;);//获取订单号数组 for(string orderid:orderids){ order order = ordermapper.selectbyid( long.parselong(orderid) ); if(order!=null){ order.setstatus(\u0026#34;2\u0026#34;);//已付款 ordermapper.updatebyid(order); } } //3、清除redis缓存数据\tredistemplate.boundhashops(\u0026#34;paylog\u0026#34;).delete(paylog.getuserid()); } 6.3控制层ordercontroller /** * 修改订单的状态 * @param out_trade_no * @param transaction_id * @return */ @apioperation(value = \u0026#34;修改订单的状态\u0026#34;,notes = \u0026#34;修改订单的状态\u0026#34;,tags = {\u0026#34;ordercontroller\u0026#34;}) @requestmapping(value=\u0026#34;/updateorderstatus\u0026#34;,method = requestmethod.get) public result updateorderstatus( @requestparam(value=\u0026#34;out_trade_no\u0026#34;) string out_trade_no, @requestparam(value=\u0026#34;transaction_id\u0026#34;) string transaction_id){ try { orderservice.updatestatus(out_trade_no,transaction_id); return new result(true,statuscode.ok,\u0026#34;修改成功\u0026#34;); } catch (exception e) { e.printstacktrace(); return new result(false,statuscode.error,\u0026#34;修改失败\u0026#34;); } } 6.4修改orderfeign /** * 修改订单状态 * @param out_trade_no * @param transaction_id * @return */ @requestmapping(value = \u0026#34;/updateorderstatus\u0026#34;,method = requestmethod.get) public result updatestatus( @requestparam(value=\u0026#34;out_trade_no\u0026#34;) string out_trade_no, @requestparam(value=\u0026#34;transaction_id\u0026#34;) string transaction_id); 6.5修改paycontroller 修改com.offcn.pay.controller.paycontroller中查询交易状态的方法querypaystatus， 支付成功调用orderfeign修改订单的状态以及日志信息，代码如下：\nif(map.get(\u0026#34;tradestatus\u0026#34;)!=null\u0026amp;\u0026amp;map.get(\u0026#34;tradestatus\u0026#34;).equals(\u0026#34;trade_success\u0026#34;)){ //如果成功 result=new result(true,statuscode.ok,\u0026#34;支付成功\u0026#34;); orderfeign.updatestatus(map.get(\u0026#34;out_trade_no\u0026#34;),map.get(\u0026#34;trade_no\u0026#34;)); break; } 7.dongyimai-pay-service集成springsecurity环境及网关配置 7.1 pom.xml加入如下依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-order-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--oauth依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 7.2 引入公钥和验证文件 将public.key和文件resourceserverconfig拷贝到dongyimai-pay-service中，参考其他项目\n7.3 引入feigninterceptor 在paycontroller引入feigninterceptor\n@bean public feigninterceptor feigninterceptor(){ return new feigninterceptor(); } 7.4、修改网关配置，路由转发到支付微服务 application.yml\n- id: dongyimai_pay_route #支付微服务 uri: lb://pay predicates: - path=/api/pay/** filters: - stripprefix=1 8.测试 8.1用户登录 8.2 添加购物车 http://localhost:8001/api/cart/addgoodstocartlist?itemid=1324601\u0026amp;num=5\n8.3查询购物车 http://localhost:8001/api/cart/findcartlist\n8.4提交订单 http://localhost:8001/api/order/\n8.5 查询redis 8.6查询数据库 8.7 预下单 http://localhost:8001/api/pay/createnative\n8.8生成二维码 8.9 扫描支付并查询交易状态 8.10查看数据库： 订单状态也已经被修改为1\n六 支付日志显示（学员实现） 需求：在运营商后台中，显示支付日志列表，实现按日期、状态、用户进行查询。\n学员实现。\n","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project-0/20220528172145/","summary":"第十四章 支付宝支付 优就业.JAVA教研室 学习目标 目标1：掌握二维码生成插件qrious的使用 目标2：能够说出支付宝支付开发的整体思路 目标3：能够调用支付宝支付接","title":"支付宝支付"},{"content":"第十五章 秒杀1 优就业.java教研室 学习目标 秒杀业务分析 秒杀商品压入redis缓存 spring定时任务了解-定时将秒杀商品存入到redis中 秒杀商品频道页实现-秒杀商品列表页 秒杀商品详情页实现 下单实现(普通下单) 多线程异步抢单实现-队列削峰 1 秒杀业务分析 1.1 需求分析 所谓“秒杀”，就是网络卖家发布一些超低价格的商品，所有买家在同一时间网上抢购的一种销售方式。通俗一点讲就是网络商家为促销等目的组织的网上限时抢购活动。由于商品价格低廉，往往一上架就被抢购一空，有时只用一秒钟。\n秒杀商品通常有两种限制：库存限制、时间限制。\n需求：\n（1）录入秒杀商品数据，主要包括：商品标题、原价、秒杀价、商品图片、介绍、秒杀时段等信息 （2）秒杀频道首页列出秒杀商品（进行中的）点击秒杀商品图片跳转到秒杀商品详细页。 （3）商品详细页显示秒杀商品信息，点击立即抢购实现秒杀下单，下单时扣减库存。当库存为0或不在活动期范围内时无法秒杀。 （4）秒杀下单成功，直接跳转到支付页面（扫码），支付成功，跳转到成功页，填写收货地址、电话、收件人等信息，完成订单。 （5）当用户秒杀下单5分钟内未支付，取消预订单，调用支付的关闭订单接口，恢复库存。 1.2 表结构说明 秒杀商品信息表\ncreate table `tb_seckill_goods` ( `id` bigint(20) not null auto_increment, `goods_id` bigint(20) default null comment \u0026#39;spu id\u0026#39;, `item_id` bigint(20) default null comment \u0026#39;sku id\u0026#39;, `title` varchar(100) default null comment \u0026#39;标题\u0026#39;, `small_pic` varchar(150) default null comment \u0026#39;商品图片\u0026#39;, `price` decimal(10,2) default null comment \u0026#39;原价格\u0026#39;, `cost_price` decimal(10,2) default null comment \u0026#39;秒杀价格\u0026#39;, `create_time` datetime default null comment \u0026#39;添加日期\u0026#39;, `check_time` datetime default null comment \u0026#39;审核日期\u0026#39;, `status` char(1) default null comment \u0026#39;审核状态，0未审核，1审核通过，2审核不通过\u0026#39;, `start_time` datetime default null comment \u0026#39;开始时间\u0026#39;, `end_time` datetime default null comment \u0026#39;结束时间\u0026#39;, `num` int(11) default null comment \u0026#39;秒杀商品数\u0026#39;, `stock_count` int(11) default null comment \u0026#39;剩余库存数\u0026#39;, `introduction` varchar(2000) default null comment \u0026#39;描述\u0026#39;, primary key (`id`) ) engine=innodb auto_increment=1 default charset=utf8; 秒杀订单表\ncreate table `tb_seckill_order` ( `id` bigint(20) not null comment \u0026#39;主键\u0026#39;, `seckill_id` bigint(20) default null comment \u0026#39;秒杀商品id\u0026#39;, `money` decimal(10,2) default null comment \u0026#39;支付金额\u0026#39;, `user_id` varchar(50) default null comment \u0026#39;用户\u0026#39;, `create_time` datetime default null comment \u0026#39;创建时间\u0026#39;, `pay_time` datetime default null comment \u0026#39;支付时间\u0026#39;, `status` char(1) default null comment \u0026#39;状态，0未支付，1已支付\u0026#39;, `receiver_address` varchar(200) default null comment \u0026#39;收货人地址\u0026#39;, `receiver_mobile` varchar(20) default null comment \u0026#39;收货人电话\u0026#39;, `receiver` varchar(20) default null comment \u0026#39;收货人\u0026#39;, `transaction_id` varchar(30) default null comment \u0026#39;交易流水\u0026#39;, primary key (`id`) ) engine=innodb default charset=utf8; 1.3 秒杀需求分析 秒杀技术实现核心思想是运用缓存减少数据库瞬间的访问压力！读取商品详细信息时运用缓存，当用户点击抢购时减少缓存中的库存数量，当库存数为0时或活动期结束时，同步到数据库。 产生的秒杀预订单也不会立刻写到数据库中，而是先写到缓存，当用户付款成功后再写入数据库。\n当然，上面实现的思路只是一种最简单的方式，并未考虑其中一些问题，例如并发状况容易产生的问题。我们看看下面这张思路更严谨的图： 2 秒杀商品压入缓存 我们这里秒杀商品列表和秒杀商品详情都是从redis中取出来的，所以我们首先要将符合参与秒杀的商品定时查询出来，并将数据存入到redis缓存中。\n数据存储类型我们可以选择hash类型。\n秒杀分页列表这里可以通过获取redistemplate.boundhashops(key).values()获取结果数据。\n秒杀商品详情，可以通过redistemplate.boundhashops(key).get(key)获取详情。\n2.1 秒杀服务工程 我们将商品数据压入到reids缓存，可以在秒杀工程的服务工程中完成，可以按照如下步骤实现：\n1.查询活动没结束的所有秒杀商品 1)状态必须为审核通过 status=1 2)商品库存个数\u0026gt;0 3)活动没有结束 endtime\u0026gt;=now() 4)在redis中没有该商品的缓存 5)执行查询获取对应的结果集 2.将活动没有结束的秒杀商品入库 我们首先搭建一个秒杀服务工程，然后按照上面步骤实现。\n搭建dongyimai-seckill-service，作为秒杀工程的服务提供工程。\n(1)pom.xml依赖\npom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-seckill-service\u0026lt;/artifactid\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-seckill-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; (2) application.yml配置\nserver: port: 9005 spring: application: name: seckill datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql://192.168.188.1:3306/dongyimaidb?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=utc username: root password: root rabbitmq: host: 192.168.188.128 #mq的服务器地址 username: guest #账号 password: guest #密码 main: allow-bean-definition-overriding: true eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true #hystrix 配置 hystrix: command: default: execution: timeout: #如果enabled设置为false，则请求超时交给ribbon控制 enabled: true isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore (3) 导入生成文件\n将生成的dao文件和pojo文件导入到工程中，如下图： (4) 启动类配置\n@springbootapplication @enableeurekaclient @enablefeignclients @mapperscan(basepackages = {\u0026#34;com.offcn.seckill.dao\u0026#34;}) @enablescheduling public class seckillapplication { public static void main(string[] args) { springapplication.run(seckillapplication.class,args); } @bean public idworker idworker(){ return new idworker(1,1); } } 2.2 定时任务 一会儿我们采用spring的定时任务定时将符合参与秒杀的商品查询出来再存入到redis缓存，所以这里需要使用到定时任务。\n这里我们了解下定时任务相关的配置,配置步骤如下：\n1)在定时任务类的指定方法上加上@scheduled开启定时任务 2)定时任务表达式：使用cron属性来配置定时任务执行时间 2.2.1 定时任务方法配置 创建com.offcn.seckill.timer.seckillgoodspushtask类，并在类中加上定时任务执行方法，代码如下：\n@component public class seckillgoodspushtask { /**** * 每30秒执行一次 */ @scheduled(cron = \u0026#34;0/30 * * * * *\u0026#34;) public void loadgoodspushredis(){ system.out.println(\u0026#34;task demo\u0026#34;); } } 2.2.2 定时任务常用时间表达式 crontrigger配置完整格式为： [秒][分] [小时][日] [月][周] [年]\n序号 说明 是否必填 允许填写的值 允许的通配符 1 秒 是 0-59 , - * / 2 分 是 0-59 , - * / 3 小时 是 0-23 , - * / 4 日 是 1-31 , - * ? / l w 5 月 是 1-12或jan-dec , - * / 6 周 是 1-7或sun-sat , - * ? / l w 7 年 否 empty 或1970-2099 , - * / 使用说明：\n通配符说明: * 表示所有值. 例如:在分的字段上设置 \u0026#34;*\u0026#34;,表示每一分钟都会触发。 ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。 例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为\u0026#34;?\u0026#34; 具体设置为 0 0 0 10 * ? - 表示区间。例如 在小时上设置 \u0026#34;10-12\u0026#34;,表示 10,11,12点都会触发。 , 表示指定多个值，例如在周字段上设置 \u0026#34;mon,wed,fri\u0026#34; 表示周一，周三和周五触发 12,14,19 / 用于递增触发。如在秒上面设置\u0026#34;5/15\u0026#34; 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置\u0026#39;1/3\u0026#39;所示每月1号开始，每隔三天触发一次。 l 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于\u0026#34;7\u0026#34;或\u0026#34;sat\u0026#34;。如果在\u0026#34;l\u0026#34;前加上数字，则表示该数据的最后一个。例如在周字段上设置\u0026#34;6l\u0026#34;这样的格式,则表示“本月最后一个星期五\u0026#34; w 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置\u0026#34;15w\u0026#34;，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 \u0026#34;1w\u0026#34;,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，\u0026#34;w\u0026#34;前只能设置具体的数字,不允许区间\u0026#34;-\u0026#34;). # 序号(表示每月的第几个周几)，例如在周字段上设置\u0026#34;6#3\u0026#34;表示在每月的第三个周六.注意如果指定\u0026#34;#5\u0026#34;,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ； 常用表达式\n0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 12 ? * wed 表示每个星期三中午12点 \u0026#34;0 0 12 * * ?\u0026#34; 每天中午12点触发 \u0026#34;0 15 10 ? * *\u0026#34; 每天上午10:15触发 \u0026#34;0 15 10 * * ?\u0026#34; 每天上午10:15触发 \u0026#34;0 15 10 * * ? *\u0026#34; 每天上午10:15触发 \u0026#34;0 15 10 * * ? 2005\u0026#34; 2005年的每天上午10:15触发 \u0026#34;0 * 14 * * ?\u0026#34; 在每天下午2点到下午2:59期间的每1分钟触发 \u0026#34;0 0/5 14 * * ?\u0026#34; 在每天下午2点到下午2:55期间的每5分钟触发 \u0026#34;0 0/5 14,18 * * ?\u0026#34; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 \u0026#34;0 0-5 14 * * ?\u0026#34; 在每天下午2点到下午2:05期间的每1分钟触发 \u0026#34;0 10,44 14 ? 3 wed\u0026#34; 每年三月的星期三的下午2:10和2:44触发 \u0026#34;0 15 10 ? * mon-fri\u0026#34; 周一至周五的上午10:15触发 \u0026#34;0 15 10 15 * ?\u0026#34; 每月15日上午10:15触发 \u0026#34;0 15 10 l * ?\u0026#34; 每月最后一日的上午10:15触发 \u0026#34;0 15 10 ? * 6l\u0026#34; 每月的最后一个星期五上午10:15触发 \u0026#34;0 15 10 ? * 6l 2002-2005\u0026#34; 2002年至2005年的每月的最后一个星期五上午10:15触发 \u0026#34;0 15 10 ? * 6#3\u0026#34; 每月的第三个星期五上午10:15触发 2.3 秒杀商品压入缓存实现 2.3.1 数据检索条件分析 按照2.1中的几个步骤实现将秒杀商品从数据库中查询出来，并存入到redis缓存\n1.查询活动没结束的所有秒杀商品 1)计算秒杀时间段 2)状态必须为审核通过 status=1 3)商品库存个数\u0026gt;0 4)活动没有结束 endtime\u0026gt;now() 5)在redis中没有该商品的缓存 6)执行查询获取对应的结果集 2.将活动没有结束的秒杀商品入库 上面这里会涉及到时间操作，所以这里提前准备了一个时间工具包dateutil。\n2.3.2 时间菜单分析 我们将商品数据从数据库中查询出来，并存入redis缓存，但页面每次显示的时候，只显示当前正在秒杀以及往后延时2个小时、4个小时、6个小时、8个小时的秒杀商品数据。我们要做的第一个事是计算出秒杀时间菜单，这个菜单是从后台获取的。\n这个时间菜单的计算我们来分析下，可以先求出当前时间的凌晨，然后每2个小时后作为下一个抢购的开始时间，这样可以分出12个抢购时间段,如下：\n00:00-02:00 02:00-04:00 04:00-06:00 06:00-08:00 08:00-10:00 10:00-12:00 12:00-14:00 14:00-16:00 16:00-18:00 18:00-20:00 20:00-22:00 22:00-00:00 而现实的菜单只需要计算出当前时间在哪个时间段范围，该时间段范围就属于正在秒杀的时间段，而后面即将开始的秒杀时间段的计算也就出来了，可以在当前时间段基础之上+2小时、+4小时、+6小时、+8小时。\n关于时间菜单的运算，在给出的dateutil包里已经实现，代码如下：\npublic class dateutil { //给定一个date转换成指定格式的字符串 public static string date2strfull(date date){ simpledateformat dateformat = new simpledateformat(\u0026#34;yyyy-mm-dd hh:mm:ss\u0026#34;); return dateformat.format(date); } //把date转换成年月日时的字符串 public static string date2str(date date){ simpledateformat dateformat = new simpledateformat(\u0026#34;yyyymmddhh\u0026#34;); return dateformat.format(date); } //获取指定date的 当前日期的 00：00：00的date对象 public static date todaystarthour(date date){ calendar calendar = calendar.getinstance(); calendar.settime(date); //拨动表盘 calendar.set(calendar.hour_of_day, 0); calendar.set(calendar.minute, 0); calendar.set(calendar.second, 0); calendar.set(calendar.millisecond, 0); date start = calendar.gettime(); return start; } /*** * 时间递增n小时 * @param hour * @return */ public static date adddatehour(date date,int hour){ calendar calendar = calendar.getinstance(); calendar.settime(date); calendar.add(calendar.hour, hour);// 24小时制 date = calendar.gettime(); return date; } //获取指定数量n个时间段 public static list\u0026lt;date\u0026gt; getdates(int hours){ //创建集合 list\u0026lt;date\u0026gt; dates=new arraylist\u0026lt;\u0026gt;(); //获取当前系统时间，的凌晨时间对象 date date = todaystarthour(new date()); //2021-09-08 00:00:00 //2021-09-08 02:00:00 //2021-09-08 04:00:00 for (int i = 0; i \u0026lt;hours ; i++) { dates.add(adddatehour(date,i*2)); } return dates; } //获取当前时间端和往后4个的时间段 public static list\u0026lt;date\u0026gt; getdatemenus(){ //获取12个时间 list\u0026lt;date\u0026gt; datelist = getdates(12); //获取当前系统时间 date now = new date(); //遍历12个时间段，和当前系统时间比对，看当前系统时间属于哪个时间段 for (date date : datelist) { if(date.gettime()\u0026lt;=now.gettime()\u0026amp;\u0026amp;now.gettime()\u0026lt;adddatehour(date,2).gettime()){ now=date; break; } } //处理要显示时间段 list\u0026lt;date\u0026gt; datemenus=new arraylist\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt;5 ; i++) { datemenus.add(adddatehour(now,i*2)); } return datemenus; } public static void main(string[] args) { /*list\u0026lt;date\u0026gt; datelist = dateutil.getdates(12); for (date date : datelist) { system.out.println(dateutil.date2strfull(date)); }*/ list\u0026lt;date\u0026gt; datemenus = dateutil.getdatemenus(); for (date datemenu : datemenus) { system.out.println(dateutil.date2strfull(datemenu)); } } } 2.3.3 查询秒杀商品导入reids 我们可以写个定时任务，查询从当前时间开始，往后延续4个时间菜单间隔，也就是一共只查询5个时间段抢购商品数据，并压入缓存，实现代码如下：\n修改seckillgoodspushtask的loadgoodspushredis方法，代码如下：\n/**** * 每30秒执行一次 */ @scheduled(cron = \u0026#34;0/30 * * * * ?\u0026#34;) public void loadgoodspushredis(){ //获得时间段集合 list\u0026lt;date\u0026gt; datemenus = dateutil.getdatemenus(); //循环时间段集合 for (date starttime : datemenus) { //提取开始时间，转换为年月日格式的字符串 string extname = dateutil.date2str(starttime); //创建查询条件对象 querywrapper\u0026lt;seckillgoods\u0026gt; querywrapper = new querywrapper\u0026lt;\u0026gt;(); //设置查询条件 1)商品必须审核通过 status=1 querywrapper.eq(\u0026#34;status\u0026#34;,\u0026#34;1\u0026#34;); //2)库存大于0 querywrapper.gt(\u0026#34;stock_count\u0026#34;,0); //3)开始时间\u0026lt;=活动开始时间（数据库） querywrapper.ge(\u0026#34;start_time\u0026#34;,dateutil.date2strfull(starttime)); //4)活动结束时间\u0026lt;开始时间+2小时 querywrapper.lt(\u0026#34;end_time\u0026#34;,dateutil.date2strfull(dateutil.adddatehour(starttime,2))); //5)读取redis中存在的当天的秒杀商品 set keys = redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34;+extname).keys(); //判断keys不为空，就设置排除条件 if(keys!=null\u0026amp;\u0026amp;keys.size()\u0026gt;0){ querywrapper.notin(\u0026#34;id\u0026#34;,keys); } //查询符合条件的数据库 list\u0026lt;seckillgoods\u0026gt; seckillgoodslist = seckillgoodsmapper.selectlist(querywrapper); //遍历查询到数据集合,存储数据到redis for (seckillgoods seckillgoods : seckillgoodslist) { redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34;+extname).put(seckillgoods.getid(),seckillgoods); //设置超时时间2小时 redistemplate.expireat(\u0026#34;seckillgoods_\u0026#34;+extname,dateutil.adddatehour(starttime,2)); } } } redis数据如下： 3 秒杀频道页 秒杀频道首页，显示正在秒杀的和未开始秒杀的商品（已经开始或者还没开始，未结束的秒杀商品）\n3.1 秒杀时间菜单 如上图，时间菜单需要根据当前时间动态加载，时间菜单的计算上面功能中已经实现，在dateutil工具包中。我们只需要将时间菜单获取，然后响应到页面，页面根据对应的数据显示即可。\n创建com.offcn.seckill.controller.seckillgoodscontroller，并添加菜单获取方法，代码如下：\n@restcontroller @requestmapping(\u0026#34;/seckillgoods\u0026#34;) @crossorigin public class seckillgoodscontroller { /***** * 获取时间菜单 * urll:/seckill/goods/menus */ @requestmapping(value = \u0026#34;/menus\u0026#34;) public list\u0026lt;date\u0026gt; datemenus(){ return dateutil.getdatemenus(); } } 使用postman测试，效果如下：\nhttp://localhost:9005/seckillgoods/menus 访问方向显示的时间段和当前时间相差八个小时，需要设置时区\n修改配置文件application.yml设置json转换时区\nspring: jackson: time-zone: gmt+8 3.2 秒杀频道页 秒杀频道页是指将对应时区的秒杀商品从reids缓存中查询出来，并到页面显示。对应时区秒杀商品存储的时候以hash类型进行了存储，key=seckillgoods_2019010112，value=每个商品详情。\n每次用户在前端点击对应时间菜单的时候，可以将时间菜单的开始时间以yyyymmddhh格式提交到后台，后台根据时间格式查询出对应时区秒杀商品信息。\n3.2.1 业务层 创建com.offcn.seckill.service.seckillgoodsservice,添加根据时区查询秒杀商品的方法，代码如下：\npublic interface seckillgoodsservice { /*** * 获取指定时间对应的秒杀商品列表 * @param key */ list\u0026lt;seckillgoods\u0026gt; list(string key); } 创建com.offcn.seckill.service.impl.seckillgoodsserviceimpl，实现根据时区查询秒杀商品的方法，代码如下：\n@service public class seckillgoodsserviceimpl implements seckillgoodsservice { @autowired private redistemplate redistemplate; /*** * redis中根据key获取秒杀商品列表 * @param key * @return */ @override public list\u0026lt;seckillgoods\u0026gt; list(string key) { return redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34;+key).values(); } } 3.2.2 控制层 修改com.offcn.seckill.controller.seckillgoodscontroller，并添加秒杀商品查询方法，代码如下：\n@autowired private seckillgoodsservice seckillgoodsservice; /**** * url:/seckillgoods/list * 对应时间段秒杀商品集合查询 * 调用service查询数据 * @param time:2019050716 */ @requestmapping(value = \u0026#34;/list\u0026#34;) public list\u0026lt;seckillgoods\u0026gt; list(string time){ //调用service查询数据 return seckillgoodsservice.list(time); } 使用postman测试，效果如下：\nhttp://localhost:9005/seckillgoods/list?time=2019052414 4 秒杀详情页 通过秒杀频道页点击请购按钮，会跳转到商品秒杀详情页，秒杀详情页需要根据商品id查询商品详情，我们可以在频道页点击秒杀抢购的时候将id一起传到后台，然后根据id去redis中查询详情信息。\n4.1 业务层 修改com.offcn.seckill.service.seckillgoodsservice，添加如下方法实现查询秒杀商品详情,代码如下：\n/**** * 根据id查询商品详情 * @param time:时间区间 * @param id:商品id */ seckillgoods one(string time,long id); 修改com.offcn.seckill.service.impl.seckillgoodsserviceimpl，添加查询秒杀商品详情，代码如下：\n/**** * 根据商品id查询商品详情 * @param time:时间区间 * @param id:商品id * @return */ @override public seckillgoods one(string time, long id) { return (seckillgoods) redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34;+time).get(id); } 4.2 控制层 修改com.offcn.seckill.controller.seckillgoodscontroller，添加如下方法实现查询秒杀商品详情，代码如下：\n/**** * url:/seckillgoods/one * 根据id查询商品详情 * 调用service查询商品详情 * @param time * @param id */ @requestmapping(value = \u0026#34;/one\u0026#34;) public seckillgoods one(string time,long id){ //调用service查询商品详情 return seckillgoodsservice.one(time,id); } 使用postman测试，效果如下：\nhttp://localhost:9005/seckillgoods/one?id=1\u0026amp;time=2019052414 5 下单实现 用户下单，从控制层-\u0026gt;service层-\u0026gt;dao层，所以我们先把dao创建好，再创建service层，再创建控制层。\n用户下单，为了提升下单速度，我们将订单数据存入到redis缓存中，如果用户支付了，则将reids缓存中的订单存入到mysql中，并清空redis缓存中的订单。\n5.1 业务层 创建com.offcn.seckill.service.seckillorderservice，并在接口中增加下单方法，代码如下：\npublic interface seckillorderservice { /*** * 添加秒杀订单 * @param id:秒杀商品id * @param time:商品秒杀开始时间 * @param username:用户登录名 * @return */ boolean add(long id, string time, string username); } 创建com.offcn.seckill.service.impl.seckillorderserviceimpl实现类，并在类中添加下单实现方法，代码如下：\n@service public class seckillorderserviceimpl implements seckillorderservice { @autowired private redistemplate redistemplate; @autowired private seckillgoodsmapper seckillgoodsmapper; @autowired private idworker idworker; /**** * 添加订单 * @param id * @param time * @param username */ @override public boolean add(long id, string time, string username){ //获取商品数据 seckillgoods goods = (seckillgoods) redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).get(id); //如果没有库存，则直接抛出异常 if(goods==null || goods.getstockcount()\u0026lt;=0){ throw new runtimeexception(\u0026#34;已售罄!\u0026#34;); } //如果有库存，则创建秒杀商品订单 seckillorder seckillorder = new seckillorder(); seckillorder.setid(idworker.nextid()); seckillorder.setseckillid(id); seckillorder.setmoney(goods.getcostprice()); seckillorder.setuserid(username); seckillorder.setcreatetime(new date()); seckillorder.setstatus(\u0026#34;0\u0026#34;); //将秒杀订单存入到redis中 redistemplate.boundhashops(\u0026#34;seckillorder\u0026#34;).put(username,seckillorder); //库存减少 goods.setstockcount(goods.getstockcount()-1); //判断当前商品是否还有库存 if(goods.getstockcount()\u0026lt;=0){ //并且将商品数据同步到mysql中 seckillgoodsmapper.updatebyid(goods); //如果没有库存,则清空redis缓存中该商品 redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).delete(id); }else{ //如果有库存，则直数据重置到reids中 redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).put(id,goods); } return true; } } 5.2 控制层 创建com.offcn.seckill.controller.seckillordercontroller，添加下单方法，代码如下：\n@restcontroller @crossorigin @requestmapping(value = \u0026#34;/seckillorder\u0026#34;) public class seckillordercontroller { @autowired private seckillorderservice seckillorderservice; /**** * url:/seckillorder/add * 添加订单 * 调用service增加订单 * 匿名访问：anonymoususer * @param time * @param id */ @requestmapping(value = \u0026#34;/add\u0026#34;) public result add(string time, long id){ try { //用户登录名 string username = tokendcode.getuserinfo().get(\u0026#34;user_name\u0026#34;); //调用service增加订单 boolean bo = seckillorderservice.add(id, time, username); if(bo){ //抢单成功 return new result(true,statuscode.ok,\u0026#34;抢单成功！\u0026#34;); } } catch (exception e) { e.printstacktrace(); return new result(true,statuscode.error,e.getmessage()); } return new result(true,statuscode.error,\u0026#34;服务器繁忙，请稍后再试\u0026#34;); } } 5.3、整合gateway网关、配置资源服务器 5.3.1、修改项目dongyimai-seckill-service引入依赖 \u0026lt;!--oauth依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 5.3.2、拷贝公钥、以及资源服务器配置类文件 5.3.3、修改网关配置文件，增加秒杀微服务转发 - id: dongyimai_seckill_route uri: lb://seckill predicates: - path=/api/seckillgoods/**,/api/seckillorder/** filters: - stripprefix=1 测试秒杀下单：\nhttp://localhost:8001/api/seckillorder/add?time=2021061820\u0026amp;id=1\n{ flag: true, code: 20000, message: \u0026#34;秒杀成功\u0026#34;, data: null } 问题分析:\n上述功能完成了秒杀抢单操作，但没有解决并发相关的问题，例如并发、超卖现象，这块甚至有可能产生雪崩问题。\n6 多线程抢单 6.1 实现思路分析 在现实秒杀中，操作一般都是比较复杂的，而且并发量特别高，比如，检查当前账号操作是否已经秒杀过该商品，检查该账号是否存在存在刷单行为，记录用户操作日志等。\n下订单这里，我们一般采用多线程下单，但多线程中我们又需要保证用户抢单的公平性，也就是先抢先下单。我们可以这样实现，用户进入秒杀抢单，如果用户符合抢单资格，只需要记录用户抢单数据，存入队列，多线程从队列中进行消费即可，存入队列采用左压，多线程下单采用右取的方式。\n6.2 异步实现 要想使用spring的异步操作，需要先开启异步操作，用@enableasync注解开启，然后在对应的异步方法上添加注解@async即可。\n创建com.offcn.seckill.task.multithreadingcreateorder类，在类中创建一个createorder方法，并在方法上添加@async,代码如下：\n@component public class multithreadingcreateorder { /*** * 多线程下单操作 */ @async public void createorder(){ try { system.out.println(\u0026#34;准备执行....\u0026#34;); thread.sleep(20000); system.out.println(\u0026#34;开始执行....\u0026#34;); } catch (interruptedexception e) { e.printstacktrace(); } } } 上面createorder方法进行了休眠阻塞操作，我们在下单的方法调用createorder方法，如果下单的方法没有阻塞，继续执行，说明属于异步操作，如果阻塞了，说明没有执行异步操作。\n修改秒杀抢单seckillorderserviceimpl代码，注入multithreadingcreateorder,并调用createorder方法，代码如下： 注意async需要在主启动开启 使用postman测试如下：\nhttp://localhost:8001/api/seckillorder/add?id=1\u0026amp;time=2021061820 界面已经显示了结果，控制台还没有执行输出，异步方式完成任务。\n6.3 多线程抢单 用户每次下单的时候，我们都让他们先进行排队，然后采用多线程的方式创建订单，排队我们可以采用redis的队列实现，多线程下单我们可以采用spring的异步实现。\n6.3.1 多线程下单 将之前下单的代码全部挪到多线程的方法中，com.offcn.seckill.service.impl.seckillorderserviceimpl类的方法值负责调用即可，代码如下： 多线程下单代码如下图： 上图代码如下：\n@component public class multithreadingcreateorder { @autowired private redistemplate redistemplate; @autowired private seckillgoodsmapper seckillgoodsmapper; @autowired private idworker idworker; /*** * 多线程下单操作 */ @async public void createorder(){ try { //时间区间 string time = \u0026#34;2019052510\u0026#34;; //用户登录名 string username=\u0026#34;offcn1234\u0026#34;; //用户抢购商品 long id = 1131814847898587136l; //获取商品数据 seckillgoods goods = (seckillgoods) redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).get(id); //如果没有库存，则直接抛出异常 if(goods==null || goods.getstockcount()\u0026lt;=0){ throw new runtimeexception(\u0026#34;已售罄!\u0026#34;); } //如果有库存，则创建秒杀商品订单 seckillorder seckillorder = new seckillorder(); seckillorder.setid(idworker.nextid()); seckillorder.setseckillid(id); seckillorder.setmoney(goods.getcostprice()); seckillorder.setuserid(username); seckillorder.setcreatetime(new date()); seckillorder.setstatus(\u0026#34;0\u0026#34;); //将秒杀订单存入到redis中 redistemplate.boundhashops(\u0026#34;seckillorder\u0026#34;).put(username,seckillorder); //库存减少 goods.setstockcount(goods.getstockcount()-1); //判断当前商品是否还有库存 if(goods.getstockcount()\u0026lt;=0){ //并且将商品数据同步到mysql中 seckillgoodsmapper.updatebyprimarykeyselective(goods); //如果没有库存,则清空redis缓存中该商品 redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).delete(id); }else{ //如果有库存，则直数据重置到reids中 redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).put(id,goods); } } catch (exception e) { e.printstacktrace(); } } } 此时测试，是可以正常下单的，但是用户名和订单都写死了，此处需要继续优化。\nhttp://localhost:8001/api/seckillorder/add?id=1\u0026amp;time=2021061820\n6.3.2 排队下单 6.3.2.1 排队信息封装 用户每次下单的时候，我们可以创建一个队列进行排队，然后采用多线程的方式创建订单，排队我们可以采用redis的队列实现。 排队信息中需要有用户抢单的商品信息，主要包含商品id，商品抢购时间段，用户登录名。我们可以设计个javabean，如下：\npublic class seckillstatus implements serializable { //秒杀用户名 private string username; //创建时间 private date createtime; //秒杀状态 1:排队中，2:秒杀等待支付,3:支付超时，4:秒杀失败,5:支付完成 private integer status; //秒杀的商品id private long goodsid; //应付金额 private float money; //订单号 private long orderid; //时间段 private string time; public seckillstatus() { } public seckillstatus(string username, date createtime, integer status, long goodsid, string time) { this.username = username; this.createtime = createtime; this.status = status; this.goodsid = goodsid; this.time = time; } //get、set...略 } 6.3.2.2 排队实现 我们可以将秒杀抢单信息存入到redis中,这里采用list方式存储,list本身是一个队列，用户点击抢购的时候，就将用户抢购信息存入到redis中，代码如下：\n@service public class seckillorderserviceimpl implements seckillorderservice { @autowired private multithreadingcreateorder multithreadingcreateorder; @autowired private redistemplate redistemplate; /**** * 添加订单 * @param id * @param time * @param username */ @override public boolean add(long id, string time, string username){ //排队信息封装 seckillstatus seckillstatus = new seckillstatus(username, new date(),1, id,time); //将秒杀抢单信息存入到redis中,这里采用list方式存储,list本身是一个队列 redistemplate.boundlistops(\u0026#34;seckillorderqueue\u0026#34;).leftpush(seckillstatus); //多线程操作 multithreadingcreateorder.createorder(); return true; } } 多线程每次从队列中获取数据，分别获取用户名和订单商品编号以及商品秒杀时间段，进行下单操作，代码如下： 上图代码如下：\n/*** * 多线程下单操作 */ @async public void createorder(){ //从队列中获取排队信息 seckillstatus seckillstatus = (seckillstatus) redistemplate.boundlistops(\u0026#34;seckillorderqueue\u0026#34;).rightpop(); try { if(seckillstatus!=null){ //时间区间 string time = seckillstatus.gettime(); //用户登录名 string username=seckillstatus.getusername(); //用户抢购商品 long id = seckillstatus.getgoodsid(); //...略 } } catch (exception e) { e.printstacktrace(); } } 6.3.3 下单状态查询 按照上面的流程，虽然可以实现用户下单异步操作，但是并不能确定下单是否成功，所以我们需要做一个页面判断，每过1秒钟查询一次下单状态,多线程下单的时候，需要修改抢单状态，支付的时候，清理抢单状态。\n6.3.3.1 下单更新抢单状态 用户每次点击抢购的时候，如果排队成功，则将用户抢购状态存储到redis中，多线程抢单的时候，如果抢单成功，则更新抢单状态。\n修改seckillorderserviceimpl的add方法，记录状态，代码如下： 上图代码如下：\n//将抢单状态存入到redis中 redistemplate.boundhashops(\u0026#34;userqueuestatus\u0026#34;).put(username,seckillstatus); 多线程抢单更新状态，修改multithreadingcreateorder的createorder方法，代码如下： 上图代码如下：\n//抢单成功，更新抢单状态,排队-\u0026gt;等待支付 seckillstatus.setstatus(2); seckillstatus.setorderid(seckillorder.getid()); seckillstatus.setmoney(seckillorder.getmoney().floatvalue()); redistemplate.boundhashops(\u0026#34;userqueuestatus\u0026#34;).put(username,seckillstatus); 6.3.3.2 后台查询抢单状态 后台提供抢单状态查询方法，修改seckillorderservice，添加如下查询方法：\n/*** * 抢单状态查询 * @param username */ seckillstatus querystatus(string username); 修改seckillorderserviceimpl,添加如下实现方法：\n/*** * 抢单状态查询 * @param username * @return */ @override public seckillstatus querystatus(string username) { return (seckillstatus) redistemplate.boundhashops(\u0026#34;userqueuestatus\u0026#34;).get(username); } 修改seckillordercontroller,添加如下查询方法： 上图代码如下：\n/**** * 查询抢购 * @return */ @requestmapping(value = \u0026#34;/query\u0026#34;) public result querystatus(){ //获取用户名 string username = tokendcode.getuserinfo().get(\u0026#34;username\u0026#34;); //根据用户名查询用户抢购状态 seckillstatus seckillstatus = seckillorderservice.querystatus(username); if(seckillstatus!=null){ return new result(true,seckillstatus.getstatus(),\u0026#34;抢购状态\u0026#34;); } //notfounderror =20006,没有对应的抢购数据 return new result(false,statuscode.notfounderror,\u0026#34;没有抢购信息\u0026#34;); } 6.3.3.3 测试 使用postman测试查询状态\nhttp://localhost:8001/api/seckillorder/query ","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project-0/20220528172837/","summary":"第十五章 秒杀1 优就业.JAVA教研室 学习目标 秒杀业务分析 秒杀商品压入Redis缓存 Spring定时任务了解-定时将秒杀商品存入到Redis中 秒杀商品频道页实现-","title":"秒杀1"},{"content":"第十六章 秒杀高级 优就业.java教研室 学习目标 防止秒杀重复排队 并发超卖问题解决 订单支付 rabbitmq延时队列 库存回滚 1 防止秒杀重复排队 用户每次抢单的时候，一旦排队，我们设置一个自增值，让该值的初始值为1，每次进入抢单的时候，对它进行递增，如果值\u0026gt;1，则表明已经排队,不允许重复排队,如果重复排队，则对外抛出异常，并抛出异常信息表示已经正在排队。 1.1 后台排队记录 修改seckillorderserviceimpl的add方法，新增递增值判断是否排队中，代码如下： 上图代码如下：\n//递增，判断是否排队 long userqueuecount = redistemplate.boundhashops(\u0026#34;userqueuecount\u0026#34;).increment(username, 1); if(userqueuecount\u0026gt;1){ //100：表示有重复抢单 throw new runtimeexception(string.valueof(statuscode.reperror)); } 测试：\n首次秒杀下单：http://localhost:8001/api/seckillorder/add?id=1\u0026amp;time=2021061914 查看redis缓存，发现已经记录了userqueuecount 再次重复下单： 查看查看redis缓存，发现userqueuecount记录的用户下单数量变成了2\n2 并发超卖问题解决 超卖问题，这里是指多人抢购同一商品的时候，多人同时判断是否有库存，如果只剩一个，则都会判断有库存，此时会导致超卖现象产生，也就是一个商品下了多个订单的现象。\n2.1 思路分析 解决超卖问题，可以利用redis队列实现，给每件商品创建一个独立的商品个数队列，例如：a商品有2个，a商品的id为1001，则可以创建一个队列,key=seckillgoodscountlist_1001,往该队列中塞2次该商品id。\n每次给用户下单的时候，先从队列中取数据，如果能取到数据，则表明有库存，如果取不到，则表明没有库存，这样就可以防止超卖问题产生了。\n在我们对redis进行操作的时候，很多时候，都是先将数据查询出来，在内存中修改，然后存入到redis，在并发场景，会出现数据错乱问题，为了控制数量准确，我们单独将商品数量整一个自增键，自增键是线程安全的，所以不担心并发场景的问题。 2.2 代码实现 每次将商品压入redis缓存的时候，另外多创建一个商品的队列。\n修改seckillgoodspushtask,添加一个pushids方法，用于将指定商品id放入到指定的数字中，代码如下：\n/*** * 将商品id存入到数组中 * @param len:长度 * @param id :值 * @return */ public long[] pushids(int len,long id){ long[] ids = new long[len]; for (int i = 0; i \u0026lt;ids.length ; i++) { ids[i]=id; } return ids; } 修改seckillgoodspushtask的loadgoodspushredis方法，添加队列操作，代码如下： 上图代码如下：\n//商品数据队列存储,防止高并发超卖 long[] ids = pushids(seckillgood.getstockcount(), seckillgood.getid()); redistemplate.boundlistops(\u0026#34;seckillgoodscountlist_\u0026#34;+seckillgood.getid()).leftpushall(ids); //创建一个计数器记录各个商品的库存数量 redistemplate.boundhashops(\u0026#34;seckillgoodscount\u0026#34;).increment(seckillgood.getid(),seckillgood.getstockcount()); 测试：\n重启服务，发现定时任务执行后，在redis缓存已经记录了数据id的队列seckillgoodscountlist_1、seckillgoodscountlist_2等等\n并且也记录了每个商品的库存数量seckillgoodscoun 2.3 超卖控制 修改多线程下单方法，分别修改数量控制，以及售罄后用户抢单排队信息的清理，修改代码如下图： 上图代码如下：\n/*** * 多线程下单操作 */ @async public void createorder(){ //从队列中获取排队信息 seckillstatus seckillstatus = (seckillstatus) redistemplate.boundlistops(\u0026#34;seckillorderqueue\u0026#34;).rightpop(); try { //从队列中获取一个商品 object sgood = redistemplate.boundlistops(\u0026#34;seckillgoodscountlist_\u0026#34; + seckillstatus.getgoodsid()).rightpop(); if(sgood==null){ //清理当前用户的排队信息 clearqueue(seckillstatus); return; } //时间区间 string time = seckillstatus.gettime(); //用户登录名 string username=seckillstatus.getusername(); //用户抢购商品 long id = seckillstatus.getgoodsid(); //获取商品数据 seckillgoods goods = (seckillgoods) redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).get(id); //如果有库存，则创建秒杀商品订单 seckillorder seckillorder = new seckillorder(); seckillorder.setid(idworker.nextid()); seckillorder.setseckillid(id); seckillorder.setmoney(goods.getcostprice()); seckillorder.setuserid(username); seckillorder.setcreatetime(new date()); seckillorder.setstatus(\u0026#34;0\u0026#34;); //将秒杀订单存入到redis中 redistemplate.boundhashops(\u0026#34;seckillorder\u0026#34;).put(username,seckillorder); //商品库存-1 long surpluscount = redistemplate.boundhashops(\u0026#34;seckillgoodscount\u0026#34;).increment(id, -1);//商品数量递减 goods.setstockcount(surpluscount.intvalue()); //根据计数器统计 //判断当前商品是否还有库存 if(surpluscount\u0026lt;=0){ //并且将商品数据同步到mysql中 seckillgoodsmapper.updatebyid(goods); //如果没有库存,则清空redis缓存中该商品 redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).delete(id); }else{ //如果有库存，则直数据重置到reids中 redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34; + time).put(id,goods); } //抢单成功，更新抢单状态,排队-\u0026gt;等待支付 seckillstatus.setstatus(2); seckillstatus.setorderid(seckillorder.getid()); seckillstatus.setmoney(seckillorder.getmoney().floatvalue()); redistemplate.boundhashops(\u0026#34;userqueuestatus\u0026#34;).put(username,seckillstatus); } catch (exception e) { e.printstacktrace(); } } /*** * 清理用户排队信息 * @param seckillstatus */ public void clearqueue(seckillstatus seckillstatus){ //清理排队标示 redistemplate.boundhashops(\u0026#34;userqueuecount\u0026#34;).delete(seckillstatus.getusername()); //清理抢单标示 redistemplate.boundhashops(\u0026#34;userqueuestatus\u0026#34;).delete(seckillstatus.getusername()); } 测试：正常秒杀下单\nhttp://localhost:8001/api/seckillorder/add?id=1\u0026amp;time=2021061914\n查看redis中的seckillgoodscount发现对应编号的商品减去了库存数量。\n3 秒杀订单支付 完成秒杀下订单后，进入支付页面，此时前端会每3秒中向后台发送一次请求用于判断当前用户订单是否完成支付，如果完成了支付，则需要清理掉排队信息，并且需要修改订单状态信息。\n3.1 搭建支付模块 创建模块dongyimai-payseckill-service\n（1）、修改依赖配置文件pom.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-payseckill-service\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 支付宝支付所需类库包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alipay.sdk\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;alipay-sdk-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.11.54.all\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.bouncycastle\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;bcprov-jdk15on\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fastjson\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.72\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; （2）、配置文件application.yml server: port: 9006 spring: application: name: pay rabbitmq: host: 192.168.188.128 #mq的服务器地址 username: guest #账号 password: guest #密码 alipay: serverurl: https://openapi.alipaydev.com/gateway.do notify-url: http://7r8ukqlrpt.52http.com/pay/notify/url appid: 2016091300500103 privatekey: 用户私钥 alipaypublickey: 阿里公钥 format: json charset: utf-8 signtype: rsa2 3.2 创建支付二维码 下单成功后，会跳转到支付选择页面，在支付选择页面要显示订单编号和订单金额，所以我们需要在下单的时候，将订单金额以及订单编号信息存储到用户查询对象中。\n选择扫码支付后，会跳转到扫码支付页面，支付页面会根据用户名查看用户秒杀订单，并根据用户秒杀订单的id创建预支付信息并获取二维码信息，展示给用户看,此时页面每3秒查询一次支付状态，如果支付成功，需要修改订单状态信息。\n3.2.1 回显订单号、金额 下单后，进入支付选择页面，需要显示订单号和订单金额，所以需要在用户下单后将该数据传入到pay.html页面，所以查询订单状态的时候，需要将订单号和金额封装到查询的信息中，修改查询订单装的方法加入他们即可。\n修改seckillordercontroller的querystatus方法，代码如下： 上图代码如下：\nreturn new result(true,seckillstatus.getstatus(),\u0026#34;抢购状态\u0026#34;,seckillstatus); 使用postman测试，效果如下：\nhttp://localhost:8001/api/seckillorder/query\n订单编号为long型，转换为json字符串出现精度损失\n处理方法：在订单状态实体类，订单编号属性值上增加注解，把long按照字符串进行序列化\n//订单号 @jsonserialize(using = tostringserializer.class) private long orderid; 3.2.2 创建二维码 用户创建二维码，可以先查询用户的秒杀订单抢单信息，然后再发送请求到支付微服务中创建二维码，将订单编号以及订单对应的金额传递到支付微服务:/pay/create/native。\n修改支付模块dongyimai-payseckill-service\n（1）、编写支付接口，定义预下单方法 import java.util.map; public interface payservice { /** * 生成二维码 * @param out_trade_no * @param total_fee * @return */ map\u0026lt;string,string\u0026gt; createnative(map\u0026lt;string,string\u0026gt; parameters); } (2)、编写接口实现类 import com.alipay.api.alipayapiexception; import com.alipay.api.defaultalipayclient; import com.alipay.api.request.alipaytradeprecreaterequest; import com.alipay.api.request.alipaytradequeryrequest; import com.alipay.api.response.alipaytradeprecreateresponse; import com.alipay.api.response.alipaytradequeryresponse; import com.offcn.pay.service.payservice; import org.springframework.beans.factory.annotation.value; import org.springframework.stereotype.service; import java.util.hashmap; import java.util.map; @service public class payserviceimpl implements payservice { /** * 支付宝gatewayurl */ @value(\u0026#34;${alipay.serverurl}\u0026#34;) private string serverurl; /** * 商户应用id */ @value(\u0026#34;${alipay.appid}\u0026#34;) private string appid; /** * rsa私钥，用于对商户请求报文加签 */ @value(\u0026#34;${alipay.privatekey}\u0026#34;) private string privatekey; /** * 支付宝rsa公钥，用于验签支付宝应答 */ @value(\u0026#34;${alipay.alipaypublickey}\u0026#34;) private string alipaypublickey; /** * 签名类型 */ @value(\u0026#34;${alipay.signtype}\u0026#34;) private string signtype = \u0026#34;rsa2\u0026#34;; /** * 格式 */ @value(\u0026#34;${alipay.format}\u0026#34;) private string formate = \u0026#34;json\u0026#34;; /** * 编码 */ @value(\u0026#34;${alipay.charset}\u0026#34;) private string charset = \u0026#34;utf-8\u0026#34;; /** * 异步地址 */ @value(\u0026#34;${alipay.notify-url}\u0026#34;) private string notifyurl; @override public map\u0026lt;string, string\u0026gt; createnative(map\u0026lt;string, string\u0026gt; parameters) { //创建阿里支付客户端请求对象 defaultalipayclient alipayclient = new defaultalipayclient(serverurl, appid, privatekey, formate, charset, alipaypublickey, signtype); map\u0026lt;string,string\u0026gt; map=new hashmap\u0026lt;string, string\u0026gt;(); //创建预下单请求对象 alipaytradeprecreaterequest request = new alipaytradeprecreaterequest(); //设置回调地址 request.setnotifyurl(notifyurl); //设置预下单请求参数 request.setbizcontent(\u0026#34;{\u0026#34; + \u0026#34; \\\u0026#34;out_trade_no\\\u0026#34;:\\\u0026#34;\u0026#34;+parameters.get(\u0026#34;out_trade_no\u0026#34;)+\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;total_amount\\\u0026#34;:\\\u0026#34;\u0026#34;+parameters.get(\u0026#34;total_fee\u0026#34;)+\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;subject\\\u0026#34;:\\\u0026#34;测试购买商品001\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;store_id\\\u0026#34;:\\\u0026#34;xa_001\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;timeout_express\\\u0026#34;:\\\u0026#34;90m\\\u0026#34;}\u0026#34;);//设置业务参数 //发出预下单业务请求 try { alipaytradeprecreateresponse response = alipayclient.execute(request); //从相应对象读取相应结果 string code = response.getcode(); system.out.println(\u0026#34;响应码:\u0026#34;+code); //全部的响应结果 string body = response.getbody(); system.out.println(\u0026#34;返回结果:\u0026#34;+body); if(code.equals(\u0026#34;10000\u0026#34;)){ map.put(\u0026#34;qrcode\u0026#34;, response.getqrcode()); map.put(\u0026#34;out_trade_no\u0026#34;, response.getouttradeno()); map.put(\u0026#34;total_fee\u0026#34;,parameters.get(\u0026#34;total_fee\u0026#34;)); system.out.println(\u0026#34;qrcode:\u0026#34;+response.getqrcode()); system.out.println(\u0026#34;out_trade_no:\u0026#34;+response.getouttradeno()); system.out.println(\u0026#34;total_fee:\u0026#34;+parameters.get(\u0026#34;total_fee\u0026#34;)); }else{ system.out.println(\u0026#34;预下单接口调用失败:\u0026#34;+body); } } catch (alipayapiexception e) { e.printstacktrace(); } return map; } } （3）、编写controller控制器代码\nimport com.alibaba.fastjson.json; import com.offcn.entity.result; import com.offcn.entity.statuscode; import com.offcn.pay.service.payservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.requestparam; import org.springframework.web.bind.annotation.restcontroller; import javax.servlet.servletinputstream; import javax.servlet.http.httpservletrequest; import java.io.bytearrayoutputstream; import java.util.enumeration; import java.util.hashmap; import java.util.map; @restcontroller @requestmapping(\u0026#34;pay\u0026#34;) public class paycontroller { @autowired private payservice payservice; /** * 创建二维码连接地址返回给前端 生成二维码图片 * * @param parameters 包含 订单号 包含 金额 包含 queue队列名称 交换机信息 路由信息 用户名 * @return */ @requestmapping(\u0026#34;/create/native\u0026#34;) public result\u0026lt;map\u0026gt; createnative(@requestparam map\u0026lt;string,string\u0026gt; parameters) { //获取用户名 map\u0026lt;string, string\u0026gt; resultmap = payservice.createnative(parameters); return new result\u0026lt;map\u0026gt;(true, statuscode.ok, \u0026#34;二维码连接地址创建成功\u0026#34;, resultmap); } } （4）、编写主启动类payseckillapplication\n@springbootapplication public class payseckillapplication { public static void main(string[] args) { springapplication.run(payseckillapplication.class,args); } } 使用postman测试效果如下：\nhttp://localhost:9006/pay/create/native?out_trade_no=1132510782836314121\u0026amp;total_fee=1\n根据返回的qrcode,可以生成支付宝扫码的二维码： 使用沙箱版支付宝扫码，即可弹出支付界面。\n3.3 支付流程分析 如上图，步骤分析如下：\n1.用户抢单，经过秒杀系统实现抢单，下单后会将向mq发送一个延时队列消息，包含抢单信息，延时半小时后才能监听到 2.秒杀系统同时启用延时消息监听，一旦监听到订单抢单信息，判断redis缓存中是否存在订单信息，如果存在，则回滚 3.秒杀系统还启动支付回调信息监听，如果支付完成，则将订单持久化到mysql，如果没完成，清理排队信息回滚库存 4.每次秒杀下单后调用支付系统，创建二维码，如果用户支付成功了，支付宝平台会将支付信息发送给支付系统指定的回调地址，支付系统收到信息后，将信息发送给mq，第3个步骤就可以监听到消息了。 3.4 支付回调更新 支付回调这一块代码已经实现了，但之前实现的是订单信息的回调数据发送给mq，指定了对应的队列，不过现在需要实现的是秒杀信息发送给指定队列，所以之前的代码那块需要动态指定队列。\n3.4.1 支付回调队列指定 关于指定队列如下：\n1.创建支付二维码需要指定队列 2.回调地址回调的时候，获取支付二维码指定的队列，将支付信息发送到指定队列中 在支付宝支付统一下单api中，有一个附加参数,如下：\nbody:附加数据,string(127)，在查询api和支付通知中原样返回，可作为自定义参数使用。 我们可以在创建二维码的时候，指定该参数，该参数用于指定回调支付信息的对应队列，每次回调的时候，会获取该参数，然后将回调信息发送到该参数对应的队列去。\n3.4.1.1 在预下单时传递队列信息 修改支付微服务的payserviceimpl的createnative方法，代码如下：\n@override public map\u0026lt;string, string\u0026gt; createnative(map\u0026lt;string, string\u0026gt; parameters) { //创建阿里支付客户端请求对象 defaultalipayclient alipayclient = new defaultalipayclient(serverurl, appid, privatekey, formate, charset, alipaypublickey, signtype); map\u0026lt;string,string\u0026gt; map=new hashmap\u0026lt;string, string\u0026gt;(); //创建预下单请求对象 alipaytradeprecreaterequest request = new alipaytradeprecreaterequest(); request.setnotifyurl(notifyurl); request.setbizcontent(\u0026#34;{\u0026#34; + \u0026#34; \\\u0026#34;out_trade_no\\\u0026#34;:\\\u0026#34;\u0026#34;+parameters.get(\u0026#34;out_trade_no\u0026#34;)+\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;body\\\u0026#34;:\\\u0026#34;queue=\u0026#34;+parameters.get(\u0026#34;queue\u0026#34;)+\u0026#34;\u0026amp;username=\u0026#34;+parameters.get(\u0026#34;username\u0026#34;)+\u0026#34;\u0026amp;routingkey=\u0026#34;+parameters.get(\u0026#34;routingkey\u0026#34;)+\u0026#34;\u0026amp;exchange=\u0026#34;+parameters.get(\u0026#34;exchange\u0026#34;)+\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;total_amount\\\u0026#34;:\\\u0026#34;\u0026#34;+parameters.get(\u0026#34;total_fee\u0026#34;)+\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;subject\\\u0026#34;:\\\u0026#34;测试购买商品001\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;store_id\\\u0026#34;:\\\u0026#34;xa_001\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;timeout_express\\\u0026#34;:\\\u0026#34;90m\\\u0026#34;}\u0026#34;);//设置业务参数 //发出预下单业务请求 try { alipaytradeprecreateresponse response = alipayclient.execute(request); //从相应对象读取相应结果 string code = response.getcode(); system.out.println(\u0026#34;响应码:\u0026#34;+code); //全部的响应结果 string body = response.getbody(); system.out.println(\u0026#34;返回结果:\u0026#34;+body); if(code.equals(\u0026#34;10000\u0026#34;)){ map.put(\u0026#34;qrcode\u0026#34;, response.getqrcode()); map.put(\u0026#34;out_trade_no\u0026#34;, response.getouttradeno()); map.put(\u0026#34;total_fee\u0026#34;,parameters.get(\u0026#34;total_fee\u0026#34;)); system.out.println(\u0026#34;qrcode:\u0026#34;+response.getqrcode()); system.out.println(\u0026#34;out_trade_no:\u0026#34;+response.getouttradeno()); system.out.println(\u0026#34;total_fee:\u0026#34;+parameters.get(\u0026#34;total_fee\u0026#34;)); }else{ system.out.println(\u0026#34;预下单接口调用失败:\u0026#34;+body); } } catch (alipayapiexception e) { e.printstacktrace(); } return map; } 我们创建二维码的时候，需要将下面几个参数传递过去\nusername:用户名,可以根据用户名查询用户排队信息 out_trade_no：商户订单号，下单必须 total_fee：支付金额，支付必须 queue：队列名字，回调的时候，可以知道将支付信息发送到哪个队列 routingkey:路由的名称 exchange：交换机名称 修改主启动类payapplication，添加对应队列以及对应交换机绑定，代码如下：\n@springbootapplication(exclude = datasourceautoconfiguration.class) @enableeurekaclient public class payseckillapplication { public static void main(string[] args) { springapplication.run(payseckillapplication.class,args); } @autowired private environment env; //创建秒杀队列 @bean(name=\u0026#34;seckillqueue\u0026#34;) public queue createseckillqueue(){ return new queue(env.getproperty(\u0026#34;mq.pay.queue.seckillorder\u0026#34;)); } //创建秒杀交换机 @bean(name=\u0026#34;seckillexchanage\u0026#34;) public directexchange basicseckillexchanage(){ return new directexchange(env.getproperty(\u0026#34;mq.pay.exchange.seckillorder\u0026#34;)); } //绑定秒杀 @bean(name=\u0026#34;seckillbinding\u0026#34;) public binding basicseckillbinding(){ return bindingbuilder.bind(createseckillqueue()).to(basicseckillexchanage()).with(env.getproperty(\u0026#34;mq.pay.routing.seckillkey\u0026#34;)); } } 修改application.yml，添加如下配置\n#位置支付交换机和队列 mq: pay: exchange: seckillorder: exchange.seckillorder queue: seckillorder: queue.seckillorder routing: seckillkey: queue.seckillorder 3.4.1.2 测试 使用postman创建二维码测试\nhttp://localhost:9006/pay/create/native?username=test001\u0026amp;out_trade_no=1132510782836314121\u0026amp;total_fee=1\u0026amp;queue=queue.seckillorder\u0026amp;routingkey=queue.seckillorder\u0026amp;exchange=exchange.seckillorder\n以后每次支付，都需要带上对应的参数，包括前面的订单支付。\n3.4.1.3 改造支付回调方法 修改paycontroller的notifyurl方法，获取自定义参数，并转成map，获取queue地址，并将支付信息发送到绑定的queue中，代码如下：\n//接收支付宝网关回调数据 @requestmapping(\u0026#34;/notify/url\u0026#34;) public string reciveresult(httpservletrequest request){ //准备一个map封装全部的请求参数和值 map\u0026lt;string,string\u0026gt; map=new hashmap\u0026lt;\u0026gt;(); //获取全部的请求参数名称 enumeration\u0026lt;string\u0026gt; parameternames = request.getparameternames(); while (parameternames.hasmoreelements()){ string paramname = parameternames.nextelement(); //封装参数名和参数值到map map.put(paramname,request.getparameter(paramname)); } //转换map集合为json字符串 string jsonstring = json.tojsonstring(map); system.out.println(\u0026#34;响应结果:\u0026#34;+jsonstring); //获取body自定义参数 string body = map.get(\u0026#34;body\u0026#34;); //body参数多个用\u0026amp;隔开 string[] splits = body.split(\u0026#34;\u0026amp;\u0026#34;); //创建一个map封装body的参数 map\u0026lt;string,string\u0026gt; bodymap=new hashmap\u0026lt;\u0026gt;(); for (string split : splits) { //继续用=号切开 string[] parms = split.split(\u0026#34;=\u0026#34;); bodymap.put(parms[0],parms[1]); } //发送消息 rabbittemplate.convertandsend(bodymap.get(\u0026#34;exchange\u0026#34;),bodymap.get(\u0026#34;routingkey\u0026#34;),jsonstring); return \u0026#34;pay-success\u0026#34;; } 配置回调地址：application.yml\nalipay: notify-url: http://7r8ukqlrpt.52http.com/pay/notify/url 3.4.1.4 内网穿透 支付异步通知需要独立ip使阿里支付成功后可以回调我们的接口，所以前提条件就是内网穿透。\nhttps://www.cpolar.com/ 如何使用：\n（1）、下载 cpolar https://www.cpolar.com/static/downloads/releases/latest/cpolar_amd64.msi\n（2）、安装： 在linux或osx上，您可以使用以下命令从终端解压缩cpolar。 在windows上，只需双击安装\n（3）、连接您的帐户： 运行此命令会将您帐户的authtoken添加到您的cpolar.yml文件中。 这将为您提供更多功能，所有打开的隧道将在此处的仪表板中列出。\ncpolar authtoken yzqxmzfiy2yty2i1nc*****ltg2nzatzjjkmtrmyjq0zdrh 具体的token值：登录网站从控制面板获取：https://dashboard.cpolar.com/auth （4）、开启端口映射 cpolar http 80 在80端口开启映射。 测试内网穿透：访问回调接口接口\nhttp://6ca8e8f6.cpolar.io/pay/notify/url?id=111\u0026name=wwww\n扫描支付二维码，支付宝即可回调 接口\n控制台可以查看相关信息 3.4.2 支付状态监听 支付状态通过回调地址发送给mq之后，我们需要在秒杀系统中监听支付信息，如果用户已支付，则修改用户订单状态，如果支付失败，则直接删除订单，回滚库存。\n在秒杀工程中创建com.offcn.seckill.consumer.seckillorderpaymessagelistener,实现监听消息，代码如下:\n@component @rabbitlistener(queues = \u0026#34;${mq.pay.queue.seckillorder}\u0026#34;) public class seckillorderpaymessagelistener { /** * 监听消费消息 * @param message */ @rabbithandler public void consumemessage(@payload string message){ system.out.println(message); //将消息转换成map对象 map\u0026lt;string,string\u0026gt; resultmap = json.parseobject(message,map.class); system.out.println(\u0026#34;监听到的消息:\u0026#34;+resultmap); } } 修改seckillapplication创建对应的队列以及绑定对应交换机。\n@springbootapplication @enableeurekaclient @enablefeignclients @mapperscan(basepackages = {\u0026#34;com.offcn.seckill.dao\u0026#34;}) @enablescheduling @enableasync public class seckillapplication { public static void main(string[] args) { springapplication.run(seckillapplication.class,args); } @bean public idworker idworker(){ return new idworker(1,1); } @autowired private environment env; /*** * 创建秒杀队列 * @return */ @bean(name = \u0026#34;queueseckillorder\u0026#34;) public queue queueseckillorder(){ return new queue(env.getproperty(\u0026#34;mq.pay.queue.seckillorder\u0026#34;), true); } //创建秒杀交换机 @bean public directexchange directexchangeorder(){ return new directexchange(env.getproperty(\u0026#34;mq.pay.exchange.seckillorder\u0026#34;)); } /**** * 队列绑定到交换机上 * @return */ @bean public binding basicbindingseckillorder(){ return bindingbuilder .bind(queueseckillorder()) .to(directexchangeorder()) .with(env.getproperty(\u0026#34;mq.pay.routing.seckillkey\u0026#34;)); } } 修改application.yml文件，添加如下配置：\n#位置支付交换机和队列 mq: pay: exchange: seckillorder: exchange.seckillorder queue: seckillorder: queue.seckillorder routing: seckillkey: queue.seckillorder 3.4.3 修改订单状态 监听到支付信息后，根据支付信息判断，如果用户支付成功，则修改订单信息，并将订单入库，删除用户排队信息，如果用户支付失败，则删除订单信息，回滚库存，删除用户排队信息。\n3.4.3.1 业务层 修改seckillorderservice，添加修改订单方法，代码如下\n/*** * 更新订单状态 * @param out_trade_no * @param transaction_id * @param username */ void updatepaystatus(string out_trade_no, string transaction_id,string username); 修改seckillorderserviceimpl，添加修改订单方法实现，代码如下：\n/*** * 更新订单状态 * @param out_trade_no * @param transaction_id * @param username */ @override public void updatepaystatus(string out_trade_no, string transaction_id,string username) { //订单数据从redis数据库查询出来 seckillorder seckillorder = (seckillorder) redistemplate.boundhashops(\u0026#34;seckillorder\u0026#34;).get(username); //修改状态 seckillorder.setstatus(\u0026#34;1\u0026#34;); //设置交易流水号 seckillorder.settransactionid(transaction_id); //支付时间 seckillorder.setpaytime(new date()); //同步到mysql中 seckillordermapper.insert(seckillorder); //清空redis缓存 redistemplate.boundhashops(\u0026#34;seckillorder\u0026#34;).delete(username); //清空用户排队数据 redistemplate.boundhashops(\u0026#34;userqueuecount\u0026#34;).delete(username); //删除抢购状态信息 redistemplate.boundhashops(\u0026#34;userqueuestatus\u0026#34;).delete(username); } 修改订单实体类的id生成方式，为外面生成 3.4.3.2 修改订单对接 修改扫码支付状态监听的代码，当用户支付成功后，修改订单状态，也就是调用上面的方法，代码如下： 代码：\npackage com.offcn.seckill.consumer; import com.alibaba.fastjson.json; import com.offcn.seckill.service.seckillorderservice; import org.springframework.amqp.rabbit.annotation.rabbithandler; import org.springframework.amqp.rabbit.annotation.rabbitlistener; import org.springframework.beans.factory.annotation.autowired; import org.springframework.messaging.handler.annotation.payload; import org.springframework.stereotype.component; import java.util.hashmap; import java.util.map; @component @rabbitlistener(queues = \u0026#34;${mq.pay.queue.seckillorder}\u0026#34;) public class seckillorderpaymessagelistener { @autowired private seckillorderservice seckillorderservice; /** * 监听消费消息 * @param message */ @rabbithandler public void consumemessage(@payload string message){ system.out.println(message); //将消息转换成map对象 map\u0026lt;string,string\u0026gt; resultmap = json.parseobject(message, map.class); system.out.println(\u0026#34;监听到的消息:\u0026#34;+resultmap); //获取交易状态 string trade_status= resultmap.get(\u0026#34;trade_status\u0026#34;); //判断交易状态是否等于成功 if(trade_status!=null\u0026amp;\u0026amp;trade_status.equalsignorecase(\u0026#34;trade_success\u0026#34;)){ string body= resultmap.get(\u0026#34;body\u0026#34;); map\u0026lt;string, string\u0026gt; bodymap = new hashmap\u0026lt;\u0026gt;(); if(resultmap.get(\u0026#34;body\u0026#34;)!=null) { string[] splits = body.split(\u0026#34;\u0026amp;\u0026#34;); for (string split : splits) { string[] vs = split.split(\u0026#34;=\u0026#34;); bodymap.put(vs[0], vs[1]); } } seckillorderservice.updatepaystatus(resultmap.get(\u0026#34;out_trade_no\u0026#34;),resultmap.get(\u0026#34;trade_no\u0026#34;),bodymap.get(\u0026#34;username\u0026#34;)); }else { //支付失败，删除订单 } } } 测试：\n使用postman完整请求创建二维码下单测试一次。\n商品id：1\n剩余库存数量：10\nhttp://localhost:8001/api/seckillgoods/one?id=1\u0026amp;time=2021061916 下单：\nhttp://localhost:8001/api/seckillorder/add?time=2021061916\u0026amp;id=1\n下单后，redis数据 下单查询：\nhttp://localhost:8001/api/seckillorder/query 创建二维码：\nhttp://localhost:9006/pay/create/native?username=dongyimai\u0026amp;out_trade_no=1375043168986337280\u0026amp;total_fee=0.01\u0026amp;queue=queue.seckillorder\u0026amp;routingkey=queue.seckillorder\u0026amp;exchange=exchange.seckillorder\n注意：username 用登录的账号 out_trade_no 用下单成功的订单号\n扫码：\n使用返回的预下单url生成二维码 使用沙箱支付宝扫描二维码，完成支付\n查看订单状态：\nhttp://localhost:9005/seckillorder/query\n3.4.4 删除订单回滚库存 如果用户支付失败，我们需要删除用户订单数据，并回滚库存。\n3.4.4.1 业务层实现 修改seckillorderservice，创建一个关闭订单方法，代码如下：\n/*** * 关闭订单，回滚库存 */ void closeorder(string username); 修改seckillorderserviceimpl，创建一个关闭订单实现方法，代码如下：\n/*** * 关闭订单，回滚库存 * @param username */ @override public void closeorder(string username) { //将消息转换成seckillstatus seckillstatus seckillstatus = (seckillstatus) redistemplate.boundhashops(\u0026#34;userqueuestatus\u0026#34;).get(username); //获取redis中订单信息 seckillorder seckillorder = (seckillorder) redistemplate.boundhashops(\u0026#34;seckillorder\u0026#34;).get(username); //如果redis中有订单信息，说明用户未支付 if(seckillstatus!=null \u0026amp;\u0026amp; seckillorder!=null){ //删除订单 redistemplate.boundhashops(\u0026#34;seckillorder\u0026#34;).delete(username); //回滚库存 //1)从redis中获取该商品 seckillgoods seckillgoods = (seckillgoods) redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34;+seckillstatus.gettime()).get(seckillstatus.getgoodsid()); //2)如果redis中没有，则从数据库中加载 if(seckillgoods==null){ seckillgoods = seckillgoodsmapper.selectbyid(seckillstatus.getgoodsid()); } //3)数量+1 (递增数量+1，队列数量+1) long surpluscount = redistemplate.boundhashops(\u0026#34;seckillgoodscount\u0026#34;).increment(seckillstatus.getgoodsid(), 1); seckillgoods.setstockcount(surpluscount.intvalue()); redistemplate.boundlistops(\u0026#34;seckillgoodscountlist_\u0026#34; + seckillstatus.getgoodsid()).leftpush(seckillstatus.getgoodsid()); //4)数据同步到redis中 redistemplate.boundhashops(\u0026#34;seckillgoods_\u0026#34;+seckillstatus.gettime()).put(seckillstatus.getgoodsid(),seckillgoods); //清理排队标示 redistemplate.boundhashops(\u0026#34;userqueuecount\u0026#34;).delete(seckillstatus.getusername()); //清理抢单标示 redistemplate.boundhashops(\u0026#34;userqueuestatus\u0026#34;).delete(seckillstatus.getusername()); } } 3.4.4.2 调用删除订单 修改seckillorderpaymessagelistener，在用户支付失败后调用关闭订单方法，代码如下：\n}else{ //支付失败，关闭订单 seckillorderservice.closeorder(bodymap.get(\u0026#34;username\u0026#34;)); } 3.4.4.3 测试 使用postman完整请求创建二维码下单测试一次。\n商品id：1\n剩余库存数量：10\nhttp://localhost:9005/seckillgoods/one?id=1\u0026amp;time=2021032518 下单：\nhttp://localhost:9005/seckillorder/add?time=2021032518\u0026amp;id=1\n下单后，redis数据 下单查询：\nhttp://localhost:9005/seckillorder/query 创建二维码：\nhttp://localhost:9006/pay/create/native?username=test001\u0026amp;out_trade_no=1375043168986337280\u0026amp;total_fee=0.01\u0026amp;queue=queue.seckillorder\u0026amp;routingkey=queue.seckillorder\u0026amp;exchange=exchange.seckillorder\n秒杀抢单后，商品数量变化：\nhttp://localhost:9005/seckillgoods/one?id=1\u0026amp;time=2021032518 4 rabbitmq延时消息队列 4.1 延时队列介绍 延时队列即放置在该队列里面的消息是不需要立即消费的，而是等待一段时间之后取出消费。 那么，为什么需要延迟消费呢？我们来看以下的场景\n网上商城下订单后30分钟后没有完成支付，取消订单(如：淘宝、去哪儿网) 系统创建了预约之后，需要在预约时间到达前一小时提醒被预约的双方参会 系统中的业务失败之后，需要重试 这些场景都非常常见，我们可以思考，比如第二个需求，系统创建了预约之后，需要在预约时间到达前一小时提醒被预约的双方参会。那么一天之中肯定是会有很多个预约的，时间也是不一定的，假设现在有1点 2点 3点 三个预约，如何让系统知道在当前时间等于0点 1点 2点给用户发送信息呢，是不是需要一个轮询，一直去查看所有的预约，比对当前的系统时间和预约提前一小时的时间是否相等呢？这样做非常浪费资源而且轮询的时间间隔不好控制。如果我们使用延时消息队列呢，我们在创建时把需要通知的预约放入消息中间件中，并且设置该消息的过期时间，等过期时间到达时再取出消费即可。\nrabbitmq实现延时队列一般而言有两种形式： 第一种方式：利用两个特性： time to live(ttl)、dead letter exchanges（dlx）[a队列过期-\u0026gt;转发给b队列]\n第二种方式：利用rabbitmq中的插件x-delay-message\n4.2 ttl dlx实现延时队列 4.2.1 ttl dlx介绍 ttl rabbitmq可以针对队列设置x-expires(则队列中所有的消息都有相同的过期时间)或者针对message设置x-message-ttl(对消息进行单独设置，每条消息ttl可以不同)，来控制消息的生存时间，如果超时(两者同时设置以最先到期的时间为准)，则消息变为dead letter(死信)\ndead letter exchanges（dlx） rabbitmq的queue可以配置x-dead-letter-exchange和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由转发到指定的队列。 x-dead-letter-exchange：出现dead letter之后将dead letter重新发送到指定exchange\nx-dead-letter-routing-key：出现dead letter之后将dead letter重新按照指定的routing-key发送\n4.2.3 dlx延时队列实现 4.2.3.1 创建工程 创建springboot_rabbitmq_delay工程，并引入相关依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;springboot_rabbitmq_delay\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--starter-web--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--加入ampq--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; application.yml配置\nspring: application: name: springboot-demo rabbitmq: host: 192.168.188.128 port: 5672 password: guest username: guest 4.2.3.2 队列创建 创建2个队列，用于接收消息的叫延时队列queue.message.delay，用于转发消息的队列叫queue.message，同时创建一个交换机，代码如下：\n@configuration public class queueconfig { /** 短信发送队列 */ public static final string queue_message = \u0026#34;queue.message\u0026#34;; /** 交换机 */ public static final string dlx_exchange = \u0026#34;dlx.exchange\u0026#34;; /** 短信发送队列 延迟缓冲（按消息） */ public static final string queue_message_delay = \u0026#34;queue.message.delay\u0026#34;; /** * 接收死信队列 * @return */ @bean public queue messagequeue() { //允许长期存储消息 return new queue(queue_message, true); } /** * 接收延时消息队列 * @return */ @bean public queue delaymessagequeue() { return queuebuilder.durable(queue_message_delay) .withargument(\u0026#34;x-dead-letter-exchange\u0026#34;, dlx_exchange) // 消息超时进入死信队列，绑定死信队列交换机 .withargument(\u0026#34;x-dead-letter-routing-key\u0026#34;, queue_message) // 绑定指定的routing-key .build(); } /*** * 创建交换机 * @return */ @bean public directexchange directexchange(){ return new directexchange(dlx_exchange); } /*** * 交换机与队列绑定 * @param messagequeue * @param directexchange * @return */ @bean public binding basicbinding(queue messagequeue, directexchange directexchange) { return bindingbuilder.bind(messagequeue) .to(directexchange) .with(queue_message); } } 4.2.3.3 消息监听 创建messagelistener用于监听消息，代码如下：\n@component @rabbitlistener(queues = queueconfig.queue_message) public class messagelistener { /*** * 监听消息 * @param msg */ @rabbithandler public void msg(@payload object msg){ simpledateformat dateformat = new simpledateformat(\u0026#34;yyyy-mm-dd hh:mm:ss\u0026#34;); system.out.println(\u0026#34;当前时间:\u0026#34;+dateformat.format(new date())); system.out.println(\u0026#34;收到信息:\u0026#34;+msg); } } 注意：@payload 和 @headers 注解可以分别接收消息中的 body 与 headers 信息\n@rabbitlistener 可以标注在类上面，需配合 @rabbithandler 注解一起使用 @rabbitlistener 标注在类上面表示当有收到消息的时候，就交给 @rabbithandler 的方法处理，具体使用哪个方法处理，根据 messageconverter 转换后的参数类型。\n4.2.3.4 创建启动类 @springbootapplication @enablerabbit public class springrabbitmqapplication { public static void main(string[] args) { springapplication.run(springrabbitmqapplication.class,args); } } 4.2.3.5 测试 @springboottest(classes = springrabbitmqapplication.class) @runwith(springrunner.class) public class rabbitmqtest { @autowired private rabbittemplate rabbittemplate; /*** * 发送消息 */ @test public void sendmessage() throws interruptedexception, ioexception { simpledateformat dateformat = new simpledateformat(\u0026#34;yyyy-mm-dd hh:mm:ss\u0026#34;); system.out.println(\u0026#34;发送当前时间:\u0026#34;+dateformat.format(new date())); map\u0026lt;string,string\u0026gt; message = new hashmap\u0026lt;\u0026gt;(); message.put(\u0026#34;name\u0026#34;,\u0026#34;offcn\u0026#34;); rabbittemplate.convertandsend(queueconfig.queue_message_delay, message, new messagepostprocessor() { @override public message postprocessmessage(message message) throws amqpexception { message.getmessageproperties().setexpiration(\u0026#34;10000\u0026#34;); return message; } }); system.in.read(); } } 其中message.getmessageproperties().setexpiration(\u0026ldquo;10000\u0026rdquo;);设置消息超时时间,超时后，会将消息转入到另外一个队列。\n测试效果如下： 接收时间延迟了10秒，在死信队列收到消息 5 超时未完成支付、自动删除订单库存回滚(作业) 5.1 秒杀流程回顾 如上图，步骤分析如下：\n1.用户抢单，经过秒杀系统实现抢单，下单后会将向mq发送一个延时队列消息，包含抢单信息，延时半小时后才能监听到 2.秒杀系统同时启用延时消息监听，一旦监听到订单抢单信息，判断redis缓存中是否存在订单信息，如果存在，则回滚 3.秒杀系统还启动支付回调信息监听，如果支付完成，则将订单持久化到mysql，如果没完成，清理排队信息回滚库存 4.每次秒杀下单后调用支付系统，创建二维码，如果用户支付成功了，支付宝平台会将支付信息发送给支付系统指定的回调地址，支付系统收到信息后，将信息发送给mq，第3个步骤就可以监听到消息了。 延时队列实现订单关闭回滚库存：\n1.创建一个过期队列 queue1 2.接收消息的队列 queue2 3.中转交换机 4.监听queue2 1)seckillstatus-\u0026gt;检查redis中是否有订单信息 2)如果有订单信息，调用删除订单回滚库存-\u0026gt;[需要先关闭扫码支付] 3)如果关闭订单时，用于已支付，修改订单状态即可 4)如果关闭订单时，发生了别的错误，记录日志，人工处理 5.2 关闭支付 用户如果半个小时没有支付，我们会关闭支付订单，但在关闭之前，需要先关闭扫码支付，防止中途用户支付。\n修改支付微服务的payservice，添加关闭支付方法，代码如下：\n/*** * 关闭支付 * @param orderid * @return */ map\u0026lt;string,string\u0026gt; closepay(long out_trade_no) throws exception; 修改payserviceimpl，实现关闭扫码支付方法，代码如下：\n@override public map\u0026lt;string, string\u0026gt; closepay(long out_trade_no) throws exception { //创建阿里支付客户端请求对象 defaultalipayclient alipayclient = new defaultalipayclient(serverurl, appid, privatekey, formate, charset, alipaypublickey, signtype); map\u0026lt;string,string\u0026gt; map=new hashmap\u0026lt;string, string\u0026gt;(); //撤销交易请求对象 alipaytradecancelrequest request = new alipaytradecancelrequest(); request.setbizcontent(\u0026#34;{\u0026#34; + \u0026#34; \\\u0026#34;out_trade_no\\\u0026#34;:\\\u0026#34;\u0026#34;+out_trade_no+\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;trade_no\\\u0026#34;:\\\u0026#34;\\\u0026#34;}\u0026#34;); //设置业务参数 try { alipaytradecancelresponse response = alipayclient.execute(request); string code=response.getcode(); if(code.equals(\u0026#34;10000\u0026#34;)){ system.out.println(\u0026#34;返回值:\u0026#34;+response.getbody()); map.put(\u0026#34;code\u0026#34;, code); map.put(\u0026#34;out_trade_no\u0026#34;, out_trade_no+\u0026#34;\u0026#34;); return map; } } catch (alipayapiexception e) { e.printstacktrace(); return null; } return null; } 修改paycontroller，增加关闭服务方法\n//关闭支付预下单 @postmapping(\u0026#34;closepay\u0026#34;) public result closepay(long out_trade_no){ try { map\u0026lt;string, string\u0026gt; resultmap = payservice.closepay(out_trade_no); if(resultmap!=null\u0026amp;\u0026amp;resultmap.get(\u0026#34;code\u0026#34;)!=null\u0026amp;\u0026amp;resultmap.get(\u0026#34;code\u0026#34;).equals(\u0026#34;10000\u0026#34;)){ //成功关闭，就返回结果 return new result(true,statuscode.ok,\u0026#34;订单关闭成功\u0026#34;,resultmap); } } catch (exception e) { e.printstacktrace(); return new result(false,statuscode.error,\u0026#34;订单关闭失败\u0026#34;); } return new result(false,statuscode.error,\u0026#34;订单关闭失败\u0026#34;); } 测试：\nhttp://localhost:9006/pay/closepay?out_trade_no=1406451841629294592 5.3 关闭订单回滚库存 5.3.1 配置延时队列 在application.yml文件中引入队列信息配置，如下：\n#位置支付交换机和队列 mq: pay: exchange: seckillorder: exchange.seckillorder seckillordertimer: exchange.seckillordertimer queue: seckillorder: queue.seckillorder seckillordertimer: queue.seckillordertimer seckillordertimerdelay: queue.seckillordertimerdelay routing: seckillkey: queue.seckillorder seckillordertimerkey: queue.seckillordertime 配置队列与交换机,在seckillapplication中添加如下方法\n/** * 到期数据队列 * @return */ @bean public queue seckillordertimerqueue() { return new queue(env.getproperty(\u0026#34;mq.pay.queue.seckillordertimer\u0026#34;), true); } /** * 超时数据队列 * @return */ @bean public queue delayseckillordertimerqueue() { return queuebuilder.durable(env.getproperty(\u0026#34;mq.pay.queue.seckillordertimerdelay\u0026#34;)) .withargument(\u0026#34;x-dead-letter-exchange\u0026#34;, env.getproperty(\u0026#34;mq.pay.exchange.seckillordertimer\u0026#34;)) // 消息超时进入死信队列，绑定死信队列交换机 .withargument(\u0026#34;x-dead-letter-routing-key\u0026#34;, env.getproperty(\u0026#34;mq.pay.routing.seckillordertimerkey\u0026#34;)) // 绑定指定的routing-key .build(); } //创建延时交换机 @bean public directexchange directexchangeordertimer(){ return new directexchange(env.getproperty(\u0026#34;mq.pay.exchange.seckillordertimer\u0026#34;)); } /*** * 交换机与队列绑定 * @param * @param * @return */ @bean public binding basicbindingordertime() { return bindingbuilder.bind(seckillordertimerqueue()) .to(directexchangeordertimer()) .with(env.getproperty(\u0026#34;mq.pay.routing.seckillordertimerkey\u0026#34;)); } 5.3.2 发送延时消息 修改multithreadingcreateorder，添加如下方法：\n/*** * 发送延时消息到rabbitmq中 * @param seckillstatus */ public void sendtimermessage(seckillstatus seckillstatus){ rabbittemplate.convertandsend(env.getproperty(\u0026#34;mq.pay.queue.seckillordertimerdelay\u0026#34;), (object) json.tojsonstring(seckillstatus), new messagepostprocessor() { @override public message postprocessmessage(message message) throws amqpexception { message.getmessageproperties().setexpiration(\u0026#34;10000\u0026#34;); return message; } }); } 在createorder方法中调用上面方法，如下代码：\n//发送延时消息到mq中 sendtimermessage(seckillstatus); 5.3.3 feign调用支付服务关闭预下单接口 在模块dongyimai-seckill-service创建feign接口\npackage com.offcn.seckill.feign; import com.offcn.entity.result; import org.springframework.cloud.openfeign.feignclient; import org.springframework.web.bind.annotation.postmapping; import org.springframework.web.bind.annotation.requestparam; @feignclient(value = \u0026#34;pay\u0026#34;) public interface payfeign { @postmapping(\u0026#34;/pay/closepay\u0026#34;) public result closepay(@requestparam(\u0026#34;out_trade_no\u0026#34;) long out_trade_no); } 注意修改配置文件application.yml设置feign调用超时时间\nfeign: hystrix: enabled: true client: config: default: connecttimeout: 5000 #连接超时时间5秒 readtimeout: 5000 #读超时时间5秒 #hystrix 配置 hystrix: command: default: execution: timeout: #如果enabled设置为false，则请求超时交给ribbon控制 enabled: true isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore 5.3.4 库存回滚 创建seckillorderdelaymessagelistener实现监听消息，并回滚库存，代码如下：\npackage com.offcn.seckill.consumer; import com.alibaba.fastjson.json; import com.offcn.entity.result; import com.offcn.seckill.bean.seckillstatus; import com.offcn.seckill.feign.payfeign; import com.offcn.seckill.pojo.seckillorder; import com.offcn.seckill.service.seckillorderservice; import org.springframework.amqp.rabbit.annotation.rabbithandler; import org.springframework.amqp.rabbit.annotation.rabbitlistener; import org.springframework.beans.factory.annotation.autowired; import org.springframework.data.redis.core.redistemplate; import org.springframework.messaging.handler.annotation.payload; import org.springframework.stereotype.component; import java.util.map; @component @rabbitlistener(queues = \u0026#34;${mq.pay.queue.seckillordertimer}\u0026#34;) public class seckillorderdelaymessagelistener { @autowired private redistemplate redistemplate; @autowired private seckillorderservice seckillorderservice; @autowired private payfeign payfeign; /*** * 读取消息 * 判断redis中是否存在对应的订单 * 如果存在，则关闭支付，再关闭订单 * @param message */ @rabbithandler public void consumemessage(@payload string message){ //读取消息 seckillstatus seckillstatus = json.parseobject(message,seckillstatus.class); //获取redis中订单信息 string username = seckillstatus.getusername(); seckillorder seckillorder = (seckillorder) redistemplate.boundhashops(\u0026#34;seckillorder\u0026#34;).get(username); //如果redis中有订单信息，说明用户未支付 if(seckillorder!=null){ system.out.println(\u0026#34;准备回滚---\u0026#34;+seckillstatus); //关闭支付 result closeresult = payfeign.closepay(seckillstatus.getorderid()); map\u0026lt;string,string\u0026gt; closemap = (map\u0026lt;string, string\u0026gt;) closeresult.getdata(); if(closemap!=null \u0026amp;\u0026amp; closemap.get(\u0026#34;code\u0026#34;).equalsignorecase(\u0026#34;10000\u0026#34;)){ //关闭订单 seckillorderservice.closeorder(username); } } } } 测试：\nhttp://localhost:8001/api/seckillorder/add?time=2021062012\u0026amp;id=1\n测试下单，10秒内未完成支付，即可收到延时消息，回滚订单 ","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project-0/20220528173393/","summary":"第十六章 秒杀高级 优就业.JAVA教研室 学习目标 防止秒杀重复排队 并发超卖问题解决 订单支付 RabbitMQ延时队列 库存回滚 1 防止秒杀重复排队 用户每次抢单的时候，一旦","title":"秒杀高级"},{"content":"第十二章 购物车解决方案 优就业.java教研室 学习目标 目标1：资源服务器授权配置\n目标2：掌握oauth认证微服务动态加载数据\n目标3：掌握购物车流程\n目标4：掌握购物车渲染流程\n目标5：oauth2.0认证并获取用户令牌数据\n目标6：微服务与微服务之间的认证\n1 资源服务器授权配置 1.1 资源服务授权配置 基本上所有微服务都是资源服务\n(1)配置公钥 认证服务生成令牌采用非对称加密算法，认证服务采用私钥加密生成令牌，对外向资源服务提供公钥，资源服务使 用公钥 来校验令牌的合法性。 将公钥拷贝到 public.key文件中，将此文件拷贝到每一个需要的资源服务工程的classpath下 ,例如:用户微服务.\n(2)添加依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; (3)配置每个系统的http请求路径安全控制策略以及读取公钥信息识别令牌，如下：\n@configuration @enableresourceserver @enableglobalmethodsecurity(prepostenabled = true, securedenabled = true)//激活方法上的preauthorize注解 public class resourceserverconfig extends resourceserverconfigureradapter { //公钥 private static final string public_key = \u0026#34;public.key\u0026#34;; /*** * 定义jwttokenstore * @param jwtaccesstokenconverter * @return */ @bean public tokenstore tokenstore(jwtaccesstokenconverter jwtaccesstokenconverter) { return new jwttokenstore(jwtaccesstokenconverter); } /*** * 定义jjwtaccesstokenconverter * @return */ @bean public jwtaccesstokenconverter jwtaccesstokenconverter() { jwtaccesstokenconverter converter = new jwtaccesstokenconverter(); converter.setverifierkey(getpubkey()); return converter; } /** * 获取非对称加密公钥 key * @return 公钥 key */ private string getpubkey() { resource resource = new classpathresource(public_key); try { inputstreamreader inputstreamreader = new inputstreamreader(resource.getinputstream()); bufferedreader br = new bufferedreader(inputstreamreader); //读取第1行，公钥数据 string s; if((s=br.readline())!=null){ return s; } } catch (ioexception ioe) { return null; } } /*** * http安全配置，对每个到达系统的http请求链接进行校验 * @param http * @throws exception */ @override public void configure(httpsecurity http) throws exception { //所有请求必须认证通过 http.authorizerequests() //下边的路径放行 .antmatchers( \u0026#34;/user/add\u0026#34;). //配置地址放行 permitall() .anyrequest(). authenticated(); //其他地址需要认证授权 } } 1.2 用户微服务资源授权 将上面生成的公钥public.key拷贝到dongyimai-user-service微服务工程的resources目录下，如下图： (1)引入依赖\n在dongyimai-user-service微服务工程pom.xml中引入oauth依赖\n\u0026lt;!--oauth依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; (2)资源授权配置\n在dongyimai-user-service工程中创建com.offcn.user.config.resourceserverconfig，代码如下：\n@configuration @enableresourceserver @enableglobalmethodsecurity(prepostenabled = true, securedenabled = true)//激活方法上的preauthorize注解 public class resourceserverconfig extends resourceserverconfigureradapter { //公钥 private static final string public_key = \u0026#34;public.key\u0026#34;; /*** * 定义jwttokenstore * @param jwtaccesstokenconverter * @return */ @bean public tokenstore tokenstore(jwtaccesstokenconverter jwtaccesstokenconverter) { return new jwttokenstore(jwtaccesstokenconverter); } /*** * 定义jjwtaccesstokenconverter * @return */ @bean public jwtaccesstokenconverter jwtaccesstokenconverter() { jwtaccesstokenconverter converter = new jwtaccesstokenconverter(); converter.setverifierkey(getpubkey()); return converter; } /** * 获取非对称加密公钥 key * @return 公钥 key */ private string getpubkey(){ //加载公钥文件 resource resource = new classpathresource(public_key); //读取输入流 try { inputstreamreader inputstreamreader = new inputstreamreader(resource.getinputstream()); bufferedreader br = new bufferedreader(inputstreamreader); //读取第1行，公钥数据 string s; if((s=br.readline())!=null){ return s; } } catch (ioexception e) { e.printstacktrace(); } return null; } /*** * http安全配置，对每个到达系统的http请求链接进行校验 * @param http * @throws exception */ @override public void configure(httpsecurity http) throws exception { //所有请求必须认证通过 http.authorizerequests() //下边的路径放行 .antmatchers( \u0026#34;/user/add\u0026#34;). //配置地址放行 permitall() .anyrequest(). authenticated(); //其他地址需要认证授权 } } 问题：注意公钥的格式必须正确，要不然会出现如下错误 1.3 授权测试 用户每次访问微服务的时候，需要先申请令牌，令牌申请后，每次将令牌放到头文件中，才能访问微服务。\n头文件中每次需要添加一个authorization头信息，头的结果为bearer token。\n(1)不携带令牌测试\n访问http://localhost:9007/user 不携带令牌，结果如下： (2)携带正确令牌访问，注意重新生成令牌\n访问http://localhost:9007/user 携带正确令牌\n在请求头携带参数：\nkey: authorization\nvalue: bearer+半角空格+accesstoken\n结果如下： (3)携带错误令牌\n访问http://localhost:9007/user 携带不正确令牌，结果如下： 注意：客户端资源必须拥有：oauth2-resource，否则报错\nclients.inmemory() .withclient(\u0026#34;client1\u0026#34;) .secret(passwordencoder.encode(\u0026#34;123\u0026#34;)) .resourceids(\u0026#34;oauth2-resource\u0026#34;,\u0026#34;dongyimai-user\u0026#34;, \u0026#34;dongyimai-goods\u0026#34;) 2 网关对接微服务转发token 用户每次访问微服务的时候，先去oauth2.0服务登录，登录后再访问微服务网关，微服务网关将请求转发给其他微服务处理。\n1.用户登录成功后，会将令牌信息存入到cookie中(一般建议存入到头文件中) 2.用户携带cookie中的令牌访问微服务网关 3.微服务网关先获取头文件中的令牌信息，如果header中没有authorization令牌信息，则从参数中找，参数中如果没有，则取cookie中找authorization，最后将令牌信息封装到header中，并调用其他微服务 4.其他微服务会获取头文件中的authorization令牌信息，然后匹配令牌数据是否能使用公钥解密，如果解密成功说明用户已登录，解密失败，说明用户未登录 1.1 令牌加入到header中 修改dongyimai-gateway-web的全局过滤器com.offcn.filter.authorizefilter，实现将令牌信息添加到头文件中，代码如下： try { //不用解析令牌，直接转发 // claims claims = jwtutil.parsejwt(token); //判断token是否有bearer开头,如果没有，就添加bearer开头 if(token!=null){ if(!token.substring(0,6).tolowercase().startswith(\u0026#34;bearer\u0026#34;)){ //添加bearer开头 token=\u0026#34;bearer \u0026#34;+token; } } //把token转发到对应微服务 request.mutate().header(authorize_token,token); } catch (exception e) { e.printstacktrace(); //解析出现异常返回401 response.setstatuscode(httpstatus.unauthorized); return response.setcomplete(); } 测试：\n访问http://localhost:8001/api/user，将生成的新令牌放到头文件中效果如下： 注意：经测试如上由于java代码中添加了bearer， 那么在发出请求的时候就可以不加了。并且由于网关中gateway中authorizefilter添加的从cookie中获取令牌。此时参数中请求头中不添加authorization参数也不会报错。因为最终都会被cookie获取的令牌给覆盖了。\n1.2 springsecurity权限控制 由于我们项目使用了微服务，任何用户都有可能使用任意微服务，此时我们需要控制相关权限，例如：普通用户角色不能使用用户的删除操作，只有管理员才可以使用,那么这个时候就需要使用到springsecurity的权限控制功能了。\n1.2.1 角色加载 在dongyimai-user-oauth服务中，找到配置类websecurityconfig,\n//编写自定义认证类，账号、密码、授权 private userdetailsservice createuserdetailsservice(){ //用户账号集合 list\u0026lt;userdetails\u0026gt; userdetailslist=new arraylist\u0026lt;\u0026gt;(); //创建第一组账号 userdetails userdetails1 = user.withusername(\u0026#34;admin\u0026#34;).password(passwordencoder().encode(\u0026#34;123\u0026#34;)).authorities(\u0026#34;admin\u0026#34;, \u0026#34;user\u0026#34;).build(); userdetails userdetails2 = user.withusername(\u0026#34;user1\u0026#34;).password(passwordencoder().encode(\u0026#34;456\u0026#34;)).authorities(\u0026#34;user\u0026#34;).build(); userdetails userdetails3 = user.withusername(\u0026#34;user2\u0026#34;).password(passwordencoder().encode(\u0026#34;789\u0026#34;)).authorities(\u0026#34;admin\u0026#34;, \u0026#34;user\u0026#34;).build(); //把创建好账号添加到账号集合 userdetailslist.add(userdetails1); userdetailslist.add(userdetails2); userdetailslist.add(userdetails3); //把账号存储到内存 return new inmemoryuserdetailsmanager(userdetailslist); } 注意：.authorities(\u0026ldquo;admin\u0026rdquo;, \u0026ldquo;user\u0026rdquo;) 就是给用户授权的\n1.2.2 角色权限控制 在每个微服务中，需要获取用户的角色，然后根据角色识别是否允许操作指定的方法，spring security中定义了四个支持权限控制的表达式注解，分别是@preauthorize、@postauthorize、@prefilter和@postfilter。其中前两者可以用来在方法调用前或者调用后进行权限检查，后两者可以用来对集合类型的参数或者返回值进行过滤。在需要控制权限的方法上，我们可以添加@preauthorize注解，用于方法执行前进行权限检查，校验用户当前角色是否能访问该方法。\n(1)开启@preauthorize\n在dongyimai-user-service的resourceserverconfig类上添加@enableglobalmethodsecurity注解，用于开启@preauthorize的支持，代码如下： @enableglobalmethodsecurity(prepostenabled = true,securedenabled = true) (2)方法权限控制\n在dongyimaig-user-service微服务的com.offcn.user.controller.usercontroller类的findbyid方法上添加权限控制注解@preauthorize，代码如下： @preauthorize(\u0026#34;hasanyauthority(\u0026#39;admin\u0026#39;)\u0026#34;) (3)测试\n我们使用postman测试，先重新登录创建令牌，然后将令牌数存放到头文件中访问微服务网关来调用user微服务的findbyid方法，效果如下：\n地址：http://localhost:8001/api/user/1提交方式：get 发现上面无法访问，因为用户登录的时候，角色不包含admin角色，而delete方法需要admin角色，所以被拦截了。\n我们再测试其他方法，其他方法没有配置拦截，所以用户登录后就会放行。\n访问http://localhost:8001/api/user\n效果如下： 知识点说明：\n如果希望一个方法能被多个角色访问，配置:@preauthorize(\u0026quot;hasanyauthority('admin','user')\u0026quot;)\n如果希望一个类都能被多个角色访问，在类上配置:@preauthorize(\u0026quot;hasanyauthority('admin','user')\u0026quot;)\n再次执行查询方法 3 oauth动态加载数据 前面oauth我们用的数据都是静态的，在现实工作中，数据都是从数据库加载的，所以我们需要调整一下oauth服务，从数据库加载相关数据。\n客户端数据[生成令牌相关数据] 用户登录账号密码从数据库加载 3.1 客户端数据加载 3.1.1 数据介绍 (1)客户端静态数据\n在dongyimai-user-oauth的com.offcn.oauth.config.authorizationserverconfig类中配置了客户端静态数据，主要用于配置客户端数据，代码如下：\n//客户端账号配置 @override public void configure(clientdetailsserviceconfigurer clients) throws exception { //在内存中创建账号 clients.inmemory() // admin，授权码认证、密码认证、客户端认证、简单认证、刷新token .withclient(\u0026#34;admin\u0026#34;) //账号名称 .secret(passwordencoder.encode(\u0026#34;admin\u0026#34;))//密码，要设置加密 .resourceids(\u0026#34;dongyimai-user\u0026#34;, \u0026#34;dongyimai-goods\u0026#34;)//资源编号 .scopes(\u0026#34;server\u0026#34;,\u0026#34;app\u0026#34;)//作用范围 .authorizedgranttypes(\u0026#34;authorization_code\u0026#34;, \u0026#34;password\u0026#34;, \u0026#34;refresh_token\u0026#34;, \u0026#34;client_credentials\u0026#34;,\u0026#34;implicit\u0026#34;)//登录授权模式 .redirecturis(\u0026#34;http://localhost\u0026#34;);//登录成功跳转地址 } (2)客户端表结构介绍\n在数据库中创建一张表oauth_client_details，表主要用于记录客户端相关信息，表结构如下：\ncreate table `oauth_client_details` ( `client_id` varchar(48) not null comment \u0026#39;客户端id，主要用于标识对应的应用\u0026#39;, `resource_ids` varchar(256) default null, `client_secret` varchar(256) default null comment \u0026#39;客户端秘钥，bcryptpasswordencoder加密算法加密\u0026#39;, `scope` varchar(256) default null comment \u0026#39;对应的范围\u0026#39;, `authorized_grant_types` varchar(256) default null comment \u0026#39;认证模式\u0026#39;, `web_server_redirect_uri` varchar(256) default null comment \u0026#39;认证后重定向地址\u0026#39;, `authorities` varchar(256) default null, `access_token_validity` int(11) default null comment \u0026#39;令牌有效期\u0026#39;, `refresh_token_validity` int(11) default null comment \u0026#39;令牌刷新周期\u0026#39;, `additional_information` varchar(4096) default null, `autoapprove` varchar(256) default null, primary key (`client_id`) ) engine=innodb default charset=utf8; 字段说明：\nclient_id：客户端id resource_ids：资源id（暂时不用） client_secret：客户端秘钥 scope：范围 access_token_validity：访问token的有效期（秒） refresh_token_validity：刷新token的有效期（秒） authorized_grant_type：授权类型:authorization_code,password,refresh_token,client_credentials 导入2条记录到表中，sql如下：数据中密文为123\ninsert into `oauth_client_details` values (\u0026#39;dongyimai\u0026#39;, null, \u0026#39;$2a$10$8dcluiu2leg99ctgxdpzvowoqbjy.iz7qxclq.uom8gq9fdx/exho\u0026#39;, \u0026#39;app\u0026#39;, \u0026#39;authorization_code,password,refresh_token,client_credentials\u0026#39;, \u0026#39;http://localhost\u0026#39;, null, \u0026#39;432000000\u0026#39;, \u0026#39;432000000\u0026#39;, null, null); insert into `oauth_client_details` values (\u0026#39;ujiuye\u0026#39;, null, \u0026#39;$2a$10$8dcluiu2leg99ctgxdpzvowoqbjy.iz7qxclq.uom8gq9fdx/exho\u0026#39;, \u0026#39;app\u0026#39;, \u0026#39;authorization_code,password,refresh_token,client_credentials\u0026#39;, \u0026#39;http://localhost\u0026#39;, null, \u0026#39;432000000\u0026#39;, \u0026#39;432000000\u0026#39;, null, null); 上述表结构属于springsecurity oauth2.0所需的一个认证表结构，不能随意更改。相关操作在其他类中有所体现，如：org.springframework.security.oauth2.provider.client.jdbcclientdetailsservice中的片段代码如下： 3.1.2 加载数据改造 （1）、引入依赖库\n修改pom.xml\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; （2）、修改连接配置\n从数据库加载数据，我们需要先配置数据库连接，在dongyimai-user-oauth的application.yml中配置连接信息，如下代码： 上图代码如下：\nspring: application: name: oauth2 datasource: url: jdbc:mysql://localhost:3306/dongyimaidb username: root password: root driver-class-name: com.mysql.cj.jdbc.driver (3)修改客户端加载源\n修改dongyimai-user-oauth的com.offcn.oauth.config.authorizationserverconfig类的configure方法，将之前静态的客户端数据变成从数据库加载，修改如下：\n修改前： 修改后： 注意如果：表中的密码不清楚可以创建一个测试类生成一段密码拷贝进入表中替换掉原有的密码即可。\n在项目的test目录下，编写测试类testbcryptdemo:\npackage com.offcn.oauth; import org.junit.jupiter.api.test; import org.springframework.security.crypto.bcrypt.bcryptpasswordencoder; public class testbcryptdemo { @test public void test1() { string password=\u0026#34;dongyimai\u0026#34;; system.out.println(new bcryptpasswordencoder().encode(password)); } } (4)测试\n授权码模式测试\n访问：http://localhost:9100/oauth/authorize?client_id=dongyimai\u0026amp;response_type=code\u0026amp;scope=app\u0026amp;redirect_uri=http://localhost\n效果如下： 用户名对应应用id，密码对应秘钥。账号输入：dongyimai 密码：dongyimai\n当然此时从数据中取出数据，注意：如果采用授权码模式，客户端账号密码和用户登录账号密码必须一致。\n自定义账号密码模式授权测试\n我们之前编写的账号密码登录代码如下，每次都会加载指定的客户端id和指定的秘钥，所以此时的客户端id和秘钥固定了，输入的账号密码不再是客户端id和秘钥了。 如果客户端账号密码发生变化，对应的修改配置文件中的配置，和数据表oauth_client_details中的账号密码一致\nauth: ttl: 3600 #token存储过期时间 clientid: dongyimai #客户端账号 clientsecret: 123 #客户端密码 cookiedomain: localhost cookiemaxage: -1 3.2 用户数据加载 因为我们目前整套系统是对内提供登录访问，所以每次用户登录的时候oauth需要调用用户微服务查询用户信息，如上图：\n我们需要在用户微服务中提供用户信息查询的方法，并在oauth中使用feign调用即可。\n在真实工作中，用户和管理员对应的oauth认证服务器会分开，网关也会分开，我们今天的课堂案例只实现用户相关的认证即可。\n(1)、实现自定义认证类\n编写自定义认证类，com.offcn.oauth.auth.userdetailsserviceimpl该类实现了加载用户相关信息进行授权和认证，如下代码：\n@service public class userdetailsserviceimpl implements userdetailsservice { @override public userdetails loaduserbyusername(string username) throws usernamenotfoundexception { //根据用户名查询用户信息 string pwd = new bcryptpasswordencoder().encode(\u0026#34;dongyimai\u0026#34;); //创建角色 string permissions=\u0026#34;salesman,accountant,user\u0026#34;; //创建用户对象 user userdetails = new user(username,pwd, authorityutils.commaseparatedstringtoauthoritylist(permissions)); return userdetails; } } 上述代码给登录用户定义了三个角色，分别为salesman,accountant,user，这一块我们目前使用的是硬编码方式将角色写死了，后面会从数据库加载。\n密码也统一写死成了:dongyimai\n修改配置类websecurityconfig\n注释原来写死账号密码的如下代码：\n/* //声明自定义认证对象 @bean(name = \u0026#34;userdetailsservice\u0026#34;) @override public userdetailsservice userdetailsservicebean() throws exception { return this.createuserdetailsservice(); } @override protected userdetailsservice userdetailsservice() { //启用自定义认证对象进行认证 return this.createuserdetailsservice(); } //自定义认证，声明用户登录账号、密码 private userdetailsservice createuserdetailsservice(){ list\u0026lt;userdetails\u0026gt; users=new arraylist\u0026lt;\u0026gt;(); userdetails adminuser = user.withusername(\u0026#34;admin\u0026#34;).password(passwordencoder().encode(\u0026#34;123\u0026#34;)).authorities(\u0026#34;admin\u0026#34;, \u0026#34;user\u0026#34;).build(); userdetails oneuser = user.withusername(\u0026#34;user1\u0026#34;).password(passwordencoder().encode(\u0026#34;123\u0026#34;)).authorities(\u0026#34;admin\u0026#34;, \u0026#34;user\u0026#34;).build(); userdetails towuser = user.withusername(\u0026#34;user2\u0026#34;).password(passwordencoder().encode(\u0026#34;456\u0026#34;)).authorities(\u0026#34;user\u0026#34;).build(); users.add(adminuser); users.add(oneuser); users.add(towuser); return new inmemoryuserdetailsmanager(users); }*/ 重写获取自定义认证类方法\n@autowired userdetailsservice userdetailsservice; @override protected userdetailsservice userdetailsservice() { return userdetailsservice; } (2)修改feign\n修改dongyimai-user-service-api中创建com.offcn.user.feign.userfeign，添加代码如下：\n@feignclient(name=\u0026#34;dym-user\u0026#34;) @requestmapping(\u0026#34;/user\u0026#34;) public interface userfeign { /*** * 根据username查询用户信息 * @param username * @return */ @getmapping(\u0026#34;/load/{username}\u0026#34;) result\u0026lt;user\u0026gt; findbyusername(@pathvariable string username); } (3)修改usercontroller\n修改dongyimai-user-service的usercontroller添加findbyusername方法，代码如下： @getmapping(\u0026#34;/load/{username}\u0026#34;) public result\u0026lt;user\u0026gt; findbyusername(@pathvariable string username){ //调用userservice实现根据主键查询user user user = userservice.findbyusername(username); return new result\u0026lt;user\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,user); } (4)放行查询用户方法\n因为oauth需要调用查询用户信息，需要在dongyimai-user-service中放行/user/load/{username}方法,修改resourceserverconfig，添加对/user/load/{username}的放行操作，代码如下： (5)oauth调用查询用户信息\noauth引入对user-service-api的依赖\n\u0026lt;!--依赖用户api--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-user-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 修改oauth的com.offcn.oauth.userdetailsserviceimpl的loaduserbyusername方法，调用userfeign查询用户信息，代码如下：\n@autowired private userfeign userfeign; @override public userdetails loaduserbyusername(string username) throws usernamenotfoundexception { //调用用户微服务，根据用户名获得用户信息 result\u0026lt;user\u0026gt; userresult = userfeign.findbyusername(username); if(userresult!=null\u0026amp;\u0026amp;userresult.getdata()!=null) { //获取用户密码 string pwd = userresult.getdata().getpassword(); //根据用户名查询用户信息 //string pwd = new bcryptpasswordencoder().encode(\u0026#34;dongyimai\u0026#34;); //创建user对象 //string permissions = \u0026#34;goods_list,seckill_list\u0026#34;; string permissions = \u0026#34;salesman,accountant,user\u0026#34;; user userdetails = new user(username, pwd, authorityutils.commaseparatedstringtoauthoritylist(permissions)); return userdetails; }else { return null; } } (6)feign开启\n修改com.offcn.oauthapplication开启feign客户端功能\n@springbootapplication @enablediscoveryclient @enablefeignclients(basepackages = {\u0026#34;com.offcn.user.feign\u0026#34;}) public class oauthapplication { public static void main(string[] args) { springapplication.run(oauthapplication.class,args); } @bean(name = \u0026#34;resttemplate\u0026#34;) public resttemplate resttemplate() { return new resttemplate(); } } (7)、设置feign的调用超时时间修改application.yml\n# 开启feign的熔断功能 feign: hystrix: enabled: true #总连接超时时间=（切换服务实例次数+1）*（每个实例重试次数+1）*连接超时时间 user: #服务名称 ribbon: #配置指定服务的负载均衡策略 nfloadbalancerruleclassname: com.netflix.loadbalancer.roundrobinrule # ribbon的连接超时时间 connecttimeout: 2000 # ribbon的数据读取超时时间 readtimeout: 2000 # 是否对所有操作都进行重试 oktoretryonalloperations: true # 切换实例的重试次数 maxautoretriesnextserver: 1 # 对当前实例的重试次数 maxautoretries: 1 #设定hystrix熔断超时时间 ，理论上熔断时间应该大于总连接超时时间 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 (7)测试\n我们换个数据库中的账号密码登录，分别输入zhangsan，密码使用我们前面的测试类重新生成密码拷贝进入数据库中替换原有的数据，然后测试效果如下： 注意账号密码从数据表tb_user查看： 4 购物车 购物车分为用户登录购物车和未登录购物车操作，传统的电商系统在用户登录和不登录都可以操作购物车，如果用户不登录，操作购物车可以将数据存储到cookie或者websql或者sessionstorage中，用户登录后购物车数据可以存储到redis中，再将之前未登录加入的购物车合并到redis中即可。\n淘宝天猫等则采用了另外一种实现方案，用户要想将商品加入购物车，必须先登录才能操作购物车。\n我们今天实现的购物车是天猫解决方案，即用户必须先登录才能使用购物车功能。\n4.1 购物车分析 (1)需求分析\n用户在商品详细页点击加入购物车，提交商品sku编号和购买数量，添加到购物车。购物车展示页面如下： (2)购物车实现思路 我们实现的是用户登录后的购物车，用户将商品加入购物车的时候，直接将要加入购物车的详情存入到redis即可。每次查看购物车的时候直接从redis中获取。\n(3)表结构分析\n用户登录后将商品加入购物车，需要存储商品详情以及购买数量，购物车详情表如下：\ndongyimaidb数据库中tb_order_item表：\ncreate table `tb_order_item` ( `id` bigint(20) not null, `item_id` bigint(20) not null comment \u0026#39;sku_id\u0026#39;, `goods_id` bigint(20) default null comment \u0026#39;spu_id\u0026#39;, `order_id` bigint(20) not null comment \u0026#39;订单id\u0026#39;, `title` varchar(200) collate utf8_bin default null comment \u0026#39;商品标题\u0026#39;, `price` decimal(20,2) default null comment \u0026#39;商品单价\u0026#39;, `num` int(10) default null comment \u0026#39;商品购买数量\u0026#39;, `total_fee` decimal(20,2) default null comment \u0026#39;商品总金额\u0026#39;, `pic_path` varchar(200) collate utf8_bin default null comment \u0026#39;商品图片地址\u0026#39;, `seller_id` varchar(100) collate utf8_bin default null, primary key (`id`) using btree, key `item_id` (`item_id`) using btree, key `order_id` (`order_id`) using btree ) engine=innodb default charset=utf8 collate=utf8_bin row_format=dynamic 购物车详情表其实就是订单详情表结构，只是目前临时存储数据到redis，等用户下单后才将数据从redis取出存入到数据库中。\n4.2 订单购物车微服务 我们先搭建一个订单购物车微服务工程，按照如下步骤实现即可。\n(1)导入资源\n搭建订单购物车微服务，工程名字dongyimai-order-service并搭建对应的api工程dongyimai-order-service-api，如下图：\n同时在dongyimai-order-service中引入dongyimai-order-service-api,\n依赖引入：\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-order-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在dongyimai-order-service-api中引入依赖：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common-db\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 将代码生成器生成好的dao和相关文件拷贝到工程中，以及生成好的pojo拷贝到api工程中\ndongyimai-order-service: (2)application.yml配置\n在dongyimai-service-order的resources中添加application.yml配置文件，代码如下：\nserver: port: 9008 spring: application: name: order datasource: driver-class-name: com.mysql.cj.jdbc.driver url: jdbc:mysql://localhost:3306/dongyimaidb?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=gmt%2b8 username: root password: root type: com.alibaba.druid.pool.druiddatasource redis: host: 192.168.188.138 port: 6379 main: allow-bean-definition-overriding: true eureka: client: service-url: defaultzone: http://localhost:8761/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 feign: hystrix: enabled: true mybatis-plus: configuration: map-underscore-to-camel-case: true #开启驼峰式编写规范 type-aliases-package: com.offcn.order.pojo # 配置sql打印日志 logging: level: com.offcn: debug (3)创建启动类\n在dongyimai-service-order的com.offcn.order中创建启动类，代码如下：\n@springbootapplication @enablediscoveryclient @mapperscan(basepackages = {\u0026#34;com.offcn.order.dao\u0026#34;}) public class orderapplication { public static void main(string[] args) { springapplication.run(orderapplication.class,args); } } 4.3 添加购物车 4.3.1 思路分析 用户添加购物车，只需要将要加入购物车的商品存入到redis中即可。一个用户可以将多件商品加入购物车，存储到redis中的数据可以采用hash类型。\n购物车数据的存储结构如下： 4.3.2 代码实现 (1)在dongyimai-order-service-api下创建购物车复合实体类com.offcn.order.group.cart.java\npublic class cart implements serializable{ private string sellerid;//商家id private string sellername;//商家名称 private list\u0026lt;orderitem\u0026gt; orderitemlist;//购物车明细 //getter and setter ...... } (2)feign创建\n下订单需要调用feign查看商品信息，我们先创建feign分别根据id查询sku和spu信息，在dongyimai-sellergoods-serivce-api工程中的itemfeign和goodsfeign根据id查询方法如下：\ncom.offcn.sellergoods.feign.itemfeign\n@feignclient(name=\u0026#34;dym-sellergoods\u0026#34;) @requestmapping(\u0026#34;/item\u0026#34;) public interface itemfeign { /*** * 根据id查询item数据 * @param id * @return */ @getmapping(\u0026#34;/{id}\u0026#34;) result\u0026lt;item\u0026gt; findbyid(@pathvariable long id); } com.offcn.sellergoods.feign.goodsfeign\n@feignclient(name=\u0026#34;dym-sellergoods\u0026#34;) @requestmapping(\u0026#34;/goods\u0026#34;) public interface goodsfeign { /*** * 根据id查询商品数据 * @param id * @return */ @getmapping(\u0026#34;/{id}\u0026#34;) result\u0026lt;goodsentity\u0026gt; findbyid(@pathvariable long id); } (3)业务层\n业务层接口\n在dongyimai-order-servicer微服务中创建com.offcn.order.service.cartservice接口，代码如下：\npublic interface cartservice { /** * 添加商品到购物车 * @param cartlist * @param itemid * @param num * @return */ public list\u0026lt;cart\u0026gt; addgoodstocartlist(list\u0026lt;cart\u0026gt; cartlist, long itemid, integer num ); /** * 从redis中查询购物车 * @param username * @return */ public list\u0026lt;cart\u0026gt; findcartlistfromredis(string username); /** * 将购物车保存到redis * @param username * @param cartlist */ public void savecartlisttoredis(string username,list\u0026lt;cart\u0026gt; cartlist); } 业务层接口实现类\n在dongyimai-service-order微服务中创建接口实现类com.offcn.order.service.impl.cartserviceimpl,代码如下：\n@service public class cartserviceimpl implements cartservice { @autowired private itemfeign itemfeign; @autowired private redistemplate redistemplate; @override public list\u0026lt;cart\u0026gt; addgoodstocartlist(list\u0026lt;cart\u0026gt; cartlist, long itemid, integer num) { //1.根据商品sku id查询sku商品信息 result\u0026lt;item\u0026gt; itemresult = itemfeign.findbyid(itemid); item item = itemresult.getdata(); if(item==null){ throw new runtimeexception(\u0026#34;商品不存在\u0026#34;); } if(!item.getstatus().equals(\u0026#34;1\u0026#34;)){ throw new runtimeexception(\u0026#34;商品状态无效\u0026#34;); } //2.获取商家id string sellerid = item.getsellerid(); //3.根据商家id判断购物车列表中是否存在该商家的购物车 cart cart = searchcartbysellerid(cartlist,sellerid); //4.如果购物车列表中不存在该商家的购物车 if(cart==null){ //4.1 新建购物车对象 ， cart=new cart(); cart.setsellerid(sellerid); cart.setsellername(item.getseller()); orderitem orderitem = createorderitem(item,num); list orderitemlist=new arraylist(); orderitemlist.add(orderitem); cart.setorderitemlist(orderitemlist); //4.2将购物车对象添加到购物车列表 cartlist.add(cart); }else{ //5.如果购物车列表中存在该商家的购物车 // 判断购物车明细列表中是否存在该商品 orderitem orderitem = searchorderitembyitemid(cart.getorderitemlist(),itemid); if(orderitem==null){ //5.1. 如果没有，新增购物车明细 orderitem=createorderitem(item,num); cart.getorderitemlist().add(orderitem); }else{ //5.2. 如果有，在原购物车明细上添加数量，更改金额 orderitem.setnum(orderitem.getnum()+num); orderitem.settotalfee(new bigdecimal(orderitem.getnum()*orderitem.getprice().doublevalue())); //如果数量操作后小于等于0，则移除 if(orderitem.getnum()\u0026lt;=0){ cart.getorderitemlist().remove(orderitem);//移除购物车明细 } //如果移除后cart的明细数量为0，则将cart移除 if(cart.getorderitemlist().size()==0){ cartlist.remove(cart); } } } return cartlist; } /** * 从redis中查询购物车 * * @param username * @return */ @override public list\u0026lt;cart\u0026gt; findcartlistfromredis(string username) { system.out.println(\u0026#34;从redis中提取购物车数据.....\u0026#34;+username); list\u0026lt;cart\u0026gt; cartlist = (list\u0026lt;cart\u0026gt;) redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).get(username); if(cartlist==null){ cartlist=new arraylist(); } return cartlist; } /** * 将购物车保存到redis * * @param username * @param cartlist */ @override public void savecartlisttoredis(string username, list\u0026lt;cart\u0026gt; cartlist) { system.out.println(\u0026#34;向redis存入购物车数据.....\u0026#34;+username); redistemplate.boundhashops(\u0026#34;cartlist\u0026#34;).put(username, cartlist); } /** * 根据商家id查询购物车对象 * @param cartlist * @param sellerid * @return */ private cart searchcartbysellerid(list\u0026lt;cart\u0026gt; cartlist, string sellerid){ for(cart cart:cartlist){ if(cart.getsellerid().equals(sellerid)){ return cart; } } return null; } /** * 根据商品明细id查询 * @param orderitemlist * @param itemid * @return */ private orderitem searchorderitembyitemid(list\u0026lt;orderitem\u0026gt; orderitemlist ,long itemid ){ for(orderitem orderitem :orderitemlist){ if(orderitem.getitemid().longvalue()==itemid.longvalue()){ return orderitem; } } return null; } /** * 创建订单明细 * @param item * @param num * @return */ private orderitem createorderitem(item item,integer num){ if(num\u0026lt;=0){ throw new runtimeexception(\u0026#34;数量非法\u0026#34;); } orderitem orderitem=new orderitem(); orderitem.setgoodsid(item.getgoodsid()); orderitem.setitemid(item.getid()); orderitem.setnum(num); orderitem.setpicpath(item.getimage()); orderitem.setprice(item.getprice()); orderitem.setsellerid(item.getsellerid()); orderitem.settitle(item.gettitle()); orderitem.settotalfee(new bigdecimal(orderitem.getprice().doublevalue()*num)); return orderitem; } } 添加dongyimai-order-service对dongyimai-sellergoods-serivce-api的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-sellergoods-serivce-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; (3)控制层\n在dongyimai-service-order微服务中创建com.offcn.order.controller.cartcontroller，代码如下：\n@restcontroller @crossorigin @requestmapping(value = \u0026#34;/cart\u0026#34;) public class cartcontroller { @autowired private cartservice cartservice; /** * 购物车列表 * * @return */ @requestmapping(\u0026#34;/findcartlist\u0026#34;) public list\u0026lt;cart\u0026gt; findcartlist(string username) { return cartservice.findcartlistfromredis(username);//从redis中提取 } @requestmapping(\u0026#34;/addgoodstocartlist\u0026#34;) public result addgoodstocartlist(long itemid, integer num) { string username = \u0026#34;ujiuye\u0026#34;; try { list\u0026lt;cart\u0026gt; cartlist = findcartlist(username);//获取购物车列表 cartlist = cartservice.addgoodstocartlist(cartlist, itemid, num); cartservice.savecartlisttoredis(username, cartlist); return new result(true, statuscode.ok, \u0026#34;添加成功\u0026#34;); } catch (exception e) { e.printstacktrace(); return new result(false, statuscode.error, \u0026#34;添加失败\u0026#34;); } } } (4)feign配置\n修改com.offcn.orderapplication开启feign客户端：\n@springbootapplication @enableeurekaclient @enablefeignclients(basepackages = {\u0026#34;com.offcn.sellergoods.feign\u0026#34;}) @mapperscan(basepackages = {\u0026#34;com.offcn.order.dao\u0026#34;}) public class orderapplication { public static void main(string[] args) { springapplication.run(orderapplication.class,args); } } 测试添加购物车，效果如下：\n请求地址http://localhost:9008/cart/addgoodstocartlist?itemid=1369283\u0026amp;num=100 测试查看购物车：http://localhost:9008/cart/findcartlist?username=ujiuye 5 用户身份识别 5.1 购物车需求分析 购物车功能已经做完了，但用户我们都是硬编码写死的。用户要想将商品加入购物车，必须得先登录授权，登录授权后再经过微服务网关，微服务网关需要过滤判断用户请求是否存在令牌，如果存在令牌，才能再次访问微服务，此时网关会通过过滤器将令牌数据再次存入到头文件中，然后访问模板渲染服务，模板渲染服务再调用订单购物车微服务，此时也需要将令牌数据存入到头文件中，将令牌数据传递给购物车订单微服务，到了购物车订单微服务的时候，此时微服务需要校验令牌数据，如果令牌正确，才能使用购物车功能，并解析令牌数据获取用户信息。\n5.2 微服务之间认证 如上图：因为微服务之间并没有传递头文件，所以我们可以定义一个拦截器，每次微服务调用之前都先检查下头文件，将请求的头文件中的令牌数据再放入到header中，再调用其他微服务即可。\n(1)创建feign拦截器\n在dongyimai-order-service服务中创建一个com.offcn.order.config.feigninterceptor拦截器，并将所有头文件数据再次加入到feign请求的微服务头文件中，代码如下：\npublic class feigninterceptor implements requestinterceptor { @override public void apply(requesttemplate requesttemplate) { try { //使用requestcontextholder工具获取request相关变量 servletrequestattributes attributes = (servletrequestattributes) requestcontextholder.getrequestattributes(); if (attributes != null) { //取出request httpservletrequest request = attributes.getrequest(); //获取所有头文件信息的key enumeration\u0026lt;string\u0026gt; headernames = request.getheadernames(); if (headernames != null) { while (headernames.hasmoreelements()) { //头文件的key string name = headernames.nextelement(); //头文件的value string values = request.getheader(name); //将令牌数据添加到头文件中 requesttemplate.header(name, values); } } } } catch (exception e) { e.printstacktrace(); } } } (2)创建拦截器bean\n在dongyimai-order-service服务中启动类里创建对象实例\n/*** * 创建拦截器bean对象 * @return */ @bean public feigninterceptor feigninterceptor(){ return new feigninterceptor(); } (3)我们将sellergoods工程配置上身份认证\n修改dongyimai-order-service的pom.xml，添加oauth的依赖\n\u0026lt;!--oauth依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 将公钥拷贝到dongyimai-order-service工程的resources中 在dongyimai-order-service工程中创建com.offcn.order.config.resourceserverconfig,配置需要拦截的路径，这里需要拦截所有请求路径，代码如下：\n@configuration @enableresourceserver @enableglobalmethodsecurity(prepostenabled = true, securedenabled = true)//激活方法上的preauthorize注解 public class resourceserverconfig extends resourceserverconfigureradapter { //公钥 private static final string public_key = \u0026#34;public.key\u0026#34;; //读取公钥的方法 private string getpubkey(){ //加载公钥文件 resource resource = new classpathresource(public_key); //读取输入流 try { inputstreamreader inputstreamreader = new inputstreamreader(resource.getinputstream()); bufferedreader br = new bufferedreader(inputstreamreader); //读取第1行，公钥数据 string s; if((s=br.readline())!=null){ return s; } } catch (ioexception e) { e.printstacktrace(); } return null; } /*** * 定义jjwtaccesstokenconverter * 帮助程序在jwt编码的令牌值和oauth身份验证信息之间进行转换 * @return */ @bean public jwtaccesstokenconverter jwtaccesstokenconverter() { jwtaccesstokenconverter converter = new jwtaccesstokenconverter(); converter.setverifierkey(getpubkey()); return converter; } /*** * 定义jwttokenstore * @param jwtaccesstokenconverter * @return */ @bean public tokenstore tokenstore(jwtaccesstokenconverter jwtaccesstokenconverter) { return new jwttokenstore(jwtaccesstokenconverter); } /*** * http安全配置，对每个到达系统的http请求链接进行校验 * @param http * @throws exception */ @override public void configure(httpsecurity http) throws exception { //所有请求必须认证通过 http.authorizerequests() //下边的路径放行 .antmatchers( \u0026#34;/spec/**\u0026#34;). //配置地址放行 permitall() .anyrequest(). authenticated(); //其他地址需要认证授权 } } 注意：当dongyimai-order-service运行起来可能会报链接不到redis localhost:6379,此处可以再配置文件中配置一下即可 。\n再次发送添加购物车请求测试， 我们发现servletrequestattributes始终为空，原因是requestcontextholder.getrequestattributes()该方法是从threadlocal变量里面取得相应信息的，当hystrix断路器的隔离策略为thread时，是无法取得threadlocal中的值。\n解决方案：开启熔断，并将hystrix隔离策略换为semaphore\n修改dongyimai-order-service的application.yml配置文件，在application.yml中添加如下代码，代码如下：\n#hystrix 配置 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 strategy: semaphore 再次测试(注意要重新登陆、使用生成的令牌进行访问)\n效果如下： (4)工具类抽取\n微服务之间相互认证的情况非常多，我们可以把上面的拦截器抽取出去，放到dongyimai-common的config包中，其他工程需要用，直接创建一个@bean对象即可。\n5.3 网关过滤 为了不给微服务带来一些无效的请求，我们可以在网关中过滤用户请求，先看看头文件中是否有authorization，如果没有再看看cookie中是否有authorization，如果都通过了才允许请求到达微服务。\n5.4 订单对接网关+oauth (1)application.yml配置\n修改微服务网关dongyimai-gateway-web的application.yml配置文件，添加order的路由过滤配置，配置如下： 上图代码如下：\n#购物车微服务 - id: dongyimai_order_route uri: lb://order predicates: - path=/api/cart/**,/api/order/**,/api/orderitem/** filters: - stripprefix=1 这里注意使用的是yml格式，所以上面代码中的空格也一并记得拷贝到application.yml文件中。\n(2)过滤配置\n在微服务网关dongyimai-gateway-web中添加com.offcn.filter.urlfilter过滤类，用于过滤需要用户登录的地址，代码如下：\npublic class urlfilter { /** * 要放行的路径 */ private static final string noauthorizeurls = \u0026#34;/api/user/add,/api/user/login\u0026#34;; /** * 判断 当前的请求的地址中是否在已有的不拦截的地址中存在,如果存在 则返回true 表示 不拦截 false表示拦截 * * @param uri 获取到的当前的请求的地址 * @return */ public static boolean hasauthorize(string uri) { string[] split = noauthorizeurls.split(\u0026#34;,\u0026#34;); for (string s : split) { if (s.equals(uri)) { return true; } } return false; } } (3)全局过滤器修改\n修改之前的com.offcn.filter.authorizefilter的过滤方法，将是否需要用户登录过滤也加入其中，代码如下： //获取请求的uri string path = request.geturi().getpath(); //判断请求路径是否是不需要验证的 if(urlfilter.hasauthorize(path)){ //直接放行 return chain.filter(exchange); } (4)测试\n使用postman访问 http://localhost:8001/api/cart/addgoodstocartlist?itemid=1369283\u0026amp;num=100，效果如下：\n未登录： 使用postman访问 http://localhost:8001/api/cart/addgoodstocartlist?itemid=1369283\u0026amp;num=100，效果如下：\n已登录： 使用postman访问 http://localhost:8001/api/cart/findcartlist?username=ujiuye，效果如下：\n5.5 获取用户数据 5.5.1 数据分析 用户登录后，数据会封装到securitycontextholder.getcontext().getauthentication()里面，我们可以将数据从这里面取出，然后转换成oauth2authenticationdetails,在这里面可以获取到令牌信息、令牌类型等，代码如下： 这里的tokenvalue是加密之后的令牌数据，remoteaddress是用户的ip信息，tokentype是令牌类型。\n我们可以获取令牌加密数据后，使用公钥对它进行解密，如果能解密说明语句无误，如果不能解密用户也没法执行到这一步。解密后可以从明文中获取用户信息。\n5.5.2 代码实现 (1)在dongyimai-common工程中引入鉴权包\n\u0026lt;!--oauth依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-oauth2\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--鉴权--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.jsonwebtoken\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jjwt\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; (2)读取公钥\n在dongyimai-common中创建com.offcn.utils.tokendecode类，用于解密令牌信息，在类中读取公钥信息，代码如下：\npublic class tokendecode { //公钥 private static final string public_key=\u0026#34;public.key\u0026#34;; //定义读取公钥内容变量 private static string publickey=\u0026#34;\u0026#34;; //读取公钥内容方法 private string getpubkey(){ resource resource=new classpathresource(public_key); try { inputstreamreader inputstreamreader = new inputstreamreader(resource.getinputstream()); bufferedreader bufferedreader = new bufferedreader(inputstreamreader); //读取第一行公钥数据 if((publickey=bufferedreader.readline())!=null){ return publickey; } } catch (ioexception e) { e.printstacktrace(); } return publickey; } } (2)校验解析令牌数据\n在tokendecode类中添加校验解析令牌数据的方法，这里用到了jwthelper实现。\n/*** * 读取令牌数据 */ public map\u0026lt;string,string\u0026gt; dcodetoken(string token){ //校验jwt jwt jwt = jwthelper.decodeandverify(token, new rsaverifier(getpubkey())); //获取jwt原始内容 string claims = jwt.getclaims(); return json.parseobject(claims,map.class); } (3)获取令牌数据\n在tokendecode类中添加一个getuserinfo方法，用于从容器中获取令牌信息，代码如下：\n/*** * 获取用户信息 * @return */ public map\u0026lt;string,string\u0026gt; getuserinfo(){ //获取授权信息 oauth2authenticationdetails details = (oauth2authenticationdetails) securitycontextholder.getcontext().getauthentication().getdetails(); //令牌解码 return dcodetoken(details.gettokenvalue()); } 完整代码：\nimport com.alibaba.fastjson.json; import org.springframework.core.io.classpathresource; import org.springframework.core.io.resource; import org.springframework.security.core.context.securitycontextholder; import org.springframework.security.jwt.jwt; import org.springframework.security.jwt.jwthelper; import org.springframework.security.jwt.crypto.sign.rsaverifier; import org.springframework.security.oauth2.provider.authentication.oauth2authenticationdetails; import java.io.bufferedreader; import java.io.ioexception; import java.io.inputstreamreader; import java.util.map; public class tokendecode { //公钥 private static final string public_key=\u0026#34;public.key\u0026#34;; //定义读取公钥内容变量 private static string publickey=\u0026#34;\u0026#34;; //读取公钥内容方法 private string getpubkey(){ resource resource=new classpathresource(public_key); try { inputstreamreader inputstreamreader = new inputstreamreader(resource.getinputstream()); bufferedreader bufferedreader = new bufferedreader(inputstreamreader); //读取第一行公钥数据 if((publickey=bufferedreader.readline())!=null){ return publickey; } } catch (ioexception e) { e.printstacktrace(); } return publickey; } //解析令牌读取数据 public map\u0026lt;string, string\u0026gt; decodetoken(string token){ //调用公钥解析令牌 jwt jwt = jwthelper.decodeandverify(token, new rsaverifier(getpubkey())); //获取原始内容 string claims = jwt.getclaims(); //解析json字符串为map return json.parseobject(claims, map.class); } //访问当前登录的用户信息解析令牌获取用户数据 public map\u0026lt;string, string\u0026gt; getuserinfo(){ //获取springsecurity登录信息 oauth2authenticationdetails details= (oauth2authenticationdetails) securitycontextholder.getcontext().getauthentication().getdetails(); //解析令牌 return decodetoken(details.gettokenvalue()); } } (4)dongyimai-order-service微服务的主启动类中声明tokendecode\n@bean public tokendecode gettokendecode(){ return new tokendecode(); } (5)order微服务的控制层获取用户数据\n在cartcontroller中注入tokendecode，并调用tokendecode的getuserinfo方法获取用户信息，代码如下：\n注入tokendecode：\n@autowired private tokendecode tokendecode; 获取用户名： @restcontroller @crossorigin @requestmapping(value = \u0026#34;/cart\u0026#34;) public class cartcontroller { @autowired private cartservice cartservice; @autowired private tokendecode tokendecode; /** * 购物车列表 * * @return */ @requestmapping(\u0026#34;/findcartlist\u0026#34;) public list\u0026lt;cart\u0026gt; findcartlist() { map\u0026lt;string, string\u0026gt; userinfo = tokendecode.getuserinfo(); system.out.println(\u0026#34;userinfo:\u0026#34;+userinfo); string username=userinfo.get(\u0026#34;user_name\u0026#34;); return cartservice.findcartlistfromredis(username);//从redis中提取 } @requestmapping(\u0026#34;/addgoodstocartlist\u0026#34;) public result addgoodstocartlist(long itemid, integer num) { //string username = \u0026#34;ujiuye\u0026#34;; map\u0026lt;string, string\u0026gt; userinfo = tokendecode.getuserinfo(); system.out.println(\u0026#34;userinfo:\u0026#34;+userinfo); string username=userinfo.get(\u0026#34;user_name\u0026#34;); try { list\u0026lt;cart\u0026gt; cartlist = findcartlist();//获取购物车列表 cartlist = cartservice.addgoodstocartlist(cartlist, itemid, num); cartservice.savecartlisttoredis(username, cartlist); return new result(true, statuscode.ok, \u0026#34;添加成功\u0026#34;); } catch (exception e) { e.printstacktrace(); return new result(false, statuscode.error, \u0026#34;添加失败\u0026#34;); } } } (5)测试\n用户登录后测试\n经过网关转发请求添加到购物车：\nhttp://localhost:8001/api/cart/addgoodstocartlist?itemid=1324601\u0026amp;num=1\n查看redis缓存中保存的用户数据 经过网关，查看购物车数据:\nhttp://localhost:8001/api/cart/findcartlist\n","date":"2022-05-28","permalink":"https://lovemjh.vercel.app/posts/project-0/20220528170121/","summary":"第十二章 购物车解决方案 优就业.JAVA教研室 学习目标 目标1：资源服务器授权配置 目标2：掌握OAuth认证微服务动态加载数据 目标3：掌握购物车流程 目标4：掌握购物","title":"购物车解决方案"},{"content":"三、docker快速入门 1.docker简介 docker是一个开源的容器引擎，它可以帮助我们更快地交付应用。docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序一样进行管理。使用docker，可更快地打包、测试以及部署应用程序，并可减少从编写到部署运行代码的周期。\ndocker官方网站：https://www.docker.com/\n1.1 docker版本 1.1.1 docker（企业版） docker ee由公司支持，可在经过认证的操作系统和云提供商中使用，并可运行来自docker store的、经过认证的容器和插件。\n1.1.2 docker(免费版) docker ce是免费的docker产品的新名称，docker ce包含了完整的docker平台，非常适合开发人员和运维团队构建容器app\n1.2 docker架构 1.2.1 docker daemon(docker守护进程) docker daemon是一个运行在宿主机（docker_host）的后台进程。我们可通过docker客户端与之通信。\n1.2.2 client(docker客户端) docker客户端是docker的用户界面，它可以接受用户命令和配置标识，并与docker daemon通信。图中，docker build等都是docker的相关命令。\n1.2.3 images(docker镜像) docker镜像是一个只读模板，它包含创建docker容器的说明。它和系统安装光盘有点像——我们使用系统安装光盘安装系统，同理，我们使用docker镜像运行docker镜像中的程序。\n1.2.4 container(容器) 容器是镜像的可运行实例。镜像和容器的关系有点类似于面向对象中，类和对象的关系。我们可通过docker api或者cli命令来启停、移动、删除容器。\n1.2.5 registry(仓库) docker registry是一个集中存储与分发镜像的服务。我们构建完docker镜像后，就可在当前宿主机上运行。但如果想要在其他机器上运行这个镜像，我们就需要手动拷贝。此时，我们可借助docker registry来避免镜像的手动拷贝。\n一个docker registry可包含多个docker仓库；每个仓库可包含多个镜像标签；每个标签对应一个docker镜像。这跟maven的仓库有点类似，如果把docker registry比作maven仓库的话，那么docker仓库就可理解为某jar包的路径，而镜像标签则可理解为jar包的版本号。\n2.docker安装启动 2.1 运行安装环境 采用linux操作系统，版本为：centos7.0 64位，docker采用ce版：18.06.0.ce-3\n2.2 docker安装过程 2.2.1 下载docker-ce rpm安装包 https://download.docker.com/linux/centos/7/x86_64/stable/packages/\n注意下载版本要和操作系统版本对应。\ndocker-ce-18.06.0.ce-3.el7.x86_64.rpm\n2.2.2 安装docker 上传 docker-ce-18.06.0.ce-3.el7.x86_64.rpm 到opt\n执行命令:\tyum install -y docker-ce-18.06.0.ce-3.el7.x86_64.rpm\n注意：确保linux服务器处于联网状态。\n常见问题：\n当用yum安装时报错。。。 error: package: glibc-headers-2.17-196.el7_4.2.x86_64 (ultra-centos-7.4-updates) requires: glibc = 2.17-196.el7_4.2 installed: glibc-2.17-222.el7.x86_64 (installed) glibc = 2.17-222.el7 available: glibc-2.17-196.el7.x86_64 (ultra-centos-7.4-base) glibc = 2.17-196.el7 available: glibc-2.17-196.el7_4.2.x86_64 (ultra-centos-7.4-updates) glibc = 2.17-196.el7_4.2 error: package: gcc-4.8.5-16.el7_4.2.x86_64 (ultra-centos-7.4-updates) requires: libgomp = 4.8.5-16.el7_4.2 installed: libgomp-4.8.5-28.el7_5.1.x86_64 (installed) libgomp = 4.8.2-16.el7_5 libgomp = 4.8.5-28.el7_5.1 available: libgomp-4.8.5-16.el7.x86_64 (ultra-centos-7.4-base) libgomp = 4.8.5-16.el7 libgomp = 4.8.2-16.el7 available: libgomp-4.8.5-16.el7_4.1.x86_64 (ultra-centos-7.4-updates) libgomp = 4.8.5-16.el7_4.1 libgomp = 4.8.2-16.el7_4 available: libgomp-4.8.5-16.el7_4.2.x86_64 (ultra-centos-7.4-updates) libgomp = 4.8.5-16.el7_4.2 libgomp = 4.8.2-16.el7_4 error: package: glibc-devel-2.17-196.el7_4.2.x86_64 (ultra-centos-7.4-updates) requires: glibc = 2.17-196.el7_4.2 installed: glibc-2.17-222.el7.x86_64 (installed) glibc = 2.17-222.el7 available: glibc-2.17-196.el7.x86_64 (ultra-centos-7.4-base) glibc = 2.17-196.el7 available: glibc-2.17-196.el7_4.2.x86_64 (ultra-centos-7.4-updates) glibc = 2.17-196.el7_4.2 you could try using --skip-broken to work around the problem you could try running: rpm -va --nofiles --nodigest 解决办法： wget -o /etc/yum.repos.d/centos-base.repo http://mirrors.aliyun.com/repo/centos-7.repo sed -i \u0026#39;s/$releasever/7/g\u0026#39; /etc/yum.repos.d/centos-base.repo 、yum repolist 2.2.3 启动与停止docker 启动docker：systemctl start docker\n停止docker：systemctl stop docker\n重启docker：systemctl restart docker\n查看docker状态：systemctl status docker\n2.2.4 验证docker是否安装成功 执行命令：docker info\n查看返回信息，能否查看到docker相关信息\n到此，docker安装完毕！\n3.docker配置镜像加速器 国内访问docker hub的速度很不稳定，有时甚至出现连接不上的情况。我们来为docker配置镜像加速器，从而解决这个问题。目前国内很多云服务商都提供了镜像加速的服务。\n常用的镜像加速器有：阿里云加速器daocloud加速器等。各厂商镜像加速器的使用方式大致类似，笔者以阿里云加速器为例进行讲解。\n注册阿里云账号后，即可在阿里云控制台(https://cr.console.aliyun.com/#/accelerator)看到类似如下的页面。\n3.1 新建编辑： /etc/docker/daemon.json {\n\u0026ldquo;registry-mirrors\u0026rdquo;: [\u0026ldquo;https://ksc53x4t.mirror.aliyuncs.com\u0026rdquo;]\n}\n3.2 修改保存后输入如下命令重启docker守护进程和服务 重启docker守护程序\nsystemctl daemon-reload\n重启docker服务\nsystemctl restart docker\n查看docker容器信息\ndocker info\n查看最后倒数第二行出现如下内容说明配置成功\nregistry mirrors: https://j4pan1gm.mirror.aliyuncs.com/ 4.docker镜像操作的常用指令 4.1 搜索指令 4.1.1通过镜像仓库搜索 docker镜像仓库网址：https://hub.docker.com/search?q=\u0026amp;type=image\n4.1.2 指令搜索 docker search tomcat //搜索tomcat镜像\n4.2 下载镜像 docker pull 镜像名称 //查询最近的版本\ndocker pull 镜像名称:版本标签\n如：\ndocker pull tomcat\ndocker pull tomcat:8.5.57-jdk8-openjdk-slim\n4.3 查看本地镜像 docker images\n4.4 删除镜像 docker rmi tomcat:8.5.57-jdk8-openjdk-slim //通过镜像名:版本号\n或\ndocker rmi b1a27cee0cec //通过image id删除\n4.5 保存镜像为文件 docker save -o /root/tomcat.tar tomcat:8.5.57-jdk8-openjdk-slim\n// -o /root/tocmat.tar 保存为文件的地址\n4.6 把保存的镜像备份文件恢复成镜像 docker load -i /root/tomcat.tar\n5.docker容器操作常用指令 5.1 使用镜像新建一个容器 docker run\n创建并运行一个java容器，打印helloworld！\ndocker run java:8 /bin/echo \u0026lsquo;hello world!\u0026rsquo;\n创建一个centos容器\ndocker run -ti \u0026ndash;name=c1 centos:centos7 /bin/bash\n-d 表示守护式容器(用户退出容器后，容器依然可以正常运行)\n-i 运行容器\n-t 交互 后面跟交互shell脚本 /bin/bash\ncentos:centos7 镜像名称\n创建一个有网络使用容器\n如：创建一个容器nginx 端口为 80\n-p 端口映射 宿主机端口：容器端口\n5.2 列出容器 列出当前正在运行的容器 docker ps 列出当前全部容器 docker ps -a 列出当前容器的所有编号 docker ps -a -q 5.3 停止容器 docker stop 容器的names\ndocker stop 容器的container id\n如：\ndocker stop c1\ndocker stop 36bee7ca1cf4\n5.4 启动容器 docker start 容器名称或容器编号\ndocker start n1\n5.5 强制停止容器 docker kill 容器名称或容器编号\n5.6 重启容器 docker restart 容器名称或者容器编号\n5.7 如何进入到容器 docker exec -it c1 /bin/bash\n5.8 退出容器 exit\n5.9 从宿主机拷贝文件到容器 在宿主机上创建文件并编辑\ntouch java511.txt\nvi java511.txt\n拷贝到容器中\ndocker cp /java511.txt c1:/root/\n5.10 从容器拷贝文件到宿主机 docker cp c1:/1.java /root/2.java\n5.11 挂载宿主机的制定目录到容器(其中 \u0026ndash;privileged 是可选的) （如果你共享的是多级的目录，可能会出现权限不足的提示。这是因为centos7中的安全模块selinux把权限禁掉了，我们需要添加参数 \u0026ndash;privileged=true 来解决挂载的目录没有权限的问题）\ndocker run -di \u0026ndash;name=c2 -v /root/html:/test0722 \u0026ndash;privileged centos:centos7\n5.12 删除容器 docker rm 容器名称或者编号 //注意 不能删除正在运行中容器， 需要停掉才可以删除 -f 强制删除\n5.13 查看容器ip docker inspect n1 //输出的内容较多\ndocker inspect \u0026ndash;format=\u0026rsquo;{{.networksettings.ipaddress}}\u0026rsquo; n1 //只输出ip\n5.14 查看容器日志输出 docker logs n1 查看日志\ndocker logs \u0026ndash;tail=\u0026ldquo;2\u0026rdquo; n1 查看日志 左后2行。\n5.15、设置容器开机自启动 docker update \u0026ndash;restart=always 容器名称 //设置开机自启动\ndocker update \u0026ndash;restart=no 容器名称 //禁止开机自启动\n6.java开发者docker常用镜像容器创建 6.1 jdk部署 6.1.1 拉取jdk镜像 执行命令： docker pull java:8 6.1.2 创建jdk容器 执行命令：docker run -di --name jdk1 java:8 说明：jdk安装的是openjdk，具体安装路径是：/usr/lib/jvm/java-1.8.0-openjdk-amd64\n6.1.3 进入容器验证java环境 docker exec -it jdk1 /bin/bash\njava -version\n6.2 mysql部署 6.2.1拉取mysql镜像 执行命令：docker pull mysql:5.7 6.2.2 创建mysql容器 第一种创建容器mysql容器的方式\ndocker run -d --name=offcn_mysql -p 33306:3306 -e mysql_root_password=123456 -e mysql_database=scwdb mysql:5.7 -p 代表端口映射，格式为 宿主机映射端口:容器运行端口\n-e mysql_root_password=123456 //表示设置root的密码为123456\n-e mysql_database=scwdb //创建mysql数据库容器的同时初始化创建一个数据库 scwdb\n//开启mysql容器 docker exec -it offcn_mysql /bin/bash //登录mysql mysql -u root -p //赋外网访问权限 alter user \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified with mysql_native_password by \u0026#39;123456\u0026#39;; //刷新权限 flush privileges; 如上创建需要解决中文乱码问题乱码（默认是latin1）\nshow variables like \u0026lsquo;character_set_%\u0026rsquo;;\n乱码解决方案:\na. 进入offcn_mysql容器 修改配置文件/etc/mysql/mysql.conf.d/mysqld.cnf 注意 因为offcn_mysql容器中不能使用vi命令，所以我们将文件拷贝到宿主机后修改后在拷贝回去 b. docker cp offcn_mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /root/ vi mysqld.cnf 找到[mysqld] 在其下添加编码处理 character-set-server=utf8 collation-server=utf8_general_ci 保存 c. docker cp /root/mysqld.cnf offcn_mysql:/etc/mysql/mysql.conf.d/mysqld.cnf d. 重启容器 docker restart offcn_mysql 第二种创建容器mysql容器的方式\n创新容器同时创建表的时候，解决中文问题（使用挂载的方式，将刚刚解决乱码的mysqld.cnf 挂载下容器中相应的位置）\ndocker run -d --name=offcn_mysql -p 33306:3306 -v /root/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf -e mysql_root_password=123456 -emysql_database=dongyimaidb mysql:5.7 第三种创建容器mysql容器的方式\n在创建mysql容器时候，执行初始化数据库脚本 (将scwdb 数据库导出， 其中不要勾选 添加创建数据库语句 ，然后上传到 宿主机root目录)\ndocker run -d --name=offcn_mysql -p 33306:3306 -v /root/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /root/scwdb.sql:/docker-entrypoint-initdb.d/mysql.sql -e mysql_root_password=123456 -emysql_database=dongyimaidb mysql:5.7 //开启mysql容器 docker exec -it offcn_mysql /bin/bash //登录mysql mysql -u root -p //赋外网访问权限 alter user \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified with mysql_native_password by \u0026#39;123456\u0026#39;; //刷新权限 flush privileges; 6.2.3 连接mysql容器数据库 远程连接mysql数据库只需要使用宿主机ip和端口33306就可以\n6.3 redis 部署 6.3.1 拉取redis镜像 执行命令：docker pull redis:4.0.8 6.3.2 创建redis容器 执行命令： docker run -di --name redis -p 16379:6379 redis:4.0.8 7.dockerfile入门（了解） dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像（centos或者ubuntu，即操作系统级别的镜像）并最终创建一个新的镜像。\n对于开发人员：可以为开发团队提供一个完全一致的开发环境； 对于测试人员：可以直接拿开发时所构建的镜像或者通过dockerfile文件构建一个新的镜像开始工作了； 对于运维人员：在部署时，可以实现应用的无缝移植。 7.1 dockerfile常用命令 7.2 自主创建jdk镜像 (1) 创建一个目录： mkdir /usr/local/dockerjdk\n(2) 上传 jdk-8u131-linux-x64.tar.gz到 /usr/local/dockerjdk/\n(3) 创建一个 dockerfile 文件 并编辑 vi dockerfile 内容如下\nfrom centos:centos7 maintainer ujiuye run mkdir /usr/local/java add jdk-8u131-linux-x64.tar.gz /usr/local/java/ env java_home /usr/local/java/jdk1.8.0_131 env classpath $java_home/lib env path $java_home/bin:$path 保存文件\n(4) 创建镜像 为jdk1.8\ndocker build -t=\u0026lsquo;jdk1.8\u0026rsquo; /usr/local/dockerjdk/\n(5) 查看已经创建的镜像\ndocker images\n(6) 使用自定义的镜像创建一个容器\ndocker run -di \u0026ndash;name=java1 jdk1.8\n(7) 查看创建的容器\ndocker ps\n(8) 验证自定义容器jdk环境是否正常\ndocker exec -it java1 /bin/bash\njava -version\n7.3 自主创建tomcat镜像 (1) 创建目录 mkdir /usr/local/dockertomcat\n(2) 上传jdk tomcat 到文件中\n(3) 创建dockerfile vi dockerfile 内容如下\nfrom centos:centos7 maintainer ujiuye run mkdir /usr/local/app add jdk-8u131-linux-x64.tar.gz /usr/local/app/ add apache-tomcat-8.5.15.tar.gz /usr/local/app/ env java_home /usr/local/app/jdk1.8.0_131 env catalina_home /usr/local/app/apache-tomcat-8.5.15 env classpath $java_home/lib env path $java_home/bin:$catalina_home/bin:$path expose 8080 cmd [\u0026#34;/usr/local/app/apache-tomcat-8.5.15/bin/catalina.sh\u0026#34;,\u0026#34;run\u0026#34;] (4)创建镜像 docker build -t=\u0026lsquo;tomcat8.5:10\u0026rsquo; .\n(5)查看镜像 docker images\n(6)创建容器 docker run -di \u0026ndash;name=tomcat999 -p 5555:8080 tomcat8.5:10\n(7)查看容器 docker ps\n(8)访问： http://192.168.188.133:5555/\n","date":"2022-05-27","permalink":"https://lovemjh.vercel.app/posts/tool/_20220527215246/","summary":"三、Docker快速入门 1.Docker简介 Docker是一个开源的容器引擎，它可以帮助我们更快地交付应用。Docker可将应用程序和基础设施层隔离，并且能将基","title":"docker快速入门"},{"content":"第八章 thymeleaf实现搜索页面渲染及商品静态页 优就业.java教研室 学习目标 目标1：搜索页面渲染\n目标2：thymeleaf的介绍\n目标3：thymeleaf的入门\n目标4：thymeleaf的语法及标签\n目标5：搜索页面渲染\n目标6：商品详情页静态化工程搭建\n目标7：商品详情页静态化功能实现\n目标8：用户修改商品信息，同步更新创建商品详情页\n一 thymeleaf入门 1 thymeleaf介绍 thymeleaf是一个xml/xhtml/html5模板引擎，可用于web与非web环境中的应用开发。它是一个开源的java库，基于apache license 2.0许可，由daniel fernández创建，该作者还是java加密库jasypt的作者。\nthymeleaf提供了一个用于整合spring mvc的可选模块，在应用开发中，你可以使用thymeleaf来完全代替jsp或其他模板引擎，如velocity、freemarker等。thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的xml与html模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在dom（文档对象模型）上执行预先制定好的逻辑。\n它的特点便是：开箱即用，thymeleaf允许您处理六种模板，每种模板称为模板模式：\nxml 有效的xml xhtml 有效的xhtml html5 旧版html5 所有这些模式都指的是格式良好的xml文件，但*legacy html5*模式除外，它允许您处理html5文件，其中包含独立（非关闭）标记，没有值的标记属性或不在引号之间写入的标记属性。为了在这种特定模式下处理文件，thymeleaf将首先执行转换，将您的文件转换为格式良好的xml文件，这些文件仍然是完全有效的html5（实际上是创建html5代码的推荐方法）1。\n另请注意，验证仅适用于xml和xhtml模板。\n然而，这些并不是thymeleaf可以处理的唯一模板类型，并且用户始终能够通过指定在此模式下解析模板的方法和编写结果的方式来定义他/她自己的模式。这样，任何可以建模为dom树（无论是否为xml）的东西都可以被thymeleaf有效地作为模板处理。\n2 springboot整合thymeleaf 使用springboot 来集成使用thymeleaf可以大大减少单纯使用thymleaf的代码量，所以我们接下来使用springboot集成使用thymeleaf.\n实现的步骤为：\n创建一个sprinboot项目 添加thymeleaf的起步依赖 添加spring web的起步依赖 编写html 使用thymleaf的语法获取变量对应后台传递的值 编写controller 设置变量的值到model中 (1)创建工程\n创建一个独立的工程springboot-thymeleaf,该工程为案例工程，不需要放到dongyimai-parent工程中。\npom.xml依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springboot-thymeleaf\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.3.9.release\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--web起步依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--thymeleaf配置--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; (2)创建html\n在resources中创建templates目录，在templates目录创建 demo1.html,代码如下：\n\u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;thymeleaf的入门\u0026lt;/title\u0026gt; \u0026lt;meta http-equiv=\u0026#34;content-type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--输出hello数据--\u0026gt; \u0026lt;p th:text=\u0026#34;${hello}\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 解释：\n\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;\u0026gt;:这句声明使用thymeleaf标签\n\u0026lt;p th:text=\u0026quot;${hello}\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;:这句使用 th:text=\u0026quot;${变量名}\u0026quot; 表示 使用thymeleaf获取文本数据，类似于el表达式。\n(3)修改application.yml配置\n创建application.yml,并设置thymeleaf的缓存设置，设置为false。默认加缓存的，用于测试。\nspring: thymeleaf: cache: false 在这里，其实还有一些默认配置，比如视图前缀：classpath:/templates/,视图后缀：.html\norg.springframework.boot.autoconfigure.thymeleaf.thymeleafproperties部分源码如下： (4)控制层\n创建controller用于测试后台 设置数据到model中。\n创建com.offcn.controller.testcontroller，代码如下：\n@controller @requestmapping(\u0026#34;/test\u0026#34;) public class testcontroller { /*** * 访问/test/hello 跳转到demo1页面 * @param model * @return */ @requestmapping(\u0026#34;/hello\u0026#34;) public string hello(model model){ model.addattribute(\u0026#34;hello\u0026#34;,\u0026#34;hello welcome\u0026#34;); return \u0026#34;demo1\u0026#34;; } } (5)测试\n创建启动类com.offcn.thymeleafapplication，代码如下：\n@springbootapplication public class thymeleafapplication { public static void main(string[] args) { springapplication.run(thymeleafapplication.class,args); } } 启动系统，并在浏览器访问\nhttp://localhost:8080/test/hello 3 thymeleaf基本语法 (1)th:action 定义后台控制器路径，类似\u0026lt;form\u0026gt;标签的action属性。\n例如：\n\u0026lt;form id=\u0026#34;login-form\u0026#34; th:action=\u0026#34;@{/test/hello}\u0026#34;\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; 表示提交的请求地址为/test/hello\n(2)th:each 对象遍历，功能类似jstl中的\u0026lt;c:foreach\u0026gt;标签。\n创建com.offcn.model.user,代码如下：\npublic class user { private integer id; private string name; private string address; //无参和全参构造器以及..get..set } controller添加数据\n/*** * 访问/test/hello 跳转到demo1页面 * @param model * @return */ @requestmapping(\u0026#34;/hello\u0026#34;) public string hello(model model){ model.addattribute(\u0026#34;hello\u0026#34;,\u0026#34;hello welcome\u0026#34;); //集合数据 list\u0026lt;user\u0026gt; users = new arraylist\u0026lt;user\u0026gt;(); users.add(new user(1,\u0026#34;张三\u0026#34;,\u0026#34;深圳\u0026#34;)); users.add(new user(2,\u0026#34;李四\u0026#34;,\u0026#34;北京\u0026#34;)); users.add(new user(3,\u0026#34;王五\u0026#34;,\u0026#34;武汉\u0026#34;)); model.addattribute(\u0026#34;users\u0026#34;,users); return \u0026#34;demo1\u0026#34;; } 页面输出\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;下标\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;编号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;住址\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr th:each=\u0026#34;user,userstat:${users}\u0026#34;\u0026gt; \u0026lt;td\u0026gt; 下标:\u0026lt;span th:text=\u0026#34;${userstat.index}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;, \u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${user.id}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${user.name}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${user.address}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 测试效果 (3)map输出 后台添加map\n//map定义 map\u0026lt;string,object\u0026gt; datamap = new hashmap\u0026lt;string,object\u0026gt;(); datamap.put(\u0026#34;no\u0026#34;,\u0026#34;123\u0026#34;); datamap.put(\u0026#34;address\u0026#34;,\u0026#34;深圳\u0026#34;); model.addattribute(\u0026#34;datamap\u0026#34;,datamap); 页面输出\n\u0026lt;div th:each=\u0026#34;map,mapstat:${datamap}\u0026#34;\u0026gt; \u0026lt;div th:text=\u0026#34;${map}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; key:\u0026lt;span th:text=\u0026#34;${mapstat.current.key}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br/\u0026gt; value:\u0026lt;span th:text=\u0026#34;${mapstat.current.value}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;br/\u0026gt; ============================================== \u0026lt;/div\u0026gt; 测试效果 (4)数组输出 后台添加数组\n//存储一个数组 string[] names = {\u0026#34;张三\u0026#34;,\u0026#34;李四\u0026#34;,\u0026#34;王五\u0026#34;}; model.addattribute(\u0026#34;names\u0026#34;,names); 页面输出\n\u0026lt;div th:each=\u0026#34;nm,nmstat:${names}\u0026#34;\u0026gt; \u0026lt;span th:text=\u0026#34;${nmstat.count}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span th:text=\u0026#34;${nm}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; ============================================== \u0026lt;/div\u0026gt; 测试效果 (5)date输出 后台添加日期\n//日期 model.addattribute(\u0026#34;now\u0026#34;,new date()); 页面输出\n\u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;date输出 th:text\u0026lt;/h1\u0026gt; \u0026lt;span th:text=\u0026#34;${#dates.format(now,\u0026#39;yyyy-mm-dd hh:ss:mm\u0026#39;)}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 测试效果 (6)th:if条件 后台添加年龄\n//if条件 model.addattribute(\u0026#34;age\u0026#34;,22); 页面输出\n\u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;条件判断 th:if\u0026lt;/h1\u0026gt; \u0026lt;span th:if=\u0026#34;${(age\u0026gt;=18)}\u0026#34;\u0026gt;终于长大了！\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 测试效果 (7)使用javascript java代码为: \u0026lt;button onclick=\u0026#34;abc()\u0026#34;\u0026gt;aaaaaaa\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; var hhh=[[${hello}]]; function abc(){ alert(hhh); } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 运行结果：（注意script放置在body外面）\n(8)字符拼接 使用|| 后台代码: 模板: 查看生成的页面demo1.html的源码，可以看到如下\n二 搜索页面渲染（了解） 1 搜索分析 搜索页面要显示的内容主要分为3块。\n1)搜索的数据结果\n2)筛选出的数据搜索条件\n3)用户已经勾选的数据条件\n2 搜索实现 搜索的业务流程如上图，用户每次搜索的时候，先经过搜索业务工程，搜索业务工程调用搜索微服务工程，这里搜索业务工程单独挪出来的原因是它这里涉及到了模板渲染以及其他综合业务处理，以后很有可能会有移动端的搜索和pc端的搜索，后端渲染如果直接在搜索微服务中进行，会对微服务造成一定的侵入，不推荐这么做，推荐微服务独立，只提供服务，如果有其他页面渲染操作，可以搭建一个独立的消费工程调用微服务达到目的。\n2.1 搜索工程搭建 (1)工程创建\n在dongyimai-web工程中创建dongyimai-search-web工程,\n并在dongyimai-web的pom.xml中引入如下依赖：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--feign--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; (2)静态资源导入\n将资源中的页面/前端页面/search.html拷贝到工程的resources/templates目录下，js、css等拷贝到static目录下，如下图： (3)feign创建\ndongyimai-search-service-api，添加com.offcn.search.feign.searchskufeign，\n实现调用搜索，代码如下：\n@feignclient(name=\u0026#34;search\u0026#34;) @requestmapping(\u0026#34;/search\u0026#34;) public interface searchskufeign { /** * 搜索 * @param searchmap * @return */ @getmapping map search(@requestbody(required = false) map searchmap); } 由于以后做搜索都是基于get请求，所以我们需要将之前的搜索改成get请求操作，修改dongyimai-search-service微服务的com.offcn.search.controller.skucontroller里面的search方法，代码如下：\n(4)dongyimai-search-web的pom.xml依赖dongyimai-search-service-api\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-search-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; (5)搜索调用\n在dongyimai-search-web中创建com.offcn.search.controller.skucontroller,实现调用搜索，代码如下：\n@controller @requestmapping(value = \u0026#34;/search\u0026#34;) public class skucontroller { @autowired private searchskufeign searchskufeign; /** * 搜索 * @param searchmap * @return */ @getmapping(value = \u0026#34;/list\u0026#34;) public string search(@requestparam(required = false) map searchmap, model model){ //dongyimai-search-service微服务 map resultmap = searchskufeign.search(searchmap); model.addattribute(\u0026#34;result\u0026#34;,resultmap); return \u0026#34;search\u0026#34;; } } (6)启动类创建\n修改dongyimai-search-web,添加启动类com.offcn.search.searchwebapplication，代码如下：\n@springbootapplication(exclude={datasourceautoconfiguration.class}) @enablediscoveryclient @enablefeignclients public class searchwebapplication { public static void main(string[] args) { springapplication.run(searchwebapplication.class,args); } } (7)application.yml配置文件\nserver: port: 9101 eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true spring: thymeleaf: cache: false application: name: search-web main: allow-bean-definition-overriding: true (8)项目完整结构 在search.html的头部引入thymeleaf标签\n\u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; 将样式修改为：\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;css/webbase.css\u0026#34; th:href=\u0026#34;@{/css/webbase.css}\u0026#34;/\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;css/pages-list.css\u0026#34; th:href=\u0026#34;@{/css/pages-list.css}\u0026#34;/\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;css/widget-cartpanelview.css\u0026#34; th:href=\u0026#34;@{/css/widget-cartpanelview.css}\u0026#34;/\u0026gt; 测试：http://localhost:9101/search,效果如下： 2.2 搜索数据填充 后端搜索到数据后，前端页面进行数据显示，显示的数据分为3部分\n1)搜索的数据结果 2)筛选出的数据搜索条件 3)用户已经勾选的数据条件 2.3 关键字搜索 用户每次输入关键字的时候，直接根据关键字搜索，关键字搜索的数据会存储到result.rows中，页面每次根据result获取rows，然后循环输出即可,同时页面的搜索框每次需要回显搜索的关键词。\n实现思路\n1.前端表单提交搜索的关键词 2.后端根据关键词进行搜索 3.将搜索条件存储到model中 4.页面循环迭代输出数据 5.搜索表单回显搜索的关键词 (1)后台搜索实现\n修改skucontroller的search方法，代码如下：\n/** * 搜索 * @param searchmap * @return */ @getmapping(value = \u0026#34;/list\u0026#34;) public string search(@requestparam(required = false) map\u0026lt;string,string\u0026gt; searchmap, model model){ //调用dongyimai-search-service微服务 map\u0026lt;string,object\u0026gt; resultmap = searchskufeign.search(searchmap); //搜索数据结果 model.addattribute(\u0026#34;result\u0026#34;,resultmap); //搜索条件 model.addattribute(\u0026#34;searchmap\u0026#34;,searchmap); return \u0026#34;search\u0026#34;; } (2)页面搜索实现\n修改search.html \u0026lt;form action=\u0026#34;/search/list\u0026#34; class=\u0026#34;sui-form form-inline\u0026#34;\u0026gt; \u0026lt;!--searchautocomplete--\u0026gt; \u0026lt;div class=\u0026#34;input-append\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;autocomplete\u0026#34; name=\u0026#34;keywords\u0026#34; th:value=\u0026#34;${#maps.containskey(searchmap,\u0026#39;keywords\u0026#39;)}?${searchmap.keywords}:\u0026#39;\u0026#39;\u0026#34; class=\u0026#34;input-error input-xxlarge\u0026#34; /\u0026gt; \u0026lt;button class=\u0026#34;sui-btn btn-xlarge btn-danger\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;搜索\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; 注意：搜索按钮为submit提交。\n(3)页面结果输出\n修改search.html，代码如下： \u0026lt;ul class=\u0026#34;yui3-g\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;yui3-u-1-5\u0026#34; th:each=\u0026#34;sku,skustat:${result.rows}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;list-wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;p-img\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;item.html\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;\u0026lt;img th:src=\u0026#34;${sku.image}\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;price\u0026#34;\u0026gt; \u0026lt;strong\u0026gt; \u0026lt;em\u0026gt;¥\u0026lt;/em\u0026gt; \u0026lt;i th:text=\u0026#34;${sku.price}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/strong\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;attr\u0026#34;\u0026gt; \u0026lt;em th:utext=\u0026#34;${#strings.abbreviate(sku.title,45)}\u0026#34;\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;cu\u0026#34;\u0026gt; \u0026lt;em\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;commit\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;command\u0026#34;\u0026gt;已有2000人评价\u0026lt;/i\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;operate\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;success-cart.html\u0026#34; target=\u0026#34;_blank\u0026#34; class=\u0026#34;sui-btn btn-bordered btn-danger\u0026#34;\u0026gt;加入购物车\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; class=\u0026#34;sui-btn btn-bordered\u0026#34;\u0026gt;对比\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; class=\u0026#34;sui-btn btn-bordered\u0026#34;\u0026gt;关注\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; (4)测试，在地址栏输入：http://localhost:9101/search/list/\n搜索华为关键字,效果如下： 2.4 搜索条件回显 搜索条件除了关键字外，还有分类、品牌、以及规格，这些在我们前面已经将数据存入到了map中，我们可以直接从map中将数据取出，然后在页面输出即可。\n分类：result.categorylist\n品牌：result.brandlist\n规格：result.speclist\n修改search.html的条件显示部分\n上图代码如下：\n\u0026lt;!--selector--\u0026gt; \u0026lt;div class=\u0026#34;clearfix selector\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:if=\u0026#34;${#maps.containskey(result,\u0026#39;categorylist\u0026#39;)\u0026amp;\u0026amp;!#maps.containskey(searchmap,\u0026#39;category\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34;\u0026gt;商品分类\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;span th:each=\u0026#34;category,categorystat:${result.categorylist}\u0026#34;\u0026gt; \u0026lt;a th:text=\u0026#34;${category}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026amp;nbsp; \u0026amp;nbsp; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap logo\u0026#34; th:if=\u0026#34;${#maps.containskey(result,\u0026#39;brandlist\u0026#39;)\u0026amp;\u0026amp;!#maps.containskey(searchmap,\u0026#39;brand\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key brand\u0026#34;\u0026gt;品牌\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;value logos\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;logo-list\u0026#34;\u0026gt; \u0026lt;li th:each=\u0026#34;brand,brandstat:${result.brandlist}\u0026#34;\u0026gt; \u0026lt;a th:text=\u0026#34;${brand}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ext\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; class=\u0026#34;sui-btn\u0026#34;\u0026gt;多选\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34;\u0026gt;更多\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:each=\u0026#34;spec,specstat:${result.specmap}\u0026#34; th:unless=\u0026#34;${#maps.containskey(searchmap,\u0026#39;spec_\u0026#39;+spec.key)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34; th:text=\u0026#34;${spec.key}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;type-list\u0026#34;\u0026gt; \u0026lt;li th:each=\u0026#34;op,opstat:${spec.value}\u0026#34;\u0026gt; \u0026lt;a th:text=\u0026#34;${op}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:unless=\u0026#34;${#maps.containskey(searchmap,\u0026#39;price\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34;\u0026gt;价格\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;type-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:text=\u0026#34;0-500元\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:text=\u0026#34;500-1000元\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:text=\u0026#34;1000-1500元\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:text=\u0026#34;1500-2000元\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:text=\u0026#34;2000-3000元\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:text=\u0026#34;3000元以上\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34;\u0026gt;更多筛选项\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;type-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a\u0026gt;特点\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a\u0026gt;系统\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a\u0026gt;手机内存 \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a\u0026gt;单卡双卡\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a\u0026gt;其他\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--details--\u0026gt; 解释：\nth:unless:条件不满足时，才显示 ${#maps.containskey(result,\u0026#39;brandlist\u0026#39;)}:map中包含某个key 测试：访问：http://localhost:9101/search/list 输入 关键字 黑色\n2.5 条件搜索实现 用户每次点击搜索的时候，其实在上次搜索的基础之上加上了新的搜索条件，也就是在上一次请求的url后面追加了新的搜索条件，我们可以在后台每次拼接组装出上次搜索的url，然后每次将url存入到model中，页面每次点击不同条件的时候，从model中取出上次请求的url，然后再加上新点击的条件参数实现跳转即可。\n(1)后台记录搜索url\n修改skucontroller，添加组装url的方法，并将组装好的url存储起来,代码如下：\n/** * 搜索 * @param searchmap * @return */ @getmapping(value = \u0026#34;/list\u0026#34;) public string search(@requestparam(required = false) map searchmap, model model){ //1.调用搜索微服务的 feign 根据搜索的条件参数 查询 数据 //调用dongyimai-search-service微服务 map resultmap = searchskufeign.search(searchmap); //2.将数据设置到model中 (模板文件中 根据th:标签数据展示) model.addattribute(\u0026#34;result\u0026#34;,resultmap); //3.设置搜索的条件 回显 model.addattribute(\u0026#34;searchmap\u0026#34;,searchmap); //4.记住之前的url //拼接url string url = this.seturl(searchmap); model.addattribute(\u0026#34;url\u0026#34;,url); return \u0026#34;search\u0026#34;; } private string seturl(map\u0026lt;string, string\u0026gt; searchmap) { string url = \u0026#34;/search/list\u0026#34;; if(searchmap!=null \u0026amp;\u0026amp; searchmap.size()\u0026gt;0){ url+=\u0026#34;?\u0026#34;; for (map.entry\u0026lt;string, string\u0026gt; stringstringentry : searchmap.entryset()) { string key = stringstringentry.getkey();// keywords / brand / category string value = stringstringentry.getvalue();//华为 / 华为 / 笔记本 if(key.equals(\u0026#34;pagenum\u0026#34;)){ continue; } url+=key+\u0026#34;=\u0026#34;+value+\u0026#34;\u0026amp;\u0026#34;; } //去掉多余的\u0026amp; if(url.lastindexof(\u0026#34;\u0026amp;\u0026#34;)!=-1){ url = url.substring(0,url.lastindexof(\u0026#34;\u0026amp;\u0026#34;)); } } return url; } (2)页面搜索对接 完整代码如下：\n\u0026lt;!--selector--\u0026gt; \u0026lt;div class=\u0026#34;clearfix selector\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:if=\u0026#34;${#maps.containskey(result,\u0026#39;categorylist\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34;\u0026gt;商品分类\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;span th:each=\u0026#34;category,categorystat:${result.categorylist}\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(category=${category})}\u0026#34; th:text=\u0026#34;${category}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026amp;nbsp; \u0026amp;nbsp; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap logo\u0026#34; th:if=\u0026#34;${#maps.containskey(result,\u0026#39;brandlist\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key brand\u0026#34;\u0026gt;品牌\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;value logos\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;logo-list\u0026#34;\u0026gt; \u0026lt;li th:each=\u0026#34;brand,brandstat:${result.brandlist}\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(brand=${brand})}\u0026#34; th:text=\u0026#34;${brand}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ext\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; class=\u0026#34;sui-btn\u0026#34;\u0026gt;多选\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34;\u0026gt;更多\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:each=\u0026#34;spec,specstat:${result.specmap}\u0026#34; th:unless=\u0026#34;${#maps.containskey(searchmap,\u0026#39;spec_\u0026#39;+spec.key)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34; th:text=\u0026#34;${spec.key}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;type-list\u0026#34;\u0026gt; \u0026lt;li th:each=\u0026#34;op,opstat:${spec.value}\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(\u0026#39;spec_\u0026#39;+${spec.key}=${op})}\u0026#34; th:text=\u0026#34;${op}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:unless=\u0026#34;${#maps.containskey(searchmap,\u0026#39;price\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34;\u0026gt;价格\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;type-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;0-500\u0026#39;)}\u0026#34; th:text=\u0026#34;0-500元\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;500-1000\u0026#39;)}\u0026#34; th:text=\u0026#34;500-1000元\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;1000-1500\u0026#39;)}\u0026#34; th:text=\u0026#34;1000-1500元\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;1500-2000\u0026#39;)}\u0026#34; th:text=\u0026#34;1500-2000元\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;2000-3000\u0026#39;)}\u0026#34; th:text=\u0026#34;2000-3000元\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;3000-*\u0026#39;)}\u0026#34; th:text=\u0026#34;3000元以上\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; th:href 这里是超链接的语法，例如：th:href=\u0026quot;@{${url}(price='500-1000')}\u0026quot;表示请求地址是取url参数的值，同时向后台传递参数price的值为500-100。\n如下是查询的时候，后台使用打印输出语句输出的结果 2.6 移除搜索条件 如上图，用户点击条件搜索后，要将选中的条件显示出来，并提供移除条件的x按钮,显示条件我们可以从searchmap中获取，移除其实就是将之前的请求地址中的指定条件删除即可。\n(1)条件显示\n修改search.html，代码如下：\n\u0026lt;!--bread--\u0026gt; \u0026lt;div class=\u0026#34;bread\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;fl sui-breadcrumb\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:text=\u0026#34;${result.total}\u0026#34;\u0026gt;全部结果\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;tags-choose\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;tag\u0026#34; th:if=\u0026#34;${#maps.containskey(searchmap,\u0026#39;category\u0026#39;)}\u0026#34;\u0026gt;商品分类:\u0026lt;i th:text=\u0026#34;${searchmap.category}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;tag\u0026#34; th:if=\u0026#34;${#maps.containskey(searchmap,\u0026#39;brand\u0026#39;)}\u0026#34;\u0026gt;品牌:\u0026lt;i th:text=\u0026#34;${searchmap.brand}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;tag\u0026#34; th:if=\u0026#34;${#maps.containskey(searchmap,\u0026#39;price\u0026#39;)}\u0026#34;\u0026gt;价格:\u0026lt;i th:text=\u0026#34;${searchmap.price}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;tag\u0026#34; th:each=\u0026#34;spec,specstat:${searchmap}\u0026#34; th:if=\u0026#34;${#strings.startswith(spec.key,\u0026#39;spec_\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;i th:text=\u0026#34;${#strings.substring(spec.key,5)}\u0026#34;\u0026gt;手机屏幕尺寸\u0026lt;/i\u0026gt; : \u0026lt;i th:text=\u0026#34;${spec.value}\u0026#34;\u0026gt;5.5寸\u0026lt;/i\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 解释：\n${#strings.startswith(spec.key,\u0026#39;spec_\u0026#39;)}:表示以spec_开始的key ${#strings.replace(spec.key,\u0026#39;spec_\u0026#39;,\u0026#39;\u0026#39;)}:表示将spec.key中的spec_替换成空 (2)移除搜索条件\n修改search.html，移除分类、品牌、价格、规格搜索条件，代码如下：\n\u0026lt;!--bread--\u0026gt; \u0026lt;div class=\u0026#34;bread\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;fl sui-breadcrumb\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:text=\u0026#34;${result.total}\u0026#34;\u0026gt;全部结果\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;tags-choose\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;tag\u0026#34; th:if=\u0026#34;${#maps.containskey(searchmap,\u0026#39;category\u0026#39;)}\u0026#34;\u0026gt;商品分类:\u0026lt;i th:text=\u0026#34;${searchmap.category}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;a class=\u0026#34;sui-icon icon-tb-close\u0026#34; th:href=\u0026#34;@{${#strings.replace(url,\u0026#39;category=\u0026#39;+searchmap.category,\u0026#39;\u0026#39;)}}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;tag\u0026#34; th:if=\u0026#34;${#maps.containskey(searchmap,\u0026#39;brand\u0026#39;)}\u0026#34;\u0026gt;品牌:\u0026lt;i th:text=\u0026#34;${searchmap.brand}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;a class=\u0026#34;sui-icon icon-tb-close\u0026#34; th:href=\u0026#34;@{${#strings.replace(url,\u0026#39;brand=\u0026#39;+searchmap.brand,\u0026#39;\u0026#39;)}}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;tag\u0026#34; th:if=\u0026#34;${#maps.containskey(searchmap,\u0026#39;price\u0026#39;)}\u0026#34;\u0026gt;价格:\u0026lt;i th:text=\u0026#34;${searchmap.price}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;a class=\u0026#34;sui-icon icon-tb-close\u0026#34; th:href=\u0026#34;@{${#strings.replace(url,\u0026#39;price=\u0026#39;+searchmap.price,\u0026#39;\u0026#39;)}}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;tag\u0026#34; th:each=\u0026#34;spec,specstat:${searchmap}\u0026#34; th:if=\u0026#34;${#strings.startswith(spec.key,\u0026#39;spec_\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;i th:text=\u0026#34;${#strings.substring(spec.key,5)}\u0026#34;\u0026gt;手机屏幕尺寸\u0026lt;/i\u0026gt; : \u0026lt;i th:text=\u0026#34;${spec.value}\u0026#34;\u0026gt;5.5寸\u0026lt;/i\u0026gt; \u0026lt;a class=\u0026#34;sui-icon icon-tb-close\u0026#34; th:href=\u0026#34;@{${#strings.replace(url,spec.key+\u0026#39;=\u0026#39;+spec.value,\u0026#39;\u0026#39;)}}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div class=\u0026#34;clearfix\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 2.7 选中搜索条件隐藏搜索面板项 当有选中的搜索条件的时候，对应的搜索面板项就隐藏掉，避免出现用户重复选择的情况 实现代码，在没个搜索项上增加控制条件，当存在搜索条件的时候，就隐藏搜索面板项\n\u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:if=\u0026#34;${#maps.containskey(result,\u0026#39;categorylist\u0026#39;)} and !${#maps.containskey(searchmap,\u0026#39;category\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34;\u0026gt;商品分类\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;span th:each=\u0026#34;category,categorystat:${result.categorylist}\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(category=${category})}\u0026#34; th:text=\u0026#34;${category}\u0026#34;\u0026gt;手机\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap logo\u0026#34; th:if=\u0026#34;${#maps.containskey(result,\u0026#39;brandlist\u0026#39;)} and !${#maps.containskey(searchmap,\u0026#39;brand\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key brand\u0026#34;\u0026gt;品牌\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;value logos\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;logo-list\u0026#34;\u0026gt; \u0026lt;li th:each=\u0026#34;brand:${result.brandlist}\u0026#34;\u0026gt;\u0026lt;a th:href=\u0026#34;@{${url}(brand=${brand})}\u0026#34; th:text=\u0026#34;${brand}\u0026#34;\u0026gt;\u0026lt;/li\u0026gt;\t\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ext\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; class=\u0026#34;sui-btn\u0026#34;\u0026gt;多选\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34;\u0026gt;更多\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:each=\u0026#34;spec:${result.specmap}\u0026#34; th:unless=\u0026#34;${#maps.containskey(searchmap,\u0026#39;spec_\u0026#39;+spec.key)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34; th:text=\u0026#34;${spec.key}\u0026#34;\u0026gt;网络制式\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;type-list\u0026#34;\u0026gt; \u0026lt;li th:each=\u0026#34;op:${spec.value}\u0026#34;\u0026gt; \u0026lt;a th:text=\u0026#34;${op}\u0026#34; th:href=\u0026#34;@{${url}(\u0026#39;spec_\u0026#39;+${spec.key}=${op})}\u0026#34;\u0026gt;gsm（移动/联通2g）\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt;\t\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;\t\u0026lt;div class=\u0026#34;type-wrap\u0026#34; th:unless=\u0026#34;${#maps.containskey(searchmap,\u0026#39;price\u0026#39;)}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl key\u0026#34;\u0026gt;价格\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl value\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;type-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;0-500\u0026#39;)}\u0026#34; th:text=\u0026#34;0-500元\u0026#34;\u0026gt;0-500元\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;500-1000\u0026#39;)}\u0026#34;\u0026gt;500-1000元\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;1000-1500\u0026#39;)}\u0026#34;\u0026gt;1000-1500元\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;1500-2000\u0026#39;)}\u0026#34;\u0026gt;1500-2000元\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;2000-3000\u0026#39;)}\u0026#34;\u0026gt;2000-3000元 \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(price=\u0026#39;3000-*\u0026#39;)}\u0026#34;\u0026gt;3000元以上\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl ext\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 2.8 排序(作业) 上图代码是排序代码，需要2个属性，sortrule:排序规则，asc或者desc，sortfield:排序的域，前端每次只需要将这2个域的值传入到后台即可实现排序。\n(1)后台组装排序url\n每次排序的时候恢复第1页查询，所以url地址我们需要重新拼接,每次切换排序的时候，不需要之前的排序信息，修改skucontroller,代码如下：\nprivate string url(map\u0026lt;string, string\u0026gt; searchmap) {// { spec_网络:\u0026#34;移动4g\u0026#34;,\u0026#34;keywords\u0026#34;:\u0026#34;华为\u0026#34;} string url = \u0026#34;/search/list\u0026#34;; // a/b?id=1\u0026amp; if (searchmap != null) { url += \u0026#34;?\u0026#34;; for (map.entry\u0026lt;string, string\u0026gt; stringstringentry : searchmap.entryset()) { //如果是排序 则 跳过 拼接排序的地址 因为有数据 if(stringstringentry.getkey().equals(\u0026#34;sortfield\u0026#34;) || stringstringentry.getkey().equals(\u0026#34;sortrule\u0026#34;)){ continue; } url += stringstringentry.getkey() + \u0026#34;=\u0026#34; + stringstringentry.getvalue() + \u0026#34;\u0026amp;\u0026#34;; } if(url.lastindexof(\u0026#34;\u0026amp;\u0026#34;)!=-1) url = url.substring(0, url.lastindexof(\u0026#34;\u0026amp;\u0026#34;)); } return url; } (2)前端排序实现\n修改search.html，实现排序，代码如下：\n\u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(sortfield=price,sortrule=asc)}\u0026#34;\u0026gt;价格↑\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a th:href=\u0026#34;@{${url}(sortfield=price,sortrule=desc)}\u0026#34;\u0026gt;价格↓\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; 这一块我们实现了价格排序，同学们课后去实现以下销量和新品排序。\n2.9 分页 真实的分页应该像京东那样，如下图： (1)分页工具类定义\n在dongyimai-common工程中添加page分页对象，代码如下：\npublic class page\u0026lt;t\u0026gt; implements serializable { private list\u0026lt;t\u0026gt; list; // 每页查询出来的数据存放的集合 private int pagesize = 10; // 每页显示的记录数 private int pageno; // 当前页，通过用户传入 //\tprivate int totalpageno; // 总页数，通过计算得到 private long totalrecord; // 总记录数，通过查询数据库得到 private int firstpage; //分页页码集合起始记录 private int lastpage; //分页页码集合结束记录 private int maxpage; //分页最大页码 private boolean firstdot = true; private boolean lastdot = true; public page() { } public page(long totalrecord,int pageno,int pagesize) { this.pagesize = pagesize; this.totalrecord = totalrecord; this.pageno = pageno; this.firstpage = 1; this.lastpage = (int)this.gettotalpageno(); this.maxpage = (int)this.gettotalpageno(); setpagelabel(); } public list\u0026lt;t\u0026gt; getlist() { return list; } public void setlist(list\u0026lt;t\u0026gt; list) { this.list = list; } public long getpageno() { if (pageno \u0026lt; 1) { // 如果当前页码小于1，直接返回1 return 1; } else if (pageno \u0026gt; gettotalpageno()) { // 如果当前页码大于总页数，返回总页数 return gettotalpageno(); } else { return pageno; } } public void setpageno(int pageno) { this.pageno = pageno; } // 总页数是由总记录数和每页显示的条数计算得到 public long gettotalpageno() { if (totalrecord % pagesize == 0) { return totalrecord / pagesize; } else { return totalrecord / pagesize + 1; } } public void setpagelabel(){ if(maxpage\u0026gt;5){ if(pageno\u0026lt;=3){ lastpage = 5; firstdot = false; }else if(pageno\u0026gt;=maxpage-2){ firstpage = maxpage-4; lastdot = false; }else{ firstpage = pageno-2; lastpage = pageno+2; } }else{ firstdot = false; lastdot = false; } } public int getfirstpage(){ return this.firstpage; } public int getlastpage(){ return this.lastpage; } // public void settotalpageno(int totalpageno) { // this.totalpageno = totalpageno; // } public long gettotalrecord() { return totalrecord; } public void settotalrecord(int totalrecord) { this.totalrecord = totalrecord; } public int getpagesize() { return pagesize; } // 判断是否有上一页 public boolean hasprev() { return getpageno() \u0026gt; 1; } // 获取上一页 public long getprev() { return hasprev() ? getpageno() - 1 : 1; } // 判断是否有下一页 public boolean hasnext() { return getpageno() \u0026lt; gettotalpageno(); } // 获取下一页 public long getnext() { return hasnext() ? getpageno() + 1 : gettotalpageno(); } public boolean isfirstdot(){ return this.firstdot; } public boolean islastdot(){ return this.lastdot; } } (2)分页实现\n由于这里需要获取分页信息，我们可以在dongyimai-search-service服务中修改搜索方法实现获取分页数据，修改com.offcn.search.service.impl.skuserviceimpl的search方法，在return之前添加如下方法获取份额与数据：\n//分页数据保存 //设置当前页码 resultmap.put(\u0026#34;pagenum\u0026#34;, pagenum); resultmap.put(\u0026#34;pagesize\u0026#34;, 30); 修改skucontroller,实现分页信息封装，代码如下：\n//5.创建一个分页的对象 可以获取当前页 和总个记录数和显示的页码(以当前页为中心的5个页码) page\u0026lt;skuinfo\u0026gt; infopage = new page\u0026lt;skuinfo\u0026gt;( long.valueof(resultmap.get(\u0026#34;total\u0026#34;).tostring()), integer.valueof(resultmap.get(\u0026#34;pagenum\u0026#34;).tostring()), integer.valueof(resultmap.get(\u0026#34;pagesize\u0026#34;).tostring()) ); model.addattribute(\u0026#34;page\u0026#34;,infopage); (3)页面分页实现\n修改search.html，实现分页查询，代码如下：\n\u0026lt;div class=\u0026#34;fr page\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sui-pagination pagination-large\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026#34;prev\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:if=\u0026#34;${page.pageno\u0026gt;1}\u0026#34; th:href=\u0026#34;@{${url}(pagenum=${page.prev})}\u0026#34;\u0026gt;«上一页\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;dotted\u0026#34;\u0026gt;\u0026lt;span th:if=\u0026#34;${page.firstdot}\u0026#34;\u0026gt;...\u0026lt;/span\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li th:class=\u0026#34;${page.pageno}==${i}?\u0026#39;active\u0026#39;:\u0026#39;\u0026#39;\u0026#34; th:each=\u0026#34;i:${#numbers.sequence(page.firstpage,page.lastpage)}\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:href=\u0026#34;@{${url}(pagenum=${i})}\u0026#34; th:text=\u0026#34;${i}\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;dotted\u0026#34;\u0026gt;\u0026lt;span th:if=\u0026#34;${page.lastdot}\u0026#34;\u0026gt;...\u0026lt;/span\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;next\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:if=\u0026#34;${page.pageno\u0026lt;page.next}\u0026#34; th:href=\u0026#34;@{${url}(pagenum=${page.next})}\u0026#34;\u0026gt;下一页»\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div\u0026gt;\u0026lt;span\u0026gt;共\u0026lt;i th:text=\u0026#34;${page.totalpageno}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;页\u0026amp;nbsp;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 注意：每次如果搜条件发生变化都要从第1页查询，而点击下一页的时候，分页数据在页面给出，不需要在后台拼接的url中给出，所以在拼接url的时候，需要过滤掉分页参数，修改dongyimai-search-web的控制层com.offcn.search.controller.skucontroller的url拼接方法，代码如下： 测试效果：\n三 东易买商品详情页 1 为什么要使用网页静态化技术 网页静态化解决方案在实际开发中运用比较多，例如新闻网站，门户网站中的新闻频道或者是文章类的频道。 对于电商网站的商品详细页来说，至少几百万个商品，每个商品又有大量的信息，这样的情况同样也适用于使用网页静态化来解决。\n网页静态化技术和缓存技术的共同点都是为了减轻数据库的访问压力，但是具体的应用场景不同，缓存比较适合小规模的数据，而网页静态化比较适合大规模且相对变化不太频繁的数据。另外网页静态化还有利于seo。\n另外我们如果将网页以纯静态化的形式展现，就可以使用nginx这样的高性能的web服务器来部署，nginx可以承载5万的并发，而tomcat只有几百。\n今天我们就研究网页静态化技术\n2 需求分析 当系统审核完成商品，需要将商品详情页进行展示，那么采用静态页面生成的方式生成，并部署到高性能的web服务器中进行访问是比较合适的。所以，开发流程如下图所示： 执行步骤解释：\n系统管理员（商家运维人员）修改或者审核商品的时候，会触发canal监控数据 canal微服务获取修改数据后，调用静态页微服务的方法进行生成静态页 静态页微服务只负责使用thymeleaf的模板技术生成静态页 3 商品静态化微服务创建 3.1 搭建项目 （1）在dongyimai-web下创建一个名称为dongyimai-item-web的模块,该微服务只用于生成商品静态页，如图： （2）dongyimai-item-web中添加起步依赖，如下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-web\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-item-web\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-sellergoods-serivce-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; （3）修改application.yml的配置\nserver: port: 9102 eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true spring: thymeleaf: cache: false application: name: item-web main: allow-bean-definition-overriding: true feign: hystrix: enabled: true client: config: default: connecttimeout: 10000 #连接超时配置 readtimeout: 60000 #执行超时配置 #设定hystrix熔断超时时间 ，理论上熔断时间应该大于总连接超时时间 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 6000 # 生成静态页的位置 pagepath: c:\\\\items （4）创建系统启动类\n@springbootapplication(exclude = {datasourceautoconfiguration.class}) @enableeurekaclient @enablefeignclients(basepackages = \u0026#34;com.offcn.sellergoods.feign\u0026#34;) public class itemapplication { public static void main(string[] args) { springapplication.run(itemapplication.class,args); } } 3.2 生成静态页 3.2.1 需求分析 页面发送请求，传递要生成的静态页的的商品的spuid.后台controller 接收请求，调用thyemleaf的原生api生成商品静态页。 上图是要生成的商品详情页，从图片上可以看出需要查询spu的3个分类作为面包屑显示，同时还需要查询sku和spu信息。\n3.2.2 feign创建 稍后需要查询spu和sku以及category，所以我们需要先创建feign。\n修改dongyimai-sellergoods-service-api,添加itemcatfeign，并在itemcatfeign中添加根据id查询分类数据，代码如下：\n@feignclient(name=\u0026#34;sellergoods\u0026#34;) @requestmapping(\u0026#34;/itemcat\u0026#34;) public interface itemcatfeign { /** * 获取分类的对象信息 * @param id * @return */ @getmapping(\u0026#34;/{id}\u0026#34;) public result\u0026lt;itemcat\u0026gt; findbyid(@pathvariable(name = \u0026#34;id\u0026#34;) integer id); } 在dongyimai-sellergoods-service-api,添加goodsfeign,并添加根据spuid查询spu信息，代码如下：\n@feignclient(name=\u0026#34;sellergoods\u0026#34;) @requestmapping(\u0026#34;/goods\u0026#34;) public interface goodsfeign { /*** * 根据id查询spu数据 * @param id * @return */ @getmapping(\u0026#34;/{id}\u0026#34;) result\u0026lt;goodsentity\u0026gt; findbyid(@pathvariable long id); } 3.2.3 静态页生成代码 (1) 创建service\n在项目dongyimai-item-web中创建接口 com.offcn.item.service.pageservice\n接口：pageservice\npublic interface pageservice { /** * 根据商品的id 生成静态页 * @param spuid */ public void createpagehtml(long spuid) ; } 在项目dongyimai-item-web中创建实现类 com.offcn.item.service.impl.pageserviceimpl实现类，代码如下：\n@service public class pageserviceimpl implements pageservice { @autowired private goodsfeign goodsfeign; @autowired private itemcatfeign itemcatfeign; @autowired private templateengine templateengine; //生成静态文件路径 @value(\u0026#34;${pagepath}\u0026#34;) private string pagepath; /** * 构建数据模型 * @param spuid * @return */ private map\u0026lt;string,object\u0026gt; builddatamodel(long spuid){ //构建数据模型 map\u0026lt;string, object\u0026gt; datamap = new hashmap\u0026lt;\u0026gt;(); //获取spu 和sku列表 result\u0026lt;goodsentity\u0026gt; result = goodsfeign.findbyid(spuid); goodsentity goodsentity = result.getdata(); //1.加载spu数据 goods goods = goodsentity.getgoods(); //2.加载商品扩展数据 goodsdesc goodsdesc = goodsentity.getgoodsdesc(); //3.加载sku数据 list\u0026lt;item\u0026gt; itemlist = goodsentity.getitemlist(); datamap.put(\u0026#34;goods\u0026#34;, goods); datamap.put(\u0026#34;goodsdesc\u0026#34;, goodsdesc); datamap.put(\u0026#34;specificationlist\u0026#34;, json.parsearray(goodsdesc.getspecificationitems(),map.class)); datamap.put(\u0026#34;imagelist\u0026#34;,json.parsearray(goodsdesc.getitemimages(),map.class)); datamap.put(\u0026#34;itemlist\u0026#34;,itemlist); //4.加载分类数据 datamap.put(\u0026#34;category1\u0026#34;,itemcatfeign.findbyid(goods.getcategory1id().intvalue()).getdata()); datamap.put(\u0026#34;category2\u0026#34;,itemcatfeign.findbyid(goods.getcategory2id().intvalue()).getdata()); datamap.put(\u0026#34;category3\u0026#34;,itemcatfeign.findbyid(goods.getcategory3id().intvalue()).getdata()); return datamap; } /*** * 生成静态页 * @param spuid */ @override public void createpagehtml(long spuid) { // 1.上下文 context context = new context(); map\u0026lt;string, object\u0026gt; datamodel = builddatamodel(spuid); context.setvariables(datamodel); // 2.准备文件 file dir = new file(pagepath); if (!dir.exists()) { dir.mkdirs(); } file dest = new file(dir, spuid + \u0026#34;.html\u0026#34;); // 3.生成页面 try (printwriter writer = new printwriter(dest, \u0026#34;utf-8\u0026#34;)) { templateengine.process(\u0026#34;item\u0026#34;, context, writer); } catch (exception e) { e.printstacktrace(); } } } (2)创建controller\n在dongyimai-item-web中创建com.offcn.item.controller.pagecontroller用于接收请求，测试生成静态页\n@restcontroller @requestmapping(\u0026#34;/page\u0026#34;) public class pagecontroller { @autowired private pageservice pageservice; /** * 生成静态页面 * @param id * @return */ @requestmapping(\u0026#34;/createhtml/{id}\u0026#34;) public result createhtml(@pathvariable(name=\u0026#34;id\u0026#34;) long id){ pageservice.createpagehtml(id); return new result(true, statuscode.ok,\u0026#34;ok\u0026#34;); } } （3）拷贝模板文件 资料/网站前台/item.html\n3.2.4 模板填充 首先将模板 将资料/网站前台/item.html 拷贝到 resources/templates/下\n添加thymeleaf的头\n修改thymeleaf命名头\n\u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; (1)面包屑数据的实现\n修改item.html，填充三个分类数据作为面包屑，代码如下：\n\u0026lt;div class=\u0026#34;crumb-wrap\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;sui-breadcrumb\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:text=\u0026#34;${category1.name}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:text=\u0026#34;${category2.name}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; th:text=\u0026#34;${category3.name}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; (2)商品图片\n修改item.html，将商品图片信息输出，在真实工作中需要做空判断，代码如下：\n\u0026lt;div class=\u0026#34;fl preview-wrap\u0026#34;\u0026gt; \u0026lt;!--放大镜效果--\u0026gt; \u0026lt;div class=\u0026#34;zoom\u0026#34;\u0026gt; \u0026lt;!--默认第一个预览--\u0026gt; \u0026lt;div id=\u0026#34;preview\u0026#34; class=\u0026#34;spec-preview\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;jqzoom\u0026#34;\u0026gt;\u0026lt;img th:jqimg=\u0026#34;${imagelist[0].url}\u0026#34; th:src=\u0026#34;${imagelist[0].url}\u0026#34; width=\u0026#34;400px\u0026#34;/\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--下方的缩略图--\u0026gt; \u0026lt;div class=\u0026#34;spec-scroll\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;prev\u0026#34;\u0026gt;\u0026amp;lt;\u0026lt;/a\u0026gt; \u0026lt;!--左右按钮--\u0026gt; \u0026lt;div class=\u0026#34;items\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li th:each=\u0026#34;img:${imagelist}\u0026#34;\u0026gt;\u0026lt;img th:src=\u0026#34;${img.url}\u0026#34; th:bimg=\u0026#34;${img.url}\u0026#34; onmousemove=\u0026#34;preview(this)\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;a class=\u0026#34;next\u0026#34;\u0026gt;\u0026amp;gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; (3)规格输出\n\u0026lt;div id=\u0026#34;specification\u0026#34; class=\u0026#34;summary-wrap clearfix\u0026#34;\u0026gt; \u0026lt;!--循环map--\u0026gt; \u0026lt;dl th:each=\u0026#34;spec,specstat:${specificationlist}\u0026#34;\u0026gt; \u0026lt;dt\u0026gt; \u0026lt;div class=\u0026#34;fl title\u0026#34;\u0026gt; \u0026lt;i th:text=\u0026#34;${spec.attributename}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/dt\u0026gt; \u0026lt;dd th:each=\u0026#34;arrvalue:${spec.attributevalue}\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt; \u0026lt;i th:text=\u0026#34;${arrvalue}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span title=\u0026#34;点击取消选择\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; \u0026lt;/div\u0026gt; (4)默认sku显示\n静态页生成后，需要显示默认的sku，我们这里默认显示第1个sku即可，这里可以结合着vue一起实现。可以先定义一个集合，再定义一个spec和sku，用来存储当前选中的sku信息和sku的规格，代码如下：\n需要在页面引入vue.js\n\u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 设置绑定vue节点\n\u0026lt;!--页面顶部 结束--\u0026gt; \u0026lt;div class=\u0026#34;py-container\u0026#34; id=\u0026#34;itemarray\u0026#34;\u0026gt; \u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; var item = new vue({ el: \u0026#39;#itemarray\u0026#39;, data: { skulist: [[${itemlist}]], sku: {}, spec: {} }, created: function () { this.sku = json.parse(json.stringify(this.skulist[0])); this.spec = json.parse(this.skulist[0].spec); } }) \u0026lt;/script\u0026gt; 页面显示默认的sku信息\n\u0026lt;div class=\u0026#34;sku-name\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;{{sku.title}}\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;news\u0026#34;\u0026gt;\u0026lt;span th:text=\u0026#34;${goods.caption}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;summary\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;summary-wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl title\u0026#34;\u0026gt; \u0026lt;i\u0026gt;价　格\u0026lt;/i\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl price\u0026#34;\u0026gt; \u0026lt;i\u0026gt;¥\u0026lt;/i\u0026gt; \u0026lt;em\u0026gt;{{sku.price}}\u0026lt;/em\u0026gt; \u0026lt;span\u0026gt;降价通知\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fr remark\u0026#34;\u0026gt; \u0026lt;i\u0026gt;累计评价\u0026lt;/i\u0026gt;\u0026lt;em\u0026gt;612188\u0026lt;/em\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ……………… \u0026lt;/div\u0026gt; (5)默认sku显示\n静态页生成后，需要显示默认的sku，我们这里默认显示第1个sku即可，这里可以结合着vue一起实现。可以先定义一个集合，再定义一个spec和sku，用来存储当前选中的sku信息和sku的规格，代码如下：\n\u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; var item = new vue({ el: \u0026#39;#itemarray\u0026#39;, data: { skulist: [[${itemlist}]], sku: {}, spec: {} }, created: function () { this.sku = json.parse(json.stringify(this.skulist[0])); //注意这里是直接把json字符串转换为对象 this.spec = json.parse(this.skulist[0].spec); } }) \u0026lt;/script\u0026gt; 注意：th:inline=\u0026ldquo;javascript\u0026quot;这是thymeleaf中的内联写法，支持在javascript访问model中的数据，所以有[[${xxx.xxx}]]这样写法(javascript中访问thymeleaf变量值)的时候一定要记得在script中写上th:inline=\u0026ldquo;javascript\u0026quot;这样才成功访问。\n位置如下：\n页面显示默认的sku信息\n\u0026lt;div class=\u0026#34;fr iteminfo-wrap\u0026#34; id=\u0026#34;itemarray\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sku-name\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;{{sku.title}}\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;news\u0026#34;\u0026gt;\u0026lt;span th:text=\u0026#34;${goods.caption}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;summary\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;summary-wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;fl title\u0026#34;\u0026gt; \u0026lt;i\u0026gt;价　格\u0026lt;/i\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fl price\u0026#34;\u0026gt; \u0026lt;i\u0026gt;¥\u0026lt;/i\u0026gt; \u0026lt;em\u0026gt;{{sku.price}}\u0026lt;/em\u0026gt; \u0026lt;span\u0026gt;降价通知\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;fr remark\u0026#34;\u0026gt; \u0026lt;i\u0026gt;累计评价\u0026lt;/i\u0026gt;\u0026lt;em\u0026gt;612188\u0026lt;/em\u0026gt; \u0026lt;/div\u0026gt; ....... \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--product-detail--\u0026gt; (6)记录选中的sku\n在当前spu的所有sku中spec值是唯一的，我们可以根据spec来判断用户选中的是哪个sku，我们可以在vue中添加代码来实现，代码如下：\nmethods: { selectspecification: function (specname, specvalue) { //选中的spec信息，且触发视图更新 this.$set(this.spec, specname, specvalue); //循环匹配 for (var i = 0; i \u0026lt; this.skulist.length; i++) { //匹配规格是否相同，如果相同，则表明选中的是该sku if (this.matchobject(json.parse(this.skulist[i].spec), this.spec)) { this.sku = this.skulist[i]; return; } } //如果上面执行完毕，没有找到sku，则提示下架操作 this.sku = {\u0026#39;id\u0026#39;:0,\u0026#39;title\u0026#39;:\u0026#39;提示：该商品已经下架\u0026#39;,\u0026#39;price\u0026#39;:0}; }, matchobject: function (map1, map2) { for (var k in map1) { if (map1[k] != map2[k]) { return false; } } for (var k in map2) { if (map2[k] != map1[k]) { return false; } } return true; } } 添加规格点击事件 \u0026lt;a href=\u0026#34;javascript:;\u0026#34; th:@click=\u0026#34;|selectspecification(\u0026#39;${spec.attributename}\u0026#39;,\u0026#39;${arrvalue}\u0026#39;)|\u0026#34; th:v-bind:class=\u0026#34;|{selected:sel(\u0026#39;${spec.attributename}\u0026#39;,\u0026#39;${arrvalue}\u0026#39;)}|\u0026#34;\u0026gt;[[${arrvalue}]]\u0026lt;span title=\u0026#34;点击取消选择\u0026#34;\u0026gt;\u0026amp;nbsp;\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; (6)样式切换\n点击不同规格后，实现样式选中，我们可以根据每个规格判断该规格是否在当前选中的sku规格中，如果在，则返回true添加selected样式，否则返回false不添加selected样式。\nvue添加代码：\nsel: function (name, value) { if (this.spec == undefined) { return false; } if (this.spec[name] == value) { return true; } else { return false; } } 页面添加样式绑定，代码如下： 完整的vue代码如下:\n\u0026lt;script th:inline=\u0026#34;javascript\u0026#34;\u0026gt; var item = new vue({ el: \u0026#39;#itemarray\u0026#39;, data: { skulist: [[${itemlist}]], sku: {}, spec: {} }, created: function () { this.sku = json.parse(json.stringify(this.skulist[0])); this.spec = json.parse(this.skulist[0].spec); }, methods: { sel: function (name, value) { if (this.spec == undefined) { return false; } if (this.spec[name] == value) { return true; } else { return false; } }, selectspecification: function (specname, specvalue) { //选中的spec信息 this.$set(this.spec, specname, specvalue); //循环匹配 for (var i = 0; i \u0026lt; this.skulist.length; i++) { //匹配规格是否相同，如果相同，则表明选中的是该sku if (this.matchobject(json.parse(this.skulist[i].spec), this.spec)) { this.sku = this.skulist[i]; return; } } //如果上面执行完毕，没有找到sku，则提示下架操作 this.sku = {\u0026#39;id\u0026#39;:0,\u0026#39;title\u0026#39;:\u0026#39;提示：该商品已经下架\u0026#39;,\u0026#39;price\u0026#39;:0}; }, matchobject: function (map1, map2) { for (var k in map1) { if (map1[k] != map2[k]) { return false; } } for (var k in map2) { if (map2[k] != map1[k]) { return false; } } return true; } } }) \u0026lt;/script\u0026gt; 3.2.5 启动测试 启动eureka服务端 dongyimai-eureka\n启动商品微服务 dongyimai-sellergoods-service\n启动静态化微服务 dongyimai-item-web\n将静态资源导入到c:\\items目录下中，如下图： 这样生成静态页面到给地址的时候就可以有正确的样式等信息了。\n开始生成静态页面:\n访问生成静态页地址 http://localhost:9102/page/createhtml/149187842867985 注意: 此处一定要使用一个有效的数据信息才可以实现效果。如果数据库中的商品的数据信息不完整将不能正常生成页面数据。\n静态页生成后在生成目录中访问页面，效果如下： 这样后续我们将这些生成的静态网页部署到nginx下，就可以直接访问了。\n四 canal监听生成静态页 监听到数据的变化,直接调用feign 生成静态页即可.\n目前，已经完成使用静态页微服务，接收传递的商品spuid 通过fegin调用商品微服务获取商品数据，以及商品分类数据， 实现商品详情页的生成。\n接下需要实现就是使用canal 动态监控数据库中商品数据的变化，比如： 商品审核通过了，canal监听到商品数据发生变化，就会调用 静态页微服务并传递spuid， 接下来静态页微服务就生成静态页。\n1 需求分析 当商品微服务审核商品之后，应当发送消息，这里采用了canal监控数据变化，数据变化后，调用feign实现生成静态页\n2 feign创建 在dongyimai-service-api中创建dongyimai-item-web-api，该工程中主要创建dongyimai-item-web的对外依赖抽取信息。\n(1)feign创建\n在dongyimai-item-web-api中创建com.offcn.item.feign.pagefeign,代码如下：\n@feignclient(name=\u0026#34;item-web\u0026#34;) @requestmapping(\u0026#34;/page\u0026#34;) public interface pagefeign { /*** * 根据spuid生成静态页 * @param id * @return */ @requestmapping(\u0026#34;/createhtml/{id}\u0026#34;) result createhtml(@pathvariable(name=\u0026#34;id\u0026#34;) long id); } (2)pom.xml依赖\n修改dongyimai-canal-service工程的pom.xml，引入如下依赖：\n\u0026lt;!--静态页api 服务--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-item-web-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; (3)修改dongyiami-canal-service工程中的启动类 @springbootapplication(exclude={datasourceautoconfiguration.class}) @enableeurekaclient @enablecanalclient @enablefeignclients(basepackages = {\u0026#34;com.offcn.content.feign\u0026#34;,\u0026#34;com.offcn.item.feign\u0026#34;}) public class canalapplication { public static void main(string[] args) { springapplication.run(canalapplication.class,args); } } 3 canal监听数据变化 监听类中,监听商品数据库的tb_goods的数据变化,当数据变化的时候生成静态页或者删除静态页\n在原来的监听类中添加如下代码即可,\n@autowired private pagefeign pagefeign; @listenpoint(destination = \u0026#34;example\u0026#34;, schema = \u0026#34;dongyimaidb\u0026#34;, table = {\u0026#34;tb_goods\u0026#34;}, eventtype = {canalentry.eventtype.update, canalentry.eventtype.insert, canalentry.eventtype.delete}) public void oneventcustomspu(canalentry.eventtype eventtype, canalentry.rowdata rowdata) { //判断操作类型 if (eventtype == canalentry.eventtype.delete) { string goodsid = \u0026#34;\u0026#34;; list\u0026lt;canalentry.column\u0026gt; beforecolumnslist = rowdata.getbeforecolumnslist(); for (canalentry.column column : beforecolumnslist) { if (column.getname().equals(\u0026#34;id\u0026#34;)) { goodsid = column.getvalue();//goodsid break; } } //todo 删除静态页 }else{ //新增 或者 更新 list\u0026lt;canalentry.column\u0026gt; aftercolumnslist = rowdata.getaftercolumnslist(); string goodsid = \u0026#34;\u0026#34;; for (canalentry.column column : aftercolumnslist) { if (column.getname().equals(\u0026#34;id\u0026#34;)) { goodsid = column.getvalue(); break; } } //更新 生成静态页 pagefeign.createhtml(long.valueof(goodsid)); } } 4.具体演示可以新增一个商品数据，然后后在监听的时候打印一个数据语句便于观察效果。\n新增之后，可以看到 dongyimai-canal-service,打印如下输出语句 查看静态页面目录发现生成了静态页面。\n","date":"2022-05-27","permalink":"https://lovemjh.vercel.app/posts/project-0/20220527231757/","summary":"第八章 Thymeleaf实现搜索页面渲染及商品静态页 优就业.JAVA教研室 学习目标 目标1：搜索页面渲染 目标2：Thymeleaf的介绍 目标3：Thymeleaf","title":"thymeleaf实现搜索页面渲染及商品静态页"},{"content":"第三章 东易买后端微服务框架搭建 优就业.java教研室 学习目标 目标1：了解电商\n目标2：了解东易买架构\n目标3：了解东易买工程结构\n目标4：掌握东易买工程搭建\n目标5：掌握商品微服务搭建\n目标6：掌握品牌的增删改查\n目标7：了解fastdfs工作流程\n目标8：搭建文件上传微服务\n一、走进电商 1. 电商行业分析 ​\t近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力 不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。\n中国电子商务研究中心数据显示，截止到 2019 年底，中国电子商务市场交易规模达 34.81万亿人民币，同比增长6.7%。其中，b2b市场交易规模达到25.94万亿元，同比增长 20%以上。商品，服务类电商交易额33.76万亿元，增长6.6%；合约类电商交易额1.05万亿元，增长10.1%，\n双十一交易额 2.电商行业技术特点 技术新 技术范围广 分布式 高并发、集群、负载均衡、高可用 海量数据 业务复杂 系统安全 3.主要电商模式 3.1 b2b\u0026ndash;企业对企业 ​\tb2b （ business to business）是指进行电子商务交易的供需双方都是商家（或企业、公司），她（他）们使用了互联网的技术或各种商务网络平台，完成商务交易的过程。电子商务是现代 b2b marketing的一种具体主要的表现形式。 案例：阿里巴巴、慧聪网\n3.2 c2c\u0026ndash;个人对个人 ​\tc2c即 customer（consumer） to customer（consumer），意思就是消费者个人间的电子商务行为。比如一个消费者有一台电脑，通过网络进行交易，把它出售给另外一个消费者，此种交易类型就称为c2c电子商务。 案例：淘宝、易趣、瓜子二手车\n3.3 b2c\u0026ndash;企业对个人 ​\tb2c是business-to-customer的缩写，而其中文简称为“商对客”。“商对客”是电子商务的一种模式，也就是通常说的直接面向消费者销售产品和服务商业零售模式。这种形式的电子商务一般以网络零售业为主，主要借助于互联网开展在线销售活动。b2c即企业通过互联网为消费者提供一个新型的购物环境——网上商店，消费者通过网络在网上购物、网上支付等消费行为。 案例：唯品会、乐蜂网\n3.4 c2b\u0026ndash;个人对企业 ​\tc2b（consumer to business，即消费者到企业），是互联网经济时代新的商业模式。这一模式改变了原有生产者（企业和机构）和消费者的关系，是一种消费者贡献价值（create value）， 企业和机构消费价值（consume value）。\n​\tc2b模式和我们熟知的供需模式（dsm, demand supply model）恰恰相反，真正的c2b 应该先有消费者需求产生而后有企业生产，即先有消费者提出需求，后有生产企业按需求组织生产。通常情况为消费者根据自身需求定制产品和价格，或主动参与产品设计、生产和定价，产品、价格等彰显消费者的个性化需求，生产企业进行定制化生产。 案例：海尔商城、 尚品宅配\n3.5 o2o\u0026ndash;线上到线下 ​\to2o即online to offline（在线离线/线上到线下），是指将线下的商务机会与互联网结合，让互联网成为线下交易的平台，这个概念最早来源于美国。o2o的概念非常广泛，既可涉及到线上，又可涉及到线下,可以通称为o2o。主流商业管理课程均对o2o这种新型的商业模式有所介绍及关注。 案例：美团、饿了吗\n3.6 f2c\u0026ndash;工厂到个人 ​\tf2c指的是factory to customer，即从厂商到消费者的电子商务模式。 3.7 b2b2c -企业-企业-个人 ​\tb2b2c是一种电子商务类型的网络购物商业模式，b是business的简称，c是customer的简称，第一个b指的是商品或服务的供应商，第二个b指的是从事电子商务的企业，c则是表示消费者。 第一个business，并不仅仅局限于品牌供应商、影视制作公司和图书出版商，任何的商品供应商或服务供应商都能可以成为第一个business；第二b是b2b2c模式的电子商务企业，通过统一的经营管理对商品和服务、消费者终端同时进行整合，是广大供应商和消费者之间的桥梁，为供应商和消费者提供优质的服务，是互联网电子商务服务供应商。c表示消费者，在第二个b构建的统一电子商务平台购物的消费者； b2b2c的来源于目前的b2b、b2c模式的演变和完善，把b2c和c2c完美地结合起来，通过b2b2c模式的电子商务企业构建自己的物流供应链系统，提供统一的服务。\n案例：京东商城、天猫商城\n二、东易买- 需求分析与系统设计 2.1 东易买简介 东易买网上商城是一个综合性的 b2b2c 平台，类似京东商城、天猫商城。网站采用商家入驻的模式，商家入驻平台提交申请，有平台进行资质审核，审核通过后，商家拥有独立的管理后台录入商品信息。商品经过平台审核后即可发布。用户可以在线购买商品、加入购物车、下单、秒杀商品，可以评论已购买商品\n客服可以在后台处理退款操作。\n东易买网上商城主要分为网站前台、运营商后台、商家管理后台三个子系统。\n希望未来3到5年可以支持千万用户的使用\n2.2 网站前台 主要包括网站首页、商家首页、商品详细页、搜索页、会员中心、订单与支付相关页面、秒杀频道等。 2.3 运营商后台 是运营商的运营人员的管理后台。 主要包括商家审核、品牌管理、规格管理、模板管理、商品分类管理、商品审核、广告类型管理、广告管理、订单查询、商家结算等。 2.4 商家管理后台 入驻的商家进行管理的后台，主要功能是对商品的管理以及订单查询统计、资金结算等功能。 2.5 系统设计 2.5.1 前后端分离 网站后台的部分采用前后端分离方式。\n以前的javaweb项目大多数都是java程序员又当爹又当妈，又搞前端，又搞后端。随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。\n对于后端java工程师：\n把精力放在设计模式，spring+springmvc，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构，弹性计算架构，微服务架构，java性能优化，以及相关的项目管理等等。\n对于前端工程师：\n把精力放在html5，css3，vuejs，webpack，nodejs，google v8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。 我们在本课程中提供与项目课程配套的管理后台的前端代码，但是不讲解前端的内容。这样我们会将更多的精力放在后端代码的开发上！\n2.5.2 功能架构 2.5.3 技术架构图 三、 东易买-框架搭建 3.1 数据库表结构 表名称 含义 tb_brand 品牌 tb_specification 规格 tb_specification_option 规格选项 tb_type_template 类型模板：用于关联品牌和规格 tb_item_cat 商品分类 tb_seller 商家 tb_goods 商品 tb_goods_desc 商品详情 tb_item 商品明细 tb_content 内容（广告） tb_content_category 内容（广告）类型 3.2 项目结构说明 结构说明：\ndongyimai-gateway\n网关模块，根据网站的规模和需要，可以将综合逻辑相关的服务用网关路由组合到一起。在这里还可以做鉴权和限流相关操作。 dongyimai-service\n微服务模块，该模块用于存放所有独立的微服务工程。 dongyimai-service_api\n对应工程的javabean、feign、以及hystrix配置，该工程主要对外提供依赖。 dongyimai-transaction-fescar\n分布式事务模块，将分布式事务抽取到该工程中，任何工程如需要使用分布式事务，只需依赖该工程即可。 dongyimai-web\nweb服务工程，对应功能模块如需要调用多个微服务，可以将他们写入到该模块中，例如网站后台、网站前台等 3.3 公共工程搭建 3.3.1 父工程搭建 创建父工程 dongyimai-parent ,用来管理依赖及其版本，注意是创建project，而不是moudle 填写项目信息： pom.xml文件中增加配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.3.9.release\u0026lt;/version\u0026gt; \u0026lt;relativepath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;dongyimai-parent\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;demo project for spring boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceencoding\u0026gt;utf-8\u0026lt;/project.build.sourceencoding\u0026gt; \u0026lt;project.reporting.outputencoding\u0026gt;utf-8\u0026lt;/project.reporting.outputencoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;hoxton.release\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;swagger.version\u0026gt;2.9.2\u0026lt;/swagger.version\u0026gt; \u0026lt;fastjson.version\u0026gt;1.2.51\u0026lt;/fastjson.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- springcloud --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.junit.vintage\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit-vintage-engine\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--fastjson--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fastjson\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${fastjson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--swagger--\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger2\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger-ui\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 可以发现，我们在父工程中引入了springcloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。\n然后删除一下文件及目录\n3.3.2 其他公共模块搭建 创建dongyimai-gateway、dongyimai-service、dongyimai-service-api、dongyimai-web工程，直接创建maven模块，工程全部为pom工程，并将所有工程的src文件删除。\npom.xml中打pom包\n\u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 项目结构如下： 3.4 eureka微服务搭建 这个大家应该比较熟悉了。\n我们的注册中心，起名为：dongyimai-eureka\n直接创建maven项目模块，继承父类的依赖：\n选择新建module： 选择maven安装，但是不要选择骨架： 然后填写模块名称为dongyimai-eureka:\n3.4.1 pom.xml依赖 创建模块dongyimai-eureka ，pom.xml引入依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-eureka\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 3.4.2 appliation.yml配置 创建配置文件application.yml\nserver: port: 8761 spring: application: name: eureka eureka: instance: hostname: 127.0.0.1 client: register-with-eureka: false #是否将自己注册到eureka中 fetch-registry: false #是否从eureka中获取信息 service-url: defaultzone: http://${eureka.instance.hostname}:${server.port}/eureka server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理 3.4.3 启动类配置 创建包com.offcn包下创建启动类eurekaapplication，代码如下：\n上图代码如下：\n@springbootapplication @enableeurekaserver public class eurekaapplication { public static void main(string[] args) { springapplication.run(eurekaapplication.class,args); } } 测试访问http://localhost:8761/,效果如下： 3.5 公共模块搭建 3.5.1 pom.xml依赖 创建公共子模块dongyimai-common，pom.xml引入依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--web起步依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- redis 使用--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--eureka-client--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--openfeign--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.httpcomponents\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;httpclient\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.httpcomponents\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;httpcore\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;commons-lang\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;commons-lang\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.eclipse.jetty\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jetty-util\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;9.3.7.v20160115\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 公共子模块引入这些依赖后，其他微服务引入dongyimai-common后也自动引入了这些依赖\n3.5.2 常用对象 创建com.offcn.entity包 ，在entity包下创建返回状态码实体类\n/** * 返回码 */ public class statuscode { public static final int ok = 20000;//成功 public static final int error = 20001;//失败 public static final int loginerror = 20002;//用户名或密码错误 public static final int accesserror = 20003;//权限不足 public static final int remoteerror = 20004;//远程调用失败 public static final int reperror = 20005;//重复操作 public static final int notfounderror = 20006;//没有对应的抢购数据 } com.offcn.entity包下建立类result用于微服务返回结果给前端\n/** * 返回结果实体类 */ public class result\u0026lt;t\u0026gt; { private boolean flag;//是否成功 private integer code;//返回码 private string message;//返回消息 private t data;//返回数据 public result(boolean flag, integer code, string message, t data) { this.flag = flag; this.code = code; this.message = message; this.data = data; } public result(boolean flag, integer code, string message) { this.flag = flag; this.code = code; this.message = message; } public result() { this.flag = true; this.code = statuscode.ok; this.message = \u0026#34;操作成功!\u0026#34;; } // getter and setter..... } 在entity包下建立类用于承载分页的数据结果\n/** * 分页结果类 */ public class pageresult\u0026lt;t\u0026gt; { private long total;//总记录数 private list\u0026lt;t\u0026gt; rows;//记录 public pageresult(long total, list\u0026lt;t\u0026gt; rows) { this.total = total; this.rows = rows; } public pageresult() { } //getter and setter ...... } 当然，我们还可以将其他工具类都一起倒入到工程中，以后会用到，将资料\\工具类中的所有类直接导入到entity包下。 3.6 数据访问工程搭建 创建公共模块dongyimai-common-db ，pom文件引入依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common-db\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.32\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.1.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatisplus --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 这个公共模块是连接数据库的公共微服务模块，所有需要连接数据库的微服务都继承自此工程。\n3.7 商品微服务搭建 商品微服务主要是实现对商品的增删改查相关操作，以及商品相关信息的增删改查。\n3.7.1 公共组件工程搭建 创建dongyimai-service-api子模块dongyimai-sellergoods-service-api，并将资料\\javabean\\dongyimai-service-goods-api中的pojo导入到工程中。 修改父工程dongyimai-service-api的pom.xml，代码如下：\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common-db\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 3.7.2 微服务工程搭建 在dongyimai-service中创建dongyimai-sellergoods-service ，pom.xml引入依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-sellergoods-service\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-sellergoods-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 在resources下创建配置文件application.yml\nserver: port: 9001 spring: application: name: dym-sellergoods datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/dongyimaidb?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=gmt%2b8 username: root password: 123456 type: com.alibaba.druid.pool.druiddatasource eureka: client: service-url: defaultzone: http://localhost:8761/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: ${spring.application.name}:${server.port} feign: hystrix: enabled: true mybatis-plus: configuration: map-underscore-to-camel-case: true #开启驼峰式编写规范 type-aliases-package: com.offcn.sellergoods.pojo # 配置sql打印日志 logging: level: com: offcn: debug 在包com.offcn.sellergoods 包下创建启动类sellergoodsapplication，代码如下：\n@springbootapplication @enablediscoveryclient @mapperscan(\u0026#34;com.offcn.sellergoods.dao\u0026#34;) public class sellergoodsapplication { public static void main(string[] args) { springapplication.run(sellergoodsapplication.class); } } 启动dongyimai-sellergoods-service 再访问\u0026lt;http://localhost:8761/\u0026gt;效果如下： 四 商品微服务-品牌增删改查 4.1 需求分析 创建商品微服务，实现对品牌表的增删改查功能。具体包括\n（1）查询全部列表数据\n（2）根据id查询实体数据\n（3）增加\n（4）修改\n（5）删除\n（6）条件查询\n（7）分页查询\n（8）分页+条件查询\n4.2 表结构分析 品牌表：tb_brand\n字段名称 字段含义 字段类型 字段长度 备注 id 品牌id int name 品牌名称 varchar image 品牌图片地址 varchar first_char 品牌的首字母 char 4.3 代码实现 上面品牌表对应brand实体类\n@tablename(value=\u0026#34;tb_brand\u0026#34;) public class brand implements serializable{ @tableid(type = idtype.auto) @tablefield(value = \u0026#34;id\u0026#34;) private long id;// @tablefield(value = \u0026#34;name\u0026#34;) private string name;//品牌名称 @tablefield(value = \u0026#34;first_char\u0026#34;) private string firstchar;//品牌首字母 @tablefield(value = \u0026#34;image\u0026#34;) private string image;//品牌图像 // getter and setter .....(省略) } 注解均使用mybatisplus的注解\n4.3.1 品牌列表 (1)dao创建\n在dongyimai-sellegoods-service微服务下创建com.offcn.goods.dao.brandmapper接口，代码如下：\npublic interface brandmapper extends basemapper\u0026lt;brand\u0026gt; { } 继承了mapper接口，就自动实现了增删改查的常用方法。\n(2)业务层\n创建com.offcn.sellergoods.service.brandservice接口，代码如下：\npublic interface brandservice { /*** * 查询所有品牌 * @return */ list\u0026lt;brand\u0026gt; findall(); } 创建com.offcn.sellergoods.service.impl.brandserviceimpl实现类，代码如下：\n@service public class brandserviceimpl extends serviceimpl\u0026lt;brandmapper, brand\u0026gt; implements brandservice { /** * 全部数据 * @return */ public list\u0026lt;brand\u0026gt; findall(){ return this.list(); } } (3)控制层\n控制层 com.offcn.sellergoods包下创建controller包 ，包下创建类\n@restcontroller @requestmapping(\u0026#34;/brand\u0026#34;) @crossorigin public class brandcontroller { @autowired private brandservice brandservice; /*** * 查询全部数据 * @return */ @getmapping //不写value值默认调用根路径 public result\u0026lt;list\u0026lt;brand\u0026gt;\u0026gt; findall(){ list\u0026lt;brand\u0026gt; brandlist = brandservice.findall(); return new result\u0026lt;list\u0026lt;brand\u0026gt;\u0026gt;(true, statuscode.ok,\u0026#34;查询成功\u0026#34;,brandlist) ; } } 测试：http://localhost:9001/brand 4.3.2 根据id查询品牌 (1)业务层\n修改com.offcn.sellergoods.service.brandservice接口，添加根据id查询品牌数据方法，代码如下：\n/** * 根据id查询 * @param id * @return */ brand findbyid(integer id); 修改com.offcn.sellergoods.service.impl.brandserviceimpl新增方法，代码如下：\n/** * 根据id查询brand * @param id * @return */ @override public brand findbyid(long id){ return this.getbyid(id); } (2)控制层\nbrandcontroller新增方法\n/*** * 根据id查询brand数据 * @param id * @return */ @getmapping(\u0026#34;/{id}\u0026#34;) public result\u0026lt;brand\u0026gt; findbyid(@pathvariable long id){ //调用brandservice实现根据主键查询brand brand brand = brandservice.findbyid(id); return new result\u0026lt;brand\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,brand); } 测试：\u0026lt;http://localhost:9001/brand/1 4.3.3 新增品牌 (1)业务层\n修改com.offcn.sellergoods.service.brandservice，新增方法\n/*** * 新增品牌 * @param brand */ void add(brand brand); 修改com.offcn.sellergoods.service.impl.brandserviceimpl，新增增加品牌方法代码如下：\n/** * 增加brand * @param brand */ @override public void add(brand brand){ this.save(brand); } (2) 控制层\nbrandcontroller新增方法\n/*** * 新增brand数据 * @pa am brand * @return */ @postmapping public result add(@requestbody brand brand){ //调用brandservice实现添加brand brandservice.add(brand); return new result(true,statuscode.ok,\u0026#34;添加成功\u0026#34;); } 测试：http://localhost:9001/brand 4.3.4 修改品牌 (1)业务层\n需改com.offcn.sellergoods.service.brandservice,添加修改品牌方法，代码如下：\n/*** * 修改品牌数据 * @param brand */ void update(brand brand); 修改com.offcn.sellergoods.service.impl.brandserviceimpl，添加修改品牌方法，代码如下：\n/** * 修改brand * @param brand */ @override public void update(brand brand){ this.updatebyid(brand); } (2)控制层\nbrandcontroller新增方法\n/*** * 修改brand数据 * @param brand * @param id * @return */ @putmapping(value=\u0026#34;/{id}\u0026#34;) public result update(@requestbody brand brand,@pathvariable long id){ //设置主键值 brand.setid(id); //调用brandservice实现修改brand brandservice.update(brand); return new result(true,statuscode.ok,\u0026#34;修改成功\u0026#34;); } 测试：http://localhost:9001/brand/35 4.3.5 删除品牌 (1)业务层\n修改com.offcn.sellergoods.service.brandservice，添加删除品牌方法，代码如下：\n/*** * 删除品牌 * @param id */ void delete(long id); 修改com.offcn.sellergoods.service.impl.brandserviceimpl，新增删除品牌方法，代码如下：\n/** * 删除 * @param id */ @override public void delete(long id){ this.removebyid(id); } (2)控制层\nbrandcontroller新增方法\n/*** * 根据id删除品牌数据 * @param id * @return */ @deletemapping(value = \u0026#34;/{id}\u0026#34; ) public result delete(@pathvariable long id){ //调用brandservice实现根据主键删除 brandservice.delete(id); return new result(true,statuscode.ok,\u0026#34;删除成功\u0026#34;); } 测试：http://localhost:9001/brand/35 4.3.6 品牌列表条件查询 (1)业务层\n修改com.offcn.sellergoods.service.brandservice，增加根据条件搜索品牌方法，代码如下：\n/*** * 多条件搜索品牌方法 * @param brand * @return */ list\u0026lt;brand\u0026gt; findlist(brand brand); 修改com.offcn.sellergoods.service.impl.brandserviceimpl，添加根据多条件搜索品牌方法的实现，代码如下：\n/** * brand条件查询 * @param brand * @return */ @override public list\u0026lt;brand\u0026gt; findlist(brand brand){ //构建查询条件 querywrapper\u0026lt;brand\u0026gt; querywrapper = this.createquerywrapper(brand); //根据构建的条件查询数据 return this.list(querywrapper); } /** * brand构建查询对象 * @param brand * @return */ private querywrapper\u0026lt;brand\u0026gt; createquerywrapper(brand brand){ querywrapper\u0026lt;brand\u0026gt; querywrapper = new querywrapper\u0026lt;\u0026gt;(); if(brand!=null){ // if(brand.getid()!=null){ querywrapper.eq(\u0026#34;id\u0026#34;,brand.getid()); } // 品牌名称 if(!stringutils.isempty(brand.getname())){ querywrapper.like(\u0026#34;name\u0026#34;,brand.getname()); } // 品牌首字母 if(!stringutils.isempty(brand.getfirstchar())){ querywrapper.eq(\u0026#34;first_char\u0026#34;,brand.getfirstchar()); } // 品牌图像 if(!stringutils.isempty(brand.getimage())){ querywrapper.eq(\u0026#34;image\u0026#34;,brand.getimage()); } } return querywrapper; } (2) 控制层\nbrandcontroller新增方法\n/*** * 多条件搜索品牌数据 * @param brand * @return */ @postmapping(value = \u0026#34;/search\u0026#34; ) public result\u0026lt;list\u0026lt;brand\u0026gt;\u0026gt; findlist(@requestbody(required = false) brand brand){ list\u0026lt;brand\u0026gt; list = brandservice.findlist(brand); return new result\u0026lt;list\u0026lt;brand\u0026gt;\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,list); } 测试：http://localhost:9001/brand/search 4.3.7 品牌列表分页查询 (1)业务层\n修改com.offcn.sellergoods.service.brandservice添加分页方法，代码如下：\n/*** * 分页查询 * @param page * @param size * @return */ pageresult\u0026lt;brand\u0026gt; findpage(int page, int size); 修改com.offcn.sellergoods.service.impl.brandserviceimpl添加分页方法实现，代码如下：\n/** * brand分页查询 * @param page * @param size * @return */ @override public pageresult\u0026lt;brand\u0026gt; findpage(int page, int size){ //分页参数封装对象 page\u0026lt;brand\u0026gt; brandpage = new page\u0026lt;\u0026gt;(page, size); //发出分页查询 page\u0026lt;brand\u0026gt; ipage = this.page(brandpage); return new pageresult\u0026lt;brand\u0026gt;(ipage.gettotal(),ipage.getrecords()); } (2)控制层\nbrandcontroller新增方法\n/*** * brand分页搜索实现 * @param page:当前页 * @param size:每页显示多少条 * @return */ @getmapping(value = \u0026#34;/search/{page}/{size}\u0026#34; ) public result\u0026lt;pageresult\u0026lt;brand\u0026gt;\u0026gt; findpage(@pathvariable int page, @pathvariable int size){ //调用brandservice实现分页查询brand pageresult\u0026lt;brand\u0026gt; pageresult = brandservice.findpage(page, size); return new result\u0026lt;pageresult\u0026lt;brand\u0026gt;\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,pageresult); } (3)在com.offcn.sellergoods.config包下新增mybatisplus分页插件，pageconfig.java类\n注意：3.4.1版本及以上使用mybatisplusinterceptor进行配置\n@bean public mybatisplusinterceptor mybatisplusinterceptor(){ mybatisplusinterceptor interceptor = new mybatisplusinterceptor(); paginationinnerinterceptor paginationinnerinterceptor = new paginationinnerinterceptor(); paginationinnerinterceptor.setdbtype(dbtype.mysql); //设置请求的页面大于最大页后操作，true调回到首页，false继续请求 默认false paginationinnerinterceptor.setoverflow(true); //设置最大单页限制数量，默认 500 条， -1 不受限制 paginationinnerinterceptor.setmaxlimit(500l); interceptor.addinnerinterceptor(paginationinnerinterceptor); return interceptor; } 测试：http://localhost:9001/brand/search/1/3 4.3.8 品牌列表条件+分页查询 (1)业务层\n修改com.offcn.sellergoods.service.brandservice，增加多条件分页查询方法，代码如下：\n/*** * 多条件分页查询 * @param brand * @param page * @param size * @return */ pageresult\u0026lt;brand\u0026gt; findpage(brand brand, int page, int size); 修改com.offcn.sellergoods.service.impl.brandserviceimpl，添加多条件分页查询方法代码如下：\n/** * brand条件+分页查询 * @param brand 查询条件 * @param page 页码 * @param size 页大小 * @return 分页结果 */ @override public pageresult\u0026lt;brand\u0026gt; findpage(brand brand, int page, int size){ page\u0026lt;brand\u0026gt; mypage = new page\u0026lt;\u0026gt;(page, size); querywrapper\u0026lt;brand\u0026gt; querywrapper = this.createquerywrapper(brand); ipage\u0026lt;brand\u0026gt; ipage = this.page(mypage, querywrapper); return new pageresult\u0026lt;brand\u0026gt;(ipage.gettotal(),ipage.getrecords()); } (2)控制层\nbrandcontroller新增方法\n/*** * 分页搜索实现 * @param brand * @param page * @param size * @return */ @postmapping(value = \u0026#34;/search/{page}/{size}\u0026#34; ) public result\u0026lt;pageresult\u0026gt; findpage(@requestbody(required = false) brand brand, @pathvariable int page, @pathvariable int size){ //执行搜索 pageresult\u0026lt;brand\u0026gt; pageresult = brandservice.findpage(brand, page, size); return new result(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,pageresult); } 测试：http://localhost:9001/brand/search/1/3 五、fastdfs分布式文件服务器 5.1 fastdfs简介 5.1.1 fastdfs体系结构 fastdfs是用 c 语言编写的一款开源的分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。\nfastdfs为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用fastdfs很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。\nfastdfs 架构包括 tracker server 和 storage server。客户端请求 tracker server 进行文件上传、下载，通过tracker server 调度最终由 storage server 完成文件上传和下载。\ntracker server 作用是负载均衡和调度，通过 tracker server 在文件上传时可以根据一些策略找到 storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。\nstorage server 作用是文件存储，客户端上传的文件最终存储在 storage 服务器上，storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。\n5.1.2 上传流程 客户端上传文件后存储服务器将文件 id 返回给客户端，此文件 id 用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。\n组名：文件上传后所在的 storage 组名称，在文件上传成功后有storage 服务器返回，需要客户端自行保存。\n虚拟磁盘路径：storage 配置的虚拟路径，与磁盘选项store_path*对应。如果配置了\nstore_path0 则是 m00，如果配置了 store_path1 则是 m01，以此类推。\n数据两级目录：storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据\n文件。\n文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储\n服务器 ip 地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。\n5.1.3 文件下载流程 5.2 fastdfs搭建 5.2.1 安装fastdfs镜像 我们使用docker搭建fastdfs的开发环境，虚拟机中已经下载了fastdfs的镜像，可以通过docker images查看，如下图： 拉取镜像(已经下载了该镜像，大家无需下载了)\ndocker pull morunchang/fastdfs 运行tracker\ndocker run -d --name tracker --net=host morunchang/fastdfs sh tracker.sh 运行storage\ndocker run -d --name storage --net=host -e tracker_ip=192.168.100.20:22122 -e group_name=group1 morunchang/fastdfs sh storage.sh 使用的网络模式是–net=host, 192.168.188.128是宿主机的ip group1是组名，即storage的组 如果想要增加新的storage服务器，再次运行该命令，注意更换 新组名 5.2.2 配置nginx nginx在这里主要提供对fastdfs图片访问的支持，docker容器中已经集成了nginx，我们需要修改nginx的配置,进入storage的容器内部，修改nginx.conf\ndocker exec -it storage /bin/bash 进入后\nvi /etc/nginx/conf/nginx.conf 添加以下内容\nlocation ~ /m00 { root /data/fast_data/data; ngx_fastdfs_module; } 设置禁止浏览器缓存：\nadd_header cache-control no-store; 退出容器\nexit 重启storage容器\ndocker restart storage 查看启动容器docker ps -a 开启启动设置，docker启动时\ndocker update --restart=always tracker docker update --restart=always storage 5.3 文件存储微服务 创建文件管理微服务dongyimai-file-service，该工程主要用于实现文件上传以及文件删除等功能。\n5.3.1 pom.xml依赖 修改pom.xml，引入依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-file-service\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;cn.bestwu\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fastdfs-client-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.27\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-common\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 5.3.2 fastdfs配置 在resources文件夹下创建fasfdfs的配置文件fdfs_client.conf\n#tracker服务器ip地址和端口号 tracker_server=192.168.188.128:22122 # 连接超时时间，针对socket套接字函数connect，默认为30秒 #connect_timeout=3000 # 网络通讯超时时间，默认是60秒 #network_timeout=60000 tracker_server： tracker服务器ip和端口设置\n5.3.3 创建测试类teststorageclient 代码如下：\npackage com.offcn; import org.csource.common.myexception; import org.csource.fastdfs.*; import java.io.ioexception; public class testfastdfs { public static void main(string[] args) throws ioexception, myexception { // 1、加载配置文件，配置文件中的内容就是 tracker 服务的地址。 clientglobal.init(\u0026#34;c:\\\\idea_workspace_offcn\\\\2021shadow\\\\github\\\\dongyimai-parent\\\\dongyimai-service\\\\dongyimai-file-service\\\\src\\\\main\\\\resources\\\\fdfs_client.conf\u0026#34;); // 2、创建一个 trackerclient 对象。直接 new 一个。 trackerclient trackerclient = new trackerclient(); // 3、使用 trackerclient 对象创建连接，获得一个 trackerserver 对象。 trackerserver trackerserver = trackerclient.getconnection(); // 4、创建一个 storageserver 的引用，值为 null storageserver storageserver = null; // 5、创建一个 storageclient 对象，需要两个参数 trackerserver 对象、storageserver 的引用 storageclient storageclient = new storageclient(trackerserver, storageserver); // 6、使用 storageclient 对象上传图片。 //扩展名不带“.” string[] strings = storageclient.upload_file(\u0026#34;c:/1.jpg\u0026#34;, \u0026#34;jpg\u0026#34;, null); // 7、返回数组。包含组名和图片的路径。 for (string string : strings) { system.out.println(string); } } } 注意：如果出现连接图片服务器超时失败的情况，请检查图片linux服务器是否启动、是否开启了端口22122、23000以及8080的防火墙端口，如果未开启需要开启。\nfirewall-cmd --add-port=22122/tcp --permanent firewall-cmd --add-port=23000/tcp --permanent firewall-cmd --add-port=8080/tcp --permanent firewall-cmd --reload //停止防火墙 systemctl stop firewalld //禁止开机启动防火墙 systemctl disable firewalld 控制台输出如下结果： 在浏览器输入：\nhttp://192.168.188.156:8080/group1/m00/00/00/wki8nga1w0car9lxaafehlrw1wg805.jpg\n即可看到所上传的图片。 5.3.4 application.yml配置 在resources文件夹下创建application.yml\nspring: servlet: multipart: max-file-size: 5mb max-request-size: 10mb application: name: file server: port: 9002 eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true file_server_url: http://192.168.188.128:8080/ max-file-size是单个文件大小，max-request-size是设置总上传的数据大小\n5.3.5 启动类 创建启动类fileapplication\n@springbootapplication @enableeurekaclient public class fileapplication { public static void main(string[] args) { springapplication.run(fileapplication.class); } } 这里禁止了datasource的加载创建。\n5.3.6 文件上传 5.3.6.1 添加工具类 将“资源/fastdfs/工具类”的fastdfsclient.java 拷贝到com.offcn.util 5.3.6.2 控制层 在com.offcn.controller中创建uploadcontroller.java\npackage com.offcn.controller; import com.offcn.entity.result; import com.offcn.entity.statuscode; import com.offcn.util.fastdfsclient; import org.springframework.beans.factory.annotation.value; import org.springframework.web.bind.annotation.postmapping; import org.springframework.web.bind.annotation.requestparam; import org.springframework.web.bind.annotation.restcontroller; import org.springframework.web.multipart.multipartfile; @restcontroller public class uploadcontroller { @value(\u0026#34;${file_server_url}\u0026#34;) private string file_server_url;//文件服务器地址 @postmapping(\u0026#34;/upload\u0026#34;) public result upload(@requestparam(name = \u0026#34;file\u0026#34;) multipartfile file) { //1、取文件的扩展名 string originalfilename = file.getoriginalfilename(); string extname = originalfilename.substring(originalfilename.lastindexof(\u0026#34;.\u0026#34;) + 1); try { //2、创建一个 fastdfs 的客户端 fastdfsclient fastdfsclient = new fastdfsclient(\u0026#34;classpath:fdfs_client.conf\u0026#34;); //3、执行上传处理 string path = fastdfsclient.uploadfile(file.getbytes(), extname); //4、拼接返回的 url 和 ip 地址，拼装成完整的 url string url = file_server_url + path; return new result(true, statuscode.ok, url); } catch (exception e) { e.printstacktrace(); return new result(false, statuscode.error, \u0026#34;上传失败\u0026#34;); } } } 5.3.6.3 postman测试文件上传 步骤：\n1、选择post请求方式，输入请求地址 http://localhost:9002/upload\n2、填写body\n选择form-data 然后选择文件file 点击添加文件，最后发送即可。 3、访问http://192.168.188.156:8080//group1/m00/00/00/wki8nga17kaaugxxaabgnqpthtk851.jpg\n注意，这里每次访问的端口是8080端口，访问的端口其实是storage容器的nginx端口，如果想修改该端口可以直接进入到storage容器，然后修改即可。\ndocker exec -it storage /bin/bash vi /etc/nginx/conf/nginx.conf 修改后重启storage即可根据自己修改的端口访问图片了。\n","date":"2022-05-27","permalink":"https://lovemjh.vercel.app/posts/project-0/20220527220542/","summary":"第三章 东易买后端微服务框架搭建 优就业.JAVA教研室 学习目标 目标1：了解电商 目标2：了解东易买架构 目标3：了解东易买工程结构 目标4：掌握东易买工程搭建 目标5：掌","title":"东易买后端微服务框架搭建"},{"content":"第七章 商品搜索 优就业.java教研室 学习目标 条件筛选 多条件搜索[品牌、规格条件搜索] 规格过滤 价格区间搜索 搜索分页 搜索排序 搜索高亮 1. 品牌统计 用户搜索的时候，除了使用分类搜索外，还有可能使用品牌搜索，所以我们还需要显示品牌数据和规格数据，品牌数据和规格数据的显示比较容易，都可以考虑使用分类统计的方式进行分组实现。\n1.1 品牌统计分析 看下面的sql语句，我们在执行搜索的时候，第1条sql语句是执行搜，第2条语句是根据品牌名字分组查看有多少品牌，大概执行了2个步骤就可以获取数据结果以及品牌统计，我们可以发现他们的搜索条件完全一样。\n-- 查询所有 select * from tb_item where title like \u0026#39;%手机%\u0026#39;; -- 根据品牌名字分组查询 select brand from tb_item where title like \u0026#39;%手机%\u0026#39; group by brand; 我们每次执行搜索的时候，需要显示商品品牌名称，这里要显示的品牌名称其实就是符合搜素条件的所有商品的品牌集合，我们可以按照上面的实现思路，使用es根据分组名称做一次分组查询即可实现。\n1.2 品牌分组统计实现 修改search微服务的com.offcn.search.service.impl.skuserviceimpl类，添加一个品牌分组搜索,如图: 添加的代码如下:\n//设置分组条件 商品品牌 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skubrandgroup\u0026#34;).field(\u0026#34;brand.keyword\u0026#34;).size(50)); 执行获取分组结果: 整体代码如下：\npublic map search(map\u0026lt;string, string\u0026gt; searchmap) { //1.获取关键字的值 string keywords = searchmap.get(\u0026#34;keywords\u0026#34;); if (stringutils.isempty(keywords)) { keywords = \u0026#34;华为\u0026#34;;//赋值给一个默认的值 } //2.创建查询对象 的构建对象 nativesearchquerybuilder nativesearchquerybuilder = new nativesearchquerybuilder(); //3.设置查询的条件 //设置分组条件 商品分类 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skucategorygroup\u0026#34;).field(\u0026#34;category.keyword\u0026#34;).size(50)); //设置分组条件 商品品牌 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skubrandgroup\u0026#34;).field(\u0026#34;brand.keyword\u0026#34;).size(50)); nativesearchquerybuilder.withquery(querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords)); //4.构建查询对象 nativesearchquery query = nativesearchquerybuilder.build(); //5.执行查询 aggregatedpage\u0026lt;skuinfo\u0026gt; skupage = estemplate.queryforpage(query, skuinfo.class); //获取分组结果 商品分类 terms termscategory = skupage.getaggregation(\u0026#34;skucategorygroup\u0026#34;); //获取分组结果 商品品牌 terms termsbrand = skupage.getaggregation(\u0026#34;skubrandgroup\u0026#34;); list\u0026lt;string\u0026gt; categorylist = getstringscategorylist(stringtermscategory); list\u0026lt;string\u0026gt; brandlist = getstringsbrandlist(stringtermsbrand); //6.返回结果 map resultmap = new hashmap\u0026lt;\u0026gt;(); resultmap.put(\u0026#34;categorylist\u0026#34;, categorylist); resultmap.put(\u0026#34;brandlist\u0026#34;, brandlist); resultmap.put(\u0026#34;rows\u0026#34;, skupage.getcontent()); resultmap.put(\u0026#34;total\u0026#34;, skupage.gettotalelements()); resultmap.put(\u0026#34;totalpages\u0026#34;, skupage.gettotalpages()); return resultmap; } /** * 获取品牌列表 * * @param terms * @return */ private list\u0026lt;string\u0026gt; getstringbrandlist(terms terms){ //创建一个集合存放全部的品牌分组结果 list\u0026lt;string\u0026gt; brandlist=new arraylist\u0026lt;\u0026gt;(); if(terms!=null){ for (terms.bucket bucket : terms.getbuckets()) { string keyasstring = bucket.getkeyasstring(); brandlist.add(keyasstring); } } return brandlist; } /** * 获取分类列表数据 * * @param stringterms * @return */ private list\u0026lt;string\u0026gt; getstringcategorlist(terms terms){ //创建一个集合存放全部的分组结果 list\u0026lt;string\u0026gt; categorylist=new arraylist\u0026lt;\u0026gt;(); //遍历分组结果 if(terms!=null){ for (terms.bucket bucket : terms.getbuckets()) { //获取分组的值 string keyasstring = bucket.getkeyasstring(); //把分组的值加入到集合 categorylist.add(keyasstring); } } return categorylist; } 1.3 测试 使用postman请求http://localhost:9004/search 2. 规格统计 用户搜索的时候，除了使用分类、品牌搜索外，还有可能使用规格搜索，所以我们还需要显示规格数据，规格数据的显示相比上面2种实现略微较难一些，需要对数据进行处理，我们也可以考虑使用分类统计和品牌统计的方式进行分组实现。\n2.1 规格统计分析 看下面的sql语句，我们在执行搜索的时候，第1条sql语句是执行搜，第2条语句是根据规格分组查看有多少规格，大概执行了2个步骤就可以获取数据结果以及规格统计，我们可以发现他们的搜索条件完全一样。\n-- 查询所有 select * from tb_item where name like \u0026#39;%手机%\u0026#39;; -- 根据规格名字分组查询 select spec from tb_item where title like \u0026#39;%手机%\u0026#39; group by spec; 上述sql语句执行后的结果如下图： 获取到的规格数据我们发现有重复，不过也可以解决，解决思路如下：\n1.获取所有规格数据 2.将所有规格数据转换成map 3.定义一个map\u0026lt;string,set\u0026gt;,key是规格名字，防止重复所以用map，valu是规格值，规格值有多个，所以用集合，为了防止规格重复，用set去除重复 4.循环规格的map，将数据填充到定义的map\u0026lt;string,set\u0026gt;中 我们每次执行搜索的时候，需要显示商品规格数据，这里要显示的规格数据其实就是符合搜素条件的所有商品的规格集合，我们可以按照上面的实现思路，使用es根据分组名称做一次分组查询，并去除重复数据即可实现。\n2.2 规格统计分组实现 修改search微服务的com.offcn.search.service.impl.skuserviceimpl类，添加一个规格分组搜索\n如图:添加规格分组条件 上图代码如下:\n//设置分组条件 商品的规格 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skuspecgroup\u0026#34;).field(\u0026#34;spec.keyword\u0026#34;).size(100)); 如图:获取规格分组结果: 封装调用分组结果的方法，代码如下:\n/** * 获取规格列表数据 * * @param stringtermsspec * @return */ //获取规格列表数据 public map\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt; getstringspecmap(terms terms){ //创建一个返回的map map\u0026lt;string,set\u0026lt;string\u0026gt;\u0026gt; specmap=new hashmap\u0026lt;\u0026gt;(); //创建一个set存储规格选项 set\u0026lt;string\u0026gt; specset=new hashset\u0026lt;\u0026gt;(); //判断查询结果不为空 if (terms != null) { for (terms.bucket bucket : terms.getbuckets()) { //把查询到规格名称加入到set自动去重 specset.add(bucket.getkeyasstring()); } } //遍历set for (string specjson : specset) { //解析转换规格的json字符串为map集合 map\u0026lt;string,string\u0026gt; map = json.parseobject(specjson, map.class); //遍历map for (map.entry\u0026lt;string, string\u0026gt; entry : map.entryset()) { //提取规格名称 string key = entry.getkey(); string value = entry.getvalue(); //根据规格名称提取对应的规格选项数据 set\u0026lt;string\u0026gt; specvalues=specmap.get(key); //判断规格选项数据是否为空 if(specvalues==null){ specvalues=new hashset\u0026lt;\u0026gt;(); } //把当前规格选项加入到规格选项数据集合 specvalues.add(value); //把当前的数据加入到返回map specmap.put(key,specvalues); } } return specmap; } 整体代码如下:\npublic map search(map\u0026lt;string, string\u0026gt; searchmap) { //1.获取关键字的值 string keywords = searchmap.get(\u0026#34;keywords\u0026#34;); if (stringutils.isempty(keywords)) { keywords = \u0026#34;华为\u0026#34;;//赋值给一个默认的值 } //2.创建查询对象 的构建对象 nativesearchquerybuilder nativesearchquerybuilder = new nativesearchquerybuilder(); //3.设置查询的条件 //设置分组条件 商品分类 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skucategorygroup\u0026#34;).field(\u0026#34;category.keyword\u0026#34;).size(50)); //设置分组条件 商品品牌 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skubrandgroup\u0026#34;).field(\u0026#34;brand.keyword\u0026#34;).size(50)); //设置分组条件 商品的规格 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skuspecgroup\u0026#34;).field(\u0026#34;spec.keyword\u0026#34;).size(100)); nativesearchquerybuilder.withquery(querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords)); //4.构建查询对象 nativesearchquery query = nativesearchquerybuilder.build(); //5.执行查询 aggregatedpage\u0026lt;skuinfo\u0026gt; skupage = estemplate.queryforpage(query, skuinfo.class); //获取分组结果 商品分类 stringterms stringtermscategory = (stringterms) skupage.getaggregation(\u0026#34;skucategorygroup\u0026#34;); //获取分组结果 商品品牌 stringterms stringtermsbrand = (stringterms) skupage.getaggregation(\u0026#34;skubrandgroup\u0026#34;); //获取分组结果 商品规格数据 stringterms stringtermsspec = (stringterms) skupage.getaggregation(\u0026#34;skuspecgroup\u0026#34;); list\u0026lt;string\u0026gt; categorylist = getstringscategorylist(stringtermscategory); list\u0026lt;string\u0026gt; brandlist = getstringsbrandlist(stringtermsbrand); map\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt; specmap = getstringsetmap(stringtermsspec); //6.返回结果 map resultmap = new hashmap\u0026lt;\u0026gt;(); resultmap.put(\u0026#34;specmap\u0026#34;, specmap); resultmap.put(\u0026#34;categorylist\u0026#34;, categorylist); resultmap.put(\u0026#34;brandlist\u0026#34;, brandlist); resultmap.put(\u0026#34;rows\u0026#34;, skupage.getcontent()); resultmap.put(\u0026#34;total\u0026#34;, skupage.gettotalelements()); resultmap.put(\u0026#34;totalpages\u0026#34;, skupage.gettotalpages()); return resultmap; } /** * 获取品牌列表 * * @param stringtermsbrand * @return */ private list\u0026lt;string\u0026gt; getstringsbrandlist(stringterms stringtermsbrand) { list\u0026lt;string\u0026gt; brandlist = new arraylist\u0026lt;\u0026gt;(); if (stringtermsbrand != null) { for (stringterms.bucket bucket : stringtermsbrand.getbuckets()) { brandlist.add(bucket.getkeyasstring()); } } return brandlist; } /** * 获取分类列表数据 * * @param stringterms * @return */ private list\u0026lt;string\u0026gt; getstringscategorylist(stringterms stringterms) { list\u0026lt;string\u0026gt; categorylist = new arraylist\u0026lt;\u0026gt;(); if (stringterms != null) { for (stringterms.bucket bucket : stringterms.getbuckets()) { string keyasstring = bucket.getkeyasstring();//分组的值 categorylist.add(keyasstring); } } return categorylist; } /** * 获取规格列表数据 * * @param stringtermsspec * @return */ private map\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt; getstringsetmap(stringterms stringtermsspec) { map\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt; specmap = new hashmap\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt;(); set\u0026lt;string\u0026gt; speclist = new hashset\u0026lt;\u0026gt;(); if (stringtermsspec != null) { for (stringterms.bucket bucket : stringtermsspec.getbuckets()) { speclist.add(bucket.getkeyasstring()); } } for (string specjson : speclist) { map\u0026lt;string, string\u0026gt; map = json.parseobject(specjson, map.class); for (map.entry\u0026lt;string, string\u0026gt; entry : map.entryset()) {// string key = entry.getkey(); //规格名字 string value = entry.getvalue(); //规格选项值 //获取当前规格名字对应的规格数据 set\u0026lt;string\u0026gt; specvalues = specmap.get(key); if (specvalues == null) { specvalues = new hashset\u0026lt;string\u0026gt;(); } //将当前规格加入到集合中 specvalues.add(value); //将数据存入到specmap中 specmap.put(key, specvalues); } } return specmap; } 2.3 测试 使用postman测试访问http://localhost:9004/search 效果如下： 3 条件筛选 用户有可能会根据分类搜索、品牌搜索，还有可能根据规格搜索，以及价格搜索和排序操作。根据分类和品牌搜索的时候，可以直接根据指定域搜索，而规格搜索的域数据是不确定的，价格是一个区间搜索，所以我们可以分为三段时间，先实现分类、品牌搜素，再实现规格搜索，然后实现价格区间搜索。\n3.1 分类、品牌筛选 3.1.1 需求分析 页面每次向后台传入对应的分类和品牌，后台据分类和品牌进行条件过滤即可。\n3.1.2 代码实现 修改搜索微服务com.offcn.search.service.impl.skuserviceimpl的search方法，添加分类和品牌过滤,\n添加过滤条件如下: ps说明: 以上,我们建议使用filter ,它的搜索效率要优于must.可以参考官方文档说明:\nhttps://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html\n上图整体代码如下：\n@override public map search(map\u0026lt;string, string\u0026gt; searchmap) { //1.获取关键字的值 string keywords = searchmap.get(\u0026#34;keywords\u0026#34;); if (stringutils.isempty(keywords)) { keywords = \u0026#34;华为\u0026#34;;//赋值给一个默认的值 } //2.创建查询对象 的构建对象 nativesearchquerybuilder nativesearchquerybuilder = new nativesearchquerybuilder(); //3.设置查询的条件 //设置分组条件 商品分类 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skucategorygroup\u0026#34;).field(\u0026#34;category.keyword\u0026#34;).size(50)); //设置分组条件 商品品牌 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skubrandgroup\u0026#34;).field(\u0026#34;brand.keyword\u0026#34;).size(50)); //设置分组条件 商品的规格 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skuspecgroup\u0026#34;).field(\u0026#34;spec.keyword\u0026#34;).size(1000)); //设置主关键字查询 nativesearchquerybuilder.withquery(querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords)); boolquerybuilder boolquerybuilder = querybuilders.boolquery(); if (!stringutils.isempty(searchmap.get(\u0026#34;brand\u0026#34;))) { boolquerybuilder.filter(querybuilders.termquery(\u0026#34;brand.keyword\u0026#34;, searchmap.get(\u0026#34;brand\u0026#34;))); } if (!stringutils.isempty(searchmap.get(\u0026#34;category\u0026#34;))) { boolquerybuilder.filter(querybuilders.termquery(\u0026#34;category.keyword\u0026#34;, searchmap.get(\u0026#34;category\u0026#34;))); } //构建过滤查询 nativesearchquerybuilder.withfilter(boolquerybuilder); //4.构建查询对象 nativesearchquery query = nativesearchquerybuilder.build(); //5.执行查询 aggregatedpage\u0026lt;skuinfo\u0026gt; skupage = estemplate.queryforpage(query, skuinfo.class); //获取分组结果 商品分类 stringterms stringtermscategory = (stringterms) skupage.getaggregation(\u0026#34;skucategorygroup\u0026#34;); //获取分组结果 商品品牌 stringterms stringtermsbrand = (stringterms) skupage.getaggregation(\u0026#34;skubrandgroup\u0026#34;); //获取分组结果 商品规格数据 stringterms stringtermsspec = (stringterms) skupage.getaggregation(\u0026#34;skuspecgroup\u0026#34;); list\u0026lt;string\u0026gt; categorylist = getstringscategorylist(stringtermscategory); list\u0026lt;string\u0026gt; brandlist = getstringsbrandlist(stringtermsbrand); map\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt; specmap = getstringsetmap(stringtermsspec); //6.返回结果 map resultmap = new hashmap\u0026lt;\u0026gt;(); resultmap.put(\u0026#34;specmap\u0026#34;, specmap); resultmap.put(\u0026#34;categorylist\u0026#34;, categorylist); resultmap.put(\u0026#34;brandlist\u0026#34;, brandlist); resultmap.put(\u0026#34;rows\u0026#34;, skupage.getcontent()); resultmap.put(\u0026#34;total\u0026#34;, skupage.gettotalelements()); resultmap.put(\u0026#34;totalpages\u0026#34;, skupage.gettotalpages()); return resultmap; } 3.1.3 测试 测试效果如下：\n访问地址：http://localhost:9004/search\n{\u0026#34;keywords\u0026#34;:\u0026#34;黑色\u0026#34;,\u0026#34;category\u0026#34;:\u0026#34;手机\u0026#34;,\u0026#34;brand\u0026#34;:\u0026#34;三星\u0026#34;} 此时只能搜到tcl手机\n3.2 规格过滤 3.2.1 需求分析 格这一块，需要向后台发送规格名字以及规格值，我们可以按照一定要求来发送数据，例如规格名字以特殊前缀提交到后台：spec_网络制式：电信4g、spec_显示屏尺寸：4.0-4.9英寸\n后台接到数据后，可以根据前缀spec_来区分是否是规格，如果以spec_xxx开始的数据则为规格数据，需要根据指定规格找信息。 上图是规格的索引存储格式，真实数据在spechmap.规格名字.keyword中，所以找数据也是按照如下格式去找：\nspechmap.规格名字.keyword\n使用命令可以查看存储格式：\nget /skuinfo/_mapping 3.2.2 代码实现 修改com.offcn.search.service.impl.skuserviceimpl的search方法，增加规格查询操作，代码如下：\n//规格过滤查询 if (searchmap != null) { for (string key : searchmap.keyset()) { if (key.startswith(\u0026#34;spec_\u0026#34;)) { boolquerybuilder.filter(querybuilders.termquery(\u0026#34;specmap.\u0026#34; + key.substring(5) + \u0026#34;.keyword\u0026#34;, searchmap.get(key))); } } } 3.2.3 测试 访问地址：http://localhost:9004/search\n{\u0026#34;keywords\u0026#34;:\u0026#34;黑色\u0026#34;,\u0026#34;spec_网络\u0026#34;:\u0026#34;双卡\u0026#34;,\u0026#34;spec_机身内存\u0026#34;:\u0026#34;32g\u0026#34;} 3.3 价格区间查询 3.3.1 需求分析 价格区间查询，每次需要将价格传入到后台，前端传入后台的价格大概是price=0-500或者price=500-1000依次类推，最后一个是price=3000,后台可以根据-分割，如果分割得到的结果最多有2个，第1个表示x\u0026lt;price，第2个表示price\u0026lt;=y。\n3.3.2 代码实现 修改com.offcn.search.service.impl.skuserviceimpl的search方法，增加价格区间查询操作，代码如下：\n//价格过滤查询 string price = searchmap.get(\u0026#34;price\u0026#34;); if (!stringutils.isempty(price)) { string[] split = price.split(\u0026#34;-\u0026#34;); if (!split[1].equalsignorecase(\u0026#34;*\u0026#34;)) { boolquerybuilder.filter(querybuilders.rangequery(\u0026#34;price\u0026#34;).from(split[0], true).to(split[1], true)); } else { boolquerybuilder.filter(querybuilders.rangequery(\u0026#34;price\u0026#34;).gte(split[0])); } } 3.3.3 测试 访问地址：http://localhost:9004/search\n{\u0026#34;keywords\u0026#34;:\u0026#34;黑色\u0026#34;,\u0026#34;price\u0026#34;:\u0026#34;1-500\u0026#34;} 效果如下(部分数据)：\n{ \u0026#34;total\u0026#34;: 1, \u0026#34;categorylist\u0026#34;: [ \u0026#34;手机\u0026#34; ], \u0026#34;totalpages\u0026#34;: 1, \u0026#34;specmap\u0026#34;: { \u0026#34;网络\u0026#34;: [ \u0026#34;电信3g\u0026#34;, \u0026#34;移动3g\u0026#34;, \u0026#34;联通3g\u0026#34;, \u0026#34;联通2g\u0026#34;, \u0026#34;移动4g\u0026#34;, \u0026#34;联通4g\u0026#34;, \u0026#34;移动2g\u0026#34;, \u0026#34;电信4g\u0026#34;, \u0026#34;双卡\u0026#34; ], \u0026#34;机身内存\u0026#34;: [ \u0026#34;16g\u0026#34;, \u0026#34;128g\u0026#34;, \u0026#34;32g\u0026#34;, \u0026#34;64g\u0026#34; ] }, \u0026#34;brandlist\u0026#34;: [ \u0026#34;三星\u0026#34;, \u0026#34;苹果\u0026#34;, \u0026#34;中国移动\u0026#34;, \u0026#34;联想\u0026#34;, \u0026#34;华为\u0026#34;, \u0026#34;酷派\u0026#34;, \u0026#34;诺基亚\u0026#34;, \u0026#34;飞利浦\u0026#34;, \u0026#34;oppo\u0026#34;, \u0026#34;htc\u0026#34;, \u0026#34;tcl\u0026#34;, \u0026#34;中兴\u0026#34;, \u0026#34;索尼\u0026#34;, \u0026#34;金立\u0026#34;, \u0026#34;小米\u0026#34;, \u0026#34;朵唯\u0026#34;, \u0026#34;百加\u0026#34;, \u0026#34;海信\u0026#34;, \u0026#34;微软\u0026#34;, \u0026#34;阿尔卡特\u0026#34;, \u0026#34;魅族\u0026#34;, \u0026#34;派信\u0026#34; ], \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: 1260714, \u0026#34;title\u0026#34;: \u0026#34;tcl (s850l) 16gb 耀目红 电信4g手机\u0026#34;, \u0026#34;price\u0026#34;: 759.00, \u0026#34;num\u0026#34;: 99999, \u0026#34;image\u0026#34;: \u0026#34;http://img11.360buyimg.com/n1/s450x450_jfs/t2278/328/1482029120/347965/7755349f/565e97aan5710a07d.jpg\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;createtime\u0026#34;: \u0026#34;2015-03-08t13:30:44.000+0000\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2015-03-08t13:30:44.000+0000\u0026#34;, \u0026#34;isdefault\u0026#34;: null, \u0026#34;goodsid\u0026#34;: 1, \u0026#34;categoryid\u0026#34;: 560, \u0026#34;category\u0026#34;: \u0026#34;手机\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;tcl\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\\\u0026#34;机身内存\\\u0026#34;:\\\u0026#34;16g\\\u0026#34;,\\\u0026#34;网络\\\u0026#34;:\\\u0026#34;电信4g\\\u0026#34;}\u0026#34;, \u0026#34;specmap\u0026#34;: { \u0026#34;网络\u0026#34;: \u0026#34;电信4g\u0026#34;, \u0026#34;机身内存\u0026#34;: \u0026#34;16g\u0026#34; } } ] } 4 搜索分页 4.1 分页分析 页面需要实现分页搜索，所以我们后台每次查询的时候，需要实现分页。用户页面每次会传入当前页和每页查询多少条数据，当然如果不传入每页显示多少条数据，默认查询30条即可。\n4.2 分页实现 分页使用pagerequest.of( pageno- 1, pagesize);实现，第1个参数表示第n页，从0开始，第2个参数表示每页显示多少条，实现代码如下：\n上图代码如下：\n//略 //构建过滤查询 nativesearchquerybuilder.withfilter(boolquerybuilder); //构建分页查询 integer pagenum = 1; if (!stringutils.isempty(searchmap.get(\u0026#34;pagenum\u0026#34;))) { try { pagenum = integer.valueof(searchmap.get(\u0026#34;pagenum\u0026#34;)); } catch (numberformatexception e) { e.printstacktrace(); pagenum=1; } } integer pagesize = 30; //设置分页条件 nativesearchquerybuilder.withpageable(pagerequest.of(pagenum - 1, pagesize)); //略 //4.构建查询对象 nativesearchquery query = nativesearchquerybuilder.build(); //略 测试如下: 5 搜索排序 5.1 排序分析 排序这里总共有根据价格排序、根据评价排序、根据新品排序、根据销量排序，排序要想实现非常简单，只需要告知排序的域以及排序方式即可实现。\n价格排序：只需要根据价格高低排序即可，降序价格高-\u0026gt;低，升序价格低-\u0026gt;高\n评价排序：评价分为好评、中评、差评，可以在数据库中设计3个列，用来记录好评、中评、差评的量，每次排序的时候，好评的比例来排序，当然还要有条数限制，评价条数需要超过n条。\n新品排序：直接根据商品的发布时间或者更新时间排序。\n销量排序：销量排序除了销售数量外，还应该要有时间段限制。\n5.2 排序实现 这里我们不单独针对某个功能实现排序，我们只需要在后台接收2个参数，分别是排序域名字和排序方式，代码如下： 解释: 前端页面传递要排序的字段(field)和要排序的类型(asc,desc),后台接收.\n上图代码如下：\n//构建排序查询 string sortrule = searchmap.get(\u0026#34;sortrule\u0026#34;); string sortfield = searchmap.get(\u0026#34;sortfield\u0026#34;); if (!stringutils.isempty(sortrule) \u0026amp;\u0026amp; !stringutils.isempty(sortfield)) { nativesearchquerybuilder.withsort(sortbuilders.fieldsort(sortfield).order(sortrule.equals(\u0026#34;desc\u0026#34;) ? sortorder.desc : sortorder.asc)); } 测试\n根据价格降序：\n{\u0026#34;keywords\u0026#34;:\u0026#34;手机\u0026#34;,\u0026#34;pagenum\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;sortrule\u0026#34;:\u0026#34;desc\u0026#34;,\u0026#34;sortfield\u0026#34;:\u0026#34;price\u0026#34;} 根据价格升序：\n{\u0026#34;keywords\u0026#34;:\u0026#34;手机\u0026#34;,\u0026#34;pagenum\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;sortrule\u0026#34;:\u0026#34;asc\u0026#34;,\u0026#34;sortfield\u0026#34;:\u0026#34;price\u0026#34;} 6 高亮显示 6.1 高亮分析 高亮显示是指根据商品关键字搜索商品的时候，显示的页面对关键字给定了特殊样式，让它显示更加突出，如上图商品搜索中，关键字变成了红色，其实就是给定了红色样式。 6.2 高亮搜索实现步骤解析 将之前的搜索换掉，换成高亮搜索，我们需要做3个步骤：\n1.指定高亮域，也就是设置哪个域需要高亮显示 设置高亮域的时候，需要指定前缀和后缀，也就是关键词用什么html标签包裹，再给该标签样式 2.高亮搜索实现 3.将非高亮数据替换成高亮数据 第1点，例如在百度中搜索数据的时候，会有2个地方高亮显示，分别是标题和描述，商城搜索的时候，只是商品名称高亮显示了。而高亮显示其实就是添加了样式，例如\u0026lt;span style=\u0026quot;color:red;\u0026quot;\u0026gt;笔记本\u0026lt;/span\u0026gt;,而其中span开始标签可以称为前缀，span结束标签可以称为后缀。\n第2点，高亮搜索使用elasticsearchtemplate实现。\n第3点，高亮搜索后，会搜出非高亮数据和高亮数据，高亮数据会加上第1点中的高亮样式，此时我们需要将非高亮数据换成高亮数据即可。例如非高亮:华为笔记本性能超强悍 高亮数据：华为\u0026lt;span style=\u0026quot;color:red;\u0026quot;笔记本\u0026lt;/span\u0026gt;性能超强悍,将非高亮的换成高亮的，到页面就能显示样式了。\n6.3 高亮代码实现 修改com.offcn.search.service.impl.skuserviceimpl的search方法搜索代码，添加高亮显示的域: 上图代码如下：\n//设置高亮条件 nativesearchquerybuilder.withhighlightfields(new highlightbuilder.field(\u0026#34;title\u0026#34;)); nativesearchquerybuilder.withhighlightbuilder(new highlightbuilder().pretags(\u0026#34;\u0026lt;em style=\\\u0026#34;color:red\\\u0026#34;\u0026gt;\u0026#34;).posttags(\u0026#34;\u0026lt;/em\u0026gt;\u0026#34;)); //设置主关键字查询,修改为多字段的搜索条件 nativesearchquerybuilder.withquery(querybuilders.multimatchquery(keywords,\u0026#34;title\u0026#34;,\u0026#34;brand\u0026#34;,\u0026#34;category\u0026#34;)); 处理查询高亮结果：\n//....执行查询 //获取高亮结果 for (searchhit\u0026lt;skuinfo\u0026gt; searchhit : searchhits) { //获取高亮的内容 map\u0026lt;string, list\u0026lt;string\u0026gt;\u0026gt; highlightfields = searchhit.gethighlightfields(); //获取标题的高亮结果 searchhit.getcontent().settitle(highlightfields.get(\u0026#34;title\u0026#34;)==null?searchhit.getcontent().gettitle():highlightfields.get(\u0026#34;title\u0026#34;).get(0)); } //...获取查询结果数据集合 注意：放置高亮结果处理代码的顺序，一定要放在获取查询结果数据集合上面。\n6.4 测试 效果如下：\n\u0026#34;name\u0026#34;: \u0026#34;htc m8sd (e8) 波尔多红 电信4g\u0026lt;span style=\\\u0026#34;color:red\\\u0026#34;\u0026gt;手机\u0026lt;/span\u0026gt; 双卡双待双通\u0026#34;, 整体代码如下:\n@service public class skuserviceimpl implements skuservice { @autowired private skuesmapper skuesmapper; @autowired private itemfeign itemfeign; @autowired private elasticsearchresttemplate elasticsearchresttemplate; @override public void importsku() { //调用商品微服务，获取审核状态为1，审核通过的商品 result\u0026lt;list\u0026lt;item\u0026gt;\u0026gt; result = itemfeign.findbystatus(\u0026#34;1\u0026#34;); //算法很好，把接收过来的数据，转换为json字符串，在重新转换为集合 list\u0026lt;skuinfo\u0026gt; skuinfolist = json.parsearray(json.tojsonstring(result.getdata()), skuinfo.class); //遍历sku集合 for (skuinfo skuinfo : skuinfolist) { //获取规格数据{\u0026#34;网络\u0026#34;:\u0026#34;移动4g\u0026#34;}，转换为map map\u0026lt;string, object\u0026gt; specmap= json.parseobject(skuinfo.getspec()); //关联到动态域 skuinfo.setspecmap(specmap); } //保存sku到es skuesmapper.saveall(skuinfolist); } @override public map search(map\u0026lt;string, string\u0026gt; searchmap) { //获取搜索关键字 string keywords=searchmap.get(\u0026#34;keywords\u0026#34;); //判断关键字是否为空，如果为空设置默认值 if(stringutils.isempty(keywords)){ keywords=\u0026#34;手机\u0026#34;; } //创建查询对象构建器对象 nativesearchquerybuilder nativesearchquerybuilder = new nativesearchquerybuilder(); //设置分组条件 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skucategorygroup\u0026#34;).field(\u0026#34;category.keyword\u0026#34;)); //设置分组条件 商品品牌 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skubrandgroup\u0026#34;).field(\u0026#34;brand.keyword\u0026#34;).size(50)); //设置分组条件 规格 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skuspecgroup\u0026#34;).field(\u0026#34;spec.keyword\u0026#34;).size(50)); //设置查询条件 nativesearchquerybuilder.withquery(querybuilders.matchquery(\u0026#34;title\u0026#34;,keywords)); //创建过滤器对象 boolquerybuilder boolquerybuilder = querybuilders.boolquery(); //判断品牌查询条件是否为空 if(!stringutils.isempty(searchmap.get(\u0026#34;brand\u0026#34;))){ boolquerybuilder.filter(querybuilders.termquery(\u0026#34;brand\u0026#34;,searchmap.get(\u0026#34;brand.keyword\u0026#34;))); } //判断分类查询条件是否为空 if(!stringutils.isempty(searchmap.get(\u0026#34;category\u0026#34;))){ boolquerybuilder.filter(querybuilders.termquery(\u0026#34;category\u0026#34;,searchmap.get(\u0026#34;category.keyword\u0026#34;))); } //规格过滤 if(searchmap!=null){ //遍历searchmap for (string key : searchmap.keyset()) { //判断key是不是spec_开头 if(key.startswith(\u0026#34;spec_\u0026#34;)){ boolquerybuilder.filter(querybuilders.termquery(\u0026#34;specmap.\u0026#34;+key.substring(5)+\u0026#34;.keyword\u0026#34;,searchmap.get(key))); } } } //价格区间过滤 string price= searchmap.get(\u0026#34;price\u0026#34;); //判断价格不为空 if(!stringutils.isempty(price)){ //切开价格 string[] split = price.split(\u0026#34;-\u0026#34;); //判断结束价格不等于*，就设置价格上限 和下限 if(!split[1].equalsignorecase(\u0026#34;*\u0026#34;)){ boolquerybuilder.filter(querybuilders.rangequery(\u0026#34;price\u0026#34;).from(split[0],true).to(split[1],true)); }else { //只设置价格下限 \u0026gt;= boolquerybuilder.filter(querybuilders.rangequery(\u0026#34;price\u0026#34;).gte(split[0])); } } //关联查询器对象和过滤器 nativesearchquerybuilder.withfilter(boolquerybuilder); //构建分页查询 //获取要跳转到的页面 integer pagenum=1; //判断前端传递过来的页码 if(!stringutils.isempty(searchmap.get(\u0026#34;pagenum\u0026#34;))){ //把页码转换为整数 try { pagenum= integer.valueof(searchmap.get(\u0026#34;pagenum\u0026#34;)); } catch (numberformatexception e) { e.printstacktrace(); //转换失败，赋初始化值1 pagenum=1; } } //获取每页显示的记录数 integer pagesize=5; //判断前端传递过来的每页显示记录数 if(!stringutils.isempty(searchmap.get(\u0026#34;pagesize\u0026#34;))){ try { pagesize=integer.valueof(searchmap.get(\u0026#34;pagesize\u0026#34;)); } catch (numberformatexception e) { e.printstacktrace(); pagesize=5; } } //查询器对象，设置分页参数 //注意页码要当前页码-1 nativesearchquerybuilder.withpageable(pagerequest.of(pagenum-1,pagesize)); //获取排序方式 string sortrule = searchmap.get(\u0026#34;sortrule\u0026#34;); string sortfield = searchmap.get(\u0026#34;sortfield\u0026#34;); //判断不为空，设置排序条件 if(!stringutils.isempty(sortrule)\u0026amp;\u0026amp;!stringutils.isempty(sortfield)){ nativesearchquerybuilder.withsort(sortbuilders.fieldsort(sortfield).order(sortrule.equals(\u0026#34;desc\u0026#34;)? sortorder.desc:sortorder.asc)); } //设置高亮字段 nativesearchquerybuilder.withhighlightfields(new highlightbuilder.field(\u0026#34;title\u0026#34;)); //设置高亮选项 高亮前缀、高亮后缀 nativesearchquerybuilder.withhighlightbuilder(new highlightbuilder().pretags(\u0026#34;\u0026lt;span style=\u0026#39;color:red\u0026#39;\u0026gt;\u0026#34;).posttags(\u0026#34;\u0026lt;/span\u0026gt;\u0026#34;)); //设置多关键词搜索 nativesearchquerybuilder.withquery(querybuilders.multimatchquery(keywords,\u0026#34;title\u0026#34;,\u0026#34;brand\u0026#34;,\u0026#34;category\u0026#34;)); //构建查询器对象 nativesearchquery searchquery = nativesearchquerybuilder.build(); //执行查询 searchhits\u0026lt;skuinfo\u0026gt; searchhits = elasticsearchresttemplate.search(searchquery, skuinfo.class); //获取高亮结果 for (searchhit\u0026lt;skuinfo\u0026gt; searchhit : searchhits) { //获取高亮的内容 map\u0026lt;string, list\u0026lt;string\u0026gt;\u0026gt; highlightfields = searchhit.gethighlightfields(); //获取标题的高亮结果 searchhit.getcontent().settitle(highlightfields.get(\u0026#34;title\u0026#34;)==null?searchhit.getcontent().gettitle():highlightfields.get(\u0026#34;title\u0026#34;).get(0)); } //对搜索结果进行分页封装 searchpage\u0026lt;skuinfo\u0026gt; skupage = searchhitsupport.searchpagefor(searchhits, searchquery.getpageable()); //创建集合存储商品信息 list\u0026lt;skuinfo\u0026gt; skuinfolist=new arraylist\u0026lt;\u0026gt;(); for (searchhit\u0026lt;skuinfo\u0026gt; searchhit : skupage.getcontent()) { skuinfo skuinfo= searchhit.getcontent(); skuinfolist.add(skuinfo); } //获取分组结果 //获取分组结果 terms terms = searchhits.getaggregations().get(\u0026#34;skucategorygroup\u0026#34;); // 获取分类名称集合 list\u0026lt;string\u0026gt; categorylist = getstringscategorylist(terms); //获取品牌分组结果 terms termsbrand=searchhits.getaggregations().get(\u0026#34;skubrandgroup\u0026#34;); //获取品牌集合 list\u0026lt;string\u0026gt; brandlist = getstringbrandlist(termsbrand); //获取规格分组结果 terms termsspec= searchhits.getaggregations().get(\u0026#34;skuspecgroup\u0026#34;); map\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt; specmap = getstringsetmap(termsspec); map resultmap = new hashmap\u0026lt;\u0026gt;(); resultmap.put(\u0026#34;rows\u0026#34;, skuinfolist);//获取所需skuinfo集合数据内容 resultmap.put(\u0026#34;total\u0026#34;,searchhits.gettotalhits());//总记录数 resultmap.put(\u0026#34;totalpages\u0026#34;, skupage.gettotalpages());//总页数 resultmap.put(\u0026#34;categorylist\u0026#34;,categorylist); resultmap.put(\u0026#34;brandlist\u0026#34;,brandlist); resultmap.put(\u0026#34;specmap\u0026#34;,specmap); return resultmap; } /** * 获取分类列表数据 * @param terms * @return **/ private list\u0026lt;string\u0026gt; getstringscategorylist(terms terms) { list\u0026lt;string\u0026gt; categorylist = new arraylist\u0026lt;\u0026gt;(); if (terms != null) { for (terms.bucket bucket : terms.getbuckets()) { string keyasstring = bucket.getkeyasstring();// 分组的值（分类名称） categorylist.add(keyasstring); } } return categorylist; } //获取品牌分组结果 private list\u0026lt;string\u0026gt; getstringbrandlist(terms terms){ list\u0026lt;string\u0026gt; brandlist=new arraylist\u0026lt;\u0026gt;(); if(terms!=null){ for (terms.bucket bucket : terms.getbuckets()) { string keyasstring = bucket.getkeyasstring(); brandlist.add(keyasstring); } } return brandlist; } //获取规格分组结果 private map\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt; getstringsetmap(terms terms){ map\u0026lt;string, set\u0026lt;string\u0026gt;\u0026gt; specmap=new hashmap\u0026lt;\u0026gt;(); set\u0026lt;string\u0026gt; speclist=new hashset\u0026lt;\u0026gt;(); if(terms!=null){ for (terms.bucket bucket : terms.getbuckets()) { speclist.add(bucket.getkeyasstring()); } } //循环遍历 for (string specjson : speclist) { //把规格的json字符串转换为map map\u0026lt;string, string\u0026gt; map= json.parseobject(specjson,map.class); //遍历map for (map.entry\u0026lt;string, string\u0026gt; entry : map.entryset()) { string key=entry.getkey(); string value=entry.getvalue(); //去specmap查找指定的key看是否存在 set\u0026lt;string\u0026gt; specvalues = specmap.get(key); //判断value如果为空 if(specvalues==null){ //初始化 specvalues=new hashset\u0026lt;string\u0026gt;(); } //把当前的值添加到set specvalues.add(value); //把数据添加到map specmap.put(key, specvalues); } } return specmap; } } ","date":"2022-05-27","permalink":"https://lovemjh.vercel.app/posts/project-0/20220527231000/","summary":"第七章 商品搜索 优就业.JAVA教研室 学习目标 条件筛选 多条件搜索[品牌、规格条件搜索] 规格过滤 价格区间搜索 搜索分页 搜索排序 搜索高亮 1. 品牌统计 用户搜索的时候，除了使","title":"商品搜索"},{"content":"第五章 广告管理与lua、canal实现广告缓存 优就业.java教研室 学习目标 了解网站首页页面以及广告相关表结构 后台广告微服务开发 首页广告架构设计分析 lua脚本 openresty介绍 广告缓存的载入与读取 完成网站首页前台工程广告轮播图展示 nginx高并发限流讲解 canal binlog增量数据实时同步 canal实现广告实时缓存同步 一、网站首页分析 首页门户系统需要展示各种各样的广告数据。如图，以jd为例： 1.1网站首页广告 （1）首页海报（轮播图）\n（2）今日推荐\n（3）猜你喜欢\n（4）楼层广告\n1.2数据库表结构分析 tb_content_category 广告分类表\n字段 类型 长度 含义 id bigint 主键 name varchar 255 广告分类名称 tb_content 广告表\n字段 类型 长度 含义 id bigint 主键 category_id bigint 广告分类id title varchar 200 广告标题 url varchar 500 广告链接 pic varchar 300 图片地址 status varchar 1 状态 0不显示 1显示 sort_order int 排序 二、 首页广告架构设计分析 2.1 传统实现思路 如上图此种方式 简单，直接通过数据库查询数据展示给用户即可，但是通常情况下，首页（门户系统的流量一般非常的高）不适合直接通过mysql数据库直接访问的方式来获取展示。\n2.2 高并发架构设计 1.首先访问nginx ，我们可以采用缓存的方式，先从nginx本地缓存中获取，获取到直接响应\n2.如果nginx没有获取到，再次访问redis，我们可以从redis中获取数据，如果有 则返回，并缓存到nginx中\n3.如果redis没有获取到,再次访问mysql,我们从mysql中获取数据，再将数据存储到redis中，返回。\n而这里面，我们都可以使用lua脚本嵌入到程序中执行这些查询相关的业务。 三、lua(了解) 3.1 lua是什么 lua [1] 是一个小巧的脚本语言。它是巴西里约热内卢天主教大学（pontifical catholic university of rio de janeiro）里的一个由roberto ierusalimschy、waldemar celes 和 luiz henrique de figueiredo三人所组成的研究小组于1993年开发的。 其设计目的是为了通过灵活嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能。lua由标准c编写而成，几乎在所有操作系统和平台上都可以编译，运行。lua并没有提供强大的库，这是由它的定位决定的。所以lua不适合作为开发独立应用程序的语言。lua 有一个同时进行的jit项目，提供在特定平台上的即时编译功能。\n简单来说：\nlua 是一种轻量小巧的脚本语言，用标准c语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\n3.2 特性 支持面向过程(procedure-oriented)编程和函数式编程(functional programming)； 自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象； 语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持； 通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。 3.3 应用场景 游戏开发 独立应用脚本 web 应用脚本 扩展和数据库插件如：mysql proxy 和 mysql workbench 安全系统，如入侵检测系统 redis中嵌套调用实现类似事务的功能 web容器中应用处理一些过滤 缓存等等的逻辑，例如nginx。 3.4 lua的安装 有linux版本的安装也有mac版本的安装。。我们采用linux版本的安装，首先我们准备一个linux虚拟机。\n安装步骤,在linux系统中执行下面的命令。\ncurl -r -o http://www.lua.org/ftp/lua-5.3.5.tar.gz tar zxf lua-5.3.5.tar.gz cd lua-5.3.5 make linux test 注意：此时安装，有可能会出现如下错误： 此时需要安装lua相关依赖库的支持，执行如下命令即可：\nyum install gcc libtermcap-devel ncurses-devel libevent-devel readline-devel -y 重新编译lua\nmake linux test 安装lua\nmake install 删除老版本lua,关联新版本lua\ncd /usr/bin rm -rf lua luac ln -s /usr/local/bin/lua /usr/bin/lua ln -s /usr/local/bin/luac /usr/bin/luac 此时再执行lua测试看lua是否安装成功\n[root@localhost ~]# lua lua 5.3.5 copyright (c) 1994-2018 lua.org, puc-rio 3.5 入门程序 在线脚本测试：https://www.lua.org/cgi-bin/demo\n创建hello.lua文件，内容为\n编辑文件hello.lua\nvi hello.lua 在文件中输入：\nprint(\u0026#34;hello\u0026#34;); 保存并退出。\n执行命令\nlua hello.lua 输出为：\nhello 效果如下： 3.6 lua的基本语法(了解) lua有交互式编程和脚本式编程。\n交互式编程就是直接输入语法，就能执行。\n脚本式编程需要编写脚本，然后再执行命令 执行脚本才可以。\n一般采用脚本式编程。（例如：编写一个hello.lua的文件，输入文件内容，并执行lua hell.lua即可）\n(1)交互式编程\nlua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。\nlua 交互式编程模式可以通过命令 lua -i 或 lua 来启用：\nlua -i 如下图： (2)脚本式编程\n我们可以将 lua 程序代码保持到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，例如上面入门程序中将lua语法写到hello.lua文件中。\n3.6.1 注释 一行注释：两个减号是单行注释:\n-- 多行注释：\n--[[ 多行注释 多行注释 --]] 3.6.2 定义变量 全局变量，默认的情况下，定义一个变量都是全局变量，\n如果要用局部变量 需要声明为local.例如：\n-- 全局变量赋值 a=1 -- 局部变量赋值 local b=2 如果变量没有初始化：则 它的值为nil 这和java中的null不同。\n如下图案例： 3.6.3 lua中的数据类型 lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。\nlua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。\n数据类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。 boolean 包含两个值：false和true。 number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由 c 或 lua 编写的函数 userdata 表示任意存储在变量中的c数据结构 thread 表示执行的独立线路，用于执行协同程序 table lua 中的表（table）其实是一个\u0026quot;关联数组\u0026quot;（associative arrays），数组的索引可以是数字、字符串或表类型。在 lua 里，table 的创建是通过\u0026quot;构造表达式\u0026quot;来完成，最简单构造表达式是{}，用来创建一个空表。 实例：\nprint(type(\u0026#34;hello world\u0026#34;)) --\u0026gt; string print(type(10.4*3)) --\u0026gt; number print(type(print)) --\u0026gt; function print(type(type)) --\u0026gt; function print(type(true)) --\u0026gt; boolean print(type(nil)) --\u0026gt; nil 3.6.4 流程控制 (1)if语句\nlua if 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。\n语法：\nif(布尔表达式) then --[ 在布尔表达式为 true 时执行的语句 --] end 实例： --定义变量 num=5 --使用if语句判断 if num\u0026lt;10 then print(\u0026#34;5\u0026lt;10\u0026#34;) end (2)if..else语句\nlua if 语句可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码块。\n语法：\nif(布尔表达式) then --[ 布尔表达式为 true 时执行该语句块 --] else --[ 布尔表达式为 false 时执行该语句块 --] end 实例： --定义变量 a=100 if (a\u0026lt;20) then print(\u0026#39;a\u0026lt;20\u0026#39;) else print(\u0026#39;a\u0026gt;20\u0026#39;) end 3.6.5 循环 学员完成\n(1)while循环[==满足条件就循环==]\nlua 编程语言中 while 循环语句在判断条件为 true 时会重复执行循环体语句。 语法：\nwhile(condition) do statements end 实例：\na=10 while( a \u0026lt; 20 ) do print(\u0026#34;a value:\u0026#34;, a) a = a+1 end 效果如下： (2)for循环\nlua 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。\n语法： 1-\u0026gt;10 1:exp1 10:exp2 2:exp3:递增的数量\nfor var=exp1,exp2,exp3 do \u0026lt;执行体\u0026gt; end var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 \u0026ldquo;执行体\u0026rdquo;。exp3 是可选的，如果不指定，默认为1。\n例子：\nfor i=1,9,2 do print(i) end for i=1,9,2:i=1从1开始循环，9循环数据到9结束，2每次递增2 (3)repeat\u0026hellip;until语句[==满足条件结束==]\nlua 编程语言中 repeat\u0026hellip;until 循环语句不同于 for 和 while循环，for 和 while 循环的条件语句在当前循环执行开始时判断，而 repeat\u0026hellip;until 循环的条件语句在当前循环结束后判断。\n语法：\nrepeat statements until( condition ) 案例： num=5 repeat print(num) num=num+1 until(num\u0026gt;15) 3.6.6 函数 lua中也可以定义函数，类似于java中的方法。例如：\n--[[ 函数返回两个值的最大值 --]] function max(num1, num2) if (num1 \u0026gt; num2) then result = num1; else result = num2; end return result; end -- 调用函数 print(\u0026#34;两值比较最大值为 \u0026#34;,max(10,4)) print(\u0026#34;两值比较最大值为 \u0026#34;,max(5,6)) 执行之后的结果：\n两值比较最大值为 10 两值比较最大值为 6 注意函数需要在lua脚本文件编写，不要采用交互模式\nvi test.lua 编写内容 运行lua lua test.lua 输出结果： 两值比较最大值为 10 3.6.7 表 table 是 lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。\nlua也是通过table来解决模块（module）、包（package）和对象（object）的。\n案例：\n-- 初始化表 mytable = {} -- 指定值 mytable[1]= \u0026#34;lua\u0026#34; print(\u0026#34;mytable:\u0026#34;,mytable[1]) -- 移除引用 mytable = nil 3.6.8 模块 (1)模块定义\n模块类似于一个封装库，从 lua 5.1 开始，lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 api 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。\n创建一个文件叫module.lua，在module.lua中创建一个独立的模块，代码如下：\n-- 文件名为 module.lua -- 定义一个名为 module 的模块 module = {} -- 定义一个常量 module.constant = \u0026#34;这是一个常量\u0026#34; -- 定义一个函数 function module.func1() print(\u0026#34;这是一个公有函数\u0026#34;) end local function func2() print(\u0026#34;这是一个私有函数！\u0026#34;) end function module.func3() func2() end return module 由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。\n上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.\n(2)require 函数\nrequire 用于 引入其他的模块，类似于java中的类要引用别的类的效果。\n用法：\nrequire(\u0026#34;\u0026lt;模块名\u0026gt;\u0026#34;) require \u0026#34;\u0026lt;模块名\u0026gt;\u0026#34; 两种都可以。\n我们可以将上面定义的module模块引入使用,创建一个test_module.lua文件，代码如下：\n-- test_module.lua 文件 -- module 模块为上文提到到 module.lua require(\u0026#34;module\u0026#34;) print(module.constant) module.func3() 四、openresty介绍 openresty(又称：ngx_openresty) 是一个基于 nginx的可伸缩的 web 平台，由中国人章亦春发起，提供了很多高质量的第三方模块。\nopenresty 是一个强大的 web 应用服务器，web 开发人员可以使用 lua 脚本语言调动 nginx 支持的各种 c 以及 lua 模块,更主要的是在性能方面，openresty可以 快速构造出足以胜任 10w以上并发连接响应的超高性能 web 应用系统。\n360，upyun，阿里云，新浪，腾讯网，去哪儿网，酷狗音乐等都是 openresty 的深度用户。\nopenresty 简单理解成 就相当于封装了nginx,并且集成了lua脚本，开发人员只需要简单的其提供了模块就可以实现相关的逻辑，而不再像之前，还需要在nginx中自己编写lua的脚本，再进行调用了。\n4.1 安装openresty linux安装openresty:\n1.添加仓库执行命令\nyum install yum-utils yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo 2.执行安装\nyum install openresty -y 3.安装成功后 会在默认的目录如下：\n/usr/local/openresty 4.2 配置nginx 默认已经安装好了nginx,在目录：/usr/local/openresty/nginx 下。\n修改/usr/local/openresty/nginx/conf/nginx.conf,将配置文件使用的根设置为root,目的就是将来要使用lua脚本的时候 ，直接可以加载在root下的lua脚本。\ncd /usr/local/openresty/nginx/conf vi nginx.conf 修改代码如下： 4.3、启动openresty cd /usr/local/openresty/nginx/sbin ./nginx 4.4、停止openresty ./nginx -s stop 4.5、重启openresty ./nginx -s reload 4.6 测试访问 重启下centos虚拟机，然后访问测试nginx\n访问地址：http://192.168.188.128/ 注意：linux防火墙要打开80端口\nfirewall-cmd --add-port=80/tcp --permanent firewall-cmd --reload 五、广告缓存的载入与读取 5.1 需求分析 需要在页面上显示广告的信息。\n5.2 lua+nginx配置 (1)实现思路-查询数据放入redis中 实现思路：\n定义请求：用于查询数据库中的数据更新到redis中。\na.连接mysql ，按照广告分类id读取广告列表，转换为json字符串。\nb.连接redis，将广告列表json字符串存入redis 。\n定义请求：\n请求： /update_content 参数： id --指定广告分类的id 返回值： json 请求地址：\u0026lt;http://192.168.188.128/update_content?id=1\u0026gt;\n创建/root/lua目录，在该目录下创建update_content.lua： 目的就是连接mysql 查询数据 并存储到redis中。 上图代码如下：\n--- --- created by administrator. --- datetime: 2021/2/3 15:45 --- -- 设置nginx响应数据类型json ngx.header.content_type=\u0026#34;application/json;charset=utf8\u0026#34; -- 引入json的操作类库 local cjson= require(\u0026#39;cjson\u0026#39;) -- 引入连接数据库的类库 local mysql= require(\u0026#39;resty.mysql\u0026#39;) -- 引入捕获nginx url路径参数类库 local uri_args = ngx.req.get_uri_args() -- 获取传递进来广告分类id local categoryid=uri_args[\u0026#34;id\u0026#34;] -- 连接到数据库 local db=mysql:new() -- 连接到数据库超时时间 单位是毫秒 db:set_timeout(50000) -- 设置连接到数据库参数 local props={ host=\u0026#34;192.168.188.150\u0026#34;, port=3306, database=\u0026#34;dongyimaidb\u0026#34;, user=\u0026#34;root\u0026#34;, password=\u0026#34;root\u0026#34; } -- 使用连接参数建立连接 local res=db:connect(props) -- 准备一条sql语句 local sql=\u0026#34;select url,pic from tb_content where status=1 and category_id=\u0026#34;..categoryid -- 执行sql进行查询 res=db:query(sql) --关闭数据库连接 db:close() -- 引入redis操作类库 local redis=require(\u0026#39;resty.redis\u0026#39;) -- 创建一个redis客户端对象 local red=redis:new() -- 设置redis连接的超时时间 red:set_timeout(50000) -- 指定redis服务器 ip、端口 local ip=\u0026#34;192.168.188.150\u0026#34; local port=6379 -- redis客户端连接到指定redis服务器 red:connect(ip,port) -- 把从数据库读取到数据写入到redis 要把从数据库读取到结果转换为json字符串 red:set(\u0026#34;content_\u0026#34;..categoryid,cjson.encode(res)) -- 关闭redis连接 red:close() --提示给nginx用户写入成功 ngx.say(\u0026#34;{flag:true}\u0026#34;) 注意 .. 表示拼接变量\n连接数据库的超时时间可以适当设置长一些，避免出现连接超时情况。\n创建redis容器：\ndocker run -d --name redis1 --net=host redis:4.0.8 修改/usr/local/openresty/nginx/conf/nginx.conf文件： 添加头信息，和 location信息 代码如下：\nserver { listen 80; server_name localhost; location /update_content { content_by_lua_file /root/lua/update_content.lua; } } 重启nginx\n./nginx -s reload 测试地址：http://192.168.188.128/update_content?id=1\n此时会将分类id=1的所有广告查询出来，并存入到redis缓存。 (2)实现思路-从redis中获取数据 实现思路：\n定义请求，用户根据广告分类的id 获取广告的列表。通过lua脚本直接从redis中获取数据即可。\n定义请求：\n请求:/read_content 参数：id 返回值：json 在/root/lua目录下创建read_content.lua:\n--- --- created by administrator. --- datetime: 2021/2/3 15:45 --- --设置响应头类型 ngx.header.content_type=\u0026#34;application/json;charset=utf8\u0026#34; --获取请求中的参数id local uri_args = ngx.req.get_uri_args(); local id = uri_args[\u0026#34;id\u0026#34;]; --引入redis库 local redis = require(\u0026#34;resty.redis\u0026#34;); --创建redis对象 local red = redis:new() --设置超时时间 red:set_timeout(2000) --连接 local ok, err = red:connect(\u0026#34;192.168.188.128\u0026#34;, 6379) --获取key的值 local rescontent=red:get(\u0026#34;content_\u0026#34;..id) --输出到返回响应中 ngx.say(rescontent) --关闭连接 red:close() 在/usr/local/openresty/nginx/conf/nginx.conf中配置如下：\n如图： 代码：\nlocation /read_content { content_by_lua_file /root/lua/read_content.lua; } 重启nginx\n测试地址：http://192.168.188.128/read_content?id=1\n此时会将分类id=1的所有广告查询出来。 (3)加入openresty本地缓存 如上的方式没有问题，但是如果请求都到redis，redis压力也很大，所以我们一般采用多级缓存的方式来减少下游系统的服务压力。参考基本思路图的实现。\n先查询openresty本地缓存 如果 没有\n再查询redis中的数据，如果没有\n再查询mysql中的数据，但凡有数据 则返回即可。\n修改read_content.lua文件，代码如下： 上图代码如下：\n--- 设置nginx响应头数据类型 ngx.header.content_type=\u0026#34;application/json;charset=utf8\u0026#34; --获取请求中的参数id local uri_args = ngx.req.get_uri_args(); local id = uri_args[\u0026#34;id\u0026#34;]; --获取nginx本地缓存 local cache_ngx = ngx.shared.dis_cache; --尝试从ngnx缓存读取广告轮播图数据 local contentcache=cache_ngx:get(\u0026#39;content_cache_\u0026#39;..id) --判断从nginx缓存是否读取到内容 if contentcache ==nil or contentcache == \u0026#39;\u0026#39; then -- 从redis读取缓存数据 -- 引入redis类库 local redis=require(\u0026#39;resty.redis\u0026#39;) -- 创建redis连接对象 local red=redis:new() --设置连接超时时间 red:set_timeout(30000) --建立连接 local ok,error=red:connect(\u0026#39;192.168.188.144\u0026#39;,6379) --根据指定key去redis读取数据 local response_context=red:get(\u0026#39;content_\u0026#39;..id) --判断从redis是否读取到广告轮播图的数据 if ngx.null == response_context then -- 从数据库读取数据库 local mysql=require(\u0026#39;resty.mysql\u0026#39;) -- 创建数据库对象 local db= mysql:new() -- 设置数据库连接属性 local props={ host=\u0026#34;192.168.188.1\u0026#34;, port=3306, database=\u0026#34;dongyimai-db\u0026#34;, user=\u0026#34;root\u0026#34;, password=\u0026#34;root\u0026#34; } -- 设置连接超时时间 db:set_timeout(40000) -- 和mysql数据库建立连接 local res=db:connect(props); -- 定义sql语句 local sql=\u0026#34;select\t* from tb_content where status=\u0026#39;1\u0026#39; and category_id=\u0026#34;..id --执行sql查询 res=db:query(sql) -- ngx.say(\u0026#39;form mysql----\u0026#39;) --引入json的类库 local cjson=require(\u0026#39;cjson\u0026#39;) --把读取到数据转换为json对象，存储到redis local response_json= cjson.encode(res) red:set(\u0026#39;content_\u0026#39;..id,response_json) --关闭redis连接 red:close() --写入到nginx缓存一份 缓存有效期 单位是秒 cache_ngx:set(\u0026#39;content_cache_\u0026#39;..id,response_json,60) --响应给nginx展示用户 ngx.say(response_json) --关闭数据库连接 db:close() else -- 如果redis缓存存在数据写入数据到nginx缓存 cache_ngx:set(\u0026#39;content_cache_\u0026#39;..id,response_context,60) -- 响应nginx给浏览器 ngx.say(response_context) -- ngx.say(\u0026#39;form redis cache----\u0026#39;) end else -- 从nginx缓存能够读取到数据 --直接把读取到数据响应给浏览器 ngx.say(contentcache) -- ngx.say(\u0026#39;form nginx cache----\u0026#39;) end 注意：判断从redis是否读取到广告轮播图的数据\nif ngx.null == response_context 定义lua缓存命名空间，修改nginx.conf，添加如下代码即可： 代码如下：\nlua_shared_dict dis_cache 128m; 测试地址：http://192.168.188.128/read_content?id=1\n此时会获取分类id=1的所有广告信息。\n此时手动清空redis中的数据，发现依然可以访问到信息。 六、网站首页前台工程广告轮播图展示 6.1 网站首页工程搭建 1、创建静态web工程 2、拷贝网站首页静态资源 3、把用到的vue\\axios类库拷贝过来 6.2 网站首页开发 编辑index.html\n(1)、引入vue、axios类库到当前页面\n\u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; （2）、在页面添加vue识别div\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; ......原有网页内容，注意里面不能包含javascript \u0026lt;/div\u0026gt; (3)、编写vue代码，当页面加载的时候，从服务器端获取广告轮播图数据\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; //生成一个vue实例 var app=new vue({ el:\u0026#34;#app\u0026#34;,//el ,即是element。要渲染的页面元素 data:{//数据\tcontentlist:[] }, created(){ let th=this; axios.get(\u0026#39;/read_content\u0026#39;,{ // 还可以直接把参数拼接在url后边 params:{ id:1 } }).then(function(res){ th.contentlist = res.data; //console.log(th.contentlist) }).catch(function (error) { console.log(error); }); } }) \u0026lt;/script\u0026gt; （4）、修改index.html循环显示轮播图\n\u0026lt;div class=\u0026#34;yui3-u center banerarea\u0026#34;\u0026gt; \u0026lt;!--banner轮播--\u0026gt; \u0026lt;div id=\u0026#34;mycarousel\u0026#34; data-ride=\u0026#34;carousel\u0026#34; data-interval=\u0026#34;4000\u0026#34; class=\u0026#34;sui-carousel slide\u0026#34;\u0026gt; \u0026lt;ol class=\u0026#34;carousel-indicators\u0026#34;\u0026gt; \u0026lt;li data-target=\u0026#34;#mycarousel\u0026#34; v-for=\u0026#34;(content,index) in contentlist\u0026#34; :data-slide-to=\u0026#34;index\u0026#34; :class=\u0026#34;index==0?\u0026#39;active\u0026#39;:\u0026#39;\u0026#39;\u0026#34; \u0026gt;\u0026lt;/li\u0026gt;\t\u0026lt;/ol\u0026gt; \u0026lt;div class=\u0026#34;carousel-inner\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;(content,index) in contentlist\u0026#34; :class=\u0026#34;index==0?\u0026#39;active item\u0026#39;:\u0026#39;item\u0026#39;\u0026#34; \u0026gt; \u0026lt;a :href=\u0026#34;content.url\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;content.pic\u0026#34; style=\u0026#34;width:730px;height:454px\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt;\t\u0026lt;/div\u0026gt; \u0026lt;a href=\u0026#34;#mycarousel\u0026#34; data-slide=\u0026#34;prev\u0026#34; class=\u0026#34;carousel-control left\u0026#34;\u0026gt;‹\u0026lt;/a\u0026gt;\u0026lt;a href=\u0026#34;#mycarousel\u0026#34; data-slide=\u0026#34;next\u0026#34; class=\u0026#34;carousel-control right\u0026#34;\u0026gt;›\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 6.3 部署页面 上传首页相关文件到nginx目录：/usr/local/openresty/nginx/html 6.4 访问测试 访问地址: http://192.168.188.128/ 七、nginx限流 一般情况下，首页的并发量是比较大的，即使 有了多级缓存，当用户不停的刷新页面的时候，也是没有必要的，另外如果有恶意的请求 大量达到，也会对系统造成影响。\n而限流就是保护措施之一。\n7.1 生活中限流对比 水坝泄洪，通过闸口限制洪水流量（控制流量速度）。\n办理银行业务：所有人先领号，各窗口叫号处理。每个窗口处理速度根据客户具体业务而定，所有人排队等待叫号即可。若快下班时，告知客户明日再来(拒绝流量)\n火车站排队买票安检，通过排队 的方式依次放入。（缓存带处理任务）\n7.2 nginx的限流 nginx提供两种限流的方式：\n一是控制速率\n二是控制并发连接数\n7.2.1 控制速率 控制速率的方式之一就是采用漏桶算法。\n(1)漏桶算法实现控制速率限流 漏桶(leaky bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.示意图如下: nginx的配置\n配置示意图如下： 修改/usr/local/openresty/nginx/conf/nginx.conf:\nuser root root; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #cache lua_shared_dict dis_cache 128m; #限流设置 qps limit_req_zone $binary_remote_addr zone=contentratelimit:10m rate=2r/s; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; location /update_content { content_by_lua_file /root/lua/update_content.lua; } location /read_content { #使用限流配置 limit_req zone=contentratelimit; content_by_lua_file /root/lua/read_content.lua; } } } 配置说明：\nbinary_remote_addr 是一种key，表示基于 remote_addr(客户端ip) 来做限流，binary_ 的目的是压缩内存占用量。 zone：定义共享内存区来存储访问信息， contentratelimit:10m 表示一个大小为10m，名字为contentratelimit的内存区域。1m能存储16000 ip地址的访问信息，10m可以存储16w ip地址访问信息。 rate 用于设置最大访问速率，rate=10r/s 表示每秒最多处理10个请求。nginx 实际上以毫秒为粒度来跟踪请求信息，因此 10r/s 实际上是限制：每100毫秒处理一个请求。这意味着，自上一个请求处理完后，若后续100毫秒内又有请求到达，将拒绝处理该请求.我们这里设置成2个请求 方便测试。 测试：\n重新加载配置文件\ncd /usr/local/openresty/nginx/sbin ./nginx -s reload 访问页面：http://192.168.188.128/read_content?id=1 ,连续刷新会直接报错。 (2)处理突发流量 上面例子限制 2r/s，如果有时正常流量突然增大，超出的请求将被拒绝，无法处理突发流量，可以结合 burst 参数使用来解决该问题。\n例如，如下配置表示： 上图代码如下：\nserver { listen 80; server_name localhost; location /update_content { content_by_lua_file /root/lua/update_content.lua; } location /read_content { limit_req zone=contentratelimit burst=4; content_by_lua_file /root/lua/read_content.lua; } } burst 译为突发、爆发，表示在超过设定的处理速率后能额外处理的请求数,当 rate=10r/s 时，将1s拆成10份，即每100ms可处理1个请求。\n此处，**burst=4 **，若同时有4个请求到达，nginx 会处理第一个请求，剩余3个请求将放入队列，然后每隔500ms从队列中获取一个请求进行处理。若请求数大于4，将拒绝处理多余的请求，直接返回503.\n不过，单独使用 burst 参数并不实用。假设 burst=50 ，rate依然为10r/s，排队中的50个请求虽然每100ms会处理一个，但第50个请求却需要等待 50 * 100ms即 5s，这么长的处理时间自然难以接受。\n因此，burst 往往结合 nodelay 一起使用。\n例如：如下配置：\nserver { listen 80; server_name localhost; location /update_content { content_by_lua_file /root/lua/update_content.lua; } location /read_content { limit_req zone=contentratelimit burst=4 nodelay; content_by_lua_file /root/lua/read_content.lua; } } 如上表示：\n平均每秒允许不超过2个请求，突发不超过4个请求，并且处理突发4个请求的时候，没有延迟，等到完成之后，按照正常的速率处理。\n如上两种配置结合就达到了速率稳定，但突然流量也能正常处理的效果。完整配置代码如下：\nuser root root; worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #cache lua_shared_dict dis_cache 128m; #限流设置 limit_req_zone $binary_remote_addr zone=contentratelimit:10m rate=2r/s; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; location /update_content { content_by_lua_file /root/lua/update_content.lua; } location /read_content { limit_req zone=contentratelimit burst=4 nodelay; content_by_lua_file /root/lua/read_content.lua; } } } 测试：如下图 在1秒钟之内可以刷新4次，正常处理。 但是超过之后，连续刷新5次，抛出异常。 7.2.2 控制并发量（连接数） ngx_http_limit_conn_module 提供了限制连接数的能力。主要是利用limit_conn_zone和limit_conn两个指令。\n利用连接数限制 某一个用户的ip连接的数量来控制流量。\n注意：并非所有连接都被计算在内 只有当服务器正在处理请求并且已经读取了整个请求头时，才会计算有效连接。此处忽略测试。\n配置语法：\nsyntax:\tlimit_conn zone number; default: —; context: http, server, location; (1)配置限制固定连接数 如下，配置如下： 上图配置如下：\nhttp { include mime.types; default_type application/octet-stream; #cache lua_shared_dict dis_cache 128m; #限流设置 limit_req_zone $binary_remote_addr zone=contentratelimit:10m rate=2r/s; #根据ip地址来限制，存储内存大小1m limit_conn_zone $binary_remote_addr zone=addr:1m; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #所有以brand开始的请求，访问本地dongyimai-content-service微服务 location /brand { limit_conn addr 2; proxy_pass http://192.168.188.1:9001/brand; } location /update_content { content_by_lua_file /root/lua/update_content.lua; } location /read_content { limit_req zone=contentratelimit burst=4 nodelay; content_by_lua_file /root/lua/read_content.lua; } } } 表示：\nlimit_conn_zone $binary_remote_addr zone=addr:10m; 表示限制根据用户的ip地址来显示，设置存储地址为的内存大小10m limit_conn addr 2; 表示 限制每个ip只能发起2个连接。 测试：\n此时开3个线程，测试的时候会发生异常，开2个就不会有异常 (2)限制每个客户端ip与服务器的连接数，同时限制与虚拟服务器的连接总数。(了解) 如下配置：\nlimit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; server { listen 80; server_name localhost; charset utf-8; location / { limit_conn perip 10;#单个客户端ip与服务器的连接数． limit_conn perserver 100; ＃限制与服务器的总连接数 root html; index index.html index.htm; } } 八、canal同步广告 canal可以用来监控数据库数据的变化，从而获得新增数据，或者修改的数据。\ncanal是应阿里巴巴存在杭州和美国的双机房部署，存在跨机房同步的业务需求而提出的。\n阿里系公司开始逐步的尝试基于数据库的日志解析，获取增量变更进行同步，由此衍生出了增量订阅\u0026amp;消费的业务。\n8.1 canal工作原理 原理相对比较简单：\ncanal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议 mysql master收到dump请求，开始推送binary log给slave(也就是canal) canal解析binary log对象(原始为byte流) canal需要使用到mysql，我们需要先安装mysql,给大家发的虚拟机中已经安装了mysql容器，但canal是基于mysql的主从模式实现的，所以必须先开启binlog.\n8.2、使用docker创建数据库容器 （1）、上传mysql数据库配置文件mysqld.cnf\n到服务器的/root目录下\n[mysqld] character-set-server=utf8 collation-server=utf8_general_ci pid-file = /var/run/mysqld/mysqld.pid socket = /var/run/mysqld/mysqld.sock datadir = /var/lib/mysql #log-error = /var/log/mysql/error.log # by default we only accept connections from localhost #bind-address = 127.0.0.1 # disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 （2）、上传数据库初始化脚本到 dongyimaidb.sql\n到服务器的/root目录下\n（3）、创建mysql容器\ndocker run -d --name=mysql -v /root/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /root/db.sql:/docker-entrypoint-initdb.d/mysql.sql -e mysql_root_password=root -e mysql_database=dongyimai-db --net=host mysql:5.7 注意：设置 网络模式为 host共享主机ip\n8.3 开启binlog模式 先使用docker 创建mysql容器,此处不再演示.\n(1) 连接到mysql容器中,并修改/etc/mysql/mysql.conf.d/mysqld.cnf 需要开启主 从模式，开启binlog模式。\n执行如下命令，编辑mysql配置文件 命令行如下：\ndocker exec -it mysql /bin/bash cd /etc/mysql/mysql.conf.d vi mysqld.cnf 修改mysqld.cnf配置文件，添加如下配置： 上图配置如下：\nlog-bin=/var/lib/mysql/mysql-bin server-id=12345 (2) 通过客户端创建账号 用于测试使用,\n使用root账号创建用户并授予权限\ncreate user canal@\u0026#39;%\u0026#39; identified by \u0026#39;canal\u0026#39;; grant select, replication slave, replication client,super on *.* to \u0026#39;canal\u0026#39;@\u0026#39;%\u0026#39;; flush privileges; (3)重启mysql容器\ndocker restart mysql 8.4 canal容器安装 下载镜像：\ndocker pull docker.io/canal/canal-server 容器安装\ndocker run --name canal -d --net=host docker.io/canal/canal-server 进入容器,修改核心配置canal.properties 和instance.properties，canal.properties 是canal自身的配置，instance.properties是需要同步数据的数据库连接配置。\n执行代码如下:\ndocker exec -it canal /bin/bash cd canal-server/conf/example vi instance.properties 修改instance.properties,配置数据库连接地址:\n注意ip填写mysql绑定的主机ip：192.168.188.128(每个人都不一样) 因为当前mysql容器采用了host共享主机ip模式，所以，监听ip写宿主机的ip就可以 这里的canal.instance.filter.regex有多种配置，如下：\n可以参考地址如下:\nhttps://github.com/alibaba/canal/wiki/adminguide mysql 数据解析关注的表，perl正则表达式. 多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\\\) 常见例子： 1. 所有表：.* or .*\\\\..* 2. canal schema下所有表： canal\\\\..* 3. canal下的以canal打头的表：canal\\\\.canal.* 4. canal schema下的一张表：canal.test1 5. 多个规则组合使用：canal\\\\..*,mysql.test1,mysql.test2 (逗号分隔) 注意：此过滤条件只针对row模式的数据有效(ps. mixed/statement因为不解析sql，所以无法准确提取tablename进行过滤) 配置完成后，设置开机启动，并记得重启canal。\ndocker update --restart=always canal docker restart canal 开启cancal的防火墙端口：\nfirewall-cmd --add-port=11111/tcp --permanent firewall-cmd --reload 8.5 canal微服务搭建 当用户执行 数据库的操作的时候，binlog 日志会被canal捕获到，并解析出数据。我们就可以将解析出来的数据进行同步到redis中即可。\n思路：创建一个独立的程序，并监控canal服务器，获取binlog日志，解析数据，将数据更新到redis中。这样广告的数据就更新了。\n(1)安装辅助jar包\n在源码\\spring-boot-starter-canal-master中有一个工程starter-canal，它主要提供了springboot环境下canal的支持，我们需要先安装该工程，在starter-canal目录下执行mvn install，如下图： (2)canal微服务工程搭建\n在dongyimai-service下创建dongyimai-canal-service工程，并引入相关配置。\npom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-canal-service\u0026lt;/artifactid\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--canal依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.xpand\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;starter-canal\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.0.1-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-content-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; application.yml配置\nserver: port: 9003 spring: application: name: canal eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true #hystrix 配置 hystrix: command: default: execution: timeout: #如果enabled设置为false，则请求超时交给ribbon控制 enabled: true isolation: strategy: semaphore #canal配置 canal: client: instances: example: host: 192.168.188.128 port: 11111 注意：开启canal服务器的端口防火墙\nfirewall-cmd --add-port=11111/tcp --permanent firewall-cmd --add-port=3306/tcp --permanent firewall-cmd --reload (3)监听创建\n创建一个canaldataeventlistener类，实现对表增删改操作的监听，代码如下：\npackage com.offcn.canal.listener; import com.alibaba.otter.canal.protocol.canalentry; import com.xpand.starter.canal.annotation.*; @canaleventlistener public class canaldataeventlistener { /*** * 增加数据监听 * @param eventtype * @param rowdata */ @insertlistenpoint public void oneventinsert(canalentry.eventtype eventtype, canalentry.rowdata rowdata) { rowdata.getaftercolumnslist().foreach((c) -\u0026gt; system.out.println(\u0026#34;by--annotation: \u0026#34; + c.getname() + \u0026#34; :: \u0026#34; + c.getvalue())); } /*** * 修改数据监听 * @param rowdata */ @updatelistenpoint public void oneventupdate(canalentry.rowdata rowdata) { system.out.println(\u0026#34;updatelistenpoint\u0026#34;); rowdata.getaftercolumnslist().foreach((c) -\u0026gt; system.out.println(\u0026#34;by--annotation: \u0026#34; + c.getname() + \u0026#34; :: \u0026#34; + c.getvalue())); } /*** * 删除数据监听 * @param eventtype */ @deletelistenpoint public void oneventdelete(canalentry.eventtype eventtype) { system.out.println(\u0026#34;deletelistenpoint\u0026#34;); } /*** * 自定义数据修改监听 * @param eventtype * @param rowdata */ @listenpoint(destination = \u0026#34;example\u0026#34;, schema = \u0026#34;dongyimaidb\u0026#34;, table = {\u0026#34;tb_content_category\u0026#34;, \u0026#34;tb_content\u0026#34;}, eventtype = canalentry.eventtype.update) public void oneventcustomupdate(canalentry.eventtype eventtype, canalentry.rowdata rowdata) { system.err.println(\u0026#34;customupdatelistenpoint\u0026#34;); rowdata.getaftercolumnslist().foreach((c) -\u0026gt; system.out.println(\u0026#34;by--annotation: \u0026#34; + c.getname() + \u0026#34; :: \u0026#34; + c.getvalue())); } } (4)启动类创建\n在com.offcn.canal中创建启动类，代码如下：\n@springbootapplication(exclude={datasourceautoconfiguration.class}) @enableeurekaclient @enablecanalclient public class canalapplication { public static void main(string[] args) { springapplication.run(canalapplication.class,args); } } (5)测试\n启动canal微服务，然后修改任意数据库的表数据，canal微服务后台输出如下： 8.6 广告同步(作业) 如上图，每次执行广告操作的时候，会记录操作日志到，然后将操作日志发送给canal，canal将操作记录发送给canal微服务，canal微服务根据修改的分类id调用content微服务查询分类对应的所有广告，canal微服务再将所有广告存入到redis缓存。\n8.6.1 content微服务搭建 在dongyimai-service中搭建dongyimai-content-servic微服务，对应的dao、service、controller、pojo、feign由代码生成器生成。\n8.6.1.1、构建工程 创建模块：\n（1）、dongyimai-content-service-api 模块继承父工程：dongyimai-service-api\n新建包:com.offcn.content.pojo\n（2）、dongyimai-content-service 模块继承父工程：dongyimai-service\n新建包:com.offcn.content\n引入依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-content-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 8.6.1.2、生成代码、拷贝到工程 （1）、dongyimai-content-service-api模块中拷贝生成的pojo实体类、feign调用接口 （2）、dongyimai-content-service模块中拷贝生成的dao、service、controller代码 8.6.1.3、创建配置文件 在模块dongyimai-content-service下 src/main/resources目录下创建配置文件:application.yml\nserver: port: 9004 spring: application: name: content datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/dongyimaidb?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=gmt%2b8 username: root password: root type: com.alibaba.druid.pool.druiddatasource eureka: client: service-url: defaultzone: http://localhost:8761/eureka feign: hystrix: enabled: true #设定hystrix熔断超时时间 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 6000 mybatis: configuration: map-underscore-to-camel-case: true #开启驼峰式编写规范 type-aliases-package: com.offcn.content.pojo # 配置sql打印日志 logging: level: com.offcn.content: debug 8.6.1.4、编写swagger文档配置类、mybatisplus分页插件配置类 appswggerconfig.java\npackage com.offcn.content.config; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; import springfox.documentation.builders.apiinfobuilder; import springfox.documentation.builders.pathselectors; import springfox.documentation.builders.requesthandlerselectors; import springfox.documentation.service.apiinfo; import springfox.documentation.spi.documentationtype; import springfox.documentation.spring.web.plugins.docket; import springfox.documentation.swagger2.annotations.enableswagger2; @configuration @enableswagger2 //开启swagger2自动生成api文档的功能 public class appswggerconfig { @bean public docket createrestapi() { return new docket(documentationtype.swagger_2) .groupname(\u0026#34;webapi\u0026#34;) .apiinfo(apiinfo()) .select() .apis(requesthandlerselectors.basepackage(\u0026#34;com.offcn.content.controller\u0026#34;)) .paths(pathselectors.any()) .build(); } private apiinfo apiinfo() { return new apiinfobuilder() .title(\u0026#34;广告微服务-接口文档\u0026#34;) .description(\u0026#34;提供广告模块的文档\u0026#34;) .termsofserviceurl(\u0026#34;http://www.ujiuye.com/\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .build(); } } pageconfig.java\npackage com.offcn.content.config; import com.baomidou.mybatisplus.annotation.dbtype; import com.baomidou.mybatisplus.extension.plugins.mybatisplusinterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.paginationinnerinterceptor; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; /** * @auther: lhq * @date: 2021/1/25 10:41 * @description: */ @configuration public class pageconfig { @bean public mybatisplusinterceptor mybatisplusinterceptor() { mybatisplusinterceptor interceptor = new mybatisplusinterceptor(); interceptor.addinnerinterceptor(new paginationinnerinterceptor(dbtype.mysql)); return interceptor; } } 8.6.1.5、编写主启动类 @springbootapplication @enablediscoveryclient @mapperscan(\u0026#34;com.offcn.content.dao\u0026#34;) public class contentapplication { public static void main(string[] args) { springapplication.run(contentapplication.class,args); } } 8.6.2、启动测试 8.6.2.1、运行主启动类contentapplication，启动项目 8.6.2.2、访问swagger测试接口 访问地址:http://localhost:9003/swagger-ui.html swagger小bug解决：\n使用swagger文档的时候，在后台出现错误如下： 解决bug方法，修改dongyimai-parent的依赖配置文件pom.xml\n\u0026lt;!--swagger--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger2\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;io.swagger\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;swagger-models\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.swagger\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;swagger-models\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.5.21\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger-ui\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 把springfox-swagger2所依赖的swagger-models排除掉，引入1.5.21版本的swagger-models。\n广告微服务开发完成，具体管理页面，和web前端进行对接实现！\n8.6.3 广告查询 在content微服务中，添加根据分类查询广告。\n(1)业务层\n修改dongyimai-content-service的com.offcn.content.service.contentservice接口，添加根据分类id查询广告数据，代码如下：\n/*** * 根据categoryid查询广告集合 * @param id * @return */ list\u0026lt;content\u0026gt; findbycategory(long id); 修改dongyimai-content-service的com.offcn.content.service.impl.contentserviceimpl接口实现类，添加根据分类id查询广告数据，代码如下：\n@override public list\u0026lt;content\u0026gt; findbycategory(long id) { //创建查询条件数据封装对象 content content = new content(); //设置广告分类id查询条件 content.setcategoryid(id); //设置广告状态为 1 可用 content.setstatus(\u0026#34;1\u0026#34;); //构建查询条件 querywrapper\u0026lt;content\u0026gt; querywrapper = this.createquerywrapper(content); //设置按照排序字段升序进行排序 querywrapper.orderbyasc(\u0026#34;sort_order\u0026#34;); //发出查询 return this.list(querywrapper); } (2)控制层\n修改dongyimai-content-service的com.offcn.content.controller.contentcontroller,添加根据分类id查询广告数据，代码如下：\n/*** * 根据categoryid查询广告集合 * @param content * @return */ @apioperation(value = \u0026#34;根据categoryid查询广告集合\u0026#34;,notes = \u0026#34;根据categoryid查询广告集合\u0026#34;,tags = {\u0026#34;contentcontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;分类id\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @getmapping(value = \u0026#34;/list/category/{id}\u0026#34; ) public result\u0026lt;list\u0026lt;content\u0026gt;\u0026gt; findbycategory(@pathvariable(\u0026#34;id\u0026#34;) long id){ //调用contentservice实现条件查询content list\u0026lt;content\u0026gt; list = contentservice.findbycategory(id); return new result\u0026lt;list\u0026lt;content\u0026gt;\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,list); } (3)feign配置\n在dongyimai-content-service-api工程中contentfeign添加获取指定分类id广告数据方法调用，代码如下：\n@feignclient(name=\u0026#34;content\u0026#34;) @requestmapping(value = \u0026#34;/content\u0026#34;) public interface contentfeign { /*** * 根据分类id查询所有广告 */ @getmapping(value = \u0026#34;/list/category/{id}\u0026#34;) result\u0026lt;list\u0026lt;content\u0026gt;\u0026gt; findbycategory(@pathvariable long id); } 8.6.4 同步实现 在canal微服务中修改如下:\n(1)配置redis\n修改application.yml配置文件，添加redis配置，如下代码： （2）、配置熔断超时时间\n修改application.yml配置文件\nfeign: hystrix: enabled: true #设定hystrix熔断超时时间 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 6000 (3)启动类中开启feign\n修改canalapplication，添加@enablefeignclients注解，代码如下： 错误：出现连接数据失败错误，修改主启动类排除数据库自动配置\n(3)同步实现\n修改监听类canaldataeventlistener，实现监听广告的增删改，并根据增删改的数据使用feign查询对应分类的所有广告，将广告存入到redis中，代码如下：\n上图代码如下：\n@canaleventlistener public class canaldataeventlistener { @autowired private contentfeign contentfeign; //字符串 @autowired private stringredistemplate stringredistemplate; //自定义数据库的 操作来监听 //destination = \u0026#34;example\u0026#34; @listenpoint(destination = \u0026#34;example\u0026#34;, schema = \u0026#34;dongyimaidb\u0026#34;, table = {\u0026#34;tb_content\u0026#34;, \u0026#34;tb_content_category\u0026#34;}, eventtype = { canalentry.eventtype.update, canalentry.eventtype.delete, canalentry.eventtype.insert}) public void oneventcustomupdate(canalentry.eventtype eventtype, canalentry.rowdata rowdata) { //1.获取列名 为category_id的值 string categoryid = getcolumnvalue(eventtype, rowdata); //2.调用feign 获取该分类下的所有的广告集合 result\u0026lt;list\u0026lt;content\u0026gt;\u0026gt; categoryresut = contentfeign.findbycategory(long.valueof(categoryid)); list\u0026lt;content\u0026gt; data = categoryresut.getdata(); //3.使用redistemplate存储到redis中 stringredistemplate.boundvalueops(\u0026#34;content_\u0026#34; + categoryid).set(json.tojsonstring(data)); } private string getcolumnvalue(canalentry.eventtype eventtype, canalentry.rowdata rowdata) { string categoryid = \u0026#34;\u0026#34;; //判断 如果是删除 则获取beforlist if (eventtype == canalentry.eventtype.delete) { for (canalentry.column column : rowdata.getbeforecolumnslist()) { if (column.getname().equalsignorecase(\u0026#34;category_id\u0026#34;)) { categoryid = column.getvalue(); return categoryid; } } } else { //判断 如果是添加 或者是更新 获取afterlist for (canalentry.column column : rowdata.getaftercolumnslist()) { if (column.getname().equalsignorecase(\u0026#34;category_id\u0026#34;)) { categoryid = column.getvalue(); return categoryid; } } } return categoryid; } } 测试：\n修改数据库数据，可以看到redis中的缓存跟着一起变化 ","date":"2022-05-27","permalink":"https://lovemjh.vercel.app/posts/project-0/20220527222325/","summary":"第五章 广告管理与Lua、Canal实现广告缓存 优就业.JAVA教研室 学习目标 了解网站首页页面以及广告相关表结构 后台广告微服务开发 首页广告架构设计分析 Lua脚本 O","title":"广告管理与lua、canal实现广告缓存"},{"content":"第六章 搜索解决方案-elasticsearch 优就业.java教研室 学习目标 elasticsearch、kibana环境配置 dsl语句讲解 商品索引库导入讲解 商品关键词搜索实现 分类统计搜索 一、elasticsearch 安装 elasticsearch是一个基于lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于restfulweb接口。elasticsearch是用java开发的，并作为apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。构建在全文检索开源软件lucene之上的elasticsearch，不仅能对海量规模的数据完成分布式索引与检索，还能提供数据聚合分析。据国际权威的数据库产品评测机构dbengines的统计，在2016年1月，elasticsearch已超过solr等，成为排名第一的搜索引擎类应用\n简之：elasticsearch是基于restfull乐准的高扩展高可用的实时数据分析的全文搜索工具。\n基本概念\n此处需要注意：关于类型type在不同版本是有所变化的\nelasticsearch 官网提出的近期版本对 type 概念的演变情况如下：\n在 5.x 版本中，一个 index 下可以创建多个 type；\n在 6.x 版本中，一个 index 下只能存在一个 type；\n在 7.x 版本中，直接去除了 type 的概念，就是说 index 不再会有 type。\n主要目的就是 为了保持 elasticsearch “一切为了搜索” 的宗旨\n由于我们之前已经使用过elasticsearch了，这里不再对它进行过多的介绍了，直接下载安装，本章节将采用docker安装，不过在市面上还有很多采用linxu安装，关于linux安装，已经提供了安装手册，这里就不讲了。\n我们之前已经使用过elasticsearch了，这里不再对它进行介绍了，直接下载安装，本章节将采用docker安装，不过在市面上还有很多采用linxu安装，关于linux安装，已经提供了安装手册，这里就不讲了。\n(1)docker镜像下载 docker pull elasticsearch:7.7.0 注意：建议还原镜像备份文件\ndocker load -i elasticsearch7.7.tar (2)安装es容器 因为elasticsearch在启动的时候会进行一些检查，比如最多打开的文件的个数以及虚拟内存区域数量等等，所以我们需要先进行系统调优，需要在虚拟机下设置max_map_count，否则elasticsearch容器会启动不起来 查看max_map_count的值 默认是65530\ncat /proc/sys/vm/max_map_count 重新设置max_map_count的值\nsysctl -w vm.max_map_count=262144 然后执行运行容器命令，如下\ndocker run -di --name dym_es -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; -e \u0026#34;es_java_opts=-xms512m -xmx512m\u0026#34; elasticsearch:7.7.0 命令解释：\n9200端口(web管理平台端口) 9300(服务默认端口)\n-e es_java_opts=\u0026quot;-xms512m -xmx512m\u0026quot;是设置占用内存大小，一般线上检索服务器-es服务器32g，这里就小一点测试\n-e \u0026quot;discovery.type=single-node\u0026quot;这个是设置单节点运行\n(3)开启远程连接及跨域配置 将elasticsearch容器内部的/usr/share/elasticsearch/config/elasticsearch.yml配置文件拷贝到虚拟机的root目录下，编辑增加以下命令。\n拷贝命令：\ndocker cp dym_es:/usr/share/elasticsearch/config/elasticsearch.yml /root/elasticsearch.yml 编辑elasticsearch.yml\ncluster.name: my-application http.cors.enabled: true http.cors.allow-origin: \u0026#34;*\u0026#34; network.host: 0.0.0.0 其中：\ncluster.name：自定义集群名称。 network.host：当前es节点绑定的ip地址，默认127.0.0.1，如果需要开放对外访问这个属性必须设置。http.cors.enabled: true：此步为允许elasticsearch跨域访问，默认是false。 http.cors.allow-origin: \u0026quot;*\u0026quot;：表示跨域访问允许的域名地址（*表示任意）。\n删除之前的es容器，并重新执行运行容器命令\ndocker rm -f dym_es docker run -di --name dym_es -p 9200:9200 -p 9300:9300 -e \u0026#34;discovery.type=single-node\u0026#34; -e \u0026#34;es_java_opts=-xms512m -xmx512m\u0026#34; -v /root/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:7.7.0 浏览器输入地址访问：`http://192.168.188.128:9200/ 小提示：如果想让容器开启重启，可以执行下面命令\ndocker update --restart=always dym_es 二、ik分词器安装 (1)安装ik分词器\nik分词器下载地址https://github.com/medcl/elasticsearch-analysis-ik/releases\n上传分词器压缩文件到linux服务器，拷贝文件到es容器\ndocker cp /root/elasticsearch-analysis-ik-7.7.0.zip dym_es:/usr/share/elasticsearch/plugins/elasticsearch-analysis-ik-7.7.0.zip 进入容器安装ik分词器\ndocker exec -it dym_es /bin/bash cd /usr/share/elasticsearch/plugins/ 在plugins目录下安装ik分词器，ik分词器需要和es版本一致\n使用上传的插件压缩包安装：\nmkdir ik mv elasticsearch-analysis-ik-7.7.0.zip ik/ cd ik unzip elasticsearch-analysis-ik-7.7.0.zip 也可以基于网络安装：\nelasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.7.0/elasticsearch-analysis-ik-7.7.0.zip 退出容器并重启\ndocker restart dym_es 测试安装成功，地址栏输入：\nhttp://192.168.188.128:9200/_cat/plugins ik分词器有两种分词模式：ik_max_word和ik_smart模式。\n1、ik_max_word\n会将文本做最细粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为“中华人民、中华、华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。\n2、ik_smart 会做最粗粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。\n两种分词器使用的最佳实践是：索引时用ik_max_word，在搜索时用ik_smart。 即：索引时最大化的将文章内容分词，搜索时更精确的搜索到想要的结果。\n三、 kibana使用-掌握dsl语句 我们这里需要一个更专业的工具实现对日志的实时分析，也就是我们接下来要讲的kibana。\nkibana 是一款开源的数据分析和可视化平台，它是 elastic stack 成员之一，设计用于和 elasticsearch 协作。您可以使用 kibana 对 elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。\nkibana 可以使大数据通俗易懂。它很简单，基于浏览器的界面便于您快速创建和分享动态数据仪表板来追踪 elasticsearch 的实时数据变化。\n搭建 kibana 非常简单。您可以分分钟完成 kibana 的安装并开始探索 elasticsearch 的索引数据 — 没有代码、不需要额外的基础设施。\n3.1 kibana下载安装 我们项目中不再使用linux，直接使用docker，所有这里就不演示在windows的下载安装了。\n(1)镜像下载\ndocker pull kibana:7.7.0 为了节省时间,建议还原虚拟机备份文件\ndocker load -i kibana7.7.tar (2)安装kibana容器\n执行如下命令，开始安装kibana容器\ndocker run -di --link dym_es:elasticsearch --name kibana --restart=always -p 5601:5601 kibana:7.7.0 restart=always:每次服务都会重启，也就是开启启动\n5601:5601:端口号\n(3)访问测试\n访问http://192.168.188.128:5601如下： 3.2 kibana使用 3.2.1 配置索引 此处我们选择 图中所示：自己的数据 选择上图的设置图标\n接下来就可以和es进行交互了\n3.2.2 索引管理 要使用kibana，您必须至少配置一个索引（但是要求elasticsearch中要有数据）。索引用于标识elasticsearch索引以运行搜索和分析。它们还用于配置字段等。下面我们看如何管理查看索引。\n点击 设置-选择d -manager space\n选择 index patterns\n创建一个索引\n没有数据目前不能建立索引 后面添加过索引可以通过如下方法查看添加的索引\n输入索引规则，点击下一步 点击创建 域的每个标题选项分别代表如下意思： 也可以直接查看 选择 elasticsearch-index managerment 查看创建的索引 3.2.3 dsl语句使用 3.2.3.1 query dsl结构化查询介绍 query dsl是一个java开源框架用于构建类型安全的sql查询语句。采用api代替传统的拼接字符串来构造查询语句。目前querydsl支持的平台包括jpa,jdo，sql，java collections，rdf，lucene，hibernate search。elasticsearch提供了一整套基于json的查询dsl语言来定义查询。 query dsl当作是一系列的抽象的查询表达式树(ast)特定查询能够包含其它的查询，(如 bool ), 有些查询能够包含过滤器(如 constant_score), 还有的可以同时包含查询和过滤器 (如 filtered). 都能够从es支持查询集合里面选择任意一个查询或者是从过滤器集合里面挑选出任意一个过滤器, 这样的话，我们就可以构造出任意复杂（maybe 非常有趣）的查询了。\n3.2.3.2 测试分词 （1）ik_smart post _analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;中华人民共和国人民大会堂\u0026#34; } (2) ik_max_word post _analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;中华人民共和国人民大会堂\u0026#34; } 四、数据导入es 4.1 springdata elasticsearch介绍 4.1.1 springdata介绍 spring data是一个用于简化数据库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持map-reduce框架和云计算数据服务。 spring data可以极大的简化jpa的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了crud外，还包括如分页、排序等一些常用的功能。\nspring data的官网：https://spring.io/projects/spring-data\n4.1.2 springdata es介绍 spring data elasticsearch 基于 spring data api 简化 elasticsearch操作，将原始操作elasticsearch的客户端api 进行封装 。spring data为elasticsearch项目提供集成搜索引擎。spring data elasticsearch pojo的关键功能区域为中心的模型与elastichsearch交互文档和轻松地编写一个存储库数据访问层。 官方网站：https://spring.io/projects/spring-data-elasticsearch\n4.2 搜索工程搭建 创建搜索微服务工程，dongyimai-search-service,该工程主要提供搜索服务以及索引数据的更新操作。\n(1)api工程搭建\n首先创建search的api工程,在dongyimai-service-api中创建dongyimai-search-service-api，如下图： pom.xml如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-search-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--goods api依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-sellergoods-serivce-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--springdataes依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-data-elasticsearch\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; (2)搜索微服务搭建\n在dongyimai-service中搭建dongyimai-search-service微服务，并进行相关配置。\npom.xml配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-search-service\u0026lt;/artifactid\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-search-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; application.yml配置\nserver: port: 9005 spring: application: name: search elasticsearch: rest: uris: 192.168.188.128:9200 #此处配置elasticsearch的访问地址 eureka: client: service-url: defaultzone: http://127.0.0.1:8761/eureka instance: prefer-ip-address: true feign: hystrix: enabled: true #超时配置 ribbon: readtimeout: 300000 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 10000 (3)启动类\n创建searchapplication作为搜索微服务工程的启动类，代码如下：\n@springbootapplication(exclude = {druiddatasourceautoconfigure.class, datasourceautoconfiguration.class}) @enableeurekaclient public class searchapplication { public static void main(string[] args) { springapplication.run(searchapplication.class,args); } } 分别创建对应的包，dao、service、controller，如下图： 4.3 数据导入 现在需要将数据从数据库中查询出来，然后将数据导入到es中。 数据导入流程如下：\n1.请求search服务,调用数据导入地址 2.根据注册中心中的注册的goods服务的地址，使用feign方式查询所有已经审核的sku 3.使用springdata es将查询到的sku集合导入到es中 4.3.1 文档映射bean创建 搜索商品的时候，会根据如下属性搜索数据,并且不是所有的属性都需要分词搜索，我们创建javabean，将javabean数据存入到es中要以搜索条件和搜索展示结果为依据，部分关键搜索条件分析如下：\n1.可能会根据商品名称搜索，而且可以搜索商品名称中的任意一个词语，所以需要分词 2.可能会根据商品分类搜索，商品分类不需要分词 3.可能会根据商品品牌搜索，商品品牌不需要分词 4.可能会根据商品商家搜索，商品商家不需要分词 5.可能根据规格进行搜索，规格时一个键值对结构，用map 根据上面的分析，我们可以在dongyimai-search-service-api工程中创建com.offcn.search.pojo.skuinfo，如下\n@document(indexname = \u0026#34;skuinfo\u0026#34;) public class skuinfo implements serializable { //商品id，同时也是商品编号 @id private long id; //sku名称 @field(type = fieldtype.text, analyzer = \u0026#34;ik_smart\u0026#34;) private string title; //商品价格，单位为：元 @field(type = fieldtype.double) private bigdecimal price; //库存数量 private integer num; //商品图片 private string image; //商品状态，1-正常，2-下架，3-删除 private string status; //创建时间 private date createtime; //更新时间 private date updatetime; //是否默认 private string isdefault; //goodsid private long goodsid; //类目id private long categoryid; //类目名称 // @field(type = fieldtype.keyword) private string category; //品牌名称 // @field(type = fieldtype.keyword) private string brand; //规格 private string spec; //规格参数 private map\u0026lt;string,object\u0026gt; specmap; //对应的get、set方法省略 .... } 4.3.2 搜索审核通过sku 修改dongyimai-sellergoods-service微服务，添加搜索审核通过的sku，供search微服务调用。\n下面都是针对goods微服务的操作。\n修改itemservice接口，添加根据状态查询sku方法，代码如下：\n/** * 根据状态查询sku列表 */ list\u0026lt;item\u0026gt; findbystatus(string status); 修改itemserviceimpl，添加根据状态查询sku实现方法，代码如下：\n@override public list\u0026lt;item\u0026gt; findbystatus(string status) { querywrapper\u0026lt;item\u0026gt; querywrapper = new querywrapper\u0026lt;\u0026gt;(); querywrapper.eq(\u0026#34;status\u0026#34;,status); return this.list(querywrapper); } 修改com.offcn.sellergoods.controller.itemcontroller，添加根据审核状态查询sku方法，代码如下：\n/*** * 根据审核状态查询sku * @param status * @return */ @getmapping(\u0026#34;/status/{status}\u0026#34;) public result\u0026lt;list\u0026lt;item\u0026gt;\u0026gt; findbystatus(@pathvariable string status){ list\u0026lt;item\u0026gt; list = itemservice.findbystatus(status); return new result\u0026lt;list\u0026lt;item\u0026gt;\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,list); } 访问地址：http://localhost:9001/item/status/1 4.3.3 sku导入es实现 (1) feign配置\n修改dongyimai-sellergoods-service-api工程，在com.offcn.sellergoods.feign.itemfeign上添加findskulist方法，代码如下：\n@feignclient(value=\u0026#34;dym-sellergoods\u0026#34;) public interface itemfeign { /*** * 根据审核状态查询sku * @param status * @return */ @getmapping(\u0026#34;/item/status/{status}\u0026#34;) result\u0026lt;list\u0026lt;item\u0026gt;\u0026gt; findbystatus(@pathvariable string status); } (2) dao创建\n修改dongyimai-search-service工程，创建com.dongyimai.search.dao.skuesmapper,该接口主要用于索引数据操作，主要使用它来实现将数据导入到es索引库中，代码如下：\n@repository public interface skuesmapper extends elasticsearchrepository\u0026lt;skuinfo,long\u0026gt; { } (3) 服务层创建\n修改dongyimai-search-service工程，创建com.dongyimai.search.service.skuservice,代码如下：\npublic interface skuservice { /*** * 导入sku数据 */ void importsku(); } 修改dongyimai-search-service工程，创建com.offcn.search.service.impl.skuserviceimpl,实现sku数据导入到es中，代码如下：\n@service public class skuserviceimpl implements skuservice { @autowired private skuesmapper skuesmapper; @autowired private itemfeign itemfeign; @override public void importsku() { //调用商品微服务，获取sku商品数据 result\u0026lt;list\u0026lt;item\u0026gt;\u0026gt; result = itemfeign.findbystatus(\u0026#34;1\u0026#34;); //把返回的结果返回搜索实体类数据集合(采用深克隆技术，把item对象属性值复制到skuinfo对象) list\u0026lt;skuinfo\u0026gt; skuinfolist = json.parsearray(json.tojsonstring(result.getdata()), skuinfo.class); //遍历sku集合 for (skuinfo skuinfo : skuinfolist) { //获取规格json字符串，转换为map对象 map\u0026lt;string,object\u0026gt; map = json.parseobject(skuinfo.getspec(), map.class); //关联设置到specmap skuinfo.setspecmap(specmap); } //保存sku集合数据到es skuesmapper.saveall(skuinfolist); } } (4)控制层配置\n修改dongyimai-search-service工程，在com.offcn.search.controller.skucontroller类中添加如下方法调用上述导入方法，代码如下：\n@restcontroller @requestmapping(value = \u0026#34;/search\u0026#34;) @crossorigin public class skucontroller { @autowired private skuservice skuservice; /** * 导入数据 * @return */ @getmapping(\u0026#34;/import\u0026#34;) public result search(){ skuservice.importsku(); return new result(true, statuscode.ok,\u0026#34;导入数据到索引库中成功！\u0026#34;); } } (5)修改启动类\n启动类中需要开启feign客户端，并且需要添加es包扫描，代码如下：\n@springbootapplication(exclude={datasourceautoconfiguration.class}) @enableeurekaclient @enablefeignclients(basepackages = \u0026#34;com.offcn.sellergoods.feign\u0026#34;) @enableelasticsearchrepositories(basepackages = \u0026#34;com.offcn.search.dao\u0026#34;) public class searchapplication { public static void main(string[] args) { springapplication.run(searchapplication.class,args); } } 注意如果出现错误： 解决办法，修改application.yml增加如下配置：\nspring: main: allow-bean-definition-overriding: true (6)测试\n调用http://localhost:9005/search/import进行测试\n打开kibana可以看到如下数据：\nhttp://192.168.188.128:5601\nget /skuinfo/_search 五、关键字搜索 我们先使用springdataelasticsearch实现一个简单的搜索功能，先实现根据关键字搜索，从上面搜索图片可以看得到，每次搜索的时候，除了关键字外，还有可能有品牌、分类、规格等，后台接收搜索条件使用map接收比较合适。\n5.1 服务层实现 修改search服务的com.offcn.search.service.skuservice,添加搜索方法，代码如下：\n/*** * 搜索 * @param searchmap * @return */ map search(map\u0026lt;string, string\u0026gt; searchmap); 修改search服务的com.dongyimai.search.service.impl.skuserviceimpl,添加搜索实现方法,代码如下：\n@autowired private elasticsearchresttemplate elasticsearchresttemplate; public map search(map\u0026lt;string, string\u0026gt; searchmap) { //1.获取关键字的值 string keywords = searchmap.get(\u0026#34;keywords\u0026#34;); if (stringutils.isempty(keywords)) { keywords = \u0026#34;华为\u0026#34;;//赋值给一个默认的值 } //2.创建查询对象 的构建对象 nativesearchquerybuilder nativesearchquerybuilder = new nativesearchquerybuilder(); //3.设置查询的条件 //使用：querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords) ，搜索华为 ---\u0026gt; 华 为 二字可以拆分查询， //使用：querybuilders.matchphrasequery(\u0026#34;title\u0026#34;, keywords) 华为二字不拆分查询 nativesearchquerybuilder.withquery(querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords)); //4.构建查询对象 nativesearchquery query = nativesearchquerybuilder.build(); //5.执行查询 searchhits\u0026lt;skuinfo\u0026gt; searchhits = elasticsearchresttemplate.search(query, skuinfo.class); //对搜索searchhits集合进行分页封装 searchpage\u0026lt;skuinfo\u0026gt; skupage = searchhitsupport.searchpagefor(searchhits, query.getpageable()); //遍历取出查询的商品信息 list\u0026lt;skuinfo\u0026gt; skulist=new arraylist\u0026lt;\u0026gt;(); for (searchhit\u0026lt;skuinfo\u0026gt; searchhit :skupage.getcontent()) { // 获取搜索到的数据 skuinfo content = (skuinfo) searchhit.getcontent(); skuinfo skuinfo = new skuinfo(); //把一个对象属性值复制到另外一个对象：两个对象属性名称必须一致，属性类型必须相同 beanutils.copyproperties(content, skuinfo); skulist.add(skuinfo); } //6.返回结果 map resultmap = new hashmap\u0026lt;\u0026gt;(); resultmap.put(\u0026#34;rows\u0026#34;, skulist);//获取所需skuinfo集合数据内容 resultmap.put(\u0026#34;total\u0026#34;,searchhits.gettotalhits());//总记录数 resultmap.put(\u0026#34;totalpages\u0026#34;, skupage.gettotalpages());//总页数 return resultmap; } 注意: elasticsearchtemplate更多是对esrepository的补充，里面提供了一些更底层的方法,更加适用于查询数据\n5.2 控制层实现 修改com.offcn.search.controller.skucontroller，在控制层调用service层即可，代码如下：\n/** * 搜索 * @param searchmap * @return */ @postmapping public map search(@requestbody(required = false) map searchmap){ return skuservice.search(searchmap); } 5.3 测试 使用postman工具，输入http://localhost:9005/search\n选中post提交 六、 分类统计 6.1 分类统计分析 看下面的sql语句，我们在执行搜索的时候，第1条sql语句是执行搜，第2条语句是根据分类名字分组查看有多少分类，大概执行了2个步骤就可以获取数据结果以及分类统计，我们可以发现他们的搜索条件完全一样。\n-- 查询所有 select * from tb_item where title like \u0026#39;%手机%\u0026#39;; -- 根据分类名字分组查询 select category from tb_item where title like \u0026#39;%手机%\u0026#39; group by category; 我们每次执行搜索的时候，需要显示商品分类名称，这里要显示的分类名称其实就是符合搜素条件的所有商品的分类集合，我们可以按照上面的实现思路，使用es根据分组名称做一次分组查询即可实现。\n6.2 分类分组统计实现 修改search微服务的com.offcn.search.service.impl.skuserviceimpl类，整体代码如下：\npublic map search(map\u0026lt;string, string\u0026gt; searchmap) { //1.获取关键字的值 string keywords = searchmap.get(\u0026#34;keywords\u0026#34;); if (stringutils.isempty(keywords)) { keywords = \u0026#34;华为\u0026#34;;//赋值给一个默认的值 } //2.创建查询对象 的构建对象 nativesearchquerybuilder nativesearchquerybuilder = new nativesearchquerybuilder(); // 设置分组的条件 terms后表示分组查询后的列名,注意搜索字段后面加.keyword nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skucategorygroup\u0026#34;).field(\u0026#34;category.keyword\u0026#34;)); //3.设置查询的条件 //使用：querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords) ，搜索华为 ---\u0026gt; 华 为 二字可以拆分查询， //使用：querybuilders.matchphrasequery(\u0026#34;title\u0026#34;, keywords) 华为二字不拆分查询 nativesearchquerybuilder.withquery(querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords)); //4.构建查询对象 nativesearchquery query = nativesearchquerybuilder.build(); //5.执行查询 searchhits\u0026lt;skuinfo\u0026gt; searchhits = elasticsearchresttemplate.search(query, skuinfo.class); //对搜索searchhits集合进行分页封装 searchpage\u0026lt;skuinfo\u0026gt; skupage = searchhitsupport.searchpagefor(searchhits, query.getpageable()); //获取分组结果 terms terms = searchhits.getaggregations().get(\u0026#34;skucategorygroup\u0026#34;); // 获取分类名称集合 list\u0026lt;string\u0026gt; categorylist = new arraylist\u0026lt;\u0026gt;(); if (terms != null) { for (terms.bucket bucket : terms.getbuckets()) { string keyasstring = bucket.getkeyasstring();// 分组的值（分类名称） categorylist.add(keyasstring); } } //遍历取出查询的商品信息 list\u0026lt;skuinfo\u0026gt; skulist=new arraylist\u0026lt;\u0026gt;(); for (searchhit\u0026lt;skuinfo\u0026gt; searchhit :skupage.getcontent()) { // 获取搜索到的数据 skuinfo content = (skuinfo) searchhit.getcontent(); skuinfo skuinfo = new skuinfo(); beanutils.copyproperties(content, skuinfo); skulist.add(skuinfo); } //6.返回结果 map resultmap = new hashmap\u0026lt;\u0026gt;(); resultmap.put(\u0026#34;rows\u0026#34;, skulist);//获取所需skuinfo集合数据内容 resultmap.put(\u0026#34;total\u0026#34;,searchhits.gettotalhits());//总记录数 resultmap.put(\u0026#34;totalpages\u0026#34;, skupage.gettotalpages());//总页数 resultmap.put(\u0026#34;categorylist\u0026#34;,categorylist); return resultmap; } 添加的代码如下: 注意分组搜索要加keyword，因为数据存储结构是keyword类型\n具体查看数据结构可以使用如下指令：\nget /skuinfo/_mapping 6.3 测试 请求http://localhost:9005/search 6.4 代码优化 如上,可以将获取分组的代码进行提取,如下代码所示:\n/** * 获取分类列表数据 * @param terms * @return **/ private list\u0026lt;string\u0026gt; getstringscategorylist(terms terms) { list\u0026lt;string\u0026gt; categorylist = new arraylist\u0026lt;\u0026gt;(); if (terms != null) { for (terms.bucket bucket : terms.getbuckets()) { string keyasstring = bucket.getkeyasstring();// 分组的值（分类名称） categorylist.add(keyasstring); } } return categorylist; } 在search方法中进行调用: // 获取分类名称集合 list\u0026lt;string\u0026gt; categorylist = this.getstringscategorylist(terms); 整体代码如下：\npackage com.offcn.search.service.impl; import com.alibaba.fastjson.json; import com.offcn.entity.result; import com.offcn.search.dao.skuesmapper; import com.offcn.search.pojo.skuinfo; import com.offcn.search.service.skuservice; import com.offcn.sellergoods.feign.skufeign; import com.offcn.sellergoods.pojo.item; import org.apache.commons.lang.stringutils; import org.elasticsearch.index.query.querybuilders; import org.elasticsearch.search.aggregations.aggregationbuilders; import org.elasticsearch.search.aggregations.bucket.terms.terms; import org.springframework.beans.beanutils; import org.springframework.beans.factory.annotation.autowired; import org.springframework.data.elasticsearch.core.*; import org.springframework.data.elasticsearch.core.query.nativesearchquery; import org.springframework.data.elasticsearch.core.query.nativesearchquerybuilder; import org.springframework.stereotype.service; import java.util.arraylist; import java.util.hashmap; import java.util.list; import java.util.map; @service public class skuserviceimpl implements skuservice { @autowired private skuesmapper skuesmapper; @autowired private skufeign skufeign; /*** * 导入sku数据 */ @override public void importsku() { //调用商品微服务，获取sku商品数据 result\u0026lt;list\u0026lt;item\u0026gt;\u0026gt; result = skufeign.findbystatus(\u0026#34;1\u0026#34;); //把数据转换为搜索实体类数据 list\u0026lt;skuinfo\u0026gt; skuinfolist = json.parsearray(json.tojsonstring(result.getdata()), skuinfo.class); //遍历sku集合 for (skuinfo skuinfo : skuinfolist) { //获取规格 map\u0026lt;string, object\u0026gt; specmap = json.parseobject(skuinfo.getspec()); //关联设置到specmap skuinfo.setspecmap(specmap); } //保存sku集合数据到es skuesmapper.saveall(skuinfolist); } @autowired private elasticsearchresttemplate elasticsearchresttemplate; public map search(map\u0026lt;string, string\u0026gt; searchmap) { //1.获取关键字的值 string keywords = searchmap.get(\u0026#34;keywords\u0026#34;); if (stringutils.isempty(keywords)) { keywords = \u0026#34;华为\u0026#34;;//赋值给一个默认的值 } //2.创建查询对象 的构建对象 nativesearchquerybuilder nativesearchquerybuilder = new nativesearchquerybuilder(); // 设置分组的条件 terms后表示分组查询后的列名 nativesearchquerybuilder.addaggregation(aggregationbuilders.terms(\u0026#34;skucategorygroup\u0026#34;).field(\u0026#34;category.keyword\u0026#34;)); //3.设置查询的条件 //使用：querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords) ，搜索华为 ---\u0026gt; 华 为 二字可以拆分查询， //使用：querybuilders.matchphrasequery(\u0026#34;title\u0026#34;, keywords) 华为二字不拆分查询 nativesearchquerybuilder.withquery(querybuilders.matchquery(\u0026#34;title\u0026#34;, keywords)); //4.构建查询对象 nativesearchquery query = nativesearchquerybuilder.build(); //5.执行查询 searchhits\u0026lt;skuinfo\u0026gt; searchhits = elasticsearchresttemplate.search(query, skuinfo.class); //对搜索searchhits集合进行分页封装 searchpage\u0026lt;skuinfo\u0026gt; skupage = searchhitsupport.searchpagefor(searchhits, query.getpageable()); //获取分组结果 terms terms = searchhits.getaggregations().get(\u0026#34;skucategorygroup\u0026#34;); // 获取分类名称集合 list\u0026lt;string\u0026gt; categorylist = this.getstringscategorylist(terms); //遍历取出查询的商品信息 list\u0026lt;skuinfo\u0026gt; skulist=new arraylist\u0026lt;\u0026gt;(); for (searchhit\u0026lt;skuinfo\u0026gt; searchhit :skupage.getcontent()) { // 获取搜索到的数据 skuinfo content = (skuinfo) searchhit.getcontent(); skuinfo skuinfo = new skuinfo(); beanutils.copyproperties(content, skuinfo); skulist.add(skuinfo); } //6.返回结果 map resultmap = new hashmap\u0026lt;\u0026gt;(); resultmap.put(\u0026#34;rows\u0026#34;, skulist);//获取所需skuinfo集合数据内容 resultmap.put(\u0026#34;total\u0026#34;,searchhits.gettotalhits());//总记录数 resultmap.put(\u0026#34;totalpages\u0026#34;, skupage.gettotalpages());//总页数 resultmap.put(\u0026#34;categorylist\u0026#34;,categorylist); return resultmap; } /** * 获取分类列表数据 * @param terms * @return **/ private list\u0026lt;string\u0026gt; getstringscategorylist(terms terms) { list\u0026lt;string\u0026gt; categorylist = new arraylist\u0026lt;\u0026gt;(); if (terms != null) { for (terms.bucket bucket : terms.getbuckets()) { string keyasstring = bucket.getkeyasstring();// 分组的值（分类名称） categorylist.add(keyasstring); } } return categorylist; } } ","date":"2022-05-27","permalink":"https://lovemjh.vercel.app/posts/project-0/20220527224880/","summary":"第六章 搜索解决方案-Elasticsearch 优就业.JAVA教研室 学习目标 Elasticsearch、Kibana环境配置 DSL语句讲解 商品索引库导入讲解 商品","title":"搜索解决方案-elasticsearch"},{"content":"第九章 消息队列及短信发送平台 优就业.java教研室 学习目标 了解常见的mq产品 了解rabbitmq的5种消息模型 会使用springboot整合amqp 短信发送平台 短信服务 用户注册 一、介绍 1.消息队列（mq） 1.1 什么是消息队列 消息队列，即mq，message queue。 消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。\n如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。\n1.2 amqp和jms mq是消息通信的模型，并不是具体实现。现在实现mq的有两种主流方式：amqp、jms。 两者间的区别和联系：\njms是定义了统一的接口，来对消息操作进行统一；amqp是通过规定协议来统一数据交互的格式 jms限定了必须使用java语言；amqp只是协议，不规定实现方式，因此是跨语言的。 jms规定了两种消息模型；而amqp的消息模型更加丰富 1.3 常见mq产品 activemq：基于jms rabbitmq：基于amqp协议，erlang语言开发，稳定性好 rocketmq：基于jms，阿里巴巴产品，目前交由apache基金会 kafka：分布式消息系统，高吞吐量 2. rabbitmq rabbitmq是基于amqp的一款消息管理系统\n官网： http://www.rabbitmq.com/\n官方教程：http://www.rabbitmq.com/getstarted.html 3. 五种消息模型 rabbitmq提供了6种消息模型，但是第6种其实是rpc，并不是mq，因此不予学习。那么也就剩下5种。\n但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。 二、rabbitmq安装 1 docker镜像下载 docker pull rabbitmq:management 注意：如果docker pull rabbitmq 后面不带management，启动rabbitmq后是无法打开管理界面的，所以我们要下载带management插件的rabbitmq.\n2.查看docker镜像 docker images 3.创建rabbitmq容器 docker run -di -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management 4.访问管理界面 访问管理界面的地址就是 http://192.168.188.128:15672，可以使用默认的账户登录，用户名和密码都guest\n三、springboot整合amqp 1. 简单队列模式（queue） rabbitmq是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，rabbitmq是邮政信箱，邮局和邮递员。\nrabbitmq与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。**** p（producer/ publisher）：生产者，一个发送消息的用户应用程序。\nc（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序\n队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。\n总之：\n生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。\n我们将用springboot编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。\n我们将调用我们的消息发布者（发送者）send和我们的消息消费者（接收者）recv。发布者将连接到rabbitmq，发送一条消息，然后退出。\n1.1 导入依赖 pom.xml 代码如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.3.9.release\u0026lt;/version\u0026gt; \u0026lt;relativepath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-amqp-demo01\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.0.1-snapshot\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;spring-amqp-demo01\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;demo project for spring boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.junit.vintage\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit-vintage-engine\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.amqp\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-rabbit-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 1.2 修改配置文件 application.yml，代码如下\nspring: rabbitmq: host: 192.168.188.128 port: 5672 username: guest password: guest 1.3 创建配置类 package com.offcn.config; import org.springframework.amqp.core.queue; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; @configuration public class simplequeueconfig { /** * 定义简单队列名 */ private string simplequeue = \u0026#34;spring.test.queue\u0026#34;; @bean public queue simplequeue() { return new queue(simplequeue); } } 注意：queue不要导错包\n1.4 发送端 import org.springframework.amqp.rabbit.core.rabbittemplate; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller public class sendcontroller { @autowired private rabbittemplate rabbittemplate; @requestmapping(\u0026#34;/\u0026#34;) public void send() { for(int i=0;i\u0026lt;5;i++) { rabbittemplate.convertandsend(\u0026#34;spring.test.queue\u0026#34;, \u0026#34;简单队列消息\u0026#34;+i); } } } 1.5 接收端 import org.springframework.amqp.rabbit.annotation.rabbitlistener; import org.springframework.stereotype.component; @component public class receivelistener { @rabbitlistener(queues= \u0026#34;spring.test.queue\u0026#34;) public void recieve(string message) { system.out.println(message); } } 1.6 输出 访问http://localhost:8080/\n控制台输出 2.work消息模型 工作队列或者竞争消费者模式 创建一个工作队列，在多个工作者之间分配耗时任务。\n工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。\n这个概念在web应用程序中特别有用，因为在短的http请求窗口中无法处理复杂的任务。\n接下来我们来模拟这个流程：\n​ p：生产者：任务的发布者\n​ c1：消费者，领取任务并且完成任务，假设完成速度较快\n​ c2：消费者2：领取任务并完成任务，假设完成速度慢\n面试题：避免消息堆积？\n1） 采用workqueue，多个消费者监听同一队列。\n2）接收到消息以后，而是通过线程池，异步消费。\n2.1 创建配置类 @configuration public class workqueueconfig { /** * 队列名. */ private final string work = \u0026#34;work_queue\u0026#34;; @bean public queue workqueue() { return new queue(work); } } 2.2 发送端 @restcontroller public class sendcontroller { @autowired private rabbittemplate rabbittemplate; @requestmapping(\u0026#34;/\u0026#34;) public void send() { for (int i = 0; i \u0026lt; 50; i++) { string message = \u0026#34;工作队列消息\u0026#34; + i; rabbittemplate.convertandsend(\u0026#34;work_queue\u0026#34;, message); } } } 这里我们循环发送50条消息\n2.3 接收端 @component public class receivelistener { @rabbitlistener(queues = \u0026#34;work_queue\u0026#34;) public void recieve1(string message) { system.out.println(\u0026#34;listener1:\u0026#34; + message); try { thread.sleep(1000); } catch (interruptedexception e) { e.printstacktrace(); } } @rabbitlistener(queues = \u0026#34;work_queue\u0026#34;) public void recieve2(string message) { system.out.println(\u0026#34;listener2:\u0026#34; + message); } } 我们在消费者1里设置延时时间，模式消费耗时\n2.4 输出 访问http://localhost:8080/\n控制台输出\n可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发，并且平均分配。\n2.5 能者多劳 刚才的实现有问题吗？\n消费者1比消费者2的效率要低，一次任务的耗时较长 然而两人最终消费的消息数量是一样的 消费者2大量时间处于空闲状态，消费者1一直忙碌 现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。\n怎么实现呢？\n我们可以设置每次只处理一个信息，告诉rabbitmq一次不要向消费端发送多于一条消息。 或者换句话说，不要向消费端发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是处于忙碌状态的下一个消费端。\n修改配置文件，如下： 再次运行程序，效果如下：\n3. 发布者订阅者模式（publish/subscribe） 在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。\n解读：\n1、1个生产者，多个消费者\n2、每一个消费者都有自己的一个队列\n3、生产者没有将消息直接发送到队列，而是发送到了交换机\n4、每个队列都要绑定到交换机\n5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的\nx（exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于exchange的类型。\nexchange类型有以下几种：\n​ fanout：广播，将消息交给所有绑定到交换机的队列\n​ direct：定向，把消息交给符合指定routing key 的队列\n​ topic：通配符，把消息交给符合routing pattern（路由模式） 的队列\n我们这里先学习\n​\tfanout：即广播模式\nexchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n3.1 创建配置类 @configuration public class fanoutqueueconfig { /** * 声明队列名 */ private final string fanout1 = \u0026#34;fanout_queue_1\u0026#34;; private final string fanout2 = \u0026#34;fanout_queue_2\u0026#34;; /** * 声明交换机的名字. */ private final string fanoutexchange = \u0026#34;fanoutexchange\u0026#34;; //声明队列1 @bean public queue fanoutqueue1(){ return new queue(fanout1); } //声明队列2 @bean public queue fanoutqueue2(){ return new queue(fanout2); } //声明交换机 @bean public fanoutexchange exchange(){ return new fanoutexchange(fanoutexchange); } //绑定交换机到队列1 @bean public binding bindingqueue1(){ return bindingbuilder.bind(fanoutqueue1()).to(exchange()); } //绑定交换机到队列2 @bean public binding bindingqueue2(){ return bindingbuilder.bind(fanoutqueue2()).to(exchange()); } } 3.2 发送端 package com.offcn.controller; import org.springframework.amqp.rabbit.core.rabbittemplate; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller public class sendcontroller { @autowired private rabbittemplate rabbittemplate; @requestmapping(\u0026#34;/\u0026#34;) public void send() { for (int i = 0; i \u0026lt; 5; i++) { string message = \u0026#34;订阅模式消息\u0026#34; + i; rabbittemplate.convertandsend(\u0026#34;fanoutexchange\u0026#34;, \u0026#34;\u0026#34;, message); } } } 注意：发送消息有三个参数，中间参数为路由key。\n3.3 接收端 package com.offcn.listener; import org.springframework.amqp.rabbit.annotation.rabbitlistener; import org.springframework.stereotype.component; @component public class receivelistener { @rabbitlistener(queues = \u0026#34;fanout_queue_1\u0026#34;) public void recieve1(string message) { system.out.println(\u0026#34;listener1:\u0026#34; + message); } @rabbitlistener(queues = \u0026#34;fanout_queue_2\u0026#34;) public void recieve2(string message) { system.out.println(\u0026#34;listener2:\u0026#34; + message); } } 3.3 输出 访问 http://localhost:8080/\n输出 控制台打印 ，发现两个绑定了不同队列的消费者都接受到了同一条消息 查看rabbitmq 服务器： 4.路由模式（direct） 有选择性的接收消息\n在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。\n在路由模式中，我们将添加一个功能 - 只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。\n但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到direct类型的exchange。\n在direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个routingkey（路由key）\n消息的发送方在向exchange发送消息时，也必须指定消息的routing key。 p：生产者，向exchange发送消息，发送消息时，会指定一个routing key。\nx：exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列\nc1：消费者，其所在队列指定了需要routing key 为 error 的消息\nc2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息\n4.1 创建配置类 @configuration public class directqueueconfig { /** * 声明队列名. */ private final string direct1 = \u0026#34;direct_queue_1\u0026#34;; private final string direct2 = \u0026#34;direct_queue_2\u0026#34;; /** * 声明交换机的名字. */ private final string directexchange = \u0026#34;directexchange\u0026#34;; //队列1 @bean public queue directqueue1(){ return new queue(direct1); } //队列2 @bean public queue directqueue2(){ return new queue(direct2); } //交换机 @bean public directexchange directexchange(){ return new directexchange(directexchange); } //绑定队列1到交换机 @bean public binding bindingdirectexchange1(){ return bindingbuilder.bind(directqueue1()).to(directexchange()).with(\u0026#34;update\u0026#34;); } //绑定队列2到交换机 @bean public binding bindingdirectexchange2(){ return bindingbuilder.bind(directqueue2()).to(directexchange()).with(\u0026#34;add\u0026#34;); } } 4.2 发送端 @restcontroller public class sendcontroller { @autowired private rabbittemplate rabbittemplate; @requestmapping(\u0026#34;/send01\u0026#34;) public void sendmessagea() { for (int i = 0; i \u0026lt; 5; i++) { string message = \u0026#34;路由模式--routingkey=update消息\u0026#34; + i; system.out.println(\u0026#34;我是生产信息的：\u0026#34; + message); rabbittemplate.convertandsend(\u0026#34;directexchange\u0026#34;, \u0026#34;update\u0026#34;, message); } } @requestmapping(\u0026#34;/send02\u0026#34;) public void sendmessageb() { for (int i = 0; i \u0026lt; 5; i++) { string message = \u0026#34;路由模式--routingkey=add消息\u0026#34; + i; system.out.println(\u0026#34;我是生产信息的：\u0026#34; + message); rabbittemplate.convertandsend(\u0026#34;directexchange\u0026#34;, \u0026#34;add\u0026#34;, message); } } } 4.3 接收端 @component public class receivelistener { @rabbitlistener(queues = \u0026#34;direct_queue_1\u0026#34;) public void recieve1(string message) { system.out.println(\u0026#34;listener1:\u0026#34; + message); } @rabbitlistener(queues = \u0026#34;direct_queue_2\u0026#34;) public void recieve2(string message) { system.out.println(\u0026#34;listener2:\u0026#34; + message); } } 4.4 输出 访问http://localhost:8080/send01 访问http://localhost:8080/send02 5. 主题模式（topic） topic类型的exchange与direct相比，都是可以根据routingkey把消息路由到不同的队列。只不过topic类型exchange可以让队列在绑定routing key 的时候使用通配符！\nroutingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert\n通配符规则：\n​ #：匹配一个或多个词\n​ *：匹配不多不少恰好1个词\n举例：\n​ audit.#：能够匹配audit.irs.corporate 或者 audit.irs\n​ audit.*：只能匹配audit.irs\n在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“\u0026lt;speed\u0026gt;.\u0026lt;color\u0026gt;.\u0026lt;species\u0026gt;”。\n我们创建了三个绑定：q1绑定了绑定键“* .orange.*”，q2绑定了“*.*.rabbit”和“lazy.＃”。\nq1匹配所有的橙色动物。\nq2匹配关于兔子以及懒惰动物的消息。\n5.1 创建配置类 @configuration public class topicqueueconfig { /** * 声明队列名. */ private final string topic1 = \u0026#34;topic_queue_1\u0026#34;; private final string topic2 = \u0026#34;topic_queue_2\u0026#34;; /** * 声明交换机的名字. */ private final string topicexchange = \u0026#34;topicexchange\u0026#34;; /** * 声明队列. * * @return */ @bean public queue topicqueue1() { return new queue(topic1); } @bean public queue topicqueue2() { return new queue(topic2); } /** * 声明路由交换机. * * @return */ @bean public topicexchange topicexchange() { return new topicexchange(topicexchange); } //绑定队列到交换机--支持通配符路由key @bean public binding bindingtopicexchange1(){ return bindingbuilder.bind(topicqueue1()).to(topicexchange()).with(\u0026#34;topic.keya\u0026#34;); } //绑定队列到交换机--支持通配符路由key @bean public binding bindingtopicexchange2(){ return bindingbuilder.bind(topicqueue2()).to(topicexchange()).with(\u0026#34;topic.#\u0026#34;); } } 5.2 发送端 package com.offcn.controller; import org.springframework.amqp.rabbit.core.rabbittemplate; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller public class sendcontroller { @autowired private rabbittemplate rabbittemplate; @requestmapping(\u0026#34;/send01\u0026#34;) public void send01() { for (int i = 0; i \u0026lt; 5; i++) { string message = \u0026#34;通配符模式--routingkey=topic.keya消息\u0026#34; + i; system.out.println(\u0026#34;我是生产信息的：\u0026#34; + message); rabbittemplate.convertandsend(\u0026#34;topicexchange\u0026#34;, \u0026#34;topic.keya\u0026#34;, message); } } @requestmapping(\u0026#34;/send02\u0026#34;) public void send02(){ for (int i = 0; i \u0026lt; 5; i++) { string message = \u0026#34;通配符模式--routingkey=topic.#消息\u0026#34; + i; system.out.println(\u0026#34;我是生产信息的：\u0026#34; + message); rabbittemplate.convertandsend(\u0026#34;topicexchange\u0026#34;, \u0026#34;topic.keyd.keye\u0026#34;, message); } } } 5.3 接收端 import org.springframework.amqp.rabbit.annotation.rabbitlistener; import org.springframework.stereotype.component; @component public class receivelistener { @rabbitlistener(queues = \u0026#34;topic_queue_1\u0026#34;) public void recieve1(string message) { system.out.println(\u0026#34;listener1:\u0026#34; + message); } @rabbitlistener(queues = \u0026#34;topic_queue_2\u0026#34;) public void recieve2(string message) { system.out.println(\u0026#34;listener2:\u0026#34; + message); } } 5.4 输出 访问http://localhost:8080/send01\n输出，发现两个消费者都能消费 访问http://localhost:8080/send02\n输出，发现只有消费者2 可以消费 查看rabbitmq 服务器： 四、短信发送平台-106三网短信 1 106三网短信 ​ 山东鼎信（decent）——专业106短信平台，短信验证码api接口调用，可免费试用短信接口，让app、网站、小程序快速实现短信注册、短信认证，短信登陆、密码找回短信、支付认证短信、通知短信，提供短信验证码、短信通知服务直连短信通道，3s必达，99%到达率，可辅助人脸识别进行验证，7x24小时技术服务。提供验证码传递下发短信服务，三网合一的高质量专用通道，金融级安全保护。\n2 准备工作 2.1购买“106三网短信” 首先我们先进入“阿里云” https://www.aliyun.com/ 搜索 106三网短信 点击进入 说明：进入时请认准 官方logo\n进行购买 购买之后，自动进入订单列表 注意：免费试用只有5次。\n2.2进行测试 此时，目标手机就可以查收到短信。 2.3 通过java代码测试 参考：\nhttps://market.aliyun.com/products/56928004/cmapi023305.html?spm=5176.2020520132.101.3.4b697218kugzh1#sku=yuncode1730500007\npackage com.offcn.sms; import java.util.hashmap; import java.util.map; import com.offcn.user.utils.httputils; import org.apache.http.httpresponse; public class smstest { public static void main(string[] args) { string host = \u0026#34;http://dingxin.market.alicloudapi.com\u0026#34;; string path = \u0026#34;/dx/sendsms\u0026#34;; string method = \u0026#34;post\u0026#34;; string appcode = \u0026#34;f44b943718534....504b8e01f393\u0026#34;; // 输入自己的appcode map\u0026lt;string, string\u0026gt; headers = new hashmap\u0026lt;string, string\u0026gt;(); // 最后在header中的格式(中间是英文空格)为authorization:appcode 83359fd73fe94948385f570e3c139105 headers.put(\u0026#34;authorization\u0026#34;, \u0026#34;appcode \u0026#34; + appcode); map\u0026lt;string, string\u0026gt; querys = new hashmap\u0026lt;string, string\u0026gt;(); querys.put(\u0026#34;mobile\u0026#34;, \u0026#34;177xxxx8520\u0026#34;); // 输入正确的手机号码 querys.put(\u0026#34;param\u0026#34;, \u0026#34;code:123456\u0026#34;); querys.put(\u0026#34;tpl_id\u0026#34;, \u0026#34;tp1711063\u0026#34;); map\u0026lt;string, string\u0026gt; bodys = new hashmap\u0026lt;string, string\u0026gt;(); try { /** * 重要提示如下: httputils请从 * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/src/main/java/com/aliyun/api/gateway/demo/util/httputils.java * 下载 * * 相应的依赖请参照 * https://github.com/aliyun/api-gateway-demo-sign-java/blob/master/pom.xml */ httpresponse response = httputils.dopost(host, path, method, headers, querys, bodys); system.out.println(response.tostring()); // 获取response的body // system.out.println(entityutils.tostring(response.getentity())); //{\u0026#34;return_code\u0026#34;:\u0026#34;00000\u0026#34;,\u0026#34;order_id\u0026#34;:\u0026#34;aly1549881237643456814\u0026#34;} } catch (exception e) { e.printstacktrace(); } } } httputils安装\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.httpcomponents\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;httpclient\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;\t\u0026lt;dependency\u0026gt;\t\u0026lt;groupid\u0026gt;org.apache.httpcomponents\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;httpcore\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;\t五 短信服务 1 需求分析 构建一个短信发送服务，接收rabbitmq的消息（map类型），采用简单队列模式 、消息包括手机号（mobile）、参数字符串（param ）\n2 工程搭建 （1） 创建工程dongyimai-sms-service （war工程），pom文件引入依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-sms-service\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fastjson\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.15\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; (2) 创建配置文件 application.yml\nserver: port: 9006 spring: application: name: sms rabbitmq: host: 192.168.188.128 port: 5672 username: guest password: guest sms: appcode: b6972xxxxxxxfc0cdb62c48 #使用自己的appcode tpl_id: tp1711063 # 默认模板 (3)创建配置类\npackage com.offcn.config; import org.springframework.amqp.core.queue; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; @configuration public class simplequeueconfig { /** * 定义简单队列名 */ private string simplequeue = \u0026#34;dongyimai.sms.queue\u0026#34;; @bean public queue simplequeue() { return new queue(simplequeue); } } (3) 短信工具类\n参照之前的短信demo创建短信工具类，并将httputils.java拷贝到com.offcn.util目录下\npackage com.offcn.sms.utils; import com.offcn.uitls.httputils; import org.apache.http.httpentity; import org.apache.http.httpresponse; import org.apache.http.util.entityutils; import org.springframework.beans.factory.annotation.value; import org.springframework.stereotype.component; import java.util.hashmap; import java.util.map; @component public class smsutil { //注入短信发送相关参数：appcode @value(\u0026#34;${sms.appcode}\u0026#34;) private string appcode; //注入模板编号 @value(\u0026#34;${sms.tpl_id}\u0026#34;) private string tpl_id; //定义短信发送主机地址 private string host=\u0026#34;http://dingxin.market.alicloudapi.com\u0026#34;; //接口访问路径 private string path=\u0026#34;/dx/sendsms\u0026#34;; //请求方法 private string method=\u0026#34;post\u0026#34;; //编写一个短信发送方法 public string smssend(string mobile,string code){ //创建一个map封装请求头数据 map\u0026lt;string,string\u0026gt; headers=new hashmap\u0026lt;\u0026gt;(); //首先在请求封装身份验证appcode headers.put(\u0026#34;authorization\u0026#34;,\u0026#34;appcode \u0026#34;+appcode); //创建一个map封装请求参数 map\u0026lt;string, string\u0026gt; querys=new hashmap\u0026lt;\u0026gt;(); //需发送的手机号码 querys.put(\u0026#34;mobile\u0026#34;,mobile); //设置模板变量参数 querys.put(\u0026#34;param\u0026#34;,\u0026#34;code:\u0026#34;+code); //设置模板编号 querys.put(\u0026#34;tpl_id\u0026#34;,tpl_id); //创建一个map封装body map\u0026lt;string, string\u0026gt; bodys=new hashmap\u0026lt;\u0026gt;(); //调用httputils发出短信发送请求 try { httpresponse response = httputils.dopost(host, path, method, headers, querys, bodys); //获取响应状态码 int statuscode = response.getstatusline().getstatuscode(); //判断状态码是否等于200 if(statuscode==200){ //获取响应结果封装对象 httpentity entity = response.getentity(); //把响应结果封装对象转换为字符串 string responsestr = entityutils.tostring(entity, \u0026#34;utf-8\u0026#34;); return responsestr; } } catch (exception e) { e.printstacktrace(); } return null; } } (4) 消息监听类\n创建smslistener.java\npackage com.offcn.listener; import com.offcn.utils.smsutil; import org.springframework.amqp.rabbit.annotation.rabbitlistener; import org.springframework.beans.factory.annotation.autowired; import org.springframework.stereotype.component; import java.util.map; @component public class smslistener { @autowired private smsutil smsutil; @rabbitlistener(queues = \u0026#34;dongyimai.sms.queue\u0026#34;) public void getmessage(map\u0026lt;string,string\u0026gt; map) throws exception { if (map == null) { return; } string mobile = map.get(\u0026#34;mobile\u0026#34;); string code = map.get(\u0026#34;code\u0026#34;); // 发送短信 smsutil.sendsms(mobile,code); } } (5) 测试短信发送\n找到上面编写的消息发送测试程序，修改如下\n@restcontroller public class sendcontroller { @autowired private rabbittemplate rabbittemplate; @requestmapping(\u0026#34;/\u0026#34;) public void send() { map\u0026lt;string, string\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;mobile\u0026#34;, \u0026#34;186xxxx9365\u0026#34;); map.put(\u0026#34;code\u0026#34;, \u0026#34;9999\u0026#34;); rabbittemplate.convertandsend(\u0026#34;dongyimai.sms.queue\u0026#34;, map); } } 注意修改发送队列为目前短信监听队列\n(6) 测试短信发送\n启动dongyimai-sms-service\n观察控制台输出 随后短信也成功发送到你的手机上\n六 用户注册 1 需求分析 完成用户注册功能 2 工程搭建 2.1 用户服务实现层 （1）在dongyiami-service-api创建dongyimai-user-service-api，导入pojo，如图： （2）在dongyimai-service下创建dongyimai-user-service，pom.xml引入依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-service\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-user-service\u0026lt;/artifactid\u0026gt; \u0026lt;!--依赖--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dongyimai-user-service-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 从代码生成器拷贝相关代码： (3）添加配置文件application.yml\nserver: port: 9007 spring: application: name: user datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql://localhost:3306/dongyimaidb?useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;servertimezone=utc username: root password: 123456 redis: host: 192.168.188.128 port: 6379 rabbitmq: host: 192.168.188.128 port: 5672 username: guest password: guest eureka: client: service-url: defaultzone: http://localhost:8761/eureka feign: hystrix: enabled: true # 配置sql打印日志 logging: level: com.offcn: debug 2.2 后端服务实现层 修改dongyimai-user-service的userserviceimpl.java\n/** * 增加user * @param user */ @override public void add(user user){ user.setcreated(new date());//创建日期 user.setupdated(new date());//修改日期 bcryptpasswordencoder passwordencoder = new bcryptpasswordencoder(); string password= passwordencoder.encode(user.getpassword()); user.setpassword(password); this.save(user); } 注意：bcryptpasswordencoder加密后的密码串长度过大，把数据表tb_user的password字段长度调整为128位\n3 注册判断短信验证码 3.1实现思路 点击页面上的”获取短信验证码”连接，向后端传递手机号。后端随机生成6位数字作为短信验证码，将其保存在redis中（手机号作为key），并发送到短信网关。\n用户注册时，后端根据手机号查询redis中的验证码与用户填写的验证码是否相同，如果不同则提示用户不能注册。\n3.2生成验证码 （1）修改dongyimai-user-service工程userservice.java ，增加方法\n/** * 生成短信验证码 * @return */ public void createsmscode(string phone); （2）修改dongyimai-user-service工程的userserviceimpl.java\n/** * 生成短信验证码 * * @param phone * @return */ @override public void createsmscode(string phone) { system.out.println(\u0026#34;验证码:\u0026#34;+code); //把验证码存储到redis redistemplate.opsforvalue().set(mobile,code); //设置redis验证码有效期 redistemplate.expire(mobile,5, timeunit.minutes); //发送短信稍后处理 } （3）在 dongyimai-common 添加工具类phoneformatcheckutils.java（资源\\工具类），用于验证手机号\n（4）新增模块dongyimai-user-service的usercontroller.java\n/** * 发送短信验证码 * @param phone * @return */ @getmapping(\u0026#34;/sendcode\u0026#34;) public result sendcode(string phone){ //判断手机号格式 if(!phoneformatcheckutils.isphonelegal(phone)){ return new result(false, statuscode.error,\u0026#34;手机号格式不正确\u0026#34;); } try { userservice.createsmscode(phone);//生成验证码 return new result(true,statuscode.ok, \u0026#34;验证码发送成功\u0026#34;); } catch (exception e) { e.printstacktrace(); return new result(false,statuscode.error, \u0026#34;验证码发送失败\u0026#34;); } } (5)、编写主启动类\npackage com.offcn.user; import org.mybatis.spring.annotation.mapperscan; import org.springframework.amqp.rabbit.annotation.enablerabbit; import org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; import org.springframework.cloud.client.discovery.enablediscoveryclient; @springbootapplication @enablediscoveryclient @mapperscan(\u0026#34;com.offcn.user.dao\u0026#34;) public class userapplication { public static void main(string[] args) { springapplication.run(userapplication.class,args); } } 3.3用户注册判断验证码 （1）修改dongyimai-user-service的userservice.java，增加方法\n/** * 判断短信验证码是否存在 * @param phone * @return */ public boolean checksmscode(string phone,string code); （2）修改dongyimai-user-service的 userserviceimpl.java\n/** * 判断验证码是否正确 */ public boolean checksmscode(string phone,string code){ //得到缓存中存储的验证码 string syscode = (string) redistemplate.boundhashops(\u0026#34;smscode\u0026#34;).get(phone); if(syscode==null){ return false; } if(!syscode.equals(code)){ return false; } return true; } （3）修改dongyimai-user-service的usercontroller.java 的add方法\n/** * 增加 * @param user * @return */ @postmapping(\u0026#34;/add\u0026#34;) public result add(@requestbody user user,string smscode){ boolean checksmscode = userservice.checksmscode(user.getphone(), smscode); if(checksmscode==false){ return new result(false,statuscode.error ,\u0026#34;验证码输入错误！\u0026#34;); } try { userservice.add(user); return new result(true,statuscode.ok, \u0026#34;增加成功\u0026#34;); } catch (exception e) { e.printstacktrace(); return new result(false,statuscode.error, \u0026#34;增加失败\u0026#34;); } } 3.4短信验证码发送到手机 修改dongyimai-user-service的依赖，引入rabbitmq所需依赖包\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; （1）修改dongyimai-user-service的userserviceimpl.java\n@autowired private rabbittemplate rabbittemplate; 测试1，短信验证码发送： http://localhost:9007/user/sendcode?phone=13881221311 测试2：用户注册 ","date":"2022-05-27","permalink":"https://lovemjh.vercel.app/posts/project-0/20220527233134/","summary":"第九章 消息队列及短信发送平台 优就业.JAVA教研室 学习目标 了解常见的MQ产品 了解RabbitMQ的5种消息模型 会使用SpringBoot整合AMQP 短信发送平台","title":"消息队列及短信发送平台"},{"content":"第四章 规格管理、模板管理、分类管理以及商品发布 优就业.java教研室 学习目标 目标一：规格管理\n目标二：模板管理\n目标三：商品分类管理\n目标四：了解电商概念spu 和sku\n目标五：新增商品、修改商品\n目标六：删除商品\n目标七：审核商品\n目标八：注解式事务\n一 代码生成器 1 代码生成 我们接下来使用《优就业java代码生成器1.0》来完成代码的编写。生成后将代码拷贝到工程中。具体步骤如下：\n（1）导入（资源\\配套软件\\dongyimaimakecode)代码生成器工程到开发工具。 （2）修改数据库连接配置：打开src/main/resources/properties/db.properties\n#pojo实体类所在包 pojopackage=com.offcn.sellergoods.pojo #dao接口所在包 mapperpackage=com.offcn.sellergoods.dao #service服务接口所在包 serviceinterfacepackage=com.offcn.sellergoods.service #service服务实现类所在包 serviceinterfaceimplpackage=com.offcn.sellergoods.service.impl #controller控制器所在包 controllerpackage=com.offcn.sellergoods.controller #feignfeign调用接口所在包 feignpackage=com.offcn.sellergoods.feign #是否开启swagger注解 enableswagger=true #swagger-ui所在目录 swaggeruipath=com.offcn.swagger #服务名，提供feign调用 servicename=sellergoods #数据库地址、账号密码 url=jdbc:mysql://192.168.188.1:3306/dongyimai-db uname=root pwd=root driver=com.mysql.jdbc.driver （3）运行代码生成主程序:codeapplication及可生成代码。\n（4）提示成功后，到生成路径去找生成的代码，并拷贝到我们的工程中。\npojo、dao、service、serviceimpl、controller都生成到了 /src/main/java目录下 2 代码拷贝 将商品相关代码拷贝到工程\n（1）拷贝实体类 （2）拷贝dao层接口 （3）拷贝服务接口 （4）拷贝服务实现类 （5）拷贝控制器 二 swagger2的使用 1 配置swagger文档 swagger 是一个规范和完整的框架,用于生成、描述、调用和可视化 restful 风格的 web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法,参数和模型紧密集成到服务器端的代码,允许api来始终保持同步。swagger 让部署管理和使用功能强大的api从未如此简单。\n1) 在dongyimai-parent工程中pom.xml引入swagger2和swagger ui\n\u0026lt;!-- springfox-swagger2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger2\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- springfox-swagger-ui --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger-ui\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2) 在模块中编写配置类（@enableswagger2 开启swagger2自动生成api文档功能）\n@configuration @enableswagger2 public class swaggerconfig { //配置文档属性 private apiinfo getapiinfo(){ return new apiinfobuilder().title(\u0026#34;商品微服务接口文档\u0026#34;) .description(\u0026#34;给前端妹子看的\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .termsofserviceurl(\u0026#34;http://www.ujiuye.com\u0026#34;) .build(); } //创建文档配置对象 @bean public docket docket(){ return new docket(documentationtype.swagger_2).apiinfo(getapiinfo()) .groupname(\u0026#34;group1\u0026#34;) .select() .build(); } } 3)访问文档\nhttp://localhost:9001/swagger-ui.html\n试着操作一下品牌管理的内容~\n三 规格管理 1 需求分析 规格管理是用于管理规格选项的单元。规格是例如颜色、手机运行内存等信息，选项是例如系统：安卓（android）后置摄像头像素：2000万及以上 热点：快速充电等信息 。\n前端交互方式见管理后台的静态原型\n2 表结构分析 tb_specification 规格表\n字段 类型 长度 含义 id bigint 主键 spec_name varchar 255 规格名称 tb_specification_option 规格选项表\n字段 类型 长度 含义 id bigint 主键 option_name varchar 200 规格选项名称 spec_id bigint 30 规格id orders int 11 排序 3 代码实现 3.1 新增规格 实现思路：我们将规格和规格选项数据合并成一个对象来传递，这时我们需要用一个对象将这两个对象组合起来。在业务逻辑中，得到组合对象中的规格和规格选项列表，插入规格返回规格id，然后循环插入规格选项。\n（1）在dongyimai-sellergoods-service-api 建立com.offcn.sellergoods.group包，包下建立specentity类\n@apimodel(description = \u0026#34;规格复合实体类\u0026#34;,value = \u0026#34;specentity\u0026#34;) public class specentity implements serializable { @apimodelproperty(value = \u0026#34;规格对象\u0026#34;,required = false) private specification specification; @apimodelproperty(value = \u0026#34;规格选项对象\u0026#34;,required = false) private list\u0026lt;specificationoption\u0026gt; specificationoptionlist; public specification getspecification() { return specification; } public void setspecification(specification specification) { this.specification = specification; } public list\u0026lt;specificationoption\u0026gt; getspecificationoptionlist() { return specificationoptionlist; } public void setspecificationoptionlist(list\u0026lt;specificationoption\u0026gt; specificationoptionlist) { this.specificationoptionlist = specificationoptionlist; } } （2）业务层\n修改com.offcn.sellergoods.service.specificationservice，新增方法\n/*** * 新增specification * @param specentity */ void add(specentity specentity); 修改com.offcn.sellergoods.service.impl.specificationserviceimpl，新增增加规格方法代码如下：\n/** * 增加specification * @param specentity */ @override public void add(specentity specentity){ //1.保存规格名称 this.save(specentity.getspecification()); //2.得到规格名称id if (null != specentity.getspecificationoptionlist() \u0026amp;\u0026amp; specentity.getspecificationoptionlist().size() \u0026gt; 0) { for (specificationoption specificationoption : specentity.getspecificationoptionlist()) { //3.向规格选项中设置规格id specificationoption.setspecid(specentity.getspecification().getid()); //4.保存规格选项 specificationoptionmapper.insert(specificationoption); } } } （3）控制层\n修改specificationcontroller新增方法\n/*** * 新增specification数据 * @param specentity * @return */ @apioperation(value = \u0026#34;specification添加\u0026#34;,notes = \u0026#34;添加specification方法详情\u0026#34;,tags = {\u0026#34;specificationcontroller\u0026#34;}) @postmapping public result add(@requestbody @apiparam(name = \u0026#34;specentity复合实体\u0026#34;,value = \u0026#34;传入json数据\u0026#34;,required = true) specentity specentity){ //调用specificationservice实现添加specification specificationservice.add(specentity); return new result(true,statuscode.ok,\u0026#34;添加成功\u0026#34;); } 测试数据\n{ \u0026#34;specification\u0026#34;: { \u0026#34;specname\u0026#34;: \u0026#34;测试规格01\u0026#34; }, \u0026#34;specificationoptionlist\u0026#34;: [ { \u0026#34;optionname\u0026#34;: \u0026#34;16g\u0026#34;, \u0026#34;orders\u0026#34;: \u0026#34;1\u0026#34; }, { \u0026#34;optionname\u0026#34;: \u0026#34;21g\u0026#34;, \u0026#34;orders\u0026#34;: \u0026#34;2\u0026#34; }, { \u0026#34;optionname\u0026#34;: \u0026#34;33g\u0026#34;, \u0026#34;orders\u0026#34;: \u0026#34;3\u0026#34; } ] } 3.2 根据id查询规格 （1）业务层\n修改com.offcn.sellergoods.service.specificationservice，查询规格方法，代码如下：\nspecentity findbyid(long id); （2）修改com.offcn.sellergoods.service.impl.specificationserviceimpl，查询规格方法，代码如下：\npublic specentity findbyid(long id) { specification specification = specificationmapper.selectbyid(id); querywrapper\u0026lt;specificationoption\u0026gt; querywrapper = new querywrapper(); querywrapper.eq(\u0026#34;spec_id\u0026#34;,id); list\u0026lt;specificationoption\u0026gt; specificationoptionlist = specificationoptionmapper.selectlist(querywrapper); specentity specentity = new specentity(); specentity.setspecification(specification); specentity.setspecificationoptionlist(specificationoptionlist); return specentity; } （3）控制层\nspecificationcontroller修改方法\n@apioperation(value = \u0026#34;specification根据id查询\u0026#34;,notes = \u0026#34;根据id查询specification方法详情\u0026#34;,tags = {\u0026#34;specificationcontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;主键id\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @getmapping(\u0026#34;/{id}\u0026#34;) public result\u0026lt;specentity\u0026gt; findbyid(@pathvariable long id){ //调用specificationservice实现根据主键查询specification specentity specification = specificationservice.findbyid(id); return new result\u0026lt;specentity\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,specification); } 3.3 修改规格 （1）业务层\n修改com.offcn.sellergoods.service.specificationservice，修改规格方法，代码如下：\n/*** * 修改specification数据 * @param specentity */ void update(specentity specentity); 修改com.offcn.sellergoods.service.impl.specificationserviceimpl，修改品牌方法，代码如下：\n/** * 修改specification * @param specentity */ @override public void update(specentity specentity){ //1.修改规格名称对象 this.updatebyid(specentity.getspecification()); //2.根据id删除规格选项集合 querywrapper\u0026lt;specificationoption\u0026gt; querywrapper = new querywrapper\u0026lt;specificationoption\u0026gt;(); querywrapper.eq(\u0026#34;spec_id\u0026#34;, specentity.getspecification().getid()); //执行删除 specificationoptionmapper.delete(querywrapper); //3.重新插入规格选项 if (!collectionutils.isempty(specentity.getspecificationoptionlist())) { for (specificationoption specificationoption : specentity.getspecificationoptionlist()) { //先设置规格名称的id specificationoption.setspecid(specentity.getspecification().getid()); specificationoptionmapper.insert(specificationoption); } } } (2)控制层\nspecificationcontroller修改方法\n/*** * 修改specification数据 * @param specentity * @param id * @return */ @apioperation(value = \u0026#34;specification根据id修改\u0026#34;,notes = \u0026#34;根据id修改specification方法详情\u0026#34;,tags = {\u0026#34;specificationcontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;主键id\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @putmapping(value=\u0026#34;/{id}\u0026#34;) public result update(@requestbody @apiparam(name = \u0026#34;specification对象\u0026#34;,value = \u0026#34;传入json数据\u0026#34;,required = false) specentity specentity,@pathvariable long id){ //设置主键值 specentity.getspecification().setid(id); specificationservice.update(specentity); return new result(true,statuscode.ok,\u0026#34;修改成功\u0026#34;); } 测试数据\n{ \u0026#34;specification\u0026#34;: { \u0026#34;specname\u0026#34;: \u0026#34;测试规格01_update\u0026#34; }, \u0026#34;specificationoptionlist\u0026#34;: [ { \u0026#34;optionname\u0026#34;: \u0026#34;21g_update\u0026#34;, \u0026#34;orders\u0026#34;: \u0026#34;2\u0026#34; }, { \u0026#34;optionname\u0026#34;: \u0026#34;33g\u0026#34;, \u0026#34;orders\u0026#34;: \u0026#34;3\u0026#34; }, { \u0026#34;optionname\u0026#34;: \u0026#34;48g\u0026#34;, \u0026#34;orders\u0026#34;: \u0026#34;4\u0026#34; } ] } 3.4 删除规格 (1)业务层\n修改com.offcn.sellergoods.service.specificationserviceimpl，删除规格方法，代码如下：\n/** * 删除 * @param id */ @override public void delete(long id){ //1.删除规格名称对象 this.removebyid(id); //2.关联删除规格选项集合 querywrapper\u0026lt;specificationoption\u0026gt; querywrapper = new querywrapper(); querywrapper.eq(\u0026#34;spec_id\u0026#34;, id); //执行删除 specificationoptionmapper.delete(querywrapper); } (2)控制层\nspecificationcontroller删除方法\n/*** * 根据id删除品牌数据 * @param id * @return */ @apioperation(value = \u0026#34;specification根据id删除\u0026#34;,notes = \u0026#34;根据id删除specification方法详情\u0026#34;,tags = {\u0026#34;specificationcontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;主键id\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @deletemapping(value = \u0026#34;/{id}\u0026#34; ) public result delete(@pathvariable long id){ //调用specificationservice实现根据主键删除 specificationservice.delete(id); return new result(true,statuscode.ok,\u0026#34;删除成功\u0026#34;); } 四 模板管理 **1 **需求分析 首先我们需要理解模板的作用。模板主要有两个：\n1是用于关联品牌与规格\n2定义扩充属性\n2 表结构分析 tb_type_template 模板表\n字段 类型 长度 含义 id bigint 主键 name varchar 80 模板名称 spec_ids varchar 1000 关联规格（json格式） brand_ids varchar 1000 关联品牌（json格式） custom_attribute_items varchar 2000 扩展属性（json格式） 3.品牌下拉列表 在弹出窗口中有个品牌下拉列表，要求品牌是可以选择多个，需要后台提供数据支持 3.1 品牌下拉列表代码实现 （1）修改dao层 ，在brandmapper中添加查询\n@select(\u0026#34;select id,name as text from tb_brand\u0026#34;) public list\u0026lt;map\u0026gt; selectoptions(); （2）修改com.offcn.sellergoods.service.brandservice，增加方法定义\n/** * 查询品牌下拉列表 * @return */ public list\u0026lt;map\u0026gt; selectoptions(); （3）修改com.offcn.sellergoods.service.impl.brandserviceimpl，增加方法\n/** * 查询品牌下拉列表 * * @return */ @override public list\u0026lt;map\u0026gt; selectoptions() { return brandmapper.selectoptions(); } （4）修改brandcontroller.java\n@apioperation(value = \u0026#34;查询品牌下拉列表\u0026#34;,notes = \u0026#34;查询品牌下拉列表\u0026#34;,tags = {\u0026#34;brandcontroller\u0026#34;}) @getmapping(\u0026#34;/selectoptions\u0026#34;) public responseentity\u0026lt;list\u0026lt;map\u0026gt;\u0026gt; selectoptions(){ return responseentity.ok(brandservice.selectoptions()); } 3.2 规格下拉列表代码实现 （1）修改dao层 ，在specificationmapper中添加查询\n@select(\u0026#34;select id,spec_name as text from tb_specification\u0026#34;) public list\u0026lt;map\u0026gt; selectoptions(); （2）修改com.offcn.sellergoods.service.specificationservice，增加方法定义\n/** * 查询规格下拉列表 * @return */ public list\u0026lt;map\u0026gt; selectoptions(); （3）修改com.offcn.sellergoods.service.impl.specificationserviceimpl，增加方法\n/** * 查询规格下拉列表 * * @return */ @override public list\u0026lt;map\u0026gt; selectoptions() { return specificationmapper.selectoptions(); } （4）修改specificationcontroller.java\n@apioperation(value = \u0026#34;查询规格下拉列表\u0026#34;,notes = \u0026#34;查询规格下拉列表\u0026#34;,tags = {\u0026#34;specificationcontroller\u0026#34;}) @getmapping(\u0026#34;/selectoptions\u0026#34;) public list\u0026lt;map\u0026gt; selectoptions() { return specificationservice.selectoptions(); } 五 商品分类 1 需求分析 实现三级商品分类列表查询功能\n进入页面首先显示所以一级分类，效果如下： 点击列表行的查询下级按钮，进入下级分类列表，同时更新面包屑导航 2 表结构分析 tb_item_cat 商品分类表\n字段 类型 长度 含义 id bigint 主键 parent_id bigint 上级id name varchar 分类名称 type_id bigint 模板id 3 查询下级代码实现 （1）修改com.offcn.sellergoods.service.itemcatservice接口，新增方法定义\n/** * 根据父级id查询分类列表 * @param parentid * @return */ public list\u0026lt;itemcat\u0026gt; findbyparentid(long parentid); （2）修改com.offcn.sellergoods.service.impl.itemcatserviceimpl ，实现方法\n/** * 根据父级id查询分类列表 * * @param parentid * @return */ public list\u0026lt;itemcat\u0026gt; findbyparentid(long parentid) { itemcat itemcat = new itemcat(); itemcat.setparentid(parentid); querywrapper\u0026lt;itemcat\u0026gt; querywrapper = this.createquerywrapper(itemcat); return this.list(querywrapper); } （3）修改itemcatcontroller.java\n@apioperation(value = \u0026#34;根据父级id查询itemcat\u0026#34;,notes = \u0026#34;根据父级id查询itemcat\u0026#34;,tags = {\u0026#34;itemcatcontroller\u0026#34;}) @getmapping(\u0026#34;/findbyparentid\u0026#34;) public result\u0026lt;list\u0026lt;itemcat\u0026gt;\u0026gt; findbyparentid(long parentid) { list\u0026lt;itemcat\u0026gt; list = itemcatservice.findbyparentid(parentid); return new result\u0026lt;list\u0026lt;itemcat\u0026gt;\u0026gt;(true, statuscode.ok,\u0026#34;查询成功\u0026#34;,list) ; } 4 新增商品分类（学员实现） 4.1新增商品分类\u0026ndash;实现模板下拉列表（学员实现） 5 修改商品分类（学员实现） 6 删除商品分类（学员实现） 六 电商概念及表结构分析 1. spu与sku概念 spu = standard product unit （标准产品单位）\n概念 : spu 是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。\n通俗点讲，属性值、特性相同的货品就可以称为一个 spu\n==同款商品的公共属性抽取==\n例如： iphone12就是一个spu，与商家，与颜色、款式、套餐都无关\nsku = stock keeping unit( 库存量单位)\nsku 即库存进出计量的单位， 可以是以件、盒、托盘等为单位。\nsku 是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。\n在服装、鞋类商品中使用最多最普遍。\n==某个库存单位的商品独有属性(某个商品的独有属性)==\n例如：iphone12 黑色 128g 全网通 就是一个 sku\n2 表结构分析 tb_goods 商品表 tb_goods_desc 商品扩展信息表 tb_item sku表 七 新增和修改商品 1 需求分析 实现商品的新增与修改功能。\n(1)先选择添加的商品所属分类，选择关联品牌，并填写相关信息 （2)上传图片以及填写关联扩展属性的信息 (3)填写sku信息 2 实现思路 前端传递给后端的数据格式 是一个spu对象和sku列表组成的对象,如下图: 上图json数据如下：\n{ \u0026#34;goods\u0026#34;: { \u0026#34;brandid\u0026#34;: 1, \u0026#34;caption\u0026#34;: \u0026#34;测试商品01副标题\u0026#34;, \u0026#34;category1id\u0026#34;: 558, \u0026#34;category2id\u0026#34;: 559, \u0026#34;category3id\u0026#34;: 560, \u0026#34;goodsname\u0026#34;: \u0026#34;测试商品01\u0026#34;, \u0026#34;isenablespec\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;price\u0026#34;: \u0026#34;1000\u0026#34;, \u0026#34;typetemplateid\u0026#34;: 35 }, \u0026#34;goodsdesc\u0026#34;: { \u0026#34;customattributeitems\u0026#34;: \u0026#34;[{\u0026#34;text\u0026#34;:\u0026#34;内存大小\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;16g\u0026#34;},{\u0026#34;text\u0026#34;:\u0026#34;颜色\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;绿色\u0026#34;}]\u0026#34;, \u0026#34;introduction\u0026#34;: \u0026#34;\u0026lt;span style=\u0026#34;color:#666666;font-family:tahoma, arial, \u0026amp;quot;font-size:14px;background-color:#ffffff;\u0026#34;\u0026gt;测试描述\u0026lt;/span\u0026gt;\u0026lt;br /\u0026gt;\u0026#34;, \u0026#34;itemimages\u0026#34;: \u0026#34;[{\u0026#34;color\u0026#34;:\u0026#34;红色\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;http://192.168.188.146/group1/m00/00/00/wki8kly5gxgaz9x_aaqqpbr_emi045.png\u0026#34;},{\u0026#34;color\u0026#34;:\u0026#34;绿色\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;http://192.168.188.146/group1/m00/00/00/wki8kly5gxmanvndaai1bfuiuje180.jpg\u0026#34;}]\u0026#34;, \u0026#34;packagelist\u0026#34;: \u0026#34;测试包装\u0026#34;, \u0026#34;saleservice\u0026#34;: \u0026#34;测试售后服务\u0026#34;, \u0026#34;specificationitems\u0026#34;: \u0026#34;[{\u0026#34;attributevalue\u0026#34;:[\u0026#34;移动3g\u0026#34;,\u0026#34;移动4g\u0026#34;],\u0026#34;attributename\u0026#34;:\u0026#34;网络\u0026#34;},{\u0026#34;attributevalue\u0026#34;:[\u0026#34;16g\u0026#34;,\u0026#34;32g\u0026#34;],\u0026#34;attributename\u0026#34;:\u0026#34;机身内存\u0026#34;}]\u0026#34; }, \u0026#34;itemlist\u0026#34;: [ { \u0026#34;isdefault\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;num\u0026#34;: 9999, \u0026#34;price\u0026#34;: \u0026#34;1000\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\u0026#34;机身内存\u0026#34;:\u0026#34;16g\u0026#34;,\u0026#34;网络\u0026#34;:\u0026#34;移动3g\u0026#34;}\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34;, }, { \u0026#34;isdefault\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;num\u0026#34;: 9999, \u0026#34;price\u0026#34;: \u0026#34;2000\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\u0026#34;机身内存\u0026#34;:\u0026#34;16g\u0026#34;,\u0026#34;网络\u0026#34;:\u0026#34;移动4g\u0026#34;}\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34;, }, { \u0026#34;isdefault\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;num\u0026#34;: 9999, \u0026#34;price\u0026#34;: \u0026#34;2001\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\u0026#34;机身内存\u0026#34;:\u0026#34;24g\u0026#34;,\u0026#34;网络\u0026#34;:\u0026#34;移动3g\u0026#34;}\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34;, }, { \u0026#34;isdefault\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;num\u0026#34;: 9999, \u0026#34;price\u0026#34;: \u0026#34;2002\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\u0026#34;机身内存\u0026#34;:\u0026#34;24g\u0026#34;,\u0026#34;网络\u0026#34;:\u0026#34;移动4g\u0026#34;}\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34;, } ] } 3 查询分类级联数据 3.1 需求分析 在实现商品增加之前，需要先选择对应的分类，选择分类的时候，首选选择一级分类，然后根据选中的分类，将选中的分类作为查询的父id，再查询对应的子分类集合。这块在昨天的代码中已经有一个根据父节点id查询分类信息的方法，参考findbyprantid方法，首先查询顶级分类，也就是pid=0，然后根据用户选择的分类，将选择的分类作为pid查询子分类。\n3.2 代码实现 (1)dao实现，代码如下：\npublic interface itemcatmapper extends basemapper\u0026lt;itemcat\u0026gt; { } (2)service层，代码如下：\n/** * 根据父级id查询分类列表 * @param parentid * @return */ public list\u0026lt;itemcat\u0026gt; findbyparentid(long parentid); 服务实现，代码如下：\n/** * 根据父级id查询分类列表 * * @param parentid * @return */ public list\u0026lt;itemcat\u0026gt; findbyparentid(long parentid) { itemcat itemcat = new itemcat(); itemcat.setparentid(parentid); querywrapper\u0026lt;itemcat\u0026gt; querywrapper = this.createquerywrapper(itemcat); return this.list(querywrapper); } (3)controller层，代码如下：\n@apioperation(value = \u0026#34;根据父级id查询itemcat\u0026#34;,notes = \u0026#34;根据父级id查询itemcat\u0026#34;,tags = {\u0026#34;itemcatcontroller\u0026#34;}) @getmapping(\u0026#34;/findbyparentid\u0026#34;) public result\u0026lt;list\u0026lt;itemcat\u0026gt;\u0026gt; findbyparentid(long parentid) { list\u0026lt;itemcat\u0026gt; list = itemcatservice.findbyparentid(parentid); return new result\u0026lt;list\u0026lt;itemcat\u0026gt;\u0026gt;(true, statuscode.ok,\u0026#34;查询成功\u0026#34;,list) ; } 4 查询分类下品牌数据 4.1 分析 用户每次选择了分类之后，可以根据用户选择的分类到tb_item_cat表中根据模板id关联到tb_type_template表中查询品牌，再将品牌集合数据放到前端来展示即可实现上述功能。\n4.2 代码实现 (1)dao实现\ncom.offcn.sellergoods.dao.typetemplatemapper，代码如下：\npublic interface typetemplatemapper extends basemapper\u0026lt;typetemplate\u0026gt; { } (2)service层，代码如下：\n/** * 根据id查询typetemplate * @param id * @return */ typetemplate findbyid(long id); 服务实现，代码如下：\n/** * 根据id查询typetemplate * @param id * @return */ @override public typetemplate findbyid(long id){ return this.getbyid(id); } (3)controller层，代码如下：\n/*** * 根据id查询typetemplate数据 * @param id * @return */ @apioperation(value = \u0026#34;typetemplate根据id查询\u0026#34;,notes = \u0026#34;根据id查询typetemplate方法详情\u0026#34;,tags = {\u0026#34;typetemplatecontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;主键id\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @getmapping(\u0026#34;/{id}\u0026#34;) public result\u0026lt;typetemplate\u0026gt; findbyid(@pathvariable long id){ //调用typetemplateservice实现根据主键查询typetemplate typetemplate typetemplate = typetemplateservice.findbyid(id); return new result\u0026lt;typetemplate\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,typetemplate); } 5 规格查询 5.1 分析 用户选择分类后，需要根据所选分类对应的模板id查询对应的规格以及规格选项，需要单独编写方法查询出规格选项。 上图json数据如下：\n{ \u0026#34;options\u0026#34;: [ { \u0026#34;id\u0026#34;: 114, \u0026#34;optionname\u0026#34;: \u0026#34;移动2g\u0026#34;, \u0026#34;specid\u0026#34;: 27, \u0026#34;orders\u0026#34;: 7 }, { \u0026#34;id\u0026#34;: 115, \u0026#34;optionname\u0026#34;: \u0026#34;联通2g\u0026#34;, \u0026#34;specid\u0026#34;: 27, \u0026#34;orders\u0026#34;: 8 }, { \u0026#34;id\u0026#34;: 116, \u0026#34;optionname\u0026#34;: \u0026#34;电信2g\u0026#34;, \u0026#34;specid\u0026#34;: 27, \u0026#34;orders\u0026#34;: 9 } ], \u0026#34;id\u0026#34;: 27, \u0026#34;text\u0026#34;: \u0026#34;网络\u0026#34; }, { \u0026#34;options\u0026#34;: [ { \u0026#34;id\u0026#34;: 118, \u0026#34;optionname\u0026#34;: \u0026#34;16g\u0026#34;, \u0026#34;specid\u0026#34;: 32, \u0026#34;orders\u0026#34;: 1 }, { \u0026#34;id\u0026#34;: 119, \u0026#34;optionname\u0026#34;: \u0026#34;32g\u0026#34;, \u0026#34;specid\u0026#34;: 32, \u0026#34;orders\u0026#34;: 2 }, { \u0026#34;id\u0026#34;: 120, \u0026#34;optionname\u0026#34;: \u0026#34;64g\u0026#34;, \u0026#34;specid\u0026#34;: 32, \u0026#34;orders\u0026#34;: 3 }, { \u0026#34;id\u0026#34;: 121, \u0026#34;optionname\u0026#34;: \u0026#34;128g\u0026#34;, \u0026#34;specid\u0026#34;: 32, \u0026#34;orders\u0026#34;: 4 } ], \u0026#34;id\u0026#34;: 32, \u0026#34;text\u0026#34;: \u0026#34;机身内存\u0026#34; } 5.2 代码实现 (1)service层\n修改com.offcn.sellergoods.service.typetemplateservice添加根据分类id查询规格列表，代码如下：\n/** * 根据模板id查询规格列表 * @param typeid * @return */ public list\u0026lt;map\u0026gt; findspeclist(long typeid); （2）服务实现，修改com.offcn.sellergoods.service.impl.typetemplateservice添加上面方法的实现，代码如下：\n@autowired private specificationoptionmapper specificationoptionmapper; /** * 根据模板id查询规格列表 * * @param typeid * @return */ public list\u0026lt;map\u0026gt; findspeclist(long typeid) { //1.根据模板id查询模板对象 typetemplate typetemplate = this.findbyid(typeid); //2.将规格名称json结构的字符串转换成json对象 [{\u0026#34;id\u0026#34;:27,\u0026#34;text\u0026#34;:\u0026#34;网络\u0026#34;},{\u0026#34;id\u0026#34;:32,\u0026#34;text\u0026#34;:\u0026#34;机身内存\u0026#34;}] list\u0026lt;map\u0026gt; speclist = json.parsearray(typetemplate.getspecids(), map.class); if (!collectionutils.isempty(speclist)) { for (map map : speclist) { long specid = new long((integer) map.get(\u0026#34;id\u0026#34;)); //map集合中取得数值类型的值默认是整型 //3.根据规格id查询规格选项集合 querywrapper\u0026lt;specificationoption\u0026gt; querywrapper = new querywrapper(); querywrapper.eq(\u0026#34;spec_id\u0026#34;, specid); list\u0026lt;specificationoption\u0026gt; specificationoptionlist = specificationoptionmapper.selectlist(querywrapper); //4.重新将规格选项集合设置回json对象中 {\u0026#34;id\u0026#34;:27,\u0026#34;text\u0026#34;:\u0026#34;网络\u0026#34;,\u0026#34;options\u0026#34;:[{},{},{}]} map.put(\u0026#34;options\u0026#34;, specificationoptionlist); } } return speclist; } (3)controller层\n修改com.offcn.sellergoods.controller.typetemplatecontroller添加根据分类id查询规格数据，代码如下：\n@apioperation(value = \u0026#34;查询规格及规格选项信息\u0026#34;,notes = \u0026#34;查询规格及规格选项信息\u0026#34;,tags = {\u0026#34;typetemplatecontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;主键id\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @getmapping(\u0026#34;/findspeclist/{id}\u0026#34;) public result\u0026lt;list\u0026lt;map\u0026gt;\u0026gt; findspeclist(@pathvariable long id){ list\u0026lt;map\u0026gt; list = typetemplateservice.findspeclist(id); return new result\u0026lt;list\u0026lt;map\u0026gt;\u0026gt;(true, statuscode.ok,\u0026#34;查询成功\u0026#34;,list) ; } 6 spu+sku保存 6.1 分析 保存商品数据的时候，需要保存spu和sku，一个spu对应多个sku，我们可以先构建一个goods对象，将spu和list\u0026lt;sku\u0026gt;组合到一起,前端将2者数据提交过来，再实现添加操作。\n6.2 代码实现 (1)pojo改造\n修改dongyimai-sellergoods-service-api工程创建组合实体类，创建com.offcn.sellergoods.group.goodsentity,代码如下：\npublic class goodsentity implements serializable { private goods goods; //商品信息 spu private goodsdesc goodsdesc; //商品扩展信息 private list\u0026lt;item\u0026gt; itemlist; //商品详情 sku //..get..set..tostring } 因为扩展信息是使用spu的主键，所以需要修改扩展信息的pojo的id生成方式为input类型，代码如下：\n@apimodelproperty(value = \u0026#34;spu_id\u0026#34;,required = false) @tableid(type = idtype.input) @tablefield(value = \u0026#34;goods_id\u0026#34;) private long goodsid;//spu_id (2) 业务层\n修改com.offcn.sellergoods.service.goodsservice接口，添加保存goods方法，代码如下：\n/*** * 新增goods * @param goodsentity */ void add(goodsentity goodsentity); 修改com.offcn.sellergoods.service.impl.goodsserviceimpl类，添加保存goods的方法实现，代码如下：\n@autowired private goodsmapper goodsmapper; @autowired private goodsdescmapper goodsdescmapper; @autowired private itemmapper itemmapper; @autowired private itemcatmapper itemcatmapper; @autowired private brandmapper brandmapper; /** * 增加goods * * @param goods */ @override public void add(goodsentity goodsentity) { goodsentity.getgoods().setauditstatus(\u0026#34;0\u0026#34;); //审核状态 未审核 //1.保存spu 商品信息对象 goodsmapper.insert(goodsentity.getgoods()); //2.获取商品信息对象主键id ,向商品扩展信息对象中设置主键 goodsentity.getgoodsdesc().setgoodsid(goodsentity.getgoods().getid()); //3.保存商品扩展信息 goodsdescmapper.insert(goodsentity.getgoodsdesc()); //4.保存sku 商品详情信息 if (\u0026#34;1\u0026#34;.equals(goodsentity.getgoods().getisenablespec())) { //5.保存sku 商品详情信息 if (!collectionutils.isempty(goodsentity.getitemlist())) { for (item item : goodsentity.getitemlist()) { string title = goodsentity.getgoods().getgoodsname(); //设置sku的名称 商品名+规格选项 map\u0026lt;string, string\u0026gt; specmap = json.parseobject(item.getspec(), map.class); //取得sku的规格选项，并做json类型转换 for (string key : specmap.keyset()) { title += specmap.get(key) + \u0026#34; \u0026#34;; } item.settitle(title); //sku名称 item.setcategoryid(goodsentity.getgoods().getcategory3id()); //商品分类 三级 item.setcreatetime(new date()); //创建时间 item.setupdatetime(new date()); //更新时间 item.setgoodsid(goodsentity.getgoods().getid()); //spu id item.setsellerid(goodsentity.getgoods().getsellerid()); //商家id //查询分类对象 itemcat itemcat = itemcatmapper.selectbyid(goodsentity.getgoods().getcategory3id()); item.setcategory(itemcat.getname()); //分类名称 //查询品牌对象 brand tbbrand = brandmapper.selectbyid(goodsentity.getgoods().getbrandid()); item.setbrand(tbbrand.getname()); //品牌名称 list\u0026lt;map\u0026gt; imagelist = json.parsearray(goodsentity.getgoodsdesc().getitemimages(), map.class); if (imagelist.size() \u0026gt; 0) { item.setimage((string) imagelist.get(0).get(\u0026#34;url\u0026#34;)); //商品图片 } //保存sku信息 itemmapper.insert(item); } } } else { //不启用规格 sku信息为默认值 item item = new item(); item.settitle(goodsentity.getgoods().getgoodsname()); //商品名称 item.setprice(goodsentity.getgoods().getprice()); //默认使用spu的价格 item.setnum(9999); item.setstatus(\u0026#34;1\u0026#34;); //是否启用 item.setisdefault(\u0026#34;1\u0026#34;); //是否默认 item.setspec(\u0026#34;{}\u0026#34;); //没有选择规格，则放置空json结构 this.setitemvalue(goodsentity, item); itemmapper.insert(item); } } (3)controller层\n修改com.offcn.sellergoods.controller.goodscontroller，增加保存goods方法，代码如下：\n/*** * 新增goods数据 * @param goods * @return */ @apioperation(value = \u0026#34;goods添加\u0026#34;,notes = \u0026#34;添加goods方法详情\u0026#34;,tags = {\u0026#34;goodscontroller\u0026#34;}) @postmapping public result add(@requestbody @apiparam(name = \u0026#34;goods复合实体对象\u0026#34;,value = \u0026#34;传入json数据\u0026#34;,required = true) goodsentity goodsentity){ //调用goodsservice实现添加goods goodsservice.add(goodsentity); return new result(true,statuscode.ok,\u0026#34;添加成功\u0026#34;); } 测试数据\n{ \u0026#34;goods\u0026#34;: { \u0026#34;brandid\u0026#34;: 1, \u0026#34;caption\u0026#34;: \u0026#34;测试商品01副标题\u0026#34;, \u0026#34;category1id\u0026#34;: 558, \u0026#34;category2id\u0026#34;: 559, \u0026#34;category3id\u0026#34;: 560, \u0026#34;goodsname\u0026#34;: \u0026#34;测试商品01\u0026#34;, \u0026#34;isenablespec\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;price\u0026#34;: \u0026#34;1000\u0026#34;, \u0026#34;typetemplateid\u0026#34;: 35 }, \u0026#34;goodsdesc\u0026#34;: { \u0026#34;customattributeitems\u0026#34;: \u0026#34;[{\\\u0026#34;text\\\u0026#34;:\\\u0026#34;内存大小\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:\\\u0026#34;16g\\\u0026#34;},{\\\u0026#34;text\\\u0026#34;:\\\u0026#34;颜色\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:\\\u0026#34;绿色\\\u0026#34;}]\u0026#34;, \u0026#34;introduction\u0026#34;: \u0026#34;\u0026lt;span style=\\\u0026#34;color:#666666;font-family:tahoma, arial, \u0026amp;quot;font-size:14px;background-color:#ffffff;\\\u0026#34;\u0026gt;测试描述\u0026lt;/span\u0026gt;\u0026lt;br /\u0026gt;\u0026#34;, \u0026#34;itemimages\u0026#34;: \u0026#34;[{\\\u0026#34;color\\\u0026#34;:\\\u0026#34;红色\\\u0026#34;,\\\u0026#34;url\\\u0026#34;:\\\u0026#34;http://192.168.188.146/group1/m00/00/00/wki8kly5gxgaz9x_aaqqpbr_emi045.png\\\u0026#34;},{\\\u0026#34;color\\\u0026#34;:\\\u0026#34;绿色\\\u0026#34;,\\\u0026#34;url\\\u0026#34;:\\\u0026#34;http://192.168.188.146/group1/m00/00/00/wki8kly5gxmanvndaai1bfuiuje180.jpg\\\u0026#34;}]\u0026#34;, \u0026#34;packagelist\u0026#34;: \u0026#34;测试包装\u0026#34;, \u0026#34;saleservice\u0026#34;: \u0026#34;测试售后服务\u0026#34;, \u0026#34;specificationitems\u0026#34;: \u0026#34;[{\\\u0026#34;attributevalue\\\u0026#34;:[\\\u0026#34;移动3g\\\u0026#34;,\\\u0026#34;移动4g\\\u0026#34;],\\\u0026#34;attributename\\\u0026#34;:\\\u0026#34;网络\\\u0026#34;},{\\\u0026#34;attributevalue\\\u0026#34;:[\\\u0026#34;16g\\\u0026#34;,\\\u0026#34;32g\\\u0026#34;],\\\u0026#34;attributename\\\u0026#34;:\\\u0026#34;机身内存\\\u0026#34;}]\u0026#34; }, \u0026#34;itemlist\u0026#34;: [ { \u0026#34;isdefault\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;num\u0026#34;: 9999, \u0026#34;price\u0026#34;: \u0026#34;1000\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\\\u0026#34;机身内存\\\u0026#34;:\\\u0026#34;16g\\\u0026#34;,\\\u0026#34;网络\\\u0026#34;:\\\u0026#34;移动3g\\\u0026#34;}\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34; }, { \u0026#34;isdefault\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;num\u0026#34;: 9999, \u0026#34;price\u0026#34;: \u0026#34;2000\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\\\u0026#34;机身内存\\\u0026#34;:\\\u0026#34;16g\\\u0026#34;,\\\u0026#34;网络\\\u0026#34;:\\\u0026#34;移动4g\\\u0026#34;}\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34; }, { \u0026#34;isdefault\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;num\u0026#34;: 9999, \u0026#34;price\u0026#34;: \u0026#34;2001\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\\\u0026#34;机身内存\\\u0026#34;:\\\u0026#34;24g\\\u0026#34;,\\\u0026#34;网络\\\u0026#34;:\\\u0026#34;移动3g\\\u0026#34;}\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34; }, { \u0026#34;isdefault\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;num\u0026#34;: 9999, \u0026#34;price\u0026#34;: \u0026#34;2002\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\\\u0026#34;机身内存\\\u0026#34;:\\\u0026#34;24g\\\u0026#34;,\\\u0026#34;网络\\\u0026#34;:\\\u0026#34;移动4g\\\u0026#34;}\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34; } ] } 7 根据id查询商品 7.1 需求分析 需求：根据id 查询spu和sku列表 ，显示效果如下：\n\u0026#34;goods\u0026#34;: { \u0026#34;id\u0026#34;: 149187842867985, \u0026#34;sellerid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goodsname\u0026#34;: \u0026#34;测试商品01\u0026#34;, \u0026#34;defaultitemid\u0026#34;: null, \u0026#34;auditstatus\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;ismarketable\u0026#34;: null, \u0026#34;brandid\u0026#34;: 1, \u0026#34;caption\u0026#34;: \u0026#34;测试商品01\u0026#34;, \u0026#34;category1id\u0026#34;: 558, \u0026#34;category2id\u0026#34;: 559, \u0026#34;category3id\u0026#34;: 560, \u0026#34;smallpic\u0026#34;: null, \u0026#34;price\u0026#34;: \u0026#34;2000.00\u0026#34;, \u0026#34;typetemplateid\u0026#34;: 35, \u0026#34;isenablespec\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;isdelete\u0026#34;: \u0026#34;1\u0026#34; }, \u0026#34;goodsdesc\u0026#34;: { \u0026#34;goodsid\u0026#34;: 149187842867985, \u0026#34;introduction\u0026#34;: \u0026#34;\u0026lt;span style=\\\u0026#34;color:#666666;font-family:tahoma, arial, \u0026amp;quot;font-size:14px;background-color:#ffffff;\\\u0026#34;\u0026gt;读者评论\u0026lt;/span\u0026gt;\u0026lt;br /\u0026gt;\u0026#34;, \u0026#34;specificationitems\u0026#34;: \u0026#34;[{\\\u0026#34;attributevalue\\\u0026#34;:[\\\u0026#34;移动3g\\\u0026#34;,\\\u0026#34;移动4g\\\u0026#34;],\\\u0026#34;attributename\\\u0026#34;:\\\u0026#34;网络\\\u0026#34;},{\\\u0026#34;attributevalue\\\u0026#34;:[\\\u0026#34;16g\\\u0026#34;,\\\u0026#34;32g\\\u0026#34;],\\\u0026#34;attributename\\\u0026#34;:\\\u0026#34;机身内存\\\u0026#34;}]\u0026#34;, \u0026#34;customattributeitems\u0026#34;: \u0026#34;[{\\\u0026#34;text\\\u0026#34;:\\\u0026#34;内存大小\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:\\\u0026#34;16g\\\u0026#34;},{\\\u0026#34;text\\\u0026#34;:\\\u0026#34;颜色\\\u0026#34;,\\\u0026#34;value\\\u0026#34;:\\\u0026#34;绿色\\\u0026#34;}]\u0026#34;, \u0026#34;itemimages\u0026#34;: \u0026#34;[{\\\u0026#34;color\\\u0026#34;:\\\u0026#34;红色\\\u0026#34;,\\\u0026#34;url\\\u0026#34;:\\\u0026#34;http://192.168.188.146/group1/m00/00/00/wki8kly5gxgaz9x_aaqqpbr_emi045.png\\\u0026#34;},{\\\u0026#34;color\\\u0026#34;:\\\u0026#34;绿色\\\u0026#34;,\\\u0026#34;url\\\u0026#34;:\\\u0026#34;http://192.168.188.146/group1/m00/00/00/wki8kly5gxmanvndaai1bfuiuje180.jpg\\\u0026#34;}]\u0026#34;, \u0026#34;packagelist\u0026#34;: \u0026#34;测试包装\u0026#34;, \u0026#34;saleservice\u0026#34;: \u0026#34;测试售后服务\u0026#34; }, \u0026#34;itemlist\u0026#34;: [ { \u0026#34;id\u0026#34;: 1369283, \u0026#34;title\u0026#34;: \u0026#34;测试商品01移动3g 16g \u0026#34;, \u0026#34;sellpoint\u0026#34;: null, \u0026#34;price\u0026#34;: \u0026#34;2001.00\u0026#34;, \u0026#34;stockcount\u0026#34;: null, \u0026#34;num\u0026#34;: 9999, \u0026#34;barcode\u0026#34;: null, \u0026#34;image\u0026#34;: \u0026#34;http://192.168.188.146/group1/m00/00/00/wki8kly5gxgaz9x_aaqqpbr_emi045.png\u0026#34;, \u0026#34;categoryid\u0026#34;: 560, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;createtime\u0026#34;: \u0026#34;2021-02-08t12:17:45.000+0000\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2021-02-08t12:17:45.000+0000\u0026#34;, \u0026#34;itemsn\u0026#34;: null, \u0026#34;costpirce\u0026#34;: null, \u0026#34;marketprice\u0026#34;: null, \u0026#34;isdefault\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goodsid\u0026#34;: 149187842867985, \u0026#34;sellerid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;cartthumbnail\u0026#34;: null, \u0026#34;category\u0026#34;: \u0026#34;手机\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;联想\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\\\u0026#34;机身内存\\\u0026#34;:\\\u0026#34;16g\\\u0026#34;,\\\u0026#34;网络\\\u0026#34;:\\\u0026#34;移动3g\\\u0026#34;}\u0026#34;, \u0026#34;seller\u0026#34;: null }, { \u0026#34;id\u0026#34;: 1369284, \u0026#34;title\u0026#34;: \u0026#34;测试商品01移动4g 16g \u0026#34;, \u0026#34;sellpoint\u0026#34;: null, \u0026#34;price\u0026#34;: \u0026#34;2001.00\u0026#34;, \u0026#34;stockcount\u0026#34;: null, \u0026#34;num\u0026#34;: 9999, \u0026#34;barcode\u0026#34;: null, \u0026#34;image\u0026#34;: \u0026#34;http://192.168.188.146/group1/m00/00/00/wki8kly5gxgaz9x_aaqqpbr_emi045.png\u0026#34;, \u0026#34;categoryid\u0026#34;: 560, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;createtime\u0026#34;: \u0026#34;2021-02-08t12:17:45.000+0000\u0026#34;, \u0026#34;updatetime\u0026#34;: \u0026#34;2021-02-08t12:17:45.000+0000\u0026#34;, \u0026#34;itemsn\u0026#34;: null, \u0026#34;costpirce\u0026#34;: null, \u0026#34;marketprice\u0026#34;: null, \u0026#34;isdefault\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goodsid\u0026#34;: 149187842867985, \u0026#34;sellerid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;cartthumbnail\u0026#34;: null, \u0026#34;category\u0026#34;: \u0026#34;手机\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;联想\u0026#34;, \u0026#34;spec\u0026#34;: \u0026#34;{\\\u0026#34;机身内存\\\u0026#34;:\\\u0026#34;16g\\\u0026#34;,\\\u0026#34;网络\\\u0026#34;:\\\u0026#34;移动4g\\\u0026#34;}\u0026#34;, \u0026#34;seller\u0026#34;: null }] 7.2 代码实现 (1)业务层\n修改dongyimai-sellergoods-service工程,修改com.offcn.sellergoods.service.goodsservice接口,添加根据id查找方法findbyid代码如下：\n/** * 根据id查询goods * @param id * @return */ goodsentity findbyid(long id); 修改dongyimai-sellergoods-service工程，修改com.offcn.sellergoods.service.impl.goodsserviceimpl类，修改根据id查找findbyid方法，代码如下：\n/** * 根据id查询goods * * @param id * @return */ @override public goodsentity findbyid(long id) { //1.根据id查询spu信息 goods goods = goodsmapper.selectbyid(id); //2.根据id查询商品扩展信息 goodsdesc goodsdesc = goodsdescmapper.selectbyid(id); //3.根据id查询sku列表 querywrapper\u0026lt;item\u0026gt; querywrapper = new querywrapper(); querywrapper.eq(\u0026#34;goods_id\u0026#34;, id); list\u0026lt;item\u0026gt; itemlist = itemmapper.selectlist(querywrapper); //4.设置复合实体对象 goodsentity goodsentity = new goodsentity(); goodsentity.setgoods(goods); goodsentity.setgoodsdesc(goodsdesc); goodsentity.setitemlist(itemlist); return goodsentity; } (2)controller层\n修改com.offcn.sellergoods.controller.goodscontroller，修改findbyid方法，代码如下：\n/*** * 根据id查询goods数据 * @param id * @return */ @apioperation(value = \u0026#34;goods根据id查询\u0026#34;,notes = \u0026#34;根据id查询goods方法详情\u0026#34;,tags = {\u0026#34;goodscontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;主键id\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @getmapping(\u0026#34;/{id}\u0026#34;) public result\u0026lt;goodsentity\u0026gt; findbyid(@pathvariable long id){ //调用goodsservice实现根据主键查询goods goodsentity goodsentity = goodsservice.findbyid(id); return new result\u0026lt;goodsentity\u0026gt;(true,statuscode.ok,\u0026#34;查询成功\u0026#34;,goodsentity); } 8 保存修改 (1)业务层\n修改dongyimai-sellergoods-service的goodsservice的update方法，代码如下：\n/*** * 修改goods数据 * @param goods */ void update(goodsentity goodsentity); 修改dongyimai-sellergoods-service的goodsserviceimpl ,将sku列表插入的代码提取出来，封装到私有方法中，代码如下：\nprivate void setitemvalue(goodsentity goodsentity, item item) { item.setcategoryid(goodsentity.getgoods().getcategory3id()); //商品分类 三级 item.setcreatetime(new date()); //创建时间 item.setupdatetime(new date()); //更新时间 item.setgoodsid(goodsentity.getgoods().getid()); //spu id item.setsellerid(goodsentity.getgoods().getsellerid()); //商家id //查询分类对象 itemcat itemcat = itemcatmapper.selectbyid(goodsentity.getgoods().getcategory3id()); item.setcategory(itemcat.getname()); //分类名称 //查询品牌对象 brand tbbrand = brandmapper.selectbyid(goodsentity.getgoods().getbrandid()); item.setbrand(tbbrand.getname()); //品牌名称 list\u0026lt;map\u0026gt; imagelist = json.parsearray(goodsentity.getgoodsdesc().getitemimages(), map.class); if (imagelist.size() \u0026gt; 0) { item.setimage((string) imagelist.get(0).get(\u0026#34;url\u0026#34;)); //商品图片 } } //保存sku信息 private void saveitemlist(goodsentity goodsentity) { if (\u0026#34;1\u0026#34;.equals(goodsentity.getgoods().getisenablespec())) { //5.保存sku 商品详情信息 if (!collectionutils.isempty(goodsentity.getitemlist())) { for (item item : goodsentity.getitemlist()) { string title = goodsentity.getgoods().getgoodsname(); //设置sku的名称 商品名+规格选项 map\u0026lt;string, string\u0026gt; specmap = json.parseobject(item.getspec(), map.class); //取得sku的规格选项，并做json类型转换 for (string key : specmap.keyset()) { title += specmap.get(key) + \u0026#34; \u0026#34;; } item.settitle(title); //sku名称 this.setitemvalue(goodsentity, item); //保存sku信息 itemmapper.insert(item); } } } else { //不启用规格 sku信息为默认值 item item = new item(); item.settitle(goodsentity.getgoods().getgoodsname()); //商品名称 item.setprice(goodsentity.getgoods().getprice()); //默认使用spu的价格 item.setnum(9999); item.setstatus(\u0026#34;1\u0026#34;); //是否启用 item.setisdefault(\u0026#34;1\u0026#34;); //是否默认 item.setspec(\u0026#34;{}\u0026#34;); //没有选择规格，则放置空json结构 this.setitemvalue(goodsentity, item); itemmapper.insert(item); } } 在add方法中调用 此方法，修改如下：\n/** * 增加goods * @param goods */ @override public void add(goodsentity goodsentity){ goodsentity.getgoods().setauditstatus(\u0026#34;0\u0026#34;); //审核状态 未审核 //1.保存spu 商品信息对象 goodsmapper.insert(goodsentity.getgoods()); //2.获取商品信息对象主键id ,向商品扩展信息对象中设置主键 goodsentity.getgoodsdesc().setgoodsid(goodsentity.getgoods().getid()); //3.保存商品扩展信息 goodsdescmapper.insert(goodsentity.getgoodsdesc()); //4.保存商品sku信息 this.saveitemlist(goodsentity); } 怎么样，是不是比原来更加清爽了呢？\n接下来，我们修改update方法，实现修改\n/** * 修改goods * @param goods */ @override public void update(goodsentity goodsentity){ //将审核状态重新设置为 未审核 goodsentity.getgoods().setauditstatus(\u0026#34;0\u0026#34;); //1.修改spu的信息 goodsmapper.updatebyid(goodsentity.getgoods()); //2.修改商品扩展信息 goodsdescmapper.updatebyid(goodsentity.getgoodsdesc()); //3.先根据商品id删除sku信息 querywrapper\u0026lt;item\u0026gt; querywrapper = new querywrapper(); querywrapper.eq(\u0026#34;goods_id\u0026#34;, goodsentity.getgoods().getid()); itemmapper.delete(querywrapper); //4.重新添加sku信息 this.saveitemlist(goodsentity); } (2)控制层\n修改com.offcn.sellergoods.controller.goodscontroller，修改update方法，代码如下：\n/*** * 修改goods数据 * @param goods * @param id * @return */ @apioperation(value = \u0026#34;goods根据id修改\u0026#34;,notes = \u0026#34;根据id修改goods方法详情\u0026#34;,tags = {\u0026#34;goodscontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;主键id\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @putmapping(value=\u0026#34;/{id}\u0026#34;) public result update(@requestbody @apiparam(name = \u0026#34;goods复合实体对象\u0026#34;,value = \u0026#34;传入json数据\u0026#34;,required = false) goodsentity goodsentity,@pathvariable long id){ //设置主键值 goodsentity.getgoods().setid(id); //调用goodsservice实现修改goods goodsservice.update(goodsentity); return new result(true,statuscode.ok,\u0026#34;修改成功\u0026#34;); } 八 商品审核与上下架（学员实现） 1 需求分析 商品新增后，审核状态为0（未审核），默认为下架状态。\n审核商品，需要校验是否是被删除的商品，如果未删除则修改审核状态为1，并自动上架\n下架商品，需要校验是否是被删除的商品，如果未删除则修改上架状态为0\n上架商品，需要审核通过的商品\n2 实现思路 （1）按照id查询spu信息\n（2）判断修改审核、上架和下架状态\n（3）保存spu\n3 代码实现 3.1 商品审核 实现审核通过，自动上架。\n(1)业务层\n修改dongyimai-sellergoods-service工程的com.offcn.sellergoods.service.goodsservice接口，添加审核方法，代码如下：\n/*** * 商品审核 * @param goodsid */ void audit(long goodsid); 修改dongyimai-sellergoods-service工程的com.offcn.sellergoods.service.impl.goodsserviceimpl类，添加audit方法，代码如下：\n/*** * 商品审核 * @param goodsid */ @override public void audit(long goodsid) { //查询商品 goods goods = goodsmapper.selectbyid(goodsid); //判断商品是否已经删除 if(goods.getisdelete().equals(\u0026#34;1\u0026#34;)){ throw new runtimeexception(\u0026#34;该商品已经删除！\u0026#34;); } //实现上架和审核 goods.setauditstatus(\u0026#34;1\u0026#34;); //审核通过 goods.setismarketable(\u0026#34;1\u0026#34;); //上架 goodsmapper.updatebyid(goods); } (2)控制层\n修改com.offcn.sellergoods.controller.goodscontroller，新增audit方法，代码如下：\n/** * 审核 * @param id * @return */ @putmapping(\u0026#34;/audit/{id}\u0026#34;) public result audit(@pathvariable long id){ goodsservice.audit(id); return new result(true,statuscode.ok,\u0026#34;审核成功\u0026#34;); } 3.2 下架商品 (1)业务层\n修改com.offcn.sellergoods.service.goodsservice接口，添加pull方法，用于商品下架，代码如下：\n/*** * 商品下架 * @param goodsid */ void pull(long goodsid); 修改com.offcn.sellergoods.impl.goodsserviceimpl，添加如下方法：\n/** * 商品下架 * @param goodsid */ @override public void pull(long goodsid) { goods goods = goodsmapper.selectbyid(goodsid); if(goods.getisdelete().equals(\u0026#34;1\u0026#34;)){ throw new runtimeexception(\u0026#34;此商品已删除！\u0026#34;); } goods.setismarketable(\u0026#34;0\u0026#34;);//下架状态 goodsmapper.updatebyid(goods); } (2)控制层\n修改com.offcn.sellergoods.controller.goodscontroller，添加pull方法，代码如下：\n/** * 下架 * @param id * @return */ @putmapping(\u0026#34;/pull/{id}\u0026#34;) public result pull(@pathvariable long id){ goodsservice.pull(id); return new result(true,statuscode.ok,\u0026#34;下架成功\u0026#34;); } 3.3 上架商品 必须是通过审核的商品才能上架\n(1)业务层\n修改com.offcn.sellergoods.service.goodsservice，添加put方法，代码如下：\n/*** * 商品上架 * @param goodsid */ void put(long goodsid); 修改com.offcn.sellergoods.service.impl.goodsserviceimpl，添加put方法实现，代码如下：\n/*** * 商品上架 * @param goodsid */ @override public void put(long goodsid) { goods goods = goodsmapper.selectbyid(goodsid); //检查是否删除的商品 if(goods.getisdelete().equals(\u0026#34;1\u0026#34;)){ throw new runtimeexception(\u0026#34;此商品已删除！\u0026#34;); } if(!goods.getauditstatus().equals(\u0026#34;1\u0026#34;)){ throw new runtimeexception(\u0026#34;未通过审核的商品不能！\u0026#34;); } //上架状态 goods.setismarketable(\u0026#34;1\u0026#34;); goodsmapper.updatebyid(goods); } (2)控制层\n修改com.offcn.sellergoods.controller.goodscontroller，添加put方法代码如下：\n/** * 商品上架 * @param id * @return */ @putmapping(\u0026#34;/put/{id}\u0026#34;) public result put(@pathvariable long id){ goodsservice.put(id); return new result(true,statuscode.ok,\u0026#34;上架成功\u0026#34;); } 3.4 批量上架 前端传递一组商品id，后端进行批量上下架处理\n(1)业务层\n修改com.offcn.sellergoods.service.goodsservice接口，代码如下：\nint putmany(long[] ids); 修改com.offcn.sellergoods.service.impl.goodsserviceimpl，添加批量上架方法实现，代码如下：\n/*** * 批量上架 * @param ids:需要上架的商品id集合 * @return */ @override public int putmany(long[] ids) { goods goods=new goods(); goods.setismarketable(\u0026#34;1\u0026#34;);//上架 //批量修改 querywrapper\u0026lt;goods\u0026gt; querywrapper = new querywrapper(); querywrapper.in(\u0026#34;id\u0026#34;, arrays.aslist(ids)); //下架 querywrapper.eq(\u0026#34;is_marketable\u0026#34;,\u0026#34;0\u0026#34;); //审核通过的 querywrapper.eq(\u0026#34;audit_status\u0026#34;,\u0026#34;1\u0026#34;); //非删除的 querywrapper.eq(\u0026#34;is_delete\u0026#34;,\u0026#34;0\u0026#34;); return goodsmapper.update(goods, querywrapper); } (2)控制层\n修改com.offcn.sellergoods.controller.goodscontroller，添加批量上架方法，代码如下：\n/** * 批量上架 * @param ids * @return */ @putmapping(\u0026#34;/put/many\u0026#34;) public result putmany(@requestbody long[] ids){ int count = goodsservice.putmany(ids); return new result(true,statuscode.ok,\u0026#34;上架\u0026#34;+count+\u0026#34;个商品\u0026#34;); } 3.5 批量下架 学员实现\n九 删除与还原商品 1 需求分析 请看管理后台的静态原型\n我们为商品管理提供商品删除功能，用户选中部分商品，点击删除按钮即可实现商品删除。注意，这里的删除并非是物理删除，而是修改tb_goods表的is_delete字段为1 ，我们可以称之为“逻辑删除”\n2 实现思路 逻辑删除商品，修改spu表is_delete字段为1\n3 代码实现 3.1 逻辑删除商品 (1)业务层\n修改com.offcn.sellergoods.service.impl.goodsserviceimpl接口，修改delete方法，代码如下：\n/** * 删除 * * @param id */ @override public void delete(long id) { // 逻辑删除 goods goods = goodsmapper.selectbyid(id); //检查是否下架的商品 if (!goods.getismarketable().equals(\u0026#34;0\u0026#34;)) { throw new runtimeexception(\u0026#34;必须先下架再删除！\u0026#34;); } goods.setisdelete(\u0026#34;1\u0026#34;); //未审核 goods.setauditstatus(\u0026#34;0\u0026#34;); goodsmapper.updatebyid(goods); } (2)控制层\n修改com.offcn.sellergoods.controller.goodscontroller，添加delete方法，如下：\n/*** * 根据id删除品牌数据 * @param id * @return */ @apioperation(value = \u0026#34;goods根据id删除\u0026#34;,notes = \u0026#34;根据id删除goods方法详情\u0026#34;,tags = {\u0026#34;goodscontroller\u0026#34;}) @apiimplicitparam(paramtype = \u0026#34;path\u0026#34;, name = \u0026#34;id\u0026#34;, value = \u0026#34;主键id集合\u0026#34;, required = true, datatype = \u0026#34;long\u0026#34;) @deletemapping(\u0026#34;/{id}\u0026#34;) public result delete(@pathvariable long id){ //调用goodsservice实现根据主键删除 goodsservice.delete(id); return new result(true,statuscode.ok,\u0026#34;删除成功\u0026#34;); } 十 注解式事务配置 1 事务异常测试 我们修改dongyimai-sellergoods-service工程goodsserviceimpl.java的add方法\n/** * 增加goods * * @param goods */ @override public void add(goodsentity goodsentity) { goodsentity.getgoods().setauditstatus(\u0026#34;0\u0026#34;); //审核状态 未审核 //1.保存spu 商品信息对象 goodsmapper.insert(goodsentity.getgoods()); //2.获取商品信息对象主键id ,向商品扩展信息对象中设置主键 goodsentity.getgoodsdesc().setgoodsid(goodsentity.getgoods().getid()); //3.保存商品扩展信息 goodsdescmapper.insert(goodsentity.getgoodsdesc()); int i = 1 / 0; //4.保存商品sku信息 this.saveitemlist(goodsentity); } 在插入商品表和扩展表后，人为制造一个异常。我们运行程序，新增商品数据，观察运行结果。\n通过观察，我们发现，程序发生异常 ，商品表仍然会存储记录，这是不符合我们要求的。这是因为我们目前的系统还没有配置事务。\n2 注解式事务解决方案 在项目pom.xml文件中，因为引入了spring-boot-starter-jdbc，会注入一个datasourcetransactionmanager的 bean，提供了事务支持 @transactional\n这个注解可以放在类上，也可以放在方法上；如果是标注在类上，则这个类的所有公共方法，都支持事务；\n如果类和方法上都有，则方法上的注解相关配置，覆盖类上的注解\n@service @transactional public class goodsserviceimpl extends serviceimpl\u0026lt;goodsmapper, goods\u0026gt; implements goodsservice { //此处略 } 经过测试，我们发现，系统发生异常，商品表不会新增记录，事务配置成功。\n删除掉测试代码int x=1/0\n我们需要将所有涉及多表操作的服务类添加事务注解，例如specificationserviceimpl类\n","date":"2022-05-27","permalink":"https://lovemjh.vercel.app/posts/project-0/20220527221560/","summary":"第四章 规格管理、模板管理、分类管理以及商品发布 优就业.JAVA教研室 学习目标 目标一：规格管理 目标二：模板管理 目标三：商品分类管理 目标四：了解电商概念SPU 和SK","title":"规格管理、模板管理、分类管理以及商品发布"},{"content":" 分布式系统概述\nrpc概述\ndubbo核心概念\ndubbo的环境搭建\n分布式系统概述 分布式系统介绍 分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统\n分布式系统（distributed system）是建立在网络之上的软件系统。\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进.\n软件架构的演变 1.单一的应用架构\n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(orm)是关键。\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n缺点： 1、性能扩展比较难\n2、协同开发问题\n3、不利于升级维护用及整合的分布式服务框架(rpc)是关键。\n2.垂直的应用架构\n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的web框架(mvc)是关键。\n通过切分业务来实现各个模块独立部署，降低了维护部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。\n缺点： 公用模块无法重复利用，开发性的浪费\n3.分布式服务架构\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时用于提高业务复用及整合的分布式服务框架(rpc)是关键。\n4.流动计算架构\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(soa)[ service oriented architecture]是关键。\nrpc概述 rpc【remote procedure call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。rpc基本原理：\ndubbo核心概念 dubbo的简介 apache dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源java rpc框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\ndubbox 是一个分布式服务框架，其前身是阿里巴巴开源项目dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在dubbo基础上进行优化，并继续维护，为了与原有的dubbo区分，故将其命名为dubbox。\ndubbox 致力于提供高性能和透明化的rpc远程服务调用方案，以及soa服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。\ndubbo的官网内容介绍 官网：http://dubbo.apache.org/\n官方文档：https://dubbo.apache.org/zh/docs/v2.7/\ndubbo的基本概念 节点角色说明\n服务提供者（provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n服务消费者（consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n注册中心（registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者.\n监控中心（monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n调用关系说明\n1.服务容器负责启动，加载，运行服务提供者。\n2.服务提供者在启动时，向注册中心注册自己提供的服务。\n3.服务消费者在启动时，向注册中心订阅自己所需的服务。\n4.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n5.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n6.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\ndubbo的环境搭建 安装zookeeper 在window安装zookeper\n1.下载zookeeper\n网址：https://archive.apache.org/dist/zookeeper/zookeeper-3.6.2/\n2.解压zookeeper\n在解压的bin 目录中打开命令窗口，运行zkserver.sh.会发现报错，找不到zoo.cfg.\n3.修改zoo.cfg配置文件\n将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。\n注意几个重要位置：\ndatadir=./ 临时数据存储的目录（可写相对路径）\nclientport=2181 zookeeper的端口号\n修改完成后再次启动zookeeper\n4.使用zkcli.cmd测试\nls / :列出zookeeper根下保存的所有节点\ncreate –e /offcn \u0026ldquo;ujiuye\u0026rdquo;：创建一个offcn节点，值为ujiuye\nget /offcn：获取/offcn节点的值\n安装dubbo-admin管理控制台 dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在linux上启动什么dubbo服务。但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。\n1.下载dubbo-admin\n下载路径：https://github.com/apache/dubbo-admin/tree/master\n2.进入目录，修改dubbo-admin配置\n打开配置文件src\\main\\resources\\application.properties，在其中指定zookeeper\ndubbo.registry.address=zookeeper://192.168.18.230:2181\n3.打包dubbo-admin\n在pom文件所在目录下打开命令窗口执行mvn clean package\n4.运行dubbo-admin\n在打包好的jar包路径下打开命令窗口执行：\njava -jar dubbo-admin-0.0.1-snapshot.jar\n5.打开浏览器输入localhost:7001/,登录用户名和密码均为root 进入首页.\n创建提供者消费工程 创建maven父工程 创建实体类子工程 创建实体类 package cn.offcn.entity; public class person implements serializable{ private integer id; private string name; private string gender; private integer age; public person(){} public person(integer id, string name, string gender, integer age) { this.id = id; this.name = name; this.gender = gender; this.age = age; } public integer getid() { return id; } public void setid(integer id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getgender() { return gender; } public void setgender(string gender) { this.gender = gender; } public integer getage() { return age; } public void setage(integer age) { this.age = age; } @override public string tostring() { return \u0026#34;person{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, gender=\u0026#39;\u0026#34; + gender + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 创建子工程dubbo_interface 在pom.xml中引入dubbo_entity依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo_entity\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写persondao接口\npackage cn.offcn.dao; import cn.offcn.entity.person; public interface persondao { public person getpersonbyid(integer id); } 编写persondao接口实现类\nimport java.util.arraylist; import java.util.list; public class persondaoimpl implements persondao { @override public person getpersonbyid(integer id) { list\u0026lt;person\u0026gt; personlist=new arraylist\u0026lt;\u0026gt;(); personlist.add(new person(1,\u0026#34;张三\u0026#34;,\u0026#34;男\u0026#34;,22)); personlist.add(new person(2,\u0026#34;李四\u0026#34;,\u0026#34;女\u0026#34;,28)); personlist.add(new person(2,\u0026#34;王五\u0026#34;,\u0026#34;男\u0026#34;,26)); personlist.add(new person(2,\u0026#34;赵六\u0026#34;,\u0026#34;女\u0026#34;,24)); return personlist.get(id-1); } } 创建子工和dubbo_service_interface 引入依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo_interface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 创建personservice接口\npackage cn.offcn.service; import cn.offcn.entity.person; public interface personservice { person findpersonbyid(integer id); } 创建子service子模块 添加spring依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.5.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-webmvc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.5.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-web\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.5.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.zookeeper\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;zookeeper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zookeeper的客户端 --\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-framework --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.curator\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;curator-framework\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.6.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo_service_interface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.apache.tomcat.maven\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;path\u0026gt;/ssm\u0026lt;/path\u0026gt; \u0026lt;port\u0026gt;8080\u0026lt;/port\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 创建personserviceimpl实现类\npackage cn.offcn.service.impl; import cn.offcn.dao.persondao; import cn.offcn.entity.person; import cn.offcn.service.personservice; import org.springframework.beans.factory.annotation.autowired; public class personserviceimpl implements personservice { @autowired private persondao persondao; public void setpersondao(persondao persondao) { this.persondao = persondao; } @override public person findpersonbyid(integer id) { return persondao.getpersonbyid(id); } } 在resources目录下创建applicationcontext.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\u0026#34;\u0026gt; \u0026lt;!-- 配置提供者的信息--\u0026gt; \u0026lt;dubbo:application name=\u0026#34;dubbo_service_person_service\u0026#34;\u0026gt;\u0026lt;/dubbo:application\u0026gt; \u0026lt;!--指定我们的注册中心 --\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://192.168.18.201:2181\u0026#34;/\u0026gt; \u0026lt;!-- 用dubbo协议在20880端口暴露服务 --\u0026gt; \u0026lt;dubbo:protocol name=\u0026#34;dubbo\u0026#34; port=\u0026#34;20886\u0026#34; /\u0026gt; \u0026lt;!-- 声明需要暴露的服务接口 --\u0026gt; \u0026lt;dubbo:service interface=\u0026#34;cn.offcn.service.personservice\u0026#34; ref=\u0026#34;personservice\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;personservice\u0026#34; class=\u0026#34;cn.offcn.service.impl.personserviceimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;persondao\u0026#34; ref=\u0026#34;persondao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;persondao\u0026#34; class=\u0026#34;cn.offcn.dao.impl.persondaoimpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 编写web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextconfiglocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationcontext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.contextloaderlistener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;/web-app\u0026gt; 创建子工程dubbo_web 引入依赖\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;dubbo_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;dubbo_web\u0026lt;/artifactid\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.2.5.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-webmvc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.2.5.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-web\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.2.5.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.6.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.zookeeper\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;zookeeper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jackson依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jackson-databind\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.9.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zookeeper的客户端 --\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-framework --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.curator\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;curator-framework\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo_interface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo_service_interface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.apache.tomcat.maven\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt; \u0026lt;port\u0026gt;9100\u0026lt;/port\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 在resources目录下创建applicationcontext.xml\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;cn.offcn.service\u0026#34;/\u0026gt; \u0026lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --\u0026gt; \u0026lt;dubbo:application name=\u0026#34;person_customer\u0026#34; /\u0026gt; \u0026lt;!-- 使用zookeeper注册中心暴露发现服务地址 --\u0026gt; \u0026lt;dubbo:registry address=\u0026#34;zookeeper://192.168.18.201:2181\u0026#34;/\u0026gt; \u0026lt;!-- 生成远程服务代理，可以和本地bean一样使用\u0026#34;personserviceservice --\u0026gt; \u0026lt;dubbo:reference id=\u0026#34;personservice\u0026#34; interface=\u0026#34;cn.offcn.service.personservice\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 创建springmvc.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:dubbo=\u0026#34;http://dubbo.apache.org/schema/dubbo\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;cn.offcn.controller\u0026#34;/\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.internalresourceviewresolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 创建web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextconfiglocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationcontext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;!--监听器 servletcontext对象--\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.contextloaderlistener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;!--过滤器用过滤post方式中文乱码--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;characterencodingfilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.characterencodingfilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;characterencodingfilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;!--配置总控制器dispatcherservlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherservlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.dispatcherservlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextconfiglocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherservlet\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- url-pattern 只能配成 / 或者*.xxx --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 编写controller\npackage cn.offcn.controller; import cn.offcn.entity.person; import cn.offcn.service.personservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller public class personcontroller { @autowired private personservice personservice; @requestmapping(\u0026#34;/getpersonbyid\u0026#34;) public person getpersonbyid(integer id){ return personservice.findpersonbyid(id); } } 启动dubbo_service工程,查看服务\n启动dubbo_web工程,查看服务\n通过浏览器访问\nhttp://localhost:9100/getpersonbyid?id=1\n","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/tool/20220526204447/","summary":"分布式系统概述 RPC概述 Dubbo核心概念 Dubbo的环境搭建 分布式系统概述 分布式系统介绍 分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系","title":"dubbo"},{"content":"1 认识elasticsearch （一）基于数据库查询的问题 需求： 查询title中包含‘手机’ 的信息？\n实现：select * from tb_item where title like \u0026lsquo;%手机%\u0026rsquo;;\n问题：\n（1）性能低：如果是模糊查询，坐标有通配符，不会走索引，会进行全表扫描，性能低。\n（2）功能弱：如果以”华为手机“作为条件，查询不出来数据。\n解决：使用es就可以倒排索引就可以解决上述存在的问题\n（二）倒排索引 1 倒排索引概念 倒排索引：将文档进行分词，形成词条和id的对应关系即为反向索引。\n2 倒排索引案例 以唐诗为例，所处包含“前”的诗句？\n正向索引：由《静夜思》\u0026ndash;\u0026gt;床前明月光\u0026mdash;\u0026gt;“前”字\nkey value \u0026laquo;静夜思\u0026raquo; 窗前明月光，疑是地上霜\u0026hellip; \u0026laquo;水调歌头\u0026raquo; 明月几时有，把酒问青天\u0026hellip; \u0026laquo;春晓\u0026raquo; 春眠不觉晓，处处闻啼鸟\u0026hellip; 反向索引：\n“床前明月光”\u0026ndash;\u0026gt; 分词\n将一段文本按照一定的规则，拆分为不同的词条（term） 案例：明月几时有，分词。分词效果如下 （三）elasticsearch存储和查询的原理 index（索引）：相当于mysql的库\n映射：相当于mysql 的表结构\ndocument(文档)：相当于mysql的表中的数据\nes使用倒排索引，对title 进行分词 使用“手机”作为关键字查询\n生成的倒排索引中，词条会排序，形成一颗树形结构，提升词条的查询速度\n使用“华为手机”作为关键字查询\n华为：1,3\n手机：1,2,3 （四）elasticsearch概念详解 elasticsearch是一个基于lucene的搜索服务器 是一个分布式、高扩展、高实时的搜索与数据分析引擎\n基于restful web接口\nelasticsearch是用java语言开发的，并作为apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎\n官网：https://www.elastic.co/\n应用场景\n搜索：海量数据的查询\n日志数据分析\n实时数据分析\n2 安装elasticsearch （一）elasticsearch安装 1 上传elasticsearch安装包 2 执行解压操作 #创建一个安装目录 mkdir /usr/local/es #将elasticsearch-7.4.0-linux-x86_64.tar.gz解压到/usr/local/es 目录下. -c 大写 tar -zxvf elasticsearch-7.4.0-linux-x86_64.tar.gz -c /usr/local/es 3 创建普通用户 因为安全问题，elasticsearch 不允许root用户直接运行，所以要创建新用户，在root用户中创建新用户,执行如下命令：\nuseradd offcn #新增offcn账户 passwd offcn #为offcn账户设置密码 4 为新用户授权，如下图 chown -r offcn:offcn /usr/local/es/elasticsearch-7.4.0 #文件夹所有者 将 /usr/local/es/elasticsearch-7.4.0文件夹授权给offcn用户，由上图可见，我们的文件夹权限赋给了offcn\n5 修改elasticsearch.yml文件 vim /usr/local/es/elasticsearch-7.4.0/config/elasticsearch.yml # ======================== elasticsearch configuration ========================= cluster.name: my-application node.name: node-1 network.host: 0.0.0.0 http.port: 9200 cluster.initial_master_nodes: [\u0026#34;node-1\u0026#34;] cluster.name：配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称\nnode.name：节点名，elasticsearch会默认随机指定一个名字，建议指定一个有意义的名称，方便管理\nnetwork.host：设置为0.0.0.0允许外网访问\nhttp.port：elasticsearch的http访问端口\ncluster.initial_master_nodes：初始化新的集群时需要此配置来选举master\n6 修改虚拟机的配置文件 新创建的offcn用户最大可创建文件数太小，最大虚拟内存太小，切换到root用户，编辑下列配置文件， 添加类似如下内容\n# 切换到root用户 su root #1. ===最大可创建文件数太小======= vim /etc/security/limits.conf # 在文件末尾中增加下面内容 offcn soft nofile 65536 offcn hard nofile 65536 #=========== vim /etc/security/limits.d/20-nproc.conf # 在文件末尾中增加下面内容 offcn soft nofile 65536 offcn hard nofile 65536 * hard nproc 4096 # 注：* 代表linux所有用户名称 #2. ===最大虚拟内存太小======= vim /etc/sysctl.conf # 在文件中增加下面内容 vm.max_map_count=655360 # 重新加载，输入下面命令： sysctl -p 7 启动elasticsearch su offcn #切换到offcn 用户启动 cd /usr/local/es/elasticsearch-7.4.0/bin ./elasticsearch #启动 通过上图我们可以看到elasticsearch已经成功启动\n8 查看elasticsearch是否启动 ps -ef|grep elastic （二）访问elasticsearch 1 关闭防火墙 #暂时关闭防火墙 systemctl stop firewalld.service # 或者 #永久设置防火墙状态 systemctl enable firewalld.service #打开防火墙永久性生效，重启后不会复原 systemctl disable firewalld.service #关闭防火墙，永久性生效，重启后不会复原 2 浏览器访问 说明： 此时elasticsearch已成功启动\n重点几个关注下即可: number\u0026#34; : \u0026#34;7.4.0\u0026#34; 表示elasticsearch版本 lucene_version\u0026#34; : \u0026#34;8.2.0\u0026#34; 表示lucene版本 name ： 默认启动的时候指定了 es 实例名称 cluster_name ： 默认名为 elasticsearch 3 elasticsearch辅助工具安装 （一） postman 介绍和安装 postman是一个http模拟请求的工具。\n官网介绍：“modern software is built on apis，postman helps you develop apis faster”\n看得出来，它是一个专门测试 api 的工具，postman 提供功能强大的 web api 和 http 请求的调试，它能够发送任何类型的http 请求 (get, post, put, delete…)，并且能附带任何数量的参数和 headers。不仅如此，它还提供测试数据和环境配置数据的导入导出。\n进入官网www.getpostman.com，下载\n（二） kibana介绍\u0026amp;安装 1 什么是kibana kibana是一个针对elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在elasticsearch索引中的数据。使用kibana，可以通过各种图表进行高级数据分析及展示。\nkibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示elasticsearch查询动态。\n2 kibana安装 2.1 上传kibana 2.2 解压kibana到安装目录 #创建安装目录 mkdir /usr/local/kibana #将kibana解压到安装目录 tar -zxvf kibana-7.4.0-linux-x86_64.tar.gz -c /usr/local/kibana 2.3 修改kibana配置 vim /usr/local/kibana/kibana-7.4.0-linux-x86_64/config/kibana.yml server.port: 5601 server.host: \u0026#34;0.0.0.0\u0026#34; server.name: \u0026#34;kibana-offcn\u0026#34; elasticsearch.hosts: [\u0026#34;http://127.0.0.1:9200\u0026#34;] elasticsearch.requesttimeout: 99999 server.port：http访问端口\nserver.host：ip地址，0.0.0.0表示可远程访问\nserver.name：kibana服务名\nelasticsearch.hosts：elasticsearch地址\nelasticsearch.requesttimeout：请求elasticsearch超时时间，默认为30000，此处可根据情况设置\n2.4 启动kibana 由于kibana不建议使用root用户启动，如果用root启动，需要加\u0026ndash;allow-root参数\n# 切换到kibana的bin目录 cd /usr/local/kibana/kibana-7.4.0-linux-x86_64/bin # 启动 ./kibana --allow-root 启动成功。\n2.5 访问kibane 访问地址： http://192.168.126.20:5601/ （三）ik分词器安装 1 环境准备 elasticsearch 要使用 ik，就要先构建 ik 的 jar包，这里要用到 maven 包管理工具，而 maven 需要java 环境，而 elasticsearch 内置了jdk， 所以可以将java_home设置为elasticsearch 内置的jdk\n1.1 设置java_home vim /etc/profile # 在profile文件末尾添加 #java environment export java_home=/usr/local/es/elasticsearch-7.4.0/jdk export path=$path:${java_home}/bin # 保存退出后，重新加载profile source /etc/profile 1.2 下载maven安装包 #安装包较小，直接使用wget命令下载，下载的默认位置，当前所在的位置 wget http://mirror.cc.columbia.edu/pub/software/apache/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz 1.3 解压maven安装包 #创建maven的安装包 mkdir /usr/local/maven/ #解压到指定的目录 tar -zxvf apache-maven-3.1.1-bin.tar.gz -c /usr/local/maven/ 1.4 设置软连接 ln -s apache-maven-3.1.1 maven 1.5 设置path #打开文件 vim /etc/profile.d/maven.sh #将下面的内容复制到文件，保存 export maven_home=/usr/local/maven/maven export path=${maven_home}/bin:${path} #设置好maven的路径之后，需要运行下面的命令使其生效 source /etc/profile.d/maven.sh 1.6 验证maven是否安装成功 mvn -v 1.7 设置maven的阿里云镜像 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorof\u0026gt;central\u0026lt;/mirrorof\u0026gt; \u0026lt;/mirror\u0026gt; 2 安装ik分词器 2.1 下载ik分词器 wget https://github.com/medcl/elasticsearch-analysis-ik/archive/v7.4.0.zip 2.2 解压ik到指定目录 由于这里是zip包不是gz包，所以我们需要使用unzip命令进行解压，如果本机环境没有安装unzip，请执行：\nyum install zip yum install unzip 解压ik\nunzip v7.4.0.zip 2.3 编译jar包 # 切换到 elasticsearch-analysis-ik-7.4.0目录 cd elasticsearch-analysis-ik-7.4.0/ #打包，注意第一次使用maven会比较慢，提前配置好阿里云镜像 mvn package 2.4 jar包移动 #切换目录 cd /usr/local/es/elasticsearch-7.4.0/plugins/ #新建目录 mkdir analysis-ik cd analysis-ik #执行拷贝 cp -r /opt/elasticsearch-analysis-ik-7.4.0/target/releases/elasticsearch-analysis-ik-7.4.0.zip /usr/local/es/elasticsearch-7.4.0/plugins/analysis-ik #执行解压 unzip /usr/local/es/elasticsearch-7.4.0/plugins/analysis-ik/elasticsearch-analysis-ik-7.4.0.zip 2.5 拷贝词典 将elasticsearch-analysis-ik-7.4.0目录下的config目录中的所有文件 拷贝到elasticsearch的config目录\ncp -r /opt/elasticsearch-analysis-ik-7.4.0/config/* /usr/local/es/elasticsearch-7.4.0/config 2.6 重新启动 配置成功之后，重新启动es，重新启动kibana，使用ik分词器。\n（四）使用ik分词器 1 ik分词器使用 ik分词器有两种分词模式：ik_max_word和ik_smart模式。\n1.1ik_max_word 会将文本做最细粒度的拆分，比如会将“乒乓球明年总冠军”拆分为“乒乓球、乒乓、球、明年、总冠军、冠军。\n#方式一 ik_max_word get /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;乒乓球明年总冠军\u0026#34; } ik_max_word分词器执行如下：\n{ \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;乒乓球\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 3, \u0026#34;type\u0026#34; : \u0026#34;cn_word\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;乒乓\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 2, \u0026#34;type\u0026#34; : \u0026#34;cn_word\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;球\u0026#34;, \u0026#34;start_offset\u0026#34; : 2, \u0026#34;end_offset\u0026#34; : 3, \u0026#34;type\u0026#34; : \u0026#34;cn_char\u0026#34;, \u0026#34;position\u0026#34; : 2 }, { \u0026#34;token\u0026#34; : \u0026#34;明年\u0026#34;, \u0026#34;start_offset\u0026#34; : 3, \u0026#34;end_offset\u0026#34; : 5, \u0026#34;type\u0026#34; : \u0026#34;cn_word\u0026#34;, \u0026#34;position\u0026#34; : 3 }, { \u0026#34;token\u0026#34; : \u0026#34;总冠军\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 8, \u0026#34;type\u0026#34; : \u0026#34;cn_word\u0026#34;, \u0026#34;position\u0026#34; : 4 }, { \u0026#34;token\u0026#34; : \u0026#34;冠军\u0026#34;, \u0026#34;start_offset\u0026#34; : 6, \u0026#34;end_offset\u0026#34; : 8, \u0026#34;type\u0026#34; : \u0026#34;cn_word\u0026#34;, \u0026#34;position\u0026#34; : 5 } ] } 1.2 ik_smart 会做最粗粒度的拆分，比如会将“乒乓球明年总冠军”拆分为乒乓球、明年、总冠军。\n#方式二ik_smart get /_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;乒乓球明年总冠军\u0026#34; } ik_smart分词器执行如下：\n{ \u0026#34;tokens\u0026#34; : [ { \u0026#34;token\u0026#34; : \u0026#34;乒乓球\u0026#34;, \u0026#34;start_offset\u0026#34; : 0, \u0026#34;end_offset\u0026#34; : 3, \u0026#34;type\u0026#34; : \u0026#34;cn_word\u0026#34;, \u0026#34;position\u0026#34; : 0 }, { \u0026#34;token\u0026#34; : \u0026#34;明年\u0026#34;, \u0026#34;start_offset\u0026#34; : 3, \u0026#34;end_offset\u0026#34; : 5, \u0026#34;type\u0026#34; : \u0026#34;cn_word\u0026#34;, \u0026#34;position\u0026#34; : 1 }, { \u0026#34;token\u0026#34; : \u0026#34;总冠军\u0026#34;, \u0026#34;start_offset\u0026#34; : 5, \u0026#34;end_offset\u0026#34; : 8, \u0026#34;type\u0026#34; : \u0026#34;cn_word\u0026#34;, \u0026#34;position\u0026#34; : 2 } ] } 由此可见 使用ik_smart可以将文本\u0026quot;text\u0026quot;: \u0026ldquo;乒乓球明年总冠军\u0026quot;分成了【乒乓球】【明年】【总冠军】\n这样看的话，这样的分词效果达到了我们的要求。\n1.3 使用ik分词器查询文档 词条查询：term\n​\t词条查询不会分析查询条件，只有当词条和查询字符串完全匹配时才匹配搜索\n全文查询：match\n​ 全文查询会分析查询条件，先将查询条件进行分词，然后查询，求并集\n1.创建索引，添加映射，并指定分词器为ik分词器\nput person2 { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34; }, \u0026#34;age\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;integer\u0026#34; } } } } 2.添加文档\npost /person2/_doc/1 { \u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;address\u0026#34;:\u0026#34;北京海淀区\u0026#34; } post /person2/_doc/2 { \u0026#34;name\u0026#34;:\u0026#34;李四\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;address\u0026#34;:\u0026#34;北京朝阳区\u0026#34; } post /person2/_doc/3 { \u0026#34;name\u0026#34;:\u0026#34;王五\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;address\u0026#34;:\u0026#34;北京昌平区\u0026#34; } post /person2/_doc/4 { \u0026#34;name\u0026#34;:\u0026#34;赵六\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;address\u0026#34;:\u0026#34;昌平区慧聪园\u0026#34; } 3.查询映射\nget person2 4.查看分词效果\nget _analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;ik_max_word\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;北京海淀\u0026#34; } 5.词条查询：term\n查询person2中匹配到\u0026quot;北京\u0026quot;两字的词条\nget /person2/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;address\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;北京\u0026#34; } } } } 6.全文查询：match\n全文查询会分析查询条件，先将查询条件进行分词，然后查询，求并集\nget /person2/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;address\u0026#34;:\u0026#34;北京昌平\u0026#34; } } } 4 elasticsearch核心概念 索引（index）\nelasticsearch存储数据的地方，可以理解成关系型数据库中的数据库概念。\n映射（mapping）\nmapping定义了每个字段的类型、字段所使用的分词器等。相当于关系型数据库中的表结构。\n文档（document）\nelasticsearch中的最小数据单元，常以json格式显示。一个document相当于关系型数据库中的一行数据。\n倒排索引\n一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，对应一个包含它的文档id列表。\n类型（type）\n一种type就像一类表。如用户表、角色表等。在elasticsearch7.x默认type为_doc\nes 5.x中一个index可以有多种type。 es 6.x中一个index只能有一种type。 es 7.x以后，将逐步移除type这个概念，现在的操作已经不再使用，默认_doc 5 脚本操作elasticsearch （一）restful风格介绍 restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，可以降低开发的复杂性，提高系统的可伸缩性。\n特点：\n1.基于http协议\n2.使用xml格式定义或json格式定义\n3.每一个uri代表1种资源。\n4.客户端使用get、post、put、delete 4个表示操作方式的动词对服务端资源进行操作：\nget：用来获取资源\npost：用来新建资源（也可以用于更新资源）\nput：用来更新资源\ndelete：用来删除资源 （二）操作索引 1 创建索引（put） http://ip:端口/索引名称 案例： http://192.168.126.20:9200/index_01 2 查询索引（get） get http://ip:端口/索引名称 # 查询单个索引信息 get http://ip:端口/索引名称1,索引名称2... # 查询多个索引信息 get http://ip:端口/_all # 查询所有索引信息 3 删除索引（delete） delete http://ip:端口/索引名称 4 关闭、打开索引（了解） post http://ip:端口/索引名称/_close post http://ip:端口/索引名称/_open （三）elasticsearch 数据类型 1 简单数据类型 数据类型 备注 字符串 text ：会分词，不支持聚合 相当于mysql 中的sum（求和） keyword：不会分词，将全部内容作为一个词条，支持聚合 数值 byte, short, integer, long, float, double 布尔 boolean 范围类型 integer_range, float_range, long_range, double_range, date_range 日期 date 2 复杂数据类型 数据类型 备注 数组: [ ] nested (for arrays of json objects 数组类型的json对象) 对象：{ } object(for single json objects 单个json对象) （四）操作映射 1 查询映射 get /索引的名称/_mapping 2 创建映射 2.1 创建索引后添加映射 #创建一个person 索引 put person #查询person 索引的mapping 是空 get /person/_mapping #给person 添加索引 put /person/_mapping { \u0026#34;properties\u0026#34;:{ \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, \u0026#34;age\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;integer\u0026#34; } } } 2.2 创建索引并添加映射 #创建索引并且添加映射 put person2 { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; }, \u0026#34;age\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } } #查询映射 get person2/_mapping 添加字段\n#给创建好的索引添加字段 put /person2/_mapping { \u0026#34;properties\u0026#34;:{ \u0026#34;address\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;text\u0026#34; } } } 总结：在实际当中 ，我们很少操作映射，一般都是使用api方式操作文档，所以以上的操作只需要能看懂就可以。\n（五） 操作文档 1 查询文档 #根据id查询具体的文档 语法： get /索引的名称/_doc/索引的id 案例： get /person1/_doc/1 #查询所有的文档 语法：get /索引名称/_search 案例：get /person1/_search 2 添加文档，指定id #语法：post /索引的名称/文档的类型/文档的id post /person2/_doc/1 { \u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;address\u0026#34;:\u0026#34;北京\u0026#34; } #查询文档 get /person1/_doc/1 添加文档，不指定id\n#添加文档，不指定id post /person1/_doc/ { \u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;address\u0026#34;:\u0026#34;北京\u0026#34; } #查询所有文档 get /person1/_search 3 删除文档 #删除指定id文档 delete /person1/_doc/1 7 elasticsearch javaapi （一）springboot整合elasticsearch环境搭建 1 搭建springboot工程 2 引入elasticsearch相关坐标 \u0026lt;!--引入es的坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.elasticsearch.client\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;elasticsearch-rest-high-level-client\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;7.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.elasticsearch.client\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;elasticsearch-rest-client\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;7.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.elasticsearch\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;elasticsearch\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;7.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3 编写核心配置类 编写核心配置文件：\nelasticsearch: hostname: 192.168.126.20 port: 9200 编写核心配置类\n@configuration @configurationproperties(prefix=\u0026#34;elasticsearch\u0026#34;) public class elasticsearchconfig { private string host; private int port; @bean public resthighlevelclient client(){ return new resthighlevelclient(restclient.builder( new httphost(host,port,\u0026#34;http\u0026#34;) )); } public string gethost() { return host; } public void sethost(string host) { this.host = host; } public int getport() { return port; } public void setport(int port) { this.port = port; } } 4 测试客户端对象 注意：使用@autowired注入resthighlevelclient 如果报红线，则是因为配置类所在的包和测试类所在的包，包名不一致造成的\n@springboottest class springelasticsearchapplicationtests { @autowired private resthighlevelclient resthighlevelclient; @test void contextloads() { system.out.println(resthighlevelclient); } } （二）操作elasticsearch 1 添加索引 /** * 添加索引： * @throws exception */ @test public void addindex() throws exception{ //1：使用resthighlevelclient获取操作索引的对象 indicesclient indices = resthighlevelclient.indices(); //2: 具体操作索引，并且获得返回值 //2.1 创建索引对象，设置索引的名称 createindexrequest createindexrequest = new createindexrequest(\u0026#34;offcn\u0026#34;); //2.2 创建索引，获得返回值 createindexresponse createindexresponse = indices.create(createindexrequest, requestoptions.default); //3:根据返回值判断返回结果 system.out.println(createindexresponse.isacknowledged()); } 2 添加索引，并添加映射 /** * 创建索引并且添加映射 * @throws ioexception */ @test public void addindexandmapping() throws ioexception { //1.使用client获取操作索引的对象 indicesclient indicesclient = resthighlevelclient.indices(); //2.具体操作，获取返回值 createindexrequest createrequest = new createindexrequest(\u0026#34;offcn\u0026#34;); //2.1 设置mappings string mapping = \u0026#34;{\\n\u0026#34; + \u0026#34; \\\u0026#34;properties\\\u0026#34; : {\\n\u0026#34; + \u0026#34; \\\u0026#34;address\\\u0026#34; : {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34; : \\\u0026#34;text\\\u0026#34;,\\n\u0026#34; + \u0026#34; \\\u0026#34;analyzer\\\u0026#34; : \\\u0026#34;ik_max_word\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;age\\\u0026#34; : {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34; : \\\u0026#34;long\\\u0026#34;\\n\u0026#34; + \u0026#34; },\\n\u0026#34; + \u0026#34; \\\u0026#34;name\\\u0026#34; : {\\n\u0026#34; + \u0026#34; \\\u0026#34;type\\\u0026#34; : \\\u0026#34;keyword\\\u0026#34;\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\u0026#34;; createrequest.mapping(mapping, xcontenttype.json); //2.2执行创建，返回对象 createindexresponse response = indicesclient.create(createrequest, requestoptions.default); //3.根据返回值判断结果 system.out.println(response.isacknowledged()); } 3 查询、删除、判断索引 3.1 查询索引 /** * 查询索引 */ @test public void queryindex() throws ioexception { //1:使用client获取操作索引的对象 indicesclient indices = resthighlevelclient.indices(); //2:获得对象，执行具体的操作 //2.1 创建获取索引的请求对象，设置索引名称 getindexrequest getreqeust = new getindexrequest(\u0026#34;offcn\u0026#34;); //2.2 执行查询，获得返回值 getindexresponse response = indices.get(getreqeust, requestoptions.default); //3：获取结果,遍历 map\u0026lt;string, mappingmetadata\u0026gt; mappings = response.getmappings(); for (string key : mappings.keyset()) { system.out.println(key + \u0026#34;:\u0026#34; + mappings.get(key).getsourceasmap()); } } 3.2 删除索引 /** * 删除索引 */ @test public void deleteindex() throws ioexception { indicesclient indices = resthighlevelclient.indices(); deleteindexrequest deleterequest = new deleteindexrequest(\u0026#34;offcn\u0026#34;); acknowledgedresponse response = indices.delete(deleterequest, requestoptions.default); system.out.println(response.isacknowledged()); } 3.3 索引是否存在 /** * 判断索引是否存在 */ @test public void existindex() throws ioexception { indicesclient indices = resthighlevelclient.indices(); getindexrequest getrequest = new getindexrequest(\u0026#34;person\u0026#34;); boolean exists = indices.exists(getrequest, requestoptions.default); system.out.println(exists); } 4 操作文档 4.1 添加文档 添加文档,使用map作为数据\n/** * 添加文档,使用map作为数据 */ @test public void adddoc() throws ioexception { //数据对象，map map data = new hashmap(); data.put(\u0026#34;address\u0026#34;, \u0026#34;北京昌平\u0026#34;); data.put(\u0026#34;name\u0026#34;, \u0026#34;马同志\u0026#34;); data.put(\u0026#34;age\u0026#34;, 20); //1：获取操作文档的对象 indexrequest request = new indexrequest(\u0026#34;offcn\u0026#34;).id(\u0026#34;1\u0026#34;).source(data); //2：添加数据，获取结果 indexresponse response = resthighlevelclient.index(request, requestoptions.default); //3：打印响应结果 system.out.println(response.getid()); } 添加文档,使用对象作为数据\n/** * 添加文档,使用对象作为数据 */ @test public void adddoc2() throws ioexception { //数据对象，javaobject person p = new person(); p.setid(\u0026#34;2\u0026#34;); p.setname(\u0026#34;小胖2222\u0026#34;); p.setage(30); p.setaddress(\u0026#34;陕西西安\u0026#34;); //将对象转为json string data = json.tojsonstring(p); //1:获取操作文档的对象 indexrequest request = new indexrequest(\u0026#34;offcn\u0026#34;).id(p.getid()).source(data, xcontenttype.json); //2:添加数据，获取结果 indexresponse response = resthighlevelclient.index(request, requestoptions.default); //3:打印响应结果 system.out.println(response.getid()); } 4.2 修改文档：添加文档时，如果id存在则修改，id不存在则添加 /** * 修改文档：添加文档时，如果id存在则修改，id不存在则添加 */ @test public void updatedoc() throws ioexception { //数据对象，map map data = new hashmap(); data.put(\u0026#34;address\u0026#34;, \u0026#34;北京昌平\u0026#34;); data.put(\u0026#34;name\u0026#34;, \u0026#34;朱同志\u0026#34;); data.put(\u0026#34;age\u0026#34;, 20); //1：获取操作文档的对象 indexrequest request = new indexrequest(\u0026#34;offcn\u0026#34;).id(\u0026#34;1\u0026#34;).source(data); //2：添加数据，获取结果 indexresponse response = resthighlevelclient.index(request, requestoptions.default); //3：打印响应结果 system.out.println(response.getid()); } 4.3 根据id查询文档 /** * 根据id查询文档 */ @test public void finddocbyid() throws ioexception { getrequest getreqeust = new getrequest(\u0026#34;offcn\u0026#34;, \u0026#34;1\u0026#34;); //getreqeust.id(\u0026#34;1\u0026#34;); getresponse response = resthighlevelclient.get(getreqeust, requestoptions.default); //获取数据对应的json system.out.println(response.getsourceasstring()); } 4.4 根据id删除文档 /** * 根据id删除文档 */ @test public void deldoc() throws ioexception { deleterequest deleterequest = new deleterequest(\u0026#34;offcn\u0026#34;, \u0026#34;1\u0026#34;); deleteresponse response = resthighlevelclient.delete(deleterequest, requestoptions.default); system.out.println(response.getid()); } （三）elasticsearch的批量操作 1 bulk 批量操作脚本实现 需求：同时完成删除，更新，添加操作\npost _bulk {\u0026#34;delete\u0026#34;:{\u0026#34;_index\u0026#34;:\u0026#34;person1\u0026#34;,\u0026#34;_id\u0026#34;:\u0026#34;4\u0026#34;}} {\u0026#34;create\u0026#34;:{\u0026#34;_index\u0026#34;:\u0026#34;person1\u0026#34;,\u0026#34;_id\u0026#34;:\u0026#34;5\u0026#34;}} {\u0026#34;name\u0026#34;:\u0026#34;八号\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;address\u0026#34;:\u0026#34;北京\u0026#34;} {\u0026#34;update\u0026#34;:{\u0026#34;_index\u0026#34;:\u0026#34;person1\u0026#34;,\u0026#34;_id\u0026#34;:\u0026#34;2\u0026#34;}} {\u0026#34;doc\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;2号\u0026#34;}} 查询运行结果~ 2 bulk批量操作javaapi 实现 /** * bulk 批量操作 */ @test public void test2() throws ioexception { //创建bulkrequest对象，整合所有操作 bulkrequest bulkrequest =new bulkrequest(); /* # 1. 删除5号记录 # 2. 添加6号记录 # 3. 修改3号记录 名称为 “三号” */ //添加对应操作 //1. 删除5号记录 deleterequest deleterequest=new deleterequest(\u0026#34;person1\u0026#34;,\u0026#34;5\u0026#34;); bulkrequest.add(deleterequest); //2. 添加6号记录 map\u0026lt;string, object\u0026gt; map=new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;name\u0026#34;,\u0026#34;六号\u0026#34;); indexrequest indexrequest=new indexrequest(\u0026#34;person1\u0026#34;).id(\u0026#34;6\u0026#34;).source(map); bulkrequest.add(indexrequest); //3. 修改3号记录 名称为 “三号” map\u0026lt;string, object\u0026gt; mapupdate=new hashmap\u0026lt;\u0026gt;(); mapupdate.put(\u0026#34;name\u0026#34;,\u0026#34;三号\u0026#34;); updaterequest updaterequest=new updaterequest(\u0026#34;person1\u0026#34;,\u0026#34;3\u0026#34;).doc(mapupdate); bulkrequest.add(updaterequest); //执行批量操作 bulkresponse response = client.bulk(bulkrequest, requestoptions.default); system.out.println(response.status()); } 3 导入数据分析\u0026amp;创建索引 需求： 将数据库中good表的数据导入到elasticsearch当中\n实现步骤：\n分析goods表结构\n创建goods索引\n查询goods表数据\n批量添加到elasticsearch中\nput goods { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ik_smart\u0026#34; }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;double\u0026#34; }, \u0026#34;createtime\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;date\u0026#34; }, \u0026#34;categoryname\u0026#34;: {\t\u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;brandname\u0026#34;: {\t\u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;spec\u0026#34;: {\t\u0026#34;type\u0026#34;: \u0026#34;object\u0026#34; }, \u0026#34;salenum\u0026#34;: {\t\u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;stock\u0026#34;: {\t\u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } } title:商品标题\nprice:商品价格\ncreatetime:创建时间\ncategoryname:分类名称。如：家电，手机\nbrandname:品牌名称。如：华为，小米\nspec: 商品规格。如： spec:{\u0026ldquo;屏幕尺寸\u0026rdquo;,\u0026ldquo;5寸\u0026rdquo;，\u0026ldquo;内存大小\u0026rdquo;,\u0026ldquo;128g\u0026rdquo;}\nsalenum:销量\nstock:库存量\n插入一条测试数据\npost goods/_doc/1 { \u0026#34;title\u0026#34;:\u0026#34;小米手机\u0026#34;, \u0026#34;price\u0026#34;:1000, \u0026#34;createtime\u0026#34;:\u0026#34;2021-12-01\u0026#34;, \u0026#34;categoryname\u0026#34;:\u0026#34;手机\u0026#34;, \u0026#34;brandname\u0026#34;:\u0026#34;小米\u0026#34;, \u0026#34;salenum\u0026#34;:3000, \u0026#34;stock\u0026#34;:10000, \u0026#34;spec\u0026#34;:{ \u0026#34;网络制式\u0026#34;:\u0026#34;移动4g\u0026#34;, \u0026#34;屏幕尺寸\u0026#34;:\u0026#34;4.5\u0026#34; } } 4 导入数据代码实现 /** * 从mysql 批量导入 elasticsearch */ @test public void test3() throws ioexception { //1.查询所有数据，mysql list\u0026lt;goods\u0026gt; goodslist = goodsmapper.findall(); //2.bulk导入 bulkrequest bulkrequest=new bulkrequest(); //2.1 循环goodslist，创建indexrequest添加数据 for (goods goods : goodslist) { //2.2 设置spec规格信息 map的数据 specstr:{} string specstr = goods.getspecstr(); //将json格式字符串转为map集合 map map = json.parseobject(specstr, map.class); //设置spec map goods.setspec(map); //将goods对象转换为json字符串 string data = json.tojsonstring(goods); indexrequest indexrequest=new indexrequest(\u0026#34;goods\u0026#34;).source(data,xcontenttype.json); bulkrequest.add(indexrequest); } bulkresponse response = client.bulk(bulkrequest, requestoptions.default); system.out.println(response.status()); } （四）elasticsearch高级查询 1 matchall脚本实现 # 默认情况下，es一次展示10条数据,通过from和size来控制分页 # 查询结果详解 get goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 100 } get goods 2 matchall-javaapi /** * 查询所有 * 1. matchall * 2. 将查询结果封装为goods对象，装载到list中 * 3. 分页。默认显示10条 */ @test public void matchall() throws ioexception { //2. 构建查询请求对象，指定查询的索引名称 searchrequest searchrequest=new searchrequest(\u0026#34;goods\u0026#34;); //4. 创建查询条件构建器searchsourcebuilder searchsourcebuilder sourcebuilder=new searchsourcebuilder(); //6. 查询条件 querybuilder querybuilder= querybuilders.matchallquery(); //5. 指定查询条件 sourcebuilder.query(querybuilder); //3. 添加查询条件构建器 searchsourcebuilder searchrequest.source(sourcebuilder); // 8 . 添加分页信息 不设置 默认10条 // sourcebuilder.from(0); // sourcebuilder.size(100); //1. 查询,获取查询结果 searchresponse searchresponse = client.search(searchrequest, requestoptions.default); //7. 获取命中对象 searchhits searchhits hits = searchresponse.gethits(); //7.1 获取总记录数 long total= hits.gettotalhits().value; system.out.println(\u0026#34;总数：\u0026#34;+total); //7.2 获取hits数据 数组 searchhit[] hits1 = hits.gethits(); //获取json字符串格式的数据 list\u0026lt;goods\u0026gt; goodslist = new arraylist\u0026lt;\u0026gt;(); for (searchhit searchhit : hits1) { string sourceasstring = searchhit.getsourceasstring(); //转为java对象 goods goods = json.parseobject(sourceasstring, goods.class); goodslist.add(goods); } for (goods goods : goodslist) { system.out.println(goods); } } 3 termquery 词条查询 term查询和字段类型有关系，首先回顾一下elasticsearch两个数据类型\nelasticsearch两个数据类型：\ntext：会分词，不支持聚合 keyword：不会分词，将全部内容作为一个词条，支持聚合 脚本实现：\n#term查询： 查询title当中包含 华为 get /goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;华为\u0026#34; } } } } javaapi代码实现：\n/** * termquery:词条查询 */ @test public void testtermquery() throws ioexception { searchrequest searchrequest = new searchrequest(\u0026#34;goods\u0026#34;); searchsourcebuilder sourcebulider = new searchsourcebuilder(); querybuilder query = querybuilders.termquery(\u0026#34;title\u0026#34;,\u0026#34;华为\u0026#34;);//term词条查询 sourcebulider.query(query); searchrequest.source(sourcebulider); searchresponse searchresponse = client.search(searchrequest, requestoptions.default); searchhits searchhits = searchresponse.gethits(); //获取记录数 long value = searchhits.gettotalhits().value; system.out.println(\u0026#34;总记录数：\u0026#34;+value); list\u0026lt;goods\u0026gt; goodslist = new arraylist\u0026lt;\u0026gt;(); searchhit[] hits = searchhits.gethits(); for (searchhit hit : hits) { string sourceasstring = hit.getsourceasstring(); //转为java goods goods = json.parseobject(sourceasstring, goods.class); goodslist.add(goods); } for (goods goods : goodslist) { system.out.println(goods); } } 4 matchquery match查询，会对查询条件分词，然后将分词后的查询条件和词条进行等值匹配,默认取并集（or）\n# match查询 get goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;华为手机\u0026#34; } }, \u0026#34;size\u0026#34;: 500 } match 的默认搜索（or 并集）\n例如：华为手机，会分词为 “华为”，“手机” 只要出现其中一个词条都会搜索到\nmatch的 and（交集） 搜索\n例如：例如：华为手机，会分词为 “华为”，“手机” 但要求“华为”，和“手机”同时出现在词条\n总结：\nterm query会去倒排索引中寻找确切的term，它并不知道分词器的存在。这种查询适合keyword 、numeric、date\nmatch query知道分词器的存在。并且理解是如何被分词的\n5 模糊查询脚本实现 通配符使用，?代表任意单个字符，*代表0个或者是多个字符 案例： \u0026#34;*华*\u0026#34; 包含华字的 \u0026#34;华*\u0026#34; 华字后边多个字符 \u0026#34;华?\u0026#34; 华字后边单个字符 \u0026#34;*华\u0026#34;或\u0026#34;?华\u0026#34; 会引发全表（全索引）扫描 注意效率问题 # wildcard 查询。查询条件分词，模糊查询 get goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;wildcard\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;华*\u0026#34; } } } } 6 模糊查询javaapi //模糊查询 wildcardquerybuilder query = querybuilders.wildcardquery(\u0026#34;title\u0026#34;, \u0026#34;华*\u0026#34;);//华后多个字符 7 范围查询脚本实现 # 范围查询 get goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;range\u0026#34;: { \u0026#34;price\u0026#34;: { \u0026#34;gte\u0026#34;: 2000, \u0026#34;lte\u0026#34;: 3000 } } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ] } 8 范围查询api实现 //范围查询 以price 价格为条件 rangequerybuilder query = querybuilders.rangequery(\u0026#34;price\u0026#34;); //指定下限 query.gte(2000); //指定上限 query.lte(3000); sourcebuilder.query(query); //排序 价格 降序排列 sourcebuilder.sort(\u0026#34;price\u0026#34;,sortorder.desc); 9 querystring 查询 querystring 多条件查询\n会对查询条件进行分词。\n然后将分词后的查询条件和词条进行等值匹配\n默认取并集（or）\n可以指定多个查询字段\nquery_string：识别query中的连接符（or 、and）\n# querystring get goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;query_string\u0026#34;: { \u0026#34;fields\u0026#34;: [\u0026#34;title\u0026#34;,\u0026#34;categoryname\u0026#34;,\u0026#34;brandname\u0026#34;], \u0026#34;query\u0026#34;: \u0026#34;华为 and 手机\u0026#34; } } } simple_query_string：不识别query中的连接符（or 、and），查询时会将 “华为”、\u0026ldquo;and\u0026rdquo;、“手机”分别进行查询\nget goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;simple_query_string\u0026#34;: { \u0026#34;fields\u0026#34;: [\u0026#34;title\u0026#34;,\u0026#34;categoryname\u0026#34;,\u0026#34;brandname\u0026#34;], \u0026#34;query\u0026#34;: \u0026#34;华为 and 手机\u0026#34; } } } 10 querystring javaapi代码实现： querystringquerybuilder query = querybuilders.querystringquery(\u0026#34;华为手机\u0026#34;).field(\u0026#34;title\u0026#34;).field(\u0026#34;categoryname\u0026#34;) .field(\u0026#34;brandname\u0026#34;).defaultoperator(operator.and); 11 聚合查询脚本实现 指标聚合：相当于mysql的聚合函数。max、min、avg、sum等\n桶聚合：相当于mysql的 group by 操作。不要对text类型的数据进行分组，会失败\n# 聚合查询 # 指标聚合 聚合函数 get goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;手机\u0026#34; } }, \u0026#34;aggs\u0026#34;: { \u0026#34;max_price\u0026#34;: { \u0026#34;max\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;price\u0026#34; } } } } # 桶聚合 分组 get goods/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;手机\u0026#34; } }, \u0026#34;aggs\u0026#34;: { \u0026#34;goods_brands\u0026#34;: { \u0026#34;terms\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;brandname\u0026#34;, \u0026#34;size\u0026#34;: 100 } } } } 12 聚合查询javaapi 聚合查询：桶聚合，分组查询\n查询title包含手机的数据\n查询品牌列表\n/** * 聚合查询：桶聚合，分组查询 * 1. 查询title包含手机的数据 * 2. 查询品牌列表 */ @test public void testaggquery() throws ioexception { searchrequest searchrequest=new searchrequest(\u0026#34;goods\u0026#34;); searchsourcebuilder sourcebuilder=new searchsourcebuilder(); //1. 查询title包含手机的数据 matchquerybuilder querybuilder = querybuilders.matchquery(\u0026#34;title\u0026#34;, \u0026#34;手机\u0026#34;); sourcebuilder.query(querybuilder); //2. 查询品牌列表 只展示前100条 aggregationbuilder aggregation=aggregationbuilders.terms(\u0026#34;goods_brands\u0026#34;).field(\u0026#34;brandname\u0026#34;).size(100); sourcebuilder.aggregation(aggregation); searchrequest.source(sourcebuilder); searchresponse searchresponse = client.search(searchrequest, requestoptions.default); //7. 获取命中对象 searchhits searchhits hits = searchresponse.gethits(); //7.1 获取总记录数 long total= hits.gettotalhits().value; system.out.println(\u0026#34;总数：\u0026#34;+total); // aggregations 对象 aggregations aggregations = searchresponse.getaggregations(); //将aggregations 转化为map map\u0026lt;string, aggregation\u0026gt; aggregationmap = aggregations.asmap(); //通过key获取goods_brands 对象 使用aggregation的子类接收 buckets属性在terms接口中体现 // aggregation goods_brands1 = aggregationmap.get(\u0026#34;goods_brands\u0026#34;); terms goods_brands =(terms) aggregationmap.get(\u0026#34;goods_brands\u0026#34;); //获取buckets 数组集合 list\u0026lt;? extends terms.bucket\u0026gt; buckets = goods_brands.getbuckets(); map\u0026lt;string,object\u0026gt;map=new hashmap\u0026lt;\u0026gt;(); //遍历buckets key 属性名，doc_count 统计聚合数 for (terms.bucket bucket : buckets) { system.out.println(bucket.getkey()); map.put(bucket.getkeyasstring(),bucket.getdoccount()); } system.out.println(map); } ","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/tool/20220526220934/","summary":"1 认识ElasticSearch （一）基于数据库查询的问题 需求： 查询title中包含‘手机’ 的信息？ 实现：SELECT * FROM tb_item WHERE title LIKE \u0026lsquo;%手机%\u0026rsq","title":"elasticsearch"},{"content":"mybatis_plus 一、mybatis-plus简介 (一) 什么是mybatis-plus mybatisplus是一个 mybatis (opens new window)的增强工具，在 mybatis的基础上只做增强不做改变，为简化开发、提高效率而生。愿景是成为 mybatis最好的搭档，就像魂斗罗中的 1p、2p，基友搭配，效率翻倍。 (二) mybatis-plus的优势 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。 损耗小：启动即会自动注入基本 curd，性能基本无损耗，直接面向对象操作。 强大的 crud 操作：内置通用 mapper、通用 service，仅仅通过少量配置即可实现单表大部分 crud 操作，更有强大的条件构造器，满足各类使用需求。 支持 lambda 形式调用：通过 lambda 表达式，方便的编写各类查询条件，无需再担心字段写错。 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 id 生成器 - sequence），可自由配置，完美解决主键问题 支持 activerecord 模式：支持 activerecord 形式调用，实体类只需继承 model 类即可进行强大的 crud 操作。 支持自定义全局通用操作：支持全局通用方法注入（ write once, use anywhere ）。 内置代码生成器：采用代码或者 maven 插件可快速生成 mapper 、 model 、 service 、 controller 层代码，支持模板引擎，更有超多自定义配置等您来使用。 内置分页插件：基于 mybatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 list 查询。 分页插件支持多种数据库：支持 mysql、mariadb、oracle、db2、h2、hsql、sqlite、postgre、sqlserver 等多种数据库。 内置性能分析插件：可输出 sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询。 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作。 (三)mybaisplus的框架结构 二、springboot整合mybatis-plus入门案例 授课思路\n本章主要回顾springboot项目的创建步聚及整合mybatis—plus的步聚。mybatis-plus的dao层接口必须实现basemapper接口，调用selectlist查测查询结果。 (一) 创建maven工程添加依赖 1.择idear中的file-\u0026gt;new-\u0026gt;project 2.输入项目组、项目名称及版本 3.检查项目名称及存储位置 4.引用依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; (二) 创建数据库表employee create table employee( emp_id bigint(20) not null, emp_name varchar(30), emp_gender varchar(6), age int, email varchar(50), primary key(emp_id) ); insert into employee(emp_id,emp_name,emp_gender,age,email) values(1367686308726788098,\u0026#39;刘晓娟\u0026#39;,\u0026#39;女\u0026#39;,20,\u0026#39;liuxianjuan@qq.com\u0026#39;); insert into employee(emp_id,emp_name,emp_gender,age,email) values(1367709299695099906,\u0026#39;张春雨\u0026#39;,\u0026#39;男\u0026#39;,28,\u0026#39;zhangchunyu@sina.com\u0026#39;); insert into employee(emp_id,emp_name,emp_gender,age,email) values(1367717669156028418,\u0026#39;何雨柱\u0026#39;,\u0026#39;男\u0026#39;,23,\u0026#39;heyuzhu@126.com\u0026#39;); (三)构建数据模型employee public class employee { private long empid; private string name; private string empgender; private integer age; private string email; public long getempid() { return empid; } public void setempid(long empid) { this.empid = empid; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getempgender() { return empgender; } public void setempgender(string empgender) { this.empgender = empgender; } public integer getage() { return age; } public void setage(integer age) { this.age = age; } public string getemail() { return email; } public void setemail(string email) { this.email = email; } @override public string tostring() { return \u0026#34;employee{\u0026#34; + \u0026#34;empid=\u0026#34; + empid + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, empgender=\u0026#39;\u0026#34; + empgender + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, email=\u0026#39;\u0026#34; + email + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } (四)配置application.yml spring: datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql:///mybatis_plus username: root password: root logging: level: com: offcn: mybatis: dao: debug (五) 编写spring boot 启动类 @springbootapplication @mapperscan(\u0026#34;com.offcn.mp.dao\u0026#34;) public class mybatisplus01application { public static void main(string[] args) { springapplication.run(mybatisplus01application.class, args); } } (六) 编写mapper接口 package com.offcn.springboot.mp.dao; import com.baomidou.mybatisplus.core.mapper.basemapper; import com.offcn.springboot.mp.entity.employee; public interface employeedao extends basemapper\u0026lt;employee\u0026gt; { } (七)启动服务测试结果 @runwith(springrunner.class) @springboottest public class mybatisplus01applicationtests { @autowired private employeemapper employeemapper; @test public void testselect(){ list\u0026lt;employee\u0026gt; employeelist = employeemapper.selectlist(null); employeelist.foreach( system.out::println); } } (八)测试 @springboottest class springbootmybatisplus001applicationtests { @autowired private employeedao employeedao; @test void contextloads() { } @test public void getallemployee(){ list\u0026lt;employee\u0026gt; employeelist = employeedao.selectlist(null); employeelist.foreach(system.out::println); } } 三、lombok插件 (一)lombok插件简介 lombok是一个插件，用途是使用注解给你类里面的字段，自动的加上属性构造器，tostring方法，equals方法等等,比较方便的一点是，你在更改字段的时候，lombok会立即发生改变以保持和你代码的一致性。 (二)常用的 lombok 注解介绍 @getter 加在类上，可以自动生成参数的getter方法。 @setter 加在类上，可以自动生成参数的setter方法 @tostring 加在类上，调用tostring()方法，可以输出实体类中所有属性的值 @requiredargsconstructor会生成一个包含常量，和标识了notnull的变量的构造方法。生成的构造方法是私有的private。这个用的很少。 @equalsandhashcode 1.它会生成equals和hashcode方法 2.默认使用非静态的属性 3.可以通过exclude参数排除不需要生成的属性 4.可以通过of参数来指定需要生成的属性 5.它默认不调用父类的方法，只使用本类定义的属性进行操作，可以使用callsuper=true来解决，会在@data中进行讲解。 @data这个是非常常用的注解，这个注解其实是以上五个注解的合体。 @noargsconstructor生成一个无参数的构造方法。 @allargsconstructor生成一个包含所有变量的构造方法。 @value这个注解要和spring的@value注解区分，spring的是从配置文件读取内容，这个注解是在类中的所有字段默认全部声明为private final类型，只会生成getter方法，不会生成setter方法，很少用。 @cleanup主要用于关闭资源使用。 (三)idea安装lombok插件 首先我们需要安装intellij idea中的lombok插件，打开intellij idea后点击菜单栏中的file\u0026ndash;\u0026gt;settings，或者使用快捷键ctrl+alt+s进入到设置页面 我们点击设置中的plugins进行插件的安装，在右侧选择browse repositories\u0026hellip;，然后在搜索页面输入lombok变可以查询到下方的lombok plugin，鼠标点击lombok plugin可在右侧看到install按钮，点击该按钮便可安装。 按装完成之后重启idear即可。\n(四)lombok插件的使用 1.去除employee类中的setter和getter方法 public class employee { private long empid; private string name; private string empgender; private integer age; private string email; } 2.在employee类上添加lombok注解 @noargsconstructor @allargsconstructor @data @tostring public class employee { private long empid; private string name; private string empgender; private integer age; private string email; } 四、mybatis-plus通用crud (一)basemapper接口方法介绍 basemaper中提供了crud方法，具体方法如下： // 插入一条记录 int insert(t entity); // 根据 entity 条件，删除记录 int delete(@param(constants.wrapper) wrapper\u0026lt;t\u0026gt; wrapper); // 删除（根据id 批量删除） int deletebatchids(@param(constants.collection) collection\u0026lt;? extends serializable\u0026gt; idlist); // 根据 id 删除 int deletebyid(serializable id); // 根据 columnmap 条件，删除记录 int deletebymap(@param(constants.column_map) map\u0026lt;string, object\u0026gt; columnmap); // 根据 whereentity 条件，更新记录 int update(@param(constants.entity) t entity, @param(constants.wrapper) wrapper\u0026lt;t\u0026gt; updatewrapper); // 根据 id 修改 int updatebyid(@param(constants.entity) t entity); list\u0026lt;t\u0026gt; selectlist(@param(constants.wrapper) wrapper\u0026lt;t\u0026gt; querywrapper); // 查询（根据 columnmap 条件） list\u0026lt;t\u0026gt; selectbymap(@param(constants.column_map) map\u0026lt;string, object\u0026gt; columnmap); // 根据 wrapper 条件，查询全部记录 list\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; selectmaps(@param(constants.wrapper) wrapper\u0026lt;t\u0026gt; querywrapper); // 根据 wrapper 条件，查询全部记录。注意： 只返回第一个字段的值 list\u0026lt;object\u0026gt; selectobjs(@param(constants.wrapper) wrapper\u0026lt;t\u0026gt; querywrapper); // 根据 entity 条件，查询全部记录（并翻页） ipage\u0026lt;t\u0026gt; selectpage(ipage\u0026lt;t\u0026gt; page, @param(constants.wrapper) wrapper\u0026lt;t\u0026gt; querywrapper); // 根据 wrapper 条件，查询全部记录（并翻页） ipage\u0026lt;map\u0026lt;string, object\u0026gt;\u0026gt; selectmapspage(ipage\u0026lt;t\u0026gt; page, @param(constants.wrapper) wrapper\u0026lt;t\u0026gt; querywrapper); // 根据 wrapper 条件，查询总记录数 integer selectcount(@param(constants.wrapper) wrapper\u0026lt;t\u0026gt; querywrapper); (二)环境搭建 1.创建数据库表employee create table `employee` ( `empid` int(11) not null auto_increment, `empname` varchar(32) default null, `age` int(11) default null, `email` varchar(32) default null, `empgender` varchar(32) default null, primary key (`empid`), ) 2.构建实体类并使用lombok注解 @data public class employee { private long empid; private string name; private string empgender; private integer age; private string email; (三)insert方法 // 插入一条记录 int insert(t entity); 测试: @test public void testinsert() { employee employee=new employee(); //employee.setempid(100000); employee.setname(\u0026#34;刘龙\u0026#34;); employee.setempgender(\u0026#34;男\u0026#34;); employee.setage(25); employee.setemail(\u0026#34;liulong@163.com\u0026#34;); employeemapper.insert(employee); } 从上面的异常可以看出，我们没有给employee类的empid属性赋值，定义数据库时对应的emp_id列不能为空，所以出错了，为了解决这个错误，你可以给empid属性赋值一个值，可以解决此问题。mybatis-plus默认采用雪花算法生成唯一值，如果想使用mybatis-plus自动生成的雪花算法值可以在实体类的属性上加@filedid注解。 (四)@tableid注解 描述：主键注解 属性 类型 必须指定 默认值 描述 value string 否 \u0026quot;\u0026quot; 主键字段名 type enum 否 idtype.none 主键类型 idtype 值 描述 auto 数据库id自增 none 无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 input) input insert前自行set主键值 assign_id 分配id(主键类型为number(long和integer)或string)(since 3.3.0),使用接口identifiergenerator的方法nextid(默认实现类为defaultidentifiergenerator雪花算法) assign_uuid 分配uuid,主键类型为string(since 3.3.0),使用接口identifiergenerator的方法nextuuid(默认default方法) @noargsconstructor @allargsconstructor @data @tostring public class employee { //使用数据库自增策略 //@tableid(type=idtype.auto) //默认使用雪花算法生成数字 @tableid private long empid; private string empname; private string empgender; private integer age; private string email; } (五)@tablename 描述：表名注解\n属性 类型 必须指定 默认值 描述 value string 否 \u0026quot;\u0026quot; 表名 schema string 否 \u0026quot;\u0026quot; schema keepglobalprefix boolean 否 false 是否保持使用全局的 tableprefix 的值(如果设置了全局 tableprefix 且自行设置了 value 的值) resultmap string 否 \u0026quot;\u0026quot; xml 中 resultmap 的 id autoresultmap boolean 否 false 是否自动构建 resultmap 并使用(如果设置 resultmap 则不会进行 resultmap 的自动构建并注入) excludeproperty string[] 否 {} 需要排除的属性名(@since 3.3.1) 当表名跟实体类类名不一致时，要使用@tablename注解进行映射 @noargsconstructor @allargsconstructor @data @tostring @tablename(value = \u0026#34;tb_employee\u0026#34;) public class employee { //使用数据库自增策略 //@tableid(type=idtype.auto) //默认使用雪花算法生成数字 @tableid private long empid; private string empname; private string empgender; private integer age; private string email; } (六)@tablefield注解 描述：字段注解(非主键)\n属性 类型 必须指定 默认值 描述 value string 否 \u0026quot;\u0026quot; 数据库字段名 el string 否 \u0026quot;\u0026quot; 映射为原生 #{ ... } 逻辑,相当于写在 xml 里的 #{ ... } 部分 exist boolean 否 true 是否为数据库表字段 condition string 否 \u0026quot;\u0026quot; 字段 where 实体查询比较条件,有值设置则按设置的值为准,没有则为默认全局的 %s=#{%s},参考 update string 否 \u0026quot;\u0026quot; 字段 update set 部分注入, 例如：update=\u0026quot;%s+1\u0026quot;：表示更新时会set version=version+1(该属性优先级高于 el 属性) insertstrategy enum n default 举例：not_null: insert into table_a(\u0026lt;if test=\u0026quot;columnproperty != null\u0026quot;\u0026gt;column\u0026lt;/if\u0026gt;) values (\u0026lt;if test=\u0026quot;columnproperty != null\u0026quot;\u0026gt;#{columnproperty}\u0026lt;/if\u0026gt;) updatestrategy enum n default 举例：ignored: update table_a set column=#{columnproperty} wherestrategy enum n default 举例：not_empty: where \u0026lt;if test=\u0026quot;columnproperty != null and columnproperty!=''\u0026quot;\u0026gt;column=#{columnproperty}\u0026lt;/if\u0026gt; fill enum 否 fieldfill.default 字段自动填充策略 select boolean 否 true 是否进行 select 查询 keepglobalformat boolean 否 false 是否保持使用全局的 format 进行处理 jdbctype jdbctype 否 jdbctype.undefined jdbc类型 (该默认值不代表会按照该值生效) typehandler class\u0026lt;? extends typehandler\u0026gt; 否 unknowntypehandler.class 类型处理器 (该默认值不代表会按照该值生效) numericscale string 否 \u0026quot;\u0026quot; 指定小数点后保留的位数 @noargsconstructor @allargsconstructor @data @tostring @tablename(value = \u0026#34;tb_employee\u0026#34;) public class employee { @tableid private long empid; //当表中的列与实体类属性不一致时，使用tablefield指定数据库中的列名 @tablefield(value = \u0026#34;emp_name\u0026#34;) private string name; private string empgender; private integer age; private string email; //当表中没有remark时，使用tablefield的exist=false属性忽略该字段 @tablefield(exist = false) private string remark; } (七)插入数据获取主键值 修改employee的empid注解 @tableid(type=idtype.auto) private long empid; mysql-plus会自获取自增主键，把数据库的emp_id设置为自增。测试获取自增主键。 测试: public void testinsert() { employee employee=new employee(); employee.setname(\u0026#34;刘龙200\u0026#34;); employee.setempgender(\u0026#34;男\u0026#34;); employee.setage(25); employee.setemail(\u0026#34;liulong@163.com\u0026#34;); employee.setremark(\u0026#34;该员工是一个好员工\u0026#34;); employeemapper.insert(employee); system.out.println(employee.getempid()); } (八)更新数据的通用方法 1.updatebyid方法 根据id进行记录更新，如果对象属性未传值，则不会更新该字段，保持数据库表原来字段值。 public void testupdatebyid() { employee employee=new employee(); employee.setempid(10) employee.setname(\u0026#34;刘龙\u0026#34;); employee.setempgender(\u0026#34;女\u0026#34;); employee.setage(23); employee.setemail(\u0026#34;liulong@163.com\u0026#34;); employeemapper.updatebyid(employee); } 2.updateallcolumnbyid方法 （在新版本中没有该方法） 根据id进行记录更新，无论对象属性传不传值，每列都进行更新，为赋值的字段被更新为null public void testupdateallcolumnbyid() { employee employee=new employee(); employee.setempid(11) employee.setname(\u0026#34;王永\u0026#34;); employee.setempgender(\u0026#34;男\u0026#34;); employeemapper.updateallcolumnbyid(employee); } (九)查询数据的通用方法 1.selectbyid方法 根据id查询指定记录 @test public void testselectbyid() { employee employee=employeemapper.selectbyid(1); system.out.println(employee); } 2.selectbatchids方法 批量查询指多个id的记录集合 @test public void testselectbatchids() { list list= arrays.aslist(1,2,3); list\u0026lt;employee\u0026gt; employeelist = employeemapper.selectbatchids(list); employeelist.foreach(system.out::println); } 3.selectbymap方法 根据map集合中传入的条件进行查询，每个条件都是and关系。 @test public void testselectbymap() { map\u0026lt;string,object\u0026gt; map=new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;emp_gender\u0026#34;,\u0026#34;男\u0026#34;); map.put(\u0026#34;age\u0026#34;,29); list\u0026lt;employee\u0026gt; employeelist = employeemapper.selectbymap(map); employeelist.foreach(system.out::println); } (十)删除数据方法 1.deletebyid方法 根据id删除记录 @test public void testdeletebyid(){ int rows=employeemapper.deletebyid(1); system.out.println(\u0026#34;受影响的行数:\u0026#34;+rows); } 2.deletebymap方法 根据map中的条件进行删除，map中的条件在sql语句中是and关系。 @test public void testdeletebymap(){ map\u0026lt;string,object\u0026gt; map=new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;emp_gender\u0026#34;,\u0026#34;男\u0026#34;); map.put(\u0026#34;emp_name\u0026#34;,\u0026#34;刘辉\u0026#34;); int rows=employeemapper.deletebymap(map); system.out.println(\u0026#34;受影响的行数:\u0026#34;+rows); } 3.deletebatchids方法 根据传入list集合中的id进行批量删除 @test public void testdeletebatchids(){ list list= arrays.aslist(4,7,1); int rows=employeemapper.deletebatchids(list); system.out.println(\u0026#34;受影响的行数:\u0026#34;+rows); } 五、mybatis-plus条件构造器 (一)条件构造器介绍 在mybatis-plus中提了构造条件的类wrapper,它可以根据自己的意图定义我们需要的条件。wrapper是一个抽象类，一般情况下我们用它的子类querywrapper来实现自定义条件查询.\n(二)selectone方法 //查询姓名为刘辉军并且性别为男的员工 @test public void testselectone(){ querywrapper\u0026lt;employee\u0026gt; querywrapper=new querywrapper\u0026lt;\u0026gt;(); querywrapper.eq(\u0026#34;emp_name\u0026#34;,\u0026#34;刘辉军\u0026#34;); querywrapper.eq(\u0026#34;emp_gender\u0026#34;,\u0026#34;男\u0026#34;); employee employee = employeemapper.selectone(querywrapper); system.out.println(employee); } (三).selectlist方法 //查询姓名中带有\u0026#34;磊\u0026#34;的并且年龄小于30的员工 @test public void testselectlist(){ querywrapper\u0026lt;employee\u0026gt; querywrapper=new querywrapper\u0026lt;\u0026gt;(); querywrapper.like(\u0026#34;emp_name\u0026#34;,\u0026#34;磊\u0026#34;).lt(\u0026#34;age\u0026#34;,30); list\u0026lt;employee\u0026gt; employeelist = employeemapper.selectlist(querywrapper); employeelist.foreach(system.out::println); } //查询姓刘的或者性别为男，按年龄的除序排序 @test public void testselectlist2(){ querywrapper\u0026lt;employee\u0026gt; querywrapper=new querywrapper\u0026lt;\u0026gt;(); querywrapper.like(\u0026#34;emp_name\u0026#34;,\u0026#34;王\u0026#34;) .or().lt(\u0026#34;emp_gender\u0026#34;,\u0026#34;男\u0026#34;) .orderbydesc(\u0026#34;age\u0026#34;); list\u0026lt;employee\u0026gt; employeelist = employeemapper.selectlist(querywrapper); employeelist.foreach(system.out::println); } //查询姓刘并且（年龄小于35或者邮箱不为空） @test public void testselectlist3(){ querywrapper\u0026lt;employee\u0026gt; querywrapper=new querywrapper\u0026lt;\u0026gt;(); querywrapper.likeright(\u0026#34;emp_name\u0026#34;,\u0026#34;刘\u0026#34;) .and(wq-\u0026gt;wq.lt(\u0026#34;age\u0026#34;,35).or().isnotnull(\u0026#34;email\u0026#34;)); list\u0026lt;employee\u0026gt; employeelist = employeemapper.selectlist(querywrapper); employeelist.foreach(system.out::println); } (四).selectpage方法 selectpage用于分页，在mybatis-plus中分页有两种一种是逻辑分页或叫内存分页，另一种是物理分页，内存分页就是把数据全部查询出来放到内存中，返回你想要的一部分数据，当数据量非常庞大时这种方法就行不通了，因为太耗内存，所以一般采用物理分页，需要springboot中加入物理分页配置：\n@configuration public class mybatisplusconfig { @bean public mybatisplusinterceptor mybatisplusinterceptor() { mybatisplusinterceptor interceptor = new mybatisplusinterceptor(); interceptor.addinnerinterceptor(new paginationinnerinterceptor(dbtype.mysql)); return interceptor; } } @test public void testselectpage(){ querywrapper\u0026lt;employee\u0026gt; querywrapper=new querywrapper\u0026lt;\u0026gt;(); querywrapper.lt(\u0026#34;age\u0026#34;,50); page\u0026lt;employee\u0026gt; page=new page\u0026lt;\u0026gt;(1,2); page\u0026lt;employee\u0026gt; employeepage = employeemapper.selectpage(page, querywrapper); system.out.println(\u0026#34;当前页:\u0026#34;+ employeepage.getcurrent()); system.out.println(\u0026#34;每页记录数:\u0026#34;+employeepage.getsize()); system.out.println(\u0026#34;总记录数:\u0026#34;+employeepage.gettotal()); system.out.println(\u0026#34;总页数:\u0026#34;+employeepage.getpages()); list\u0026lt;employee\u0026gt; employeelist = employeepage.getrecords(); employeelist.foreach(system.out::println); } (五)update方法 //根据姓名和年龄修改记录 @test public void testupdate(){ querywrapper\u0026lt;employee\u0026gt; updatewrapper=new querywrapper\u0026lt;\u0026gt;(); updatewrapper.eq(\u0026#34;emp_name\u0026#34;,\u0026#34;刘龙\u0026#34;) .eq(\u0026#34;age\u0026#34;,25); employee employee=new employee(); employee.setempid(1367720249630318593l); employee.setname(\u0026#34;刘龙\u0026#34;); employee.setemail(\u0026#34;lilong111@.qq.com\u0026#34;); employee.setage(26); employee.setempgender(\u0026#34;女\u0026#34;); int rows=employeemapper.update(employee,updatewrapper); system.out.println(\u0026#34;受影响的行数:\u0026#34;+rows); } (六).delete方法 //根据姓名和年龄删除记录 @test public void testdelete(){ querywrapper\u0026lt;employee\u0026gt; querywrapper=new querywrapper\u0026lt;\u0026gt;(); querywrapper.eq(\u0026#34;emp_name\u0026#34;,\u0026#34;刘龙\u0026#34;) .eq(\u0026#34;age\u0026#34;,26); int rows=employeemapper.delete(querywrapper); system.out.println(\u0026#34;受影响的行数:\u0026#34;+rows); } 六、mybatis-plus的service封装 (一)通用service简介 mybatis-plus除了通用的mapper还有通用的servcie层，这也减少了相对应的代码工作量，把通用的接口提取到公共。其实按照mp的这种思想，可以自己也实现一些通用的controller。 (二).通用service常用方法介绍 /** * 插入一条记录（选择字段，策略插入） * * @param entity 实体对象 */ default boolean save(t entity) { return sqlhelper.retbool(getbasemapper().insert(entity)); } /** * 根据 id 选择修改 * * @param entity 实体对象 */ default boolean updatebyid(t entity) { return sqlhelper.retbool(getbasemapper().updatebyid(entity)); } /** * tableid 注解存在更新记录，否插入一条记录 * * @param entity 实体对象 */ boolean saveorupdate(t entity); /** * 根据 wrapper，查询一条记录 \u0026lt;br/\u0026gt; * \u0026lt;p\u0026gt;结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(\u0026#34;limit 1\u0026#34;)\u0026lt;/p\u0026gt; * * @param querywrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.querywrapper} */ default t getone(wrapper\u0026lt;t\u0026gt; querywrapper) { return getone(querywrapper, true); } /** * 根据 wrapper，查询一条记录 * * @param querywrapper 实体对象封装操作类 {@link com.baomidou.mybatisplus.core.conditions.query.querywrapper} * @param throwex 有多个 result 是否抛出异常 */ t getone(wrapper\u0026lt;t\u0026gt; querywrapper, boolean throwex); 其它方法请参考iservice接口。 (三)通用service的案例 1.构建maven工程添加依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.projectlombok\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;lombok\u0026lt;/artifactid\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.构建service接口 public interface emloyeeservice extends iservice\u0026lt;employee\u0026gt; { } 3.构建service实现类 @service public class employeeserviceimpl extends serviceimpl\u0026lt;employeemapper,employee\u0026gt; implements emloyeeservice { } 4.通用servcie测试 @test public void testsave(){ employee employee=new employee(); employee.setname(\u0026#34;孙宝来\u0026#34;); employee.setempgender(\u0026#34;男\u0026#34;); employee.setage(30); employee.setemail(\u0026#34;sunbaolai@qq.com\u0026#34;); employeeservice.save(employee); } @test public void testsaveorupdate(){ employee employee=new employee(); employee.setempid(1367720249630318594l); employee.setname(\u0026#34;孙宝来\u0026#34;); employee.setempgender(\u0026#34;女\u0026#34;); employee.setage(33); employee.setemail(\u0026#34;sunbaolai@qq.com\u0026#34;); employeeservice.saveorupdate(employee); } @test public void testgetone(){ querywrapper\u0026lt;employee\u0026gt; querywrapper=new querywrapper\u0026lt;\u0026gt;(); querywrapper.gt(\u0026#34;age\u0026#34;,24); employee employee = employeeservice.getone(querywrapper,false); system.out.println(employee); } 七、mybatis-plus代码生成器 (一)代码生成器介绍 代码生成器顾名思义就是为我们生成一些代码，省去了我们一些时间。autogenerator 是 mybatis-plus 的代码生成器，通过 autogenerator 可以快速生成 entity、mapper、mapper xml、service、controller 等各个模块的代码，极大的提升了开发效率,mybatis-plus从3.0.3 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖，才能实现代码生成器功能。 (二)构建maven工程引入相关依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-generator\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.velocity\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;velocity-engine-core\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.projectlombok\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;lombok\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; (三)编写生成器代码 1.globalconfig全局配置编码 // 代码生成器 autogenerator mpg = new autogenerator(); // 全局配置 globalconfig gc = new globalconfig(); string projectpath = system.getproperty(\u0026#34;user.dir\u0026#34;); gc.setoutputdir(projectpath + \u0026#34;/src/main/java\u0026#34;); gc.setauthor(\u0026#34;yjq\u0026#34;);//设置作者 gc.setopen(false);//生成是后是否打开资源管理器 gc.setfileoverride(false);//重新生成文件时是否覆盖 gc.setservicename(\u0026#34;%sservice\u0026#34;); // gc.setswagger2(true); 实体属性 swagger2 注解 mpg.setglobalconfig(gc); 2.datasourceconfig数据源配置编码 // 数据源配置 datasourceconfig dsc = new datasourceconfig(); dsc.seturl(\u0026#34;jdbc:mysql://localhost:3306/mybatis_plus?useunicode=true\u0026amp;usessl=false\u0026amp;characterencoding=utf8\u0026#34;); // dsc.setschemaname(\u0026#34;public\u0026#34;); dsc.setdrivername(\u0026#34;com.mysql.jdbc.driver\u0026#34;); dsc.setusername(\u0026#34;root\u0026#34;); dsc.setpassword(\u0026#34;root\u0026#34;); dsc.setdbtype(dbtype.mysql); mpg.setdatasource(dsc); 3.packageconfig包名策略配置 // 包配置 packageconfig pc = new packageconfig(); pc.setmodulename(null); pc.setparent(\u0026#34;com.offcn.ssm\u0026#34;); pc.setcontroller(\u0026#34;controller\u0026#34;); pc.setentity(\u0026#34;entity\u0026#34;); pc.setservice(\u0026#34;service\u0026#34;); pc.setmapper(\u0026#34;mapper\u0026#34;); mpg.setpackageinfo(pc); 4.strategyconfig策略配置编码 //策略配置 strategyconfig strategy = new strategyconfig(); strategy.setinclude(\u0026#34;tb_employee\u0026#34;);//对那一张表生成代码 strategy.setnaming(namingstrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.settableprefix(pc.getmodulename() + \u0026#34;_\u0026#34;); //生成实体时去掉表前缀 strategy.setcolumnnaming(namingstrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setentitylombokmodel(true); // lombok 模型 @accessors(chain = true) setter链式操作 strategy.setrestcontrollerstyle(true); //restful api风格控制器 strategy.setcontrollermappinghyphenstyle(true); //url中驼峰转连字符 mpg.setstrategy(strategy); 5.执行 //执行 mpg.execute(); (四)执行生成器代码完成测试 在主启动类上用@mapperscan扫描mapper接口 @mapperscan(\u0026#34;com.offcn.ssm.mapper\u0026#34;) 在application.yml中添加数据库配置信息 spring: datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql:///mybatis_plus username: root password: root logging: level: com: offcn: mybatis: dao: debug 在生成的contorller中编写查询方法 @restcontroller @requestmapping(\u0026#34;/tb-employee\u0026#34;) public class tbemployeecontroller { @autowired private tbemployeeservice tbemployeeservice; @requestmapping(\u0026#34;/emps\u0026#34;) public list\u0026lt;tbemployee\u0026gt; getemployees(){ list\u0026lt;tbemployee\u0026gt; list = tbemployeeservice.list(); return list; } } 启动springboot在浏览器中输入http://localhost:8080/tb-employee/emps ","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220526214937/","summary":"mybatis_plus 一、Mybatis-Plus简介 (一) 什么是Mybatis-Plus MybatisPlus是一个 MyBatis (opens new window)的增强工具，在 MyBatis的基础上只做增","title":"mybatis-plus"},{"content":"nginx介绍 nginx (engine x) 是一个高性能的http和反向代理web服务器，同时也提供了imap/pop3/smtp服务。nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的rambler.ru站点（俄文：рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。\n其将源代码以类bsd许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。\nnginx是一款轻量级的web 服务器/反向代理服务器及电子邮件（imap/pop3）代理服务器，在bsd-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。\nnginx的安装 下载nginx 上传到linux操作系统 对nginx进行解压缩 tar zxf nginx-1.8.0.tar.gz\n安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++\npcre(perl compatible regular expressions)是一个perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。\nyum install -y pcre pcre-devel\n6.zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。\nyum install -y zlib zlib-devel\nopenssl 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及ssl协议，并提供丰富的应用程序供测试或其它目的使用。 nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。\nyum install -y openssl openssl-devel\n使用configure命令进行按装 ./configure \\ --prefix=/usr/local/nginx \\ --pid-path=/var/run/nginx/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi 注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录\n编译安装 make\nmake install\n启动nginx ./nginx\n关闭nginxx ./nginx -s stop\n重新加载nginx ./nginx -s reload\n充当静态资源服务器\nhttp://192.168.18.201/images/bbb.jpg\n反向代理 所谓的正向代理指是客户端代理\n所谓的反向代理指是服务器端代理\n负载均衡 解压tomcat 修改tomcat1的端口 修改tomcat2端口 分别修改index.jsp 配置nginx充当负载均衡服务器 修改nginx.conf\n可以修改权重 weight=2 权重越大，获得请求次数就会越多。\n资源的动静分离 把aaa.jsp复制到tomcat1/webapps/root目录下\n把aaa.jsp复制到tomcat2/webapps/root目录下\n\u0026lt;%@ page language=\u0026#34;java\u0026#34; import=\u0026#34;java.util.date,java.text.simpledateformat\u0026#34; contenttype=\u0026#34;text/html; charset=utf-8\u0026#34; pageencoding=\u0026#34;utf-8\u0026#34;%\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;这是tomcat2主页\u0026lt;/h1\u0026gt; \u0026lt;% date date=new date(); simpledateformat sdf=new simpledateformat(\u0026#34;yyyy-mm-dd hh:mm:ss\u0026#34;); string strdate=sdf.format(date); out.println(strdate+\u0026#34;\u0026lt;br\u0026gt;\u0026#34;); %\u0026gt; \u0026lt;img src=\u0026#34;images/aaa.jpg\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 配置nginx.conf upstream tomcat{ server 192.168.18.201:8081 weight=2; server 192.168.18.201:8082; } server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://tomcat; index index.html index.htm; } location ~\\.(jsp|do|action)$ { proxy_pass http://tomcat; } location ~\\.(html|css|js|gif|jpg|png|bmp|swf)$ { root /usr/local/staticresources; } http://192.168.18.201/aaa.jsp\n经过nginx 由nginx判断是jsp文件,走的tomcat\naaa.jsp中有一个图片 \u0026lt;img src=\u0026quot;images/aaa.jpg\u0026quot;\u0026gt;\nhttp://192.168.18.201/images/aaa.jpg 该地址也经过nginx,判断是jpg, 所以从nginx上加载图片。\n","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/tool/20220526203627/","summary":"nginx介绍 Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二","title":"nginx"},{"content":"redis介绍 redis（remote dictionary server )，即远程字典服务，是一个开源的使用ansi c语言编写、支持网络、可基于内存亦可持久化的日志型、key-value数据库，并提供多种语言的api。从2010年3月15日起，redis的开发工作由vmware主持。从2013年5月开始，redis的开发由pivotal赞助。\nredis是一个key-value存储系统。和memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set \u0026ndash;有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\nredis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了java，c/c++，c#，php，javascript，perl，object-c，python，ruby，erlang等客户端，使用很方便。 [1]\nredis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。\nredis的官网地址，非常好记，是redis.io。（域名后缀io属于国家域名，是british indian ocean territory，即英属印度洋领地），vmware在资助着redis项目的开发和维护。\nredis的按装 1. 下载redis 2. 上传到linux上并进行解压缩 tar zxf redis-5.0.5.tar.gz 3. 按装redis运行环境 redis是c语言开发的安装redis需要c语言的编译环境。如果没有gcc需要在线安装。 yum install gcc-c++ yum -y install gcc automake autoconf libtool make yum -y install tcl 4. 编译。进入redis源码目录。 make 5. 安装。 make install prefix=/usr/local/redis prefix参数指定redis的安装目录。一般软件安装到/usr/local/redis目录下 6. redis服务端启动 ./redis-server 7. 使用redis-cli连接到redis ./redis-cli [root@ibm001 bin]# ./redis-cli 127.0.0.1:6379\u0026gt; 8. 退出客户端 quit exit 9. 关闭redis服务 ./redis-cli shutdown reids的相关配置 后台启动redis.不要阻塞前端窗口 把redis-5.0.5中的redis.conf 复制到 redis/bin目录中\ncp redis.conf /usr/local/redis/bin\n编辑redis.conf\nvi redis.conf 把daemonize 改为yes\n后台启动redis ./redis-server redis.conf\n查看后台进程\nps aux |grep redis\n远程连接redis ./redis-cli -h 192.168.18.201 -p 6379\ncould not connect to redis at 192.168.18.201:6379: connection refused不能够远程连接redis\n修改redis.conf\n把bind给注释掉\n然后关闭redis服务 ./redis-cli shutdown\n重新启动redis服务 ./redis-server redis.conf\n远程连接 ./redis-cli -h 192.168.18.201 -p 6379\n可以给redis设置密码 修改redis配置文件\n把该行去掉注释，同时可以指定密码\n然后关闭redis服务 ./redis-cli shutdown\n重新启动redis服务 ./redis-server redis.conf\n远程连接 ./redis-cli -h 192.168.18.201 -p 6379\n关闭redis服务\n./redis-cli -a 123456 shutdown\n利用rdm来远程连接redis\n只有15个库，select加下标选择库 如select 1，select 15100004\nredis的数据类型 string类型 map\u0026lt;string,string\u0026gt;\n1.语法 set key value 设置key的值\n示例：set name zhangsan\nset age 22\nset name lisi 如果key存在，将会覆盖原来key的值\n2.语法 get key 获取key的值\n示例：get name\nget age\n3.语法 del key 删除指定key的值\n示例：del name\ndel age\n4.语法: append key value 在原来的值的基础上添加新值\n示例：set name zhangsan\nappend name lisi\n5.语法: strlen key 获取指定key的值的长度\nstrlen name 12\n6.语法: getrange key start end 获取指定key的值,从start位置开始，end位置结束\n示列：getrange name 2 7\n7.语法: setrange key offset value 从起始位置替换值\n示例：setrange name 2 abc\n8.语法: setex key second value 设置key的值并指定存活时间\n示例: setex name 100 lisi\n9.语法:setnx key value 设置key的值并且永久有效\n示例:setnx address beijing\n10.语法: incr key 对key的值自增1\n示列: incr currentpage\n11.语法: decr key 对key的值自减1\n示列: decr currentpage\n12.语法: incrby key number 对key的值递增number\n示列: incrby currentpage 10\n13.语法: decrby key number 对key的值递减number\n示列: decrby currentpage 5\n14.语法: mset key1 value1 key2 value2 \u0026hellip;. 一次性设置多个key-value键值对\n示列: mset name1 zhangsan name2 lisi name3 wangwu\n15.语法: mget key1 key2 \u0026hellip;. 一次性获取多个key的值\n示列: mget name1 name2\n16.语法 expire key seconds 设置key的存活时间 seconds秒数\n示例 expire address 30\n17 语法 ttl key 查看key的存活时间 如果返回-1 表示永久有效\n示例 ttl name\n18.语法 persist key 设该key永久有效\n示列 persist address\nhash数据类型 map\u0026lt;string,map\u0026lt;string,string\u0026raquo;\n1.语法: hset key field value 设置key 的 field字段的值\n示列: hset person name lisi\nhset person address changsha\nhset person birthday 1997-10-10\n2.语法: hget key field 获取key的field字段的值\n示例: hget person name\n4.语法: hmset key field1 value1 field2 value2 \u0026hellip;. 一次设置key的多个字段的值\n示例: hmset student name wagnwu age 22 gender man\n5.语法: hmget key field1 field2 \u0026hellip;. 一次获取key的多个字段的值\n示例: hmget student name age gender\n6.语法: hgetall key 获取key的多个字段的值（包括键和值）\n示例: hgetall student\n7.语法: hkeys key 获取key的所有字段\n示例: hkeys student\n8.语法: hvals key 获取key的所有字段的值\n示例: hvals student\n9.语法: hdel key field1 field2 \u0026hellip; 删除key的所有多个字段的值\n示例: hvals student\n10.语法: hlen key 返回key的所有键值对的个数\n示例: hlen student\n11.语法: hexists key field 返回key的field字段是否存在\n示例: hexists student name\nlist数据类型 1.语法: lpush key value1 value2\u0026hellip;. 向key集合的左边一次添加值\n示例: lpush ages 22 34 21 45 20\n2.语法: rpush key value1 value2\u0026hellip;. 向key集合的右边一次添加值\n示例: rpush names zhangsan lisi wangwu zhaooiu\n3.语法: lrange key start stop 取key集合中指定的start位置到stop位置的内容(-1代表集合结束)\n示列：lrange ages 0 2\nlrange ages 0 -1\nlrange ages 0 100\n4.语法: llen key 查看key集合的长度\n示例: llen ages\n5.语法: lpop key 删除key集合的第一个元素\n示例: lpop ages\n6.语法: rpop key 删除key集合的最后一个元素\n示例: rpop ages\n7.语法: lindex key index 获取key集合的index索引的元素\n示例: lindex ages 2\n8.语法: lrem key count value 删除key集合的count个索引的元素(集合中有重复值)\n示例: lrem ages 2 45\nset数据类型 1.语法: sadd key value1 value2 \u0026hellip; 向为key的集合中添加多个值（去重）\n示例: sadd empnames zhangsan lisi wangwu zhaoliu lisi\n2.语法: smembers key 循环key集合中的所有值\n示例: smembers empnames\n3.语法: scard key 统计key集合中的元素个数\n示例: scard empnames\n4.语法: srem key value 删除key集合中的value值\n示例: scard empnames lisi\n5.语法: spop key 随机删除key集合中的某个值\n示例: spop empnames\n6.语法: smove source destination member 将集合中的某个值赋给另外一个集合： smove 源集合 目的集合 值\n示例: smove empnames works zhangsan\n7.语法: sdiff 集合1 集合2 求差集\n示例: sadd seta a b c d e\nsadd setb c d e f g\nsdiff seta setb\n\u0026ldquo;a\u0026rdquo;\n\u0026ldquo;b\u0026rdquo;\nsdiff setb seta\n\u0026ldquo;f\u0026rdquo;\n\u0026ldquo;g\u0026rdquo;\n8.语法: sinter 集合1 集合2 求交集\n示例: sinter seta setb\n\u0026ldquo;d\u0026rdquo;\n\u0026ldquo;c\u0026rdquo;\n\u0026ldquo;e\u0026rdquo;\n9.语法: sunion 集合1 集合2 求并集\n示例: sunion seta setb\n\u0026ldquo;d\u0026rdquo;\n\u0026ldquo;a\u0026rdquo;\n\u0026ldquo;b\u0026rdquo;\n\u0026ldquo;c\u0026rdquo;\n\u0026ldquo;e\u0026rdquo;\n\u0026ldquo;f\u0026rdquo;\n\u0026ldquo;g\u0026rdquo;\nzset(sortedset)数据类型 1.语法: zadd key score value \u0026hellip; 向为key的集合中添加多个(score-value)\n示例: zadd students 1 zhangsan 3 lisi 2 wangwu 5 zhaoliu\n2.语法: zrange key start stop [withscores] 循环key的集合从start位到stop位置的值\n示例: zrange students 0 -1\n\u0026ldquo;zhangsan\u0026rdquo;\n\u0026ldquo;wangwu\u0026rdquo;\n\u0026ldquo;lisi\u0026rdquo;\n\u0026ldquo;zhaoliu\u0026rdquo;\n3.语法: zrem key value 删除key集合中指定的value元素\n示例: zrem students lisi\n4.语法: zrevrange key start stop [withscores] 逆序显示key集合中的元素\n示例: zrevrange students 0 -1\nzrevrange students 0 -1 withscores\n5.语法: zrangebyscore key min max 根据分数区间查询内容\n示例:zrangebyscore students 2 5\n6.语法: zcard key 统计key集合中有多少个键值对\n示例: zcard students\n7.语法: zcount key min max 统计key集合中min到max区间元素\n示例: zcount students 1 4\n8.语法: zrank students wangwu 统计key集合中指定元素索引\n示例: zrank students wangwu\n9.语法: zscore key value 统计key集合中指定元素的分数\n示例: zscore students zhangsan\n关于redis的持久化方案 redis中所有的key和value默认加载到内存中，为了数据的不丢失，把数据进行持久化，通常会把数据落地磁盘。\n第一种持久化方案（默认rdb）\nin the example below the behaviour will be to save: # after 900 sec (15 min) if at least 1 key changed # after 300 sec (5 min) if at least 10 keys changed # after 60 sec if at least 10000 keys changed 对于数据不敏感，可以用这种方式，可以会丢数据，但效率高。（减少i/o操作）。\n第二种持久化方案 aof\n修改redis.conf 对数据特别敏感，保证不能丢数据。效率低（增加i/o操作）\n利用jedis api来操作redis 导入依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.20.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-aspects\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.20.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-webmvc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.20.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.20.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jms\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.20.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context-support\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.20.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;redis.clients\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jedis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.9.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 返回json字符串的支持 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jackson-databind\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.8.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-test\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.3.0.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 把相关的类交给spring容器管理 \u0026lt;bean id=\u0026#34;jedispoolconfig\u0026#34; class=\u0026#34;redis.clients.jedis.jedispoolconfig\u0026#34;\u0026gt; \u0026lt;!-- 最大空闲连接数 --\u0026gt; \u0026lt;property name=\u0026#34;maxidle\u0026#34; value=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;!-- 最大连接数 --\u0026gt; \u0026lt;property name=\u0026#34;maxtotal\u0026#34; value=\u0026#34;5\u0026#34; /\u0026gt; \u0026lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --\u0026gt; \u0026lt;property name=\u0026#34;blockwhenexhausted\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- 获取连接时的最大等待毫秒数(如果设置为阻塞时blockwhenexhausted),如果超时就抛异常, 小于零:阻塞不确定的时间, 默认-1 --\u0026gt; \u0026lt;property name=\u0026#34;maxwaitmillis\u0026#34; value=\u0026#34;30000\u0026#34; /\u0026gt; \u0026lt;!-- 在获取连接的时候检查有效性 --\u0026gt; \u0026lt;property name=\u0026#34;testonborrow\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;jedispool\u0026#34; class=\u0026#34;redis.clients.jedis.jedispool\u0026#34; destroy-method=\u0026#34;close\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;poolconfig\u0026#34; ref=\u0026#34;jedispoolconfig\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;host\u0026#34; value=\u0026#34;192.168.18.201\u0026#34; /\u0026gt; \u0026lt;constructor-arg name=\u0026#34;port\u0026#34; value=\u0026#34;6379\u0026#34; /\u0026gt; \u0026lt;constructor-arg name=\u0026#34;timeout\u0026#34; value=\u0026#34;30000\u0026#34; /\u0026gt; \u0026lt;constructor-arg name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; 测试\n@runwith(springjunit4classrunner.class) @contextconfiguration(\u0026#34;classpath:applicationcontext.xml\u0026#34;) public class jedistest { @autowired private jedispool jedispool; @test public void testadd(){ jedis jedis = jedispool.getresource(); jedis.set(\u0026#34;name\u0026#34;,\u0026#34;wangwu\u0026#34;); jedis.close(); } @test public void testaddperson(){ person person=new person(100,\u0026#34;张三\u0026#34;,\u0026#34;男\u0026#34;,22,new date()); jedis jedis = jedispool.getresource(); // jedis.set(\u0026#34;person\u0026#34;, jsonutils.objecttojson(person)); jedis.hset(\u0026#34;persons\u0026#34;,person.getname(),jsonutils.objecttojson(person)); jedis.close(); } @test public void testaddperson2(){ jedis jedis = jedispool.getresource(); string jsondata=jedis.get(\u0026#34;person\u0026#34;); person person=jsonutils.jsontoentity(jsondata,person.class); system.out.println(person); jedis.close(); } } ","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/tool/20220526164948/","summary":"Redis介绍 Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据","title":"redis"},{"content":"spring boot第一节 一、spring boot概述 （一）微服务概述 1、微服务 微服务（英语：microservices）是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块 (small building blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (language-independent/language agnostic）的api集相互通信；2014年，martin fowler 与 james lewis 共同提出了微服务的概念，定义了微服务是以开发一组小型服务的方式来开发一个独立的应用系统的。其中每个小型服务都运行在自己的进程中，并经常采用http资源api这样轻量的机制来相互通信。这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对这些微服务我们仅做最低限度的集中管理。 把大型的项目按功能模块进行拆分，每个模块可以构建一个springboot项目。 参考martin fowler微服务\n2、单体应用 （1）单体应用：一个单块应用系统是以一个单个单元的方式来构建的。企业应用系统经常包含三个主要部分：客户端用户界面、数据库和服务端应用系统，这里的服务端应用系统就是一个单体的应用，系统中任意逻辑发生变化都会导致重新构建部署一个新版本的服务端应用系统。针对单体应用，当访问量变大时，通常采用负载均衡，横向扩展的方式将多个单体应用部署到多个服务器上访问。 （2）单体应用缺点： 软件变更受到了很大的限制，应用系统的一个很小的部分的一处变更，也需要将整个单块应用系统进行重新构建和部署。不能根据用户需求部署应用系统中的功能模块，只能扩展部署整个应用系统。 3、单体应用和微服务对比 4、微服务应用搭建 要搭建一个微服务，运维和部署都变得非常复杂，spring提供了一套解决方案： springboot:快速构建单个服务； springcloud:是一系列有序框架的集合，其主要的设施有，服务发现与注册，配置中心，消息总线，负载均衡，断路器，数据监控等，通过spring boot的方式，可以实现一键启动，和部署。 spring cloud data flow: 为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践. （二）spring boot简介 spring-boot是由pivotal团队提供的全新框架，其设计目的是用来简化新spring应用的初始搭建以及开发过程。个人理解来说spring-boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring-boot整合了其他相关联框架。 （三）spring boot的优势 1、快速构建项目。 2、对主流开发框架的无配置集成。 3、项目可独立运行，无须外部依赖servlet容器。 4、提供运行时的应用监控。 5、极大的提高了开发、部署效率。 6、与云计算的天然集成。 （四）spring boot的核心功能介绍 1、独立运行spring项目 spring boot 可以以jar包形式独立运行，运行一个spring boot项目只需要通过java -jar xx.jar来运行。 2、内嵌servlet容器 spring boot可以选择内嵌tomcat、jetty或者undertow,这样我们无须以war包形式部署项目。 3、提供starter简化maven配置 spring提供了一系列的start pom来简化maven的依赖加载，例如，当你使用了spring-boot-starter-web，会自动加入如图5-1所示的依赖包。 4、自动装配spring spring boot会根据在类路径中的jar包，类、为jar包里面的类自动配置bean，这样会极大地减少我们要使用的配置。当然，spring boot只考虑大多数的开发场景，并不是所有的场景，若在实际开发中我们需要配置bean，而spring boot没有提供支持，则可以自定义自动配置。 5、准生产的应用监控 spring boot提供基于http ssh telnet对运行时的项目进行监控。 6、无代码生产和xml配置　spring boot不是借助与代码生成来实现的，而是通过条件注解来实现的，这是spring4.x提供的新特性。 二、spring boot入门程序 新建一个maven工程 （一）创建maven工程导入springboot依赖 ( 继承父工程并加入web依赖) \u0026lt;!--继承指定的父模块pom.xml文件：对项目进行整体的管理维护，如统一版本管理--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.4.3\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!--spring提供的web项目启动器模块--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; spring boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 。\n（二）编写spring boot的主程序 1、项目结构 2、主程序代码 @springbootapplication public class example { public static void main(string[] args) { /** * 启动springboot */ springapplication.run(example.class,args); } } @springbootapplication: 注解说明这个类是springboot的主配置类，springboot 就应该运行这个类的main方法来启动springboot应用；并将主配置类（@springbootapplication标注的类）的所在包及下面所有子包里面的所有组件扫描到spring容器；\n（三）编写controller代码 @controller public class testcontroller { @requestmapping(\u0026#34;/hello\u0026#34;) @responsebody public string helloworld(){ return \u0026#34;hello world!\u0026#34;; } } （四）运行主程序进行测试 （五）学员编写第一个springboot程序\n练习crud spring boot第二节 一、spring boot的简化部署 （一）添加maven插件 \u0026lt;!--执行maven命令插件--\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; （二）执行package命令给项目打包 执行打包命令后，会在target目录下生成项目对应的jar包。 （三）执行java -jar命令运行程序 （四）学员进行简化部署练习 二、spring initializer快速创建spring boot项目 （一）创建spring boot项目 （二）项目结构解析 1、java文件夹目录结构中自动创建好指定包和spring boot启动主程序springbootapplication.class； 2、resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面，（spring boot默认jar包使用嵌入式的tomcat，默认不支持jsp页面），可以使用模板引擎（freemarker、thymeleaf）； application.properties：spring boot应用的配置文件；可以修改一些默认设置； spring boot第三节 一、spring boot配置文件 （一）配置文件的作用及规范 spring boot使用一个全局的配置文件，配置文件名是固定的；默认使用以下两种格式： •application.properties •application.yml 配置文件的作用：修改springboot自动配置的默认值；spring boot启动时会根据配置文件自动注册相关的应用组件； （二）yaml配置文件 1、yaml的语法 yaml：以数据为中心，比json、xml等更适合做配置文件； （1）基本语法 – 使用缩进表示层级关系 – 缩进时不允许使用tab键，只允许使用空格。 – 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 – 大小写敏感 - 键值对中间必须要有空格k:(空格)v （2）值的写法 yaml 支持的三种数据结构:\na、字面量：普通的值（数字，字符串，布尔） server: port: 8081 注意：字符串默认不用加上单引号或者双引号； 双引号：特殊符号表示转义符本身； name: \u0026#34;zhangsan \\n lisi\u0026#34;：输出；zhangsan 换行 lisi 单引号；特殊字符就表示字符本身； name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi b、对象、map（属性和值）（键值对) person: name: zhangsan age: 12 另一种行内写法： person: {name: zhangsan,age: 12} c、数组（list,set） hobbies: - singing - dancing - running 用-（空格）值表示数组中的一个元素 另一种行内写法： hobbies: [singing,dancing,running] yaml参考文档\n2、配置文件值的注入 （1）构建bean对象 //只有spring容器中的对象才能自动进行数据绑定 @component //将本类中的所有属性和配置文件中相关的配置进行绑定； // prefix指定要绑定的配置文件中的属性前缀； @configurationproperties(prefix = \u0026#34;person\u0026#34;) public class person { private string pname; private int age; private boolean success; private date birth; private car car; private map\u0026lt;string,object\u0026gt; maps; private list\u0026lt;object\u0026gt; lists; } （2）构建配置文件 person: pname: zhangsan age: 12 birth: 2020/12/12 success: true car: cname: 奔驰 cprice: 200.0 lists: [唱歌,跳舞] maps: {key1: v1,key2: v2} （3）执行单元测试查看person对象的值 @springboottest class springbootapplicationtests { @autowired private person person; @test void contextloads() { system.out.println(person); } } （4）引入配置文件处理器插件 \u0026lt;!--作用：编辑配置文件时会有相关提示信息--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt; org.springframework.boot \u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt; spring-boot-configuration-processor \u0026lt;/artifactid\u0026gt; \u0026lt;optional\u0026gt; true \u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 3、学员练习yuml的值的注入方式 spring boot第四节 一、spring boot配置文件 （一）properties配置文件 1、properties语法 以key=value键值对的方式设置值 （1）字面量：普通的值（数字，字符串，布尔） name=张三 （2）对象、map（属性和值）（键值对) person.name=张三 person.age=12 maps.key1=value1 maps.key2=value2 （3）数组（list,set） hobbies=singing,dancing,running 2、配置文件值的注入 （1）构建bean对象 //只有spring容器中的对象才能自动进行数据绑定 @component //将本类中的所有属性和配置文件中相关的配置进行绑定； // prefix指定要绑定的配置文件中的属性前缀； @configurationproperties(prefix = \u0026#34;person\u0026#34;) public class person { private string pname; private int age; private boolean success; private date birth; private car car; private map\u0026lt;string,object\u0026gt; maps; private list\u0026lt;object\u0026gt; lists; } （2）构建配置文件 person.pname=张三 person.age=12 person.birth=2019/12/12 person.success=true person.car.cname=宝马 person.car.cprice=100.0 person.lists=唱歌,跳舞,跑步 person.maps.k1=value1 person.maps.k2=value2 （3）执行单元测试查看person对象的值 @springboottest class springbootapplicationtests { @autowired private person person; @test void contextloads() { system.out.println(person); } } 3、学员练习properties的值的注入方式 （二）@configurationproperties注解和@value注解的区别 1、@configurationproperties注解用于根据配置文件批量注入值，springboot默认配置文件application.yml/application.properties； 2、@value注解用于根据配置文件单个注入值； 区别 @configurationproperties @value spel 不支持 支持 复杂类型封装 支持 不支持 案例： @component //@configurationproperties(prefix = \u0026#34;person\u0026#34;) public class person { @value(\u0026#34;${person.pname}\u0026#34;) private string pname; @value(\u0026#34;#{12*2}\u0026#34;) private int age; private boolean success; private date birth; private car car; private map\u0026lt;string,object\u0026gt; map; private list\u0026lt;object\u0026gt; hobbies; } （三）配置文件中的占位符 1、springboot全局配置文件中可以使用随机数 ${random.value}、${random.int}、${random.long} ${random.int(10)}、${random.int[1024,65536]} 2、springboot全局配置文件中可以使用占位符 通过${属性名}获取已经在配置文件中加载过的属性值； 通过${属性名:默认值}来指定找不到属性时的默认值； 案例： person.pname=张三 person.age=${random.int} person.success=true person.birth=2012/12/12 person.car.cname=${car.cname:奔驰} person.car.cprice=200.0 person.map.key1=value1 person.map.key2=value2 person.hobbies=唱歌,跳舞,跑步 （四）多环境支持 profile是spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境； 1、多文件多环境形式： 格式：application-{profile}.properties/yml 例如：可以在项目中创建如下主配置文件：application-dev.properties、application-test.properties、application-prod.properties、application.properties,默认使用application.properties,可以通过配置spring.profiles.active=profile指定使用某个环境的配置文件。 2、yaml支持单文件多环境形式： spring: profiles: active: test --- spring: profiles: dev server: port: 8081 --- spring: profiles: test server: port: 8082 通过---来区分不同的profile环境。 3、激活方式： 在配置文件中指定 spring.profiles.active=dev 命令行 java -jar springboot-0.0.1-snapshot.jar --spring.profiles.active=dev jvm参数 -dspring.profiles.active=dev （五）配置文件加载位置 springboot默认会从以下位置加载配置文件：application.properties/application.yml 项目所在磁盘路径file:./config/ 项目所在磁盘路径file:./ 项目类路径classpath:/config/ 项目类路径classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置；springboot会从这四个位置全部加载主配置文件，互补配置； 如果要加载其他位置的配置文件，可以通过--spring.config.location（只能加到命令行）来指定要加载的配置文件的位置。 spring boot第五节 一、spring boot的web开发 讲解思路： 本章节主要掌握springboot当中静态资源的处理，springboot当中提供的静态资源存放的位置。 在实际当中开发，我们应该满足springboot的约定和规范。如果提供的静态资源目录不能满足实际的需求，还可以自定义静态资源的位置 （一）springboot关于静态资源的处理 springboot启动时会根据配置文件自动配置相应场景的组件xxxautoconfiguration，web项目启动时会初始化webmvcautoconfiguration组件处理请求相关的操作，其中有默认处理静态资源的方法： @override protected void addresourcehandlers(resourcehandlerregistry registry) { super.addresourcehandlers(registry); if (!this.resourceproperties.isaddmappings()) { logger.debug(\u0026#34;default resource handling disabled\u0026#34;); return; } servletcontext servletcontext = getservletcontext(); addresourcehandler(registry, \u0026#34;/webjars/**\u0026#34;, \u0026#34;classpath:/meta-inf/resources/webjars/\u0026#34;); addresourcehandler(registry, this.mvcproperties.getstaticpathpattern(), (registration) -\u0026gt; { registration.addresourcelocations(this.resourceproperties.getstaticlocations()); if (servletcontext != null) { registration.addresourcelocations(new servletcontextresource(servletcontext, servlet_location)); } }); } 从该方法中可以发现： 1、默认情况下： （1）匹配/webjars/** 的请求，都去 classpath:/meta-inf/resources/webjars/ 找资源； （2）匹配 \u0026#34;/**\u0026#34; 的请求，都去（静态资源的文件夹）找映射，静态资源文件夹路径如下： \u0026#34;classpath:/meta‐inf/resources/\u0026#34; \u0026#34;classpath:/resources/\u0026#34; \u0026#34;classpath:/static/\u0026#34; \u0026#34;classpath:/public/\u0026#34; \u0026#34;/\u0026#34;：当前项目的根路径 2、自定义配置静态资源路径： spring.web.resources.static-locations=自定义路径 1、webjars的使用 我们可以通过webjars以jar包的方式引入静态资源。 静态资源坐标参考\n（1）引入依赖 \u0026lt;!--jquery的jar包引入--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.webjars\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jquery\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.6.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; （2）启动服务访问资源 浏览器访问路径：http://localhost:8080/webjars/jquery/3.6.0/jquery.min.js获取相应的静态资源。 （3）学员练习webjars的使用 2、静态资源的存放位置 （1）默认存放位置查看 默认静态资源路径： \u0026#34;classpath:/meta‐inf/resources/\u0026#34; \u0026#34;classpath:/resources/\u0026#34; \u0026#34;classpath:/static/\u0026#34; \u0026#34;classpath:/public/\u0026#34; \u0026#34;/\u0026#34;：当前项目的根路径 案例：在上述任意路径下创建静态资源hello.html,浏览器访问路径：http://localhost:8080/hello.html获取相应的静态资源。 （2）自定义位置存放 在配置文件中通过属性spring.web.resources.static-locations=自定义路径，设置自定义静态资源存放路径； 案例： a、配置文件中设置：spring.web.resources.static-locations=classpath:/hello/ b、在自定义路径下添加静态资源hello.html,浏览器访问路径：http://localhost:8080/hello.html获取相应的静态资源。 注意：自定义静态资源路径后，默认静态资源路径失效！ （3）学员练习自定义静态资源访问 spring boot第六节 一、spring boot的web开发 讲解思路： 本章节有两大重点： 1、掌握springboot web模块的自动配置原理，从该模块引申，整个springboot当中大量的应用了自动配置，实现的具体思路相同。 2、自定义拦截器，注册拦截器，演示拦截器是否生效，拦截器在实际当中有大量的应用，务必掌握 （一）springboot的自动配置 1、自动配置原理 （1）springboot启动时加载主配值类，解析注解@springbootapplication @springbootapplication public class springbootapplication { public static void main(string[] args) { springapplication.run(springbootapplication.class, args); } } （2）在@springbootapplication组合注解中解析@enableautoconfiguration获取自动配置信息 //在@enableautoconfiguration注解中，为容器导入自动配置的组件： @target(elementtype.type) @retention(retentionpolicy.runtime) @documented @inherited @autoconfigurationpackage @import(autoconfigurationimportselector.class) public @interface enableautoconfiguration{ ... } //1、第一步：通过autoconfigurationimportselector类的selectimports方法获取要导入的自动配置组件 @override public string[] selectimports(annotationmetadata annotationmetadata) { if (!isenabled(annotationmetadata)) { return no_imports; } //获取自动配置的内容 autoconfigurationentry autoconfigurationentry = getautoconfigurationentry(annotationmetadata); return stringutils.tostringarray(autoconfigurationentry.getconfigurations()); } //2、第二步： protected autoconfigurationentry getautoconfigurationentry(annotationmetadata annotationmetadata) { if (!isenabled(annotationmetadata)) { return empty_entry; } annotationattributes attributes = getattributes(annotationmetadata); //获取配置信息 list\u0026lt;string\u0026gt; configurations = getcandidateconfigurations(annotationmetadata, attributes); configurations = removeduplicates(configurations); set\u0026lt;string\u0026gt; exclusions = getexclusions(annotationmetadata, attributes); checkexcludedclasses(configurations, exclusions); configurations.removeall(exclusions); configurations = getconfigurationclassfilter().filter(configurations); fireautoconfigurationimportevents(configurations, exclusions); return new autoconfigurationentry(configurations, exclusions); } //3、第三步： protected list\u0026lt;string\u0026gt; getcandidateconfigurations(annotationmetadata metadata, annotationattributes attributes) { //获取配置信息 list\u0026lt;string\u0026gt; configurations = springfactoriesloader.loadfactorynames(getspringfactoriesloaderfactoryclass(), getbeanclassloader()); assert.notempty(configurations, \u0026#34;no auto configuration classes found in meta-inf/spring.factories. if you \u0026#34; + \u0026#34;are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } //4、第四步： public static list\u0026lt;string\u0026gt; loadfactorynames(class\u0026lt;?\u0026gt; factorytype, @nullable classloader classloader) { classloader classloadertouse = classloader; if (classloadertouse == null) { classloadertouse = springfactoriesloader.class.getclassloader(); } string factorytypename = factorytype.getname(); //获取要自动注入的组件信息 return loadspringfactories(classloadertouse).getordefault(factorytypename, collections.emptylist()); } //5、第五步： private static map\u0026lt;string, list\u0026lt;string\u0026gt;\u0026gt; loadspringfactories(classloader classloader) { map\u0026lt;string, list\u0026lt;string\u0026gt;\u0026gt; result = cache.get(classloader); if (result != null) { return result; } result = new hashmap\u0026lt;\u0026gt;(); try { //获取要自动注入的组件信息 enumeration\u0026lt;url\u0026gt; urls = classloader.getresources(factories_resource_location); while (urls.hasmoreelements()) { url url = urls.nextelement(); urlresource resource = new urlresource(url); properties properties = propertiesloaderutils.loadproperties(resource); for (map.entry\u0026lt;?, ?\u0026gt; entry : properties.entryset()) { string factorytypename = ((string) entry.getkey()).trim(); string[] factoryimplementationnames = stringutils.commadelimitedlisttostringarray((string) entry.getvalue()); for (string factoryimplementationname : factoryimplementationnames) { result.computeifabsent(factorytypename, key -\u0026gt; new arraylist\u0026lt;\u0026gt;()) .add(factoryimplementationname.trim()); } } } // replace all lists with unmodifiable lists containing unique elements result.replaceall((factorytype, implementations) -\u0026gt; implementations.stream().distinct() .collect(collectors.collectingandthen(collectors.tolist(), collections::unmodifiablelist))); cache.put(classloader, result); } catch (ioexception ex) { throw new illegalargumentexception(\u0026#34;unable to load factories from location [\u0026#34; + factories_resource_location + \u0026#34;]\u0026#34;, ex); } return result; } //第六步：获取自动配置信息spring.factories public static final string factories_resource_location = \u0026#34;meta-inf/spring.factories\u0026#34;; 获取到配置文件中的自动配置类xxxautoconfiguration的信息，并将自动配置类中的组件初始化到容器中。 初始化的过程中会加载xxxproperties对象，根据xxxproperties对象中的属性值初始化组件,xxxproperties对象的值可以通过全局配置文件指定。 （3）初始化自动配置组件 以spring boot 自动配置springmvc为例，spring boot启动时会做以下操作：\n//根据以上步骤找到自动配置类webmvcautoconfiguration，并根据自动配置类进行以下初始化操作： @configuration(proxybeanmethods = false)//表示这是一个配置类，和以前编写的配置文件一样 @conditionalonwebapplication(type = type.servlet)//@conditional判断满足指定的条件，整个配置类里面的配置就会生效,否则不生效； 这里是判断当前应用是否是web应用，如果是当前配置类生效 @conditionalonclass({ servlet.class, dispatcherservlet.class, webmvcconfigurer.class })//判断当前项目有没有以上指定类 @conditionalonmissingbean(webmvcconfigurationsupport.class)//判断容器中是否没有指定组件 @autoconfigureorder(ordered.highest_precedence + 10)//自动配置顺序 @autoconfigureafter({ dispatcherservletautoconfiguration.class, taskexecutionautoconfiguration.class, validationautoconfiguration.class })//在指定自动配置之后配置 public class webmvcautoconfiguration { /** * a、自动配置视图解析器 */ @bean//给容器中添加组件 @conditionalonbean(viewresolver.class) @conditionalonmissingbean(name = \u0026#34;viewresolver\u0026#34;, value = contentnegotiatingviewresolver.class) public contentnegotiatingviewresolver viewresolver(beanfactory beanfactory) { contentnegotiatingviewresolver resolver = new contentnegotiatingviewresolver(); resolver.setcontentnegotiationmanager(beanfactory.getbean(contentnegotiationmanager.class)); // contentnegotiatingviewresolver uses all the other view resolvers to locate // a view so it should have a high precedence resolver.setorder(ordered.highest_precedence); return resolver; } /** * 自动配置视图解析器 */ @bean @conditionalonbean(view.class) @conditionalonmissingbean public beannameviewresolver beannameviewresolver() { beannameviewresolver resolver = new beannameviewresolver(); resolver.setorder(ordered.lowest_precedence - 10); return resolver; } /** * b、提供静态资源访问路径和webjars访问路径 */ @override protected void addresourcehandlers(resourcehandlerregistry registry) { super.addresourcehandlers(registry); if (!this.resourceproperties.isaddmappings()) { logger.debug(\u0026#34;default resource handling disabled\u0026#34;); return; } servletcontext servletcontext = getservletcontext(); addresourcehandler(registry, \u0026#34;/webjars/**\u0026#34;, \u0026#34;classpath:/meta-inf/resources/webjars/\u0026#34;); addresourcehandler(registry, this.mvcproperties.getstaticpathpattern(), (registration) -\u0026gt; { registration.addresourcelocations(this.resourceproperties.getstaticlocations()); if (servletcontext != null) { registration.addresourcelocations(new servletcontextresource(servletcontext, servlet_location)); } }); } -----------------内部类-------------------- @configuration(proxybeanmethods = false) @import(enablewebmvcconfiguration.class) @enableconfigurationproperties({ webmvcproperties.class, org.springframework.boot.autoconfigure.web.resourceproperties.class, webproperties.class }) @order(0) public static class webmvcautoconfigurationadapter implements webmvcconfigurer { private final webmvcproperties mvcproperties; private final listablebeanfactory beanfactory; private final objectprovider\u0026lt;httpmessageconverters\u0026gt; messageconvertersprovider; private final objectprovider\u0026lt;dispatcherservletpath\u0026gt; dispatcherservletpath; private final objectprovider\u0026lt;servletregistrationbean\u0026lt;?\u0026gt;\u0026gt; servletregistrations; final resourcehandlerregistrationcustomizer resourcehandlerregistrationcustomizer; //该内部类只有一个带参构造方法，那么spring在创建该类实例时，只能从容器中获取参数； public webmvcautoconfigurationadapter(webproperties webproperties, webmvcproperties mvcproperties, listablebeanfactory beanfactory, objectprovider\u0026lt;httpmessageconverters\u0026gt; messageconvertersprovider, objectprovider\u0026lt;resourcehandlerregistrationcustomizer\u0026gt; resourcehandlerregistrationcustomizerprovider, objectprovider\u0026lt;dispatcherservletpath\u0026gt; dispatcherservletpath, objectprovider\u0026lt;servletregistrationbean\u0026lt;?\u0026gt;\u0026gt; servletregistrations) { this.mvcproperties = mvcproperties; this.beanfactory = beanfactory; this.messageconvertersprovider = messageconvertersprovider; this.resourcehandlerregistrationcustomizer = resourcehandlerregistrationcustomizerprovider.getifavailable(); this.dispatcherservletpath = dispatcherservletpath; this.servletregistrations = servletregistrations; this.mvcproperties.checkconfiguration(); } /** * c、自动注册converter类型转换器 */ @override public void configuremessageconverters(list\u0026lt;httpmessageconverter\u0026lt;?\u0026gt;\u0026gt; converters) { this.messageconvertersprovider .ifavailable((customconverters) -\u0026gt; converters.addall(customconverters.getconverters())); } @override public void configureasyncsupport(asyncsupportconfigurer configurer) { if (this.beanfactory.containsbean(taskexecutionautoconfiguration.application_task_executor_bean_name)) { object taskexecutor = this.beanfactory .getbean(taskexecutionautoconfiguration.application_task_executor_bean_name); if (taskexecutor instanceof asynctaskexecutor) { configurer.settaskexecutor(((asynctaskexecutor) taskexecutor)); } } duration timeout = this.mvcproperties.getasync().getrequesttimeout(); if (timeout != null) { configurer.setdefaulttimeout(timeout.tomillis()); } } @override public void configurepathmatch(pathmatchconfigurer configurer) { if (this.mvcproperties.getpathmatch() .getmatchingstrategy() == webmvcproperties.matchingstrategy.path_pattern_parser) { configurer.setpatternparser(new pathpatternparser()); } configurer.setusesuffixpatternmatch(this.mvcproperties.getpathmatch().isusesuffixpattern()); configurer.setuseregisteredsuffixpatternmatch( this.mvcproperties.getpathmatch().isuseregisteredsuffixpattern()); this.dispatcherservletpath.ifavailable((dispatcherpath) -\u0026gt; { string servleturlmapping = dispatcherpath.getservleturlmapping(); if (servleturlmapping.equals(\u0026#34;/\u0026#34;) \u0026amp;\u0026amp; singledispatcherservlet()) { urlpathhelper urlpathhelper = new urlpathhelper(); urlpathhelper.setalwaysusefullpath(true); configurer.seturlpathhelper(urlpathhelper); } }); } private boolean singledispatcherservlet() { return this.servletregistrations.stream().map(servletregistrationbean::getservlet) .filter(dispatcherservlet.class::isinstance).count() == 1; } @override public void configurecontentnegotiation(contentnegotiationconfigurer configurer) { webmvcproperties.contentnegotiation contentnegotiation = this.mvcproperties.getcontentnegotiation(); configurer.favorpathextension(contentnegotiation.isfavorpathextension()); configurer.favorparameter(contentnegotiation.isfavorparameter()); if (contentnegotiation.getparametername() != null) { configurer.parametername(contentnegotiation.getparametername()); } map\u0026lt;string, mediatype\u0026gt; mediatypes = this.mvcproperties.getcontentnegotiation().getmediatypes(); mediatypes.foreach(configurer::mediatype); } @bean @conditionalonmissingbean public internalresourceviewresolver defaultviewresolver() { internalresourceviewresolver resolver = new internalresourceviewresolver(); resolver.setprefix(this.mvcproperties.getview().getprefix()); resolver.setsuffix(this.mvcproperties.getview().getsuffix()); return resolver; } @bean @conditionalonbean(view.class) @conditionalonmissingbean public beannameviewresolver beannameviewresolver() { beannameviewresolver resolver = new beannameviewresolver(); resolver.setorder(ordered.lowest_precedence - 10); return resolver; } @bean @conditionalonbean(viewresolver.class) @conditionalonmissingbean(name = \u0026#34;viewresolver\u0026#34;, value = contentnegotiatingviewresolver.class) public contentnegotiatingviewresolver viewresolver(beanfactory beanfactory) { contentnegotiatingviewresolver resolver = new contentnegotiatingviewresolver(); resolver.setcontentnegotiationmanager(beanfactory.getbean(contentnegotiationmanager.class)); // contentnegotiatingviewresolver uses all the other view resolvers to locate // a view so it should have a high precedence resolver.setorder(ordered.highest_precedence); return resolver; } //e、自动注册消息代码提示处理器messagecodesresolver @override public messagecodesresolver getmessagecodesresolver() { if (this.mvcproperties.getmessagecodesresolverformat() != null) { defaultmessagecodesresolver resolver = new defaultmessagecodesresolver(); resolver.setmessagecodeformatter(this.mvcproperties.getmessagecodesresolverformat()); return resolver; } return null; } //获取所有的格式化器和转换器 @override public void addformatters(formatterregistry registry) { applicationconversionservice.addbeans(registry, this.beanfactory); } --------------------------------------------------------- //enablewebmvcconfiguration内部类： // c、自动注册formatter格式化器； @bean @override public formattingconversionservice mvcconversionservice() { format format = this.mvcproperties.getformat(); webconversionservice conversionservice = new webconversionservice(new datetimeformatters() .dateformat(format.getdate()).timeformat(format.gettime()).datetimeformat(format.getdatetime())); addformatters(conversionservice); return conversionservice; } //f、支持静态首页index.html访问 private resource getwelcomepage() { for (string location : this.resourceproperties.getstaticlocations()) { resource indexhtml = getindexhtml(location); if (indexhtml != null) { return indexhtml; } } servletcontext servletcontext = getservletcontext(); if (servletcontext != null) { return getindexhtml(new servletcontextresource(servletcontext, servlet_location)); } return null; } ------------------------------------------------------- @bean @conditionalonmissingbean({ requestcontextlistener.class, requestcontextfilter.class }) @conditionalonmissingfilterbean(requestcontextfilter.class) public static requestcontextfilter requestcontextfilter() { return new orderedrequestcontextfilter(); } } } a、自动配置视图解析器viewresolver（contentnegotiatingviewresolver 和 beannameviewresolver）,作用：根据方法返回值得到视图对象，由视图对象决定请求转发或者重定向到指定视图。（注意：此处会创建获取容器中的所有视图解析器，包括自定义的视图解析器） b、提供静态资源访问路径和webjars访问路径； c、自动注册converter类型转换器,formatter格式化器； d、提供httpmessageconverters，用于http请求和响应之间的转换，将json或者xml格式字符串和java类型之间做转换； （注意：如果要自定义类型转换器，也可以通过该接口注册） @configuration(proxybeanmethods = false) public class myconfiguration { @bean public httpmessageconverters customconverters() { httpmessageconverter\u0026lt;?\u0026gt; additional = ... httpmessageconverter\u0026lt;?\u0026gt; another = ... return new httpmessageconverters(additional, another); } } e、自动注册消息代码提示处理器messagecodesresolver f、支持静态首页index.html访问 g、自动注册web数据参数绑定对象configurablewebbindinginitializer，如果我们自己注册了该类型对象，那springboot会自动调用我们注册的对象，替换默认对象将请求参数绑定到javabean（了解）。 h、如果要自定义拦截器interceptors，格式化器formatters，视图控制器view controllers等，可以通过创建类型为webmvcconfigurer的配置类来实现，不要加注解@enablewebmvc。 i、如果要自定义处理器映射器requestmappinghandlermapping, 处理器适配器requestmappinghandleradapter, 或者异常处理器exceptionhandlerexceptionresolver，可以在容器中创建类型为webmvcregistrations的组件对象来实现。 j、如果想要完全使用自定义配置，不使用springboot默认配置，可以在配置类上加注解@enablewebmvc。（不推荐） 参考官方文档：https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/spring-boot-features.html#boot-features-spring-mvc （4）小结 a、springboot启动会加载大量的自动配置类 b、根据配置文件和xxxproperties的默认设置初始化自动配置类中的组件 c、可以在自动配置类中查看我们需要的功能是否已经自动配置，如果配置，我们就不用再做配置了； 2、自定义配置实现访问拦截 （1）自定义拦截器 public class myintercepter implements handlerinterceptor { @override public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler) throws exception { httpsession session = request.getsession(); string username=(string)session.getattribute(\u0026#34;username\u0026#34;); if(username!=null){ system.out.println(\u0026#34;登录成功不拦截\u0026#34;); return true; }else{ request.getrequestdispatcher(\u0026#34;/index.html\u0026#34;).forward(request,response); system.out.println(\u0026#34;未登录拦截\u0026#34;); return false; } } @override public void posthandle(httpservletrequest request, httpservletresponse response, object handler, modelandview modelandview) throws exception { } @override public void aftercompletion(httpservletrequest request, httpservletresponse response, object handler, exception ex) throws exception { } } （2）注册拦截器 @configuration public class myconfig implements webmvcconfigurer { @override public void addinterceptors(interceptorregistry registry) { registry.addinterceptor(new myintercepter()).addpathpatterns(\u0026#34;/**\u0026#34;).excludepathpatterns(\u0026#34;/\u0026#34;,\u0026#34;/index.html\u0026#34;,\u0026#34;/user/login\u0026#34;); } } 3、自定义配置视图控制器 //springboot默认不支持jsp，而是使用模板引擎thymeleaf作为视图 //引入thymeleaf \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; //配置视图控制器 @configuration public class myconfig implements webmvcconfigurer { @override public void addinterceptors(interceptorregistry registry) { registry.addinterceptor(new myintercepter()).addpathpatterns(\u0026#34;/**\u0026#34;).excludepathpatterns(\u0026#34;/\u0026#34;,\u0026#34;/index.html\u0026#34;,\u0026#34;/user/login\u0026#34;); } //配置视图控制器 @override public void addviewcontrollers(viewcontrollerregistry registry) { registry.addviewcontroller(\u0026#34;/main\u0026#34;).setviewname(\u0026#34;main\u0026#34;); } } 4、学员练习自动配置拦截器 ","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/tool/20220526204358/","summary":"Spring Boot第一节 一、Spring Boot概述 （一）微服务概述 1、微服务 微服务（英语：Microservices）是一种软件架构风格，它是以专注于单一责任与功能的","title":"spring-boot-1"},{"content":"1 thymeleaf模板解析 （一）模板引擎概述 thymeleaf是一款用于渲染xml/xhtml/html5内容的模板引擎。类似jsp， velocity，freemaker等，它也可以轻易的与spring mvc等web框架进行集成作为web应用的模板引擎。与其它模板引擎相比，thymeleaf最大的特点是能够 直接在浏览器中打开并正确显示模板页面，而不需要启动整个web应用 spring boot推荐使用thymeleaf、freemarker等现代的模板引擎技术；一但导入相 关依赖，会自动配置thymeleafautoconfiguration、freemarkerautoconfiguration。 模板引擎工作原理图：\n（二） springboot使用thymeleaf 入门案例 1 构建maven工程引入技术依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.4.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2 在application.yml当中添加配置 spring: #开始thymeleaf设置 thymeleaf: #禁用模板缓存 cache: false 3 编写controller文件 package com.offcn.demo.controller; @controller public class firstthymeleafcontroller { /** * 访问http://localhost:8080/first * 将数据message填充到templates/index.html * @param model * @return */ @getmapping(\u0026#34;/first\u0026#34;) public string indexpage(model model) { string message = \u0026#34;hello, thymeleaf!\u0026#34;; model.addattribute(\u0026#34;message\u0026#34;, message); return \u0026#34;index\u0026#34;; } } 4 编写模板文件 在resources/templates 下新建 index.html\n\u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 th:text=\u0026#34;${message}\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 通过 类似el 表达式将 model 中的数据填充到 h1 标签中\n5 运行访问地址 http://localhost:8080/first （三） thymeleaf 语法简介 （四）使用thymeleaf模板进行数据交互 1 spring boot 集成thymeleaf打印对象属性 1.1 新建一个实体bean user package com.offcn.demo.bean; public class user { private integer id; private string name; private int age; public integer getid() { return id; } public void setid(integer id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public int getage() { return age; } public void setage(int age) { this.age = age; } } 1.2 新建controller package com.offcn.demo.controller; import java.util.hashmap; import java.util.map; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.getmapping; import com.offcn.demo.bean.user; @controller public class secondthymeleafcontroller { /** * 访问localhost:8080 页面 * 将数据message填充到templates/index2.html * @param model * @return */ @getmapping(\u0026#34;/second\u0026#34;) public string indexpage(model model) { string message = \u0026#34;hello, thymeleaf!\u0026#34;; user u = new user(); u.setid(1); u.setname(\u0026#34;优就业\u0026#34;); u.setage(18); map\u0026lt;string,object\u0026gt; map=new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;src1\u0026#34;,\u0026#34;1.jpg\u0026#34;); map.put(\u0026#34;src2\u0026#34;,\u0026#34;2.jpg\u0026#34;); model.addattribute(\u0026#34;message\u0026#34;, message); model.addattribute(\u0026#34;user\u0026#34;, u); model.addattribute(\u0026#34;src\u0026#34;, map); return \u0026#34;index2\u0026#34;; } } 1.3 在resource/templates 下,新增模板文件index2.html \u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 th:text=\u0026#34;${message}\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;img th:src=\u0026#34;${src.src1}\u0026#34;/\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;img th:src=\u0026#34;${src.src2}\u0026#34;/\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;span th:text=\u0026#34;${user.id}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span th:text=\u0026#34;${user.name}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span th:text=\u0026#34;${user.age}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1.4 访问地址 http://localhost:8080/second 2 spring boot 集成thymeleaf循环遍历集合 2.1 新建一个controller package com.offcn.demo.controller; @controller public class threethymeleafcontroller { /** * 访问localhost:8080/java003 页面 * 将数据message填充到templates/index3.html * @param model * @return */ @getmapping(\u0026#34;/three\u0026#34;) public string indexpage(model model) { list\u0026lt;user\u0026gt; list=new arraylist\u0026lt;user\u0026gt;(); user u1 = new user(); u1.setid(1); u1.setname(\u0026#34;优就业\u0026#34;); u1.setage(18); list.add(u1); user u2 = new user(); u2.setid(2); u2.setname(\u0026#34;中公教育\u0026#34;); u2.setage(28); list.add(u2); user u3 = new user(); u3.setid(3); u3.setname(\u0026#34;it先锋\u0026#34;); u3.setage(88); list.add(u3); user u4 = new user(); u4.setid(4); u4.setname(\u0026#34;java第一\u0026#34;); u4.setage(888); list.add(u4); model.addattribute(\u0026#34;userlist\u0026#34;, list); return \u0026#34;index3\u0026#34;; } } 2.2 在resource/templates 下,新增模板文件index3.html \u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table width=\u0026#34;200\u0026#34; style=\u0026#34;text-align: center;\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;index\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr th:each=\u0026#34;user,iterstat : ${userlist}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${user.id}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${user.name}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${user.age}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${iterstat.index}\u0026#34;\u0026gt;index\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; iterstat 称作状态变量，属性有：\nindex：当前迭代对象的 index（从 0 开始计算）\ncount：当前迭代对象的 index（从 1 开始计算）\nsize：被迭代对象的大小\ncurrent：当前迭代变量\neven/odd：布尔值，当前循环是否是偶数/奇数（从 0 开始计算）\nfirst：布尔值，当前循环是否是第一个\nlast：布尔值，当前循环是否是最后一个\n2.3 访问地址 3 spring boot 集成thymeleaf赋值、字符串拼接 3.1 新建一个controller package com.offcn.demo.controller; @controller public class fourthymeleafcontroller { /** * 访问localhost:8080/java003 页面 * 将数据message填充到templates/index4.html * @param model * @return */ @getmapping(\u0026#34;/four\u0026#34;) public string indexpage(model model) { model.addattribute(\u0026#34;username\u0026#34;, \u0026#34;优就业\u0026#34;); model.addattribute(\u0026#34;href\u0026#34;, \u0026#34;http://www.ujiuye.com\u0026#34;); return \u0026#34;index4\u0026#34;; } } 3.2 在resource/templates 下,新增模板文件index4.html \u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 给标签赋值 th:text --\u0026gt; \u0026lt;h1 th:text=\u0026#34;${username}\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;!-- 给属性赋值 th:value、th:属性名称 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;names\u0026#34; th:value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;em th:size=\u0026#34;${username}\u0026#34;\u0026gt;\u0026lt;/em\u0026gt; \u0026lt;!-- 字符串拼接 --\u0026gt; \u0026lt;span th:text=\u0026#34;\u0026#39;欢迎来:\u0026#39;+${username}+\u0026#39;学习!\u0026#39;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;!-- 字符串拼接,方式2 --\u0026gt; \u0026lt;span th:text=\u0026#34;|欢迎来:${username}学习!|\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3.3 访问地址： http://localhost:8080/four 4 spring boot 集成thymeleaf条件判断、选择语句 4.1 新建一个controller package com.offcn.demo.controller; @controller public class fivethymeleafcontroller { /** * 访问localhost:8080/ 页面 * 将数据message填充到templates/index4.html * @param model * @return */ @getmapping(\u0026#34;/five\u0026#34;) public string indexpage(model model) { model.addattribute(\u0026#34;flag\u0026#34;, \u0026#34;yes\u0026#34;); model.addattribute(\u0026#34;menu\u0026#34;, \u0026#34;admin\u0026#34;); model.addattribute(\u0026#34;manager\u0026#34;, \u0026#34;manager\u0026#34;); return \u0026#34;index5\u0026#34;; } } 4.2 在resource/templates 下,新增模板文件index5.html \u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- th:if 条件成立就显示 --\u0026gt; \u0026lt;h1 th:if=\u0026#34;${flag==\u0026#39;yes\u0026#39;}\u0026#34; \u0026gt;中公教育\u0026lt;/h1\u0026gt; \u0026lt;!-- th:unless 条件不成立就显示 --\u0026gt; \u0026lt;h1 th:unless=\u0026#34;${flag==\u0026#39;no\u0026#39;}\u0026#34; \u0026gt;优就业\u0026lt;/h1\u0026gt; \u0026lt;!-- switch选择语句 --\u0026gt; \u0026lt;div th:switch=\u0026#34;${menu}\u0026#34;\u0026gt; \u0026lt;p th:case=\u0026#34;\u0026#39;admin\u0026#39;\u0026#34;\u0026gt;user is an administrator\u0026lt;/p\u0026gt; \u0026lt;p th:case=\u0026#34;${manager}\u0026#34;\u0026gt;user is a manager\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.3 访问地址： http://localhost:8080/five 5 spring boot 集成thymeleaf 静态资源加载 我们知道一个网页中加载的静态文件通常有一个十分尴尬的问题，比如对于bootstrap.css，就是如果我们能让ide识别这个文件，那么我们得用相对路径来引入这个文件。这样我们的ide才能加载到这个文件，并且给予我们相应的提示。但是如果我们想要在发布后服务器能够加载这个文件，我们就必须用相对于resources或者static的位置来引入静态文件。显然，一般情况下我们不能兼顾这两个问题，只能要么在编写的时候用相对自己的路径，然后在发布的时候用相对于项目资源文件夹的路径，要么就只能放弃ide的提示，非常尴尬。 而在thymeleaf中，我们可很好的处理这一点。在引入资源的时候，我们可以写类似下面的代码: \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; media=\u0026#34;all\u0026#34; href=\u0026#34;../../css/gtvg.css\u0026#34; th:href=\u0026#34;@{/css/gtvg.css}\u0026#34; /\u0026gt; 当我们在没有后台渲染的情况下，浏览器会认得href，但是不认得th:href，这样它就会选择以相对与本文件的相对路径去加载静态文件。而且我们的ide也能识别这样的加载方式，从而给我们提示。 当我们在有后台渲染的情况下，后台会把这个标签渲染为这样: \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; media=\u0026#34;all\u0026#34; href=\u0026#34;/css/gtvg.css\u0026#34; /\u0026gt; 原来的href标签会被替换成相对于项目的路径，因此服务器就能找到正确的资源，从而正确渲染。 非常的智能而且方便。 这里需要注意到所有的路径我们是用”@{}”来引用，而不是”${}”，因为后者是用来引用变量名的，而前者是引用路径的，因此我们在这里用的是前者。可是如果我们是把路径写在变量里，那么就要用后者来引用了 6 spring boot 集成thymeleaf 片段fragment定义使用 thymeleaf也提供了类似import的东西，可以将很多代码块抽象成模块，然后在需要的时候引用，非常方便。\nfragment介绍\nfragment类似于jsp的tag，在html中文件中，可以将多个地方出现的元素块用fragment包起来使用。\nfragment使用\n定义fragment,所有的fragment可以写在一个文件里面，也可以单独存在，例如：\n6.1 在resource/templates 下,新增模板文件footer.html \u0026lt;body\u0026gt; \u0026lt;h1 th:fragment=\u0026#34;copy\u0026#34;\u0026gt; \u0026amp;copy; 1999-2022 offcn.all rights reserved \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; 注意： 在springboot中，默认读取thymeleaf文件的路径是：src/main/resource/templates\n6.2 编写controller package com.offcn.demo.controller; @controller public class sixthymeleafcontroller { /** * 访问localhost:8080/java003 页面 * 将数据message填充到templates/index6.html * @param model * @return */ @getmapping(\u0026#34;/six\u0026#34;) public string indexpage(model model) { return \u0026#34;index6\u0026#34;; } } 6.3 在resource/templates 下,新增视图文件index6.html \u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 把片段的内容插入到当前位置 --\u0026gt; \u0026lt;div style=\u0026#34;color: #82ff6c\u0026#34; th:insert=\u0026#34;~{footer :: copy}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;!-- 使用片段的内容替换当前标签 --\u0026gt; \u0026lt;div style=\u0026#34;color: #82ff6c\u0026#34; th:replace=\u0026#34;~{footer :: copy}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;!-- 保留自己的主标签，不要片段的主标签 --\u0026gt; \u0026lt;div style=\u0026#34;color: #82ff6c\u0026#34; th:include=\u0026#34;~{footer :: copy}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; fragment的引用\nth:insert:保留自己的主标签，保留th:fragment的主标签。\nth:replace:不要自己的主标签，保留th:fragment的主标签。\nth:include:保留自己的主标签，不要th:fragment的主标签。（官方3.0后不推荐）\n6.4 访问地址http://localhost:8080/six 运行 7 spring boot 集成thymeleaf 表达式内置对象使用 7.1 常见内置工具对象如下： #dates 与java.util.date对象的方法对应，格式化、日期组件抽取等等 #numbers 格式化数字对象的工具方法 #strings 与java.lang.string对应的工具方法 7.2 编写controller package com.offcn.demo.controller; @controller public class seventhymeleafcontroller { /** * 访问localhost:8080/java003 页面 * 将数据message填充到templates/index7.html * @param model * @return */ @getmapping(\u0026#34;/seven\u0026#34;) public string indexpage(model model) { //日期时间 date date = new date(); model.addattribute(\u0026#34;date\u0026#34;, date); //小数的金额 double price=128.5678d; model.addattribute(\u0026#34;price\u0026#34;, price); //定义大文本数据 string str=\u0026#34;thymeleaf是web和独立环境的现代服务器端java模板引擎，能够处理html，xml，javascript，css甚至纯文本。\\r\\n\u0026#34; + \u0026#34;thymeleaf的主要目标是提供一种优雅和高度可维护的创建模板的方式。为了实现这一点，它建立在自然模板的概念上，将其逻辑注入到模板文件中，不会影响模板被用作设计原型。这改善了设计的沟通，弥补了设计和开发团队之间的差距。\\r\\n\u0026#34; + \u0026#34;thymeleaf也从一开始就设计了web标准 - 特别是html5 - 允许您创建完全验证的模板，如果这是您需要的\\r\\n\u0026#34; ; model.addattribute(\u0026#34;strtext\u0026#34;, str);\t//定义字符串 string str2=\u0026#34;java-offcn\u0026#34;; model.addattribute(\u0026#34;str2\u0026#34;, str2); return \u0026#34;index7\u0026#34;; } } 7.3 resource/templates 下,新增模板文件index7.html \u0026lt;!doctype html\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 时间：\u0026lt;span th:text=\u0026#34;${#dates.format(date,\u0026#39;yyyy-mm-dd hh:mm:ss\u0026#39;)}\u0026#34;\u0026gt;4564546\u0026lt;/span\u0026gt;\u0026lt;/br\u0026gt; 金额：\u0026lt;span th:text=\u0026#34;\u0026#39;￥\u0026#39;+${#numbers.formatdecimal(price, 1, 2)}\u0026#34;\u0026gt;180\u0026lt;/span\u0026gt; \u0026lt;/br\u0026gt; \u0026lt;!-- # 这里的含义是 如果 atc.text 这个变量多余200个字符，后面显示... --\u0026gt; \u0026lt;p th:text=\u0026#34;${#strings.abbreviate(strtext,60)}\u0026#34;\u0026gt;内容内容内容\u0026lt;/p\u0026gt; \u0026lt;!-- 判断字符串是否为空 --\u0026gt; \u0026lt;span th:if=\u0026#34;${!#strings.isempty(str2)}\u0026#34;\u0026gt;字符串str2不为空\u0026lt;/span\u0026gt;\u0026lt;/br\u0026gt; \u0026lt;!-- 截取字符串，指定长度 --\u0026gt; \u0026lt;span th:text=\u0026#34;${#strings.substring(str2,0,4)}\u0026#34;\u0026gt;字符串str2的值\u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 7.4 运行访问地址 http://localhost:8080/seven 2 springboot整合junit （一）junit5 介绍 spring boot 2.2.0 版本开始引入 junit 5 作为单元测试默认库\n作为最新版本的junit框架，junit5与之前版本的junit框架有很大的不同。由三个不同子项目的几个不同模块组成。\njunit 5 = junit platform + junit jupiter + junit vintage\njunit platform: junit platform是在jvm上启动测试框架的基础，不仅支持junit自制的测试引擎，其他测试引擎也都可以接入。\njunit jupiter: junit jupiter提供了junit5的新的编程模型，是junit5新特性的核心。内部 包含了一个测试引擎，用于在junit platform上运行。\njunit vintage: 由于juint已经发展多年，为了照顾老的项目，junit vintage提供了兼容junit4.x,junit3.x的测试引擎。 （二）springboot整合junit 1 构建工程添加依赖 \u0026lt;!--junit5版本，不兼容junit4 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--如果要继续兼容 junit4，自行引入vintage--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.junit.vintage\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit-vintage-engine\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.hamcrest\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;hamcrest-core\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 2 创建测试类 import org.junit.jupiter.api.test; import org.springframework.boot.test.context.springboottest; class testthymeleafapplicationtests { @test void contextloads() { } } 3 测试类上添加注解 @springboottest 4 测试类注入测试对象 @springboottest class testthymeleafapplicationtests { @autowired private applicationcontext applicationcontext; @test void contextloads() { system.out.println(applicationcontext); } } 3 springboot整合mybatis （一）springboot整合mybatis框架 1 创建maven工程添加依赖 \u0026lt;!--springboot整合mybatis的启动器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis.spring.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mysql驱动包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--web模块--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 2 建数据库数据库表 create table `account` ( `id` int(11) not null auto_increment, `name` varchar(255) default null, `money` double(10,2) default null, primary key (`id`) ) engine=innodb auto_increment=1005 default charset=utf8 3 创建数据模型 /** * @author offcn **/ public class account implements serializable { private integer id; private string name; private double money; public integer getid() { return id; } public void setid(integer id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public double getmoney() { return money; } public void setmoney(double money) { this.money = money; } } 4 创建接口和mapper配置文件 @mapper public interface accountmapper { account findbyid(integer id); } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.offcn.accountmapper\u0026#34;\u0026gt; \u0026lt;!-- account findbyid(integer id);--\u0026gt; \u0026lt;select id=\u0026#34;findbyid\u0026#34; resulttype=\u0026#34;com.offcn.pojo.account\u0026#34;\u0026gt; select * from acccont where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 5 配置application.yml(数据源,myatis配置) spring: datasource: url: jdbc:mysql://localhost:3306/test username: root password: root driver-class-name: com.mysql.jdbc.driver # 配置mybatis规则 mybatis: #config-location: classpath:mybatis/mybatis-config.xml #全局配置文件位置 mapper-locations: classpath:mybatis/mapper/*.xml #sql映射文件位置 type-aliases-package: com.offcn.pojo #配置了实体的别名 configuration: map-underscore-to-camel-case: true #开启 驼峰式命名法 不写全局，局配置文件的配置都放在configuration对象当中 6 创建业务层接口和实现类 public interface accountservice { account findbyidservice(integer id); } @service public class accountserviceimpl implements accountservice { @autowired private accountmapper accountmapper; @override public account findbyidservice(integer id) { return accountmapper.findbyid(id); } } 7 创建控制器controller @controller @requestmapping(\u0026#34;account\u0026#34;) public class accountcontroller { @autowired private accountservice accountservice; @getmapping(\u0026#34;findbyid\u0026#34;) @responsebody public account findbyid(integer id){ return accountservice.findbyidservice(id); } } 8 启动服务测试结果 访问地址： http://localhost:8080/account/findbyid?id=1001 测试结果： 4 springboot整合redis spring-data-redis针对jedis提供了如下功能： 1.连接池自动管理，提供了一个高度封装的“redistemplate”类 2.针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口 valueoperations：简单k-v操作 setoperations：set类型数据操作 zsetoperations：zset类型数据操作 hashoperations：针对map类型的数据操作 listoperations：针对list类型的数据操作 （一）创建springboot程序引入启动器 或者是pom.xml文件当中引入启动器依赖\n\u0026lt;!--整合redis的启动器--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; （二）application.yml配置连接信息 spring: redis: host: 192.168.126.10 port: 6379 password: 123456 1. 绍介一下redisapi spring-data-redis针对jedis提供了如下功能： 1.连接池自动管理，提供了一个高度封装的“redistemplate”类 2.针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口 valueoperations：简单k-v操作 setoperations：set类型数据操作 zsetoperations：zset类型数据操作 hashoperations：针对map类型的数据操作 listoperations：针对list类型的数据操作 （三）使用redistemplate操作redis 1 值类型操作 package com.offcn; import org.junit.jupiter.api.test; import org.springframework.beans.factory.annotation.autowired; import org.springframework.boot.test.context.springboottest; import org.springframework.data.redis.core.redistemplate; @springboottest public class bootredisdemoapplicationtests { @autowired private redistemplate\u0026lt;string,string\u0026gt; redistemplate; @test void test1() { valueoperations\u0026lt;string, string\u0026gt; ops = redistemplate.opsforvalue(); //ops 存 ops.set(\u0026#34;username\u0026#34;,\u0026#34;jack\u0026#34;); // ops取 string username = ops.get(\u0026#34;username\u0026#34;); system.out.println(username); //移除 redistemplate.delete(\u0026#34;username\u0026#34;); } } 2 set类型操作 package com.offcn; import org.junit.jupiter.api.test; import org.springframework.beans.factory.annotation.autowired; import org.springframework.boot.test.context.springboottest; import org.springframework.data.redis.core.redistemplate; import java.util.set; @springboottest public class bootredisdemoapplicationtests { @autowired private redistemplate\u0026lt;string,string\u0026gt; redistemplate; // set集合类型 @test void test2() { setoperations\u0026lt;string, string\u0026gt; ops = redistemplate.opsforset(); //存： ops.add(\u0026#34;set\u0026#34;,\u0026#34;jack\u0026#34;,\u0026#34;marray\u0026#34;,\u0026#34;george\u0026#34;); //取： set\u0026lt;string\u0026gt; set = ops.members(\u0026#34;set\u0026#34;); system.out.println(set); //移除：移除单个元素 ops.remove(\u0026#34;set\u0026#34;,\u0026#34;jack\u0026#34;); //删除key redistemplate.delete(\u0026#34;set\u0026#34;); } } 3 list集合操作 3.1 右压栈 // 右压栈 @test void test3() { listoperations\u0026lt;string, string\u0026gt; ops = redistemplate.opsforlist(); //右压栈 ops.rightpush(\u0026#34;mylist\u0026#34;,\u0026#34;a\u0026#34;); ops.rightpush(\u0026#34;mylist\u0026#34;,\u0026#34;b\u0026#34;); ops.rightpush(\u0026#34;mylist\u0026#34;,\u0026#34;c\u0026#34;); //取值： list\u0026lt;string\u0026gt; mylist = ops.range(\u0026#34;mylist\u0026#34;, 0, -1); system.out.println(mylist); } 3.2 左压栈 // 左压栈 @test void test4() { listoperations\u0026lt;string, string\u0026gt; ops = redistemplate.opsforlist(); //左压栈 ops.leftpush(\u0026#34;mylist\u0026#34;,\u0026#34;a\u0026#34;); ops.leftpush(\u0026#34;mylist\u0026#34;,\u0026#34;b\u0026#34;); ops.leftpush(\u0026#34;mylist\u0026#34;,\u0026#34;c\u0026#34;); //取值： list\u0026lt;string\u0026gt; mylist = ops.range(\u0026#34;mylist\u0026#34;, 0, -1);// cbaabc system.out.println(mylist); } 3.3 根据索引查询元素 // 根据索引查询元素 @test void test5() { listoperations\u0026lt;string, string\u0026gt; ops = redistemplate.opsforlist(); string value = ops.index(\u0026#34;mylist\u0026#34;, 1); system.out.println(value); } 3.4 移除某个元素的值 // 移除某个元素的值 @test void test6() { listoperations\u0026lt;string, string\u0026gt; ops = redistemplate.opsforlist(); ops.remove(\u0026#34;mylist\u0026#34;,1,\u0026#34;a\u0026#34;); list\u0026lt;string\u0026gt; mylist = ops.range(\u0026#34;mylist\u0026#34;, 0, -1);// system.out.println(mylist);// cbabc } 4 hash类型操作 4.1 存入值 @test void test7() { hashoperations\u0026lt;string, object, object\u0026gt; ops = redistemplate.opsforhash(); // 存入值 ops.put(\u0026#34;user\u0026#34;,\u0026#34;username\u0026#34;,\u0026#34;mrzhang\u0026#34;); ops.put(\u0026#34;user\u0026#34;,\u0026#34;address\u0026#34;,\u0026#34;beijing\u0026#34;); ops.put(\u0026#34;user\u0026#34;,\u0026#34;age\u0026#34;,\u0026#34;18\u0026#34;); } 4.2 提取所有的key // 提取所有的key @test void test8() { hashoperations\u0026lt;string, object, object\u0026gt; ops = redistemplate.opsforhash(); // 提取所有的key[field] set\u0026lt;object\u0026gt; user = ops.keys(\u0026#34;user\u0026#34;); system.out.println(user);// username address age } 4.3 提取所有的值 // 提取所有的值 @test void test9() { hashoperations\u0026lt;string, object, object\u0026gt; ops = redistemplate.opsforhash(); // 提取所有的key[field] list\u0026lt;object\u0026gt; user = ops.values(\u0026#34;user\u0026#34;); system.out.println(user); } 4.4 根据key提取值 // 根据key提取值 @test void test10() { hashoperations\u0026lt;string, object, object\u0026gt; ops = redistemplate.opsforhash(); // 提取所有的key[field] string o = (string) ops.get(\u0026#34;user\u0026#34;, \u0026#34;username\u0026#34;); system.out.println(o); } 4.5根据key移除值 // 根据key移除值 @test void test11() { hashoperations\u0026lt;string, object, object\u0026gt; ops = redistemplate.opsforhash(); // 提取所有的key[field] ops.delete(\u0026#34;user\u0026#34;, \u0026#34;username\u0026#34;); } （四）springboot整合redis序列化操作 1 spring提供的序列化器介绍 1.1 spring默认序列化器 redistemplate操作时，默认会采用jdkserializable序列化机制，使得插入的值在redis客户端看来会有乱码，若想解决这一问题，需要手动指定序列化方式。\npublic class redistemplate\u0026lt;k, v\u0026gt; extends redisaccessor implements redisoperations\u0026lt;k, v\u0026gt;, beanclassloaderaware { public void afterpropertiesset() { super.afterpropertiesset(); boolean defaultused = false; if (this.defaultserializer == null) { this.defaultserializer = new jdkserializationredisserializer(this.classloader != null ? this.classloader : this.getclass().getclassloader()); } ... } 1.2 常见的序列化器 2 序列化案例实现 2.1 创建实体实现序列化接口 /** * @author offcn * 实现序列化接口serializable **/ public class account implements serializable { private integer id; private string name; private double money; public integer getid() { return id; } public void setid(integer id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public double getmoney() { return money; } public void setmoney(double money) { this.money = money; } @override public string tostring() { return \u0026#34;account{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, money=\u0026#34; + money + \u0026#39;}\u0026#39;; } } 2.2 在配置类中设置序列化器 /** * 指定自己的redistemplate 模板对象，模板对象设定给了序列化器 * @param redisconnectionfactory * @return 返回值装在在ioc容器当中 */ @bean public redistemplate\u0026lt;string, account\u0026gt; redistemplate(redisconnectionfactory redisconnectionfactory) { redistemplate\u0026lt;string, account\u0026gt; template = new redistemplate(); template.setconnectionfactory(redisconnectionfactory); //创建一个序列化器： jackson2jsonredisserializer serializer = new jackson2jsonredisserializer(account.class); //设置默认的序列化器 template.setdefaultserializer(serializer); return template; } 2.3 测试类对象序列化 @springboottest public class redisdemo02applicationtests { @autowired private redistemplate\u0026lt;string,account\u0026gt; redistemplate; /** * 序列化对象到redis当中 */ @test public void serializableaccount() { account account = new account(); account.setid(1001); account.setname(\u0026#34;张三丰\u0026#34;); account.setid(98765); redistemplate.opsforvalue().set(\u0026#34;account\u0026#34;,account); system.out.println(\u0026#34;序列化成功\u0026#34;); } } 5 springboot整合dubbo （一）启动zookeeper注册中心服务 （二）构建maven工程添加依赖 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zkclient --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.101tec\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;zkclient\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--springboot整合dubbo--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.spring.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; （三）创建服务提供者 1 定义服务接口orderserice /** * @author offcn **/ public interface orderservice { /*** * 查询某个订单对象 */ public order loadordersservice(integer id); /*** * 查询所有订单集合 */ public list\u0026lt;order\u0026gt; loadorderslistservice(); } 2 定义接口orderserice实现类并暴露服务 /** * @author offcn * 注意： @service 注解式dubbo的注解，不是spring的service注解。 **/ @component @service public class orderserviceimpl implements orderservice { @override public order loadordersservice(integer id) { // todo auto-generated method stub order o=new order(); o.setid(id); o.setremark(\u0026#34;备注....\u0026#34;); o.settotal(123); return o; } @override public list\u0026lt;order\u0026gt; loadorderslistservice() { order o=new order(); o.setid(1001); o.setremark(\u0026#34;新疆大盘鸡一份\u0026#34;); o.settotal(12); order o1=new order(); o1.setid(1002); o1.setremark(\u0026#34;东北杀猪菜一份\u0026#34;); o1.settotal(123); list\u0026lt;order\u0026gt; results=new arraylist\u0026lt;order\u0026gt;(); results.add(o); results.add(o1); return results; } } 3 配置application.properties整合dubbo #dubbo的配置 spring.dubbo.application.name=provider-order spring.dubbo.registry.address=zookeeper://192.168.126.10:2181 spring.dubbo.scan=com.offcn.service.impl spring.dubbo.protocol.name=dubbo server.port=8088 4 创建启动类并启动服务 @springbootapplication @enabledubboconfiguration public class demoprovederapplication { public static void main(string[] args) { springapplication.run(demoprovederapplication.class, args); } } （四）创建服务器消费者 1 环境准备 创建boot工程， 引入相关依赖\n\u0026lt;!-- zkclient --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.101tec\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;zkclient\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--springboot整合dubbo--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba.spring.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 2 定义消费端业务接口orderservice \u0026amp; pojo 【copy】 public interface orderservice { /*** * 查询某个订单对象 */ public order loadordersservice(integer id); /*** * 查询所有订单集合 */ public list\u0026lt;order\u0026gt; loadorderslistservice(); } 3 定义消费端ordercontroller @controller public class ordercontroller { // @autowired spring容器当中自动装配 @reference//dubbo容器当中获得一个远程对象，注入。 private orderservice orderservice; @requestmapping(\u0026#34;findbyid\u0026#34;) @responsebody public order findbyid(integer id){ order order = orderservice.loadordersservice(id); return order; } @requestmapping(\u0026#34;findall\u0026#34;) @responsebody public list\u0026lt;order\u0026gt; findall(integer id){ return orderservice.loadorderslistservice(); } } 4 配置application.yml整合dubbo spring.dubbo.application.name=consumer spring.dubbo.registry.address=zookeeper://192.168.126.10:2181 spring.dubbo.scan=com.offcn.controller spring.dubbo.protocol.name=dubbo server.context-path=/ server.port=9090 5 创建启动类并启动服务 @springbootapplication @enabledubboconfiguration public class demoprovederapplication { public static void main(string[] args) { springapplication.run(demoprovederapplication.class, args); } } （五）启动浏览器进行测试 ","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220526213257/","summary":"1 thymeleaf模板解析 （一）模板引擎概述 thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP， Velocity，Fre","title":"spring-boot-2"},{"content":"springmvc第一天 一、springmvc的基本概念（了解） （一）三层架构和mvc 1、三层架构概述 我们的开发架构一般都是基于两种形式，一种是 c/s 架构，也就是客户端/服务器，另一种是 b/s 架构，也就是浏览器服务器。在 javaee 开发中，几乎全都是基于 browser/s 架构的开发。那么在 b/s 架构中，系统标准的三层架构 包括：表现层（web）、业务层（service）、持久层（dao）。三层架构在我们的实际开发中使用的非常多，所以我们课程中的案例也都是基于三层架构设计的。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： （1）表现层（表示层，web）：也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。\t（2）业务层：也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。\t（3）持久层（dao data access object）：也就是我们是常说的 dao 层。负责数据持久化，和数据库做交互。 （二）springmvc 概述 1、springmvc是什么？ springmvc是一个基于java的实现了mvc设计模式的请求驱动类型的轻量级web框架，通过把model，view，controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。 model： 模型 bean pojo controller： servlet 充当了控制器 view： 试图~ 百科介绍： spring mvc属于springframework的后续产品，已经融合在spring web flow里面。spring 框架提供了构建 web 应用程序的全功能 mvc 模块。使用 spring 可插入的 mvc 架构，从而在使用spring进行web开发时，可以选择使用spring的spring mvc框架或集成其他mvc开发框架，如struts1(现在一般不用)，struts 2(一般老项目使用)等等。 总结： springmvc 是应用web层的 基于mvc设计模式的轻量级的web框架。 对servlet封装，支持restful风格。 官网： https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#spring-web 2、springmvc在三层架构中的位置？ springmvc位于三层架构中的表现层，作用是接收请求响应数据，响应的数据通过视图、模板展示给用： 数据访问层： mybatis dbutils jdbctemplate jdbc | mybatis-plus | mapper hibernate jpa 业务层： spring框架： ioc提供对象， 声明式事务~ 表现层： springmvc servlet | struts2（很少） struts1 3、springmvc的优势？ （1）清晰的角色划分： （2）分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 （3）pojo 就可以充当控制器，屏蔽了繁琐的servlet的api （4）和 spring 其他框架无缝集成，是其它 web 框架所不具备的。 （5）可适配，通过 handleradapter 可以支持任意的类作为处理器。 （6）可定制性，handlermapping、viewresolver 等能够非常简单的定制。 （7）功能强大的数据验证、格式化、绑定机制。 ………………还有比如restful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配 置支持等等。 约定优于配置， 配置优于编码~ 二、springmvc入门（实战） （一）springmvc 的入门案例 1、入门案例需求分析 构建页面index.jsp发起请求，在服务器端处理请求，控制台打印处理请求成功，跳转success.jsp成功页面； 2、构建maven项目并添加依赖 注意： maven war 工程打包方式war。 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-webmvc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.2.5.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.2.5.release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 总结： springmvc： webmvc web 3、web.xml中配置核心控制器dispatcherservlet \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc01\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.dispatcherservlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextconfiglocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc01\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 4、配置springmvc的配置文件springmvc.xml \u0026lt;!--扫描注解包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.offcn.controller\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!--处理器映射器：根据请求路径匹配映射路径找到对应的执行器--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.method.annotation.requestmappinghandlermapping\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--处理器适配器：根据处理器映射器返回的执行器对象，去执行执行器对象--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.method.annotation.requestmappinghandleradapter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--视图解析器：解析视图--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.internalresourceviewresolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 5、构建页面发起请求 \u0026lt;a href=\u0026#34;/hello/test1\u0026#34;\u0026gt;hello\u0026lt;/a\u0026gt; 6、编写控制器并使用注解配置 @controller //必须开启注解扫描 @requestmapping(\u0026#34;hello\u0026#34;) public class hellocontroller { @requestmapping(\u0026#34;test1\u0026#34;) public string test1(){ system.out.println(\u0026#34;正在处理请求\u0026#34;); return \u0026#34;main\u0026#34;; } } 7、启动服务器测试 pom.xml文件中服务器插件配置： \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.apache.tomcat.maven\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--指定编码格式--\u0026gt; \u0026lt;uriencoding\u0026gt;utf-8\u0026lt;/uriencoding\u0026gt; \u0026lt;!--指定项目启动后的访问路径--\u0026gt; \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt; \u0026lt;!--指定访问端口号--\u0026gt; \u0026lt;port\u0026gt;8888\u0026lt;/port\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; （二）springmvc执行过程及原理分析 1、springmvc的请求响应流程 浏览器发送请求，被dispatcherservlet捕获，dispatcherservlet没有直接处理请求，而是将请求交给handlermapping处理器映射器，处理器映射器根据请求路径去controller控制层中匹配对应的执行器，并将匹配结果返回给dispatcherservlet，由dispacherservlet调用handleradapter处理器适配器来执行控制层执行器方法； 执行器方法执行后的返回结果，由dispatcherservlet交给视图解析器viewresolver来处理，找到对应的结果视图，渲染视图，并将结果响应给浏览器。 http://localhost:8080/xxx/servlet (1)客户端浏览器发出请求， 到达dispatcherservlet前端控制器。 springmvc 框架提供的。 (2)dispatcherservlet 将请求交给了 处理器映射器，进行路径映射。映射结果交给前端控制器。 (3)请求到达处理器适配器，可以进行数据类型的转换等操作，最后达到handler。【后端处理器，自定义的 servlet】 (4)后端处理器处理完毕之后， 将结果经过处理器适配器最终交给 前端控制器。 (5)经过视图解析器： 数据解析到 view 对象当中。 交给了前端控制器 (6)前端控制器将view对象 交给模板引擎，进行试图渲染。 最终生成静态页面，响应给用户。 以下组件： 一个中心是三个基本点： 不需要自己开发，springmvc提供的 一个中心： dispatcherservlet 三个基本点： 处理器映射器 处理器适配器 试图解析器 handler后端处理器：程序员自己开发~ https://www.pianshen.com/article/72582080569/\n（三）springmvc常用组件介绍 1、dispatcherservlet：前端控制器 用户请求到达前端控制器，它就相当于 mvc 模式中的 controller，dispatcherservlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherservlet 的存在降低了组件之间的耦合性。 dispatcherservlet本质上就是servlet web.xml当中。 该组件是springmvc 提供的， 无所编写，只需配制。 2、handlermapping：处理器映射器 handlermapping 负责根据用户请求找到 handler 即处理器，springmvc提供了不同的映射器实现不同的映射方式： 该组件： springmvc提供的。 无需编写 3、handler：后端处理器【自定义的，类似于servlet】 它就是我们开发中要编写的具体业务控制器。由 dispatcherservlet 把用户请求转发到 handler。由handler 对具体的用户请求进行处理。 等价于之前编写的servlet。后端逻辑处理 【程序员编写】 4、handladapter：处理器适配器 通过 handleradapter 对处理器进行执行， 适配器主要进行数据类型类转换等操作~ 该组件： 无需编写， 只需配置~ 5、view resolver：视图解析器 view resolver 负责将处理结果（modelandview）生成 view 对象，将view对象返回给前端控制器。 注意： 组件springmvc提供的， 如果不使用，可以不用配置。 如果要使用，自行配置试图解析器~ 6、view：视图渲染 springmvc 框架提供了很多的 view 视图类型的支持，包括：jsp、freemarkerview、pdfview，freemark ，thymeleaf 等。我们最常用的视图就是 jsp。之后的学习， 我们会学习静态模板技术~ view对象的数据渲染到页面上。 总结： springmvc 基于组件开发： dispatcherservlet： 一个中心 三个基本点： 处理器映射器： 处理器适配器： 试图解析器： 后端处理器： 类似与servlet， 程序员自定义。 7、mvc:annotation-driven标签说明： 在 springmvc 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 springmvc 的三大组件。使用 \u0026lt;mvc:annotation-driven\u0026gt; 自动加载 requestmappinghandlermapping（处理映射器）和requestmappinghandleradapter （ 处 理 适 配 器 ），可 用 在 springmvc.xml 配 置 文 件 中 使 用\u0026lt;mvc:annotation-driven\u0026gt;替代处理映射器和适配器的配置（一般开发中都需要该标签）。注意：我们只需要编写处理具体业务的控制器以及视图。 \u0026lt;mvc:annotation-driven\u0026gt; 标签相当于以下配置： \u0026lt;!-- handlermapping处理器映射器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.method.annotation.requestmappinghandlerm apping\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.beannameurlhandlermapping\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!-- handleradapter处理器适配器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.method.annotation.requestmappinghandlera dapter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.httprequesthandleradapter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.simplecontrollerhandleradapter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!-- hadnlerexceptionresolvers异常处理器 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.method.annotation.exceptionhandlerexcept ionresolver\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.annotation.responsestatusexceptionresolv er\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.mvc.support.defaulthandlerexceptionresolver\u0026#34; \u0026gt;\u0026lt;/bean\u0026gt; 三、springmvc中的请求参数绑定【重点】 （一）绑定说明 1、绑定的机制 我们都知道，表单中请求参数都是基于 key=value 的。springmvc绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。 获得前端页面提交的参数： request.getparameter(\u0026#34;username\u0026#34;); string [] values = request.getparametervalues(\u0026#34;hobby\u0026#34;); request.getparametermap(); =\u0026gt; map集合 2、支持的数据类型 简单类型参数：包括基本类型和 string 类型 pojo 类型参数：包括实体类，以及关联的实体类 数组和集合类型参数：包括 list 结构和 map 结构的集合（包括数组） 3、使用要求： 如果是基本类型或者 string 类型：要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写) 如果是 pojo 类型，或者它的关联对象：要求表单中参数名称和 pojo 类的属性名称保持一致。并且控制器方法的参数类型是 pojo 类型。 如果是集合类型,有两种方式： （1）第一种：要求集合类型的请求参数必须在 pojo 中。在表单中请求参数名称要和 pojo 中集合属性名称相同。给 list 集合中的元素赋值，使用下标。给 map 集合中的元素赋值，使用键值对。 （2）第二种：接收的请求参数是 json 格式数据。需要借助一个注解实现。 @requestbody注解 （二）参数绑定示例 1、基本类型和 string 类型作为参数 （1）页面定义请求： \u0026lt;form action=\u0026#34;/hello/test2\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 用户名：\u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 年龄：\u0026lt;input name=\u0026#34;age\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; （2）执行器方法绑定参数： @requestmapping(\u0026#34;test2\u0026#34;) public string test2(string username,int age){ system.out.println(\u0026#34;用户名：\u0026#34;+username); system.out.println(\u0026#34;年龄：\u0026#34;+age); return \u0026#34;main\u0026#34;; } 注意： 参数提交的名称和方法形式参数的名称保持一致。 否则封装失败~ ，并且能够进行数据类型的转换。 2、pojo 类型作为参数 （1）页面定义请求： \u0026lt;form action=\u0026#34;/hello/test3\u0026#34; \u0026gt; 用户名：\u0026lt;input name=\u0026#34;pname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 年龄：\u0026lt;input name=\u0026#34;age\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 车名称：\u0026lt;input name=\u0026#34;car.cname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 车价格：\u0026lt;input name=\u0026#34;car.cprice\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; （2）执行器方法绑定参数： @requestmapping(\u0026#34;test3\u0026#34;) public string test3(person person){ system.out.println(person); return \u0026#34;main\u0026#34;; } 3、pojo 类中包含集合类型参数（了解） 集合类型，不能直接绑定在方法的形式参数上。 （1）页面定义请求： \u0026lt;form action=\u0026#34;/hello/test4\u0026#34; \u0026gt; 用户名：\u0026lt;input name=\u0026#34;pname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 年龄：\u0026lt;input name=\u0026#34;age\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 车名称：\u0026lt;input name=\u0026#34;car.cname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 车价格：\u0026lt;input name=\u0026#34;car.cprice\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; list集合车1：车名称\u0026lt;input name=\u0026#34;carlist[0].cname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; list集合车1：车价格\u0026lt;input name=\u0026#34;carlist[0].cprice\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; list集合车2：车名称\u0026lt;input name=\u0026#34;carlist[1].cname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; list集合车2：车价格\u0026lt;input name=\u0026#34;carlist[1].cprice\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; set集合车1：车名称\u0026lt;input name=\u0026#34;carset[0].cname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; set集合车1：车价格\u0026lt;input name=\u0026#34;carset[0].cprice\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; set集合车2：车名称\u0026lt;input name=\u0026#34;carset[1].cname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; set集合车2：车价格\u0026lt;input name=\u0026#34;carset[1].cprice\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; map集合车1：车名称\u0026lt;input name=\u0026#34;map[\u0026#39;x\u0026#39;].cname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; map集合车1：车价格\u0026lt;input name=\u0026#34;map[\u0026#39;x\u0026#39;].cprice\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; map集合车2：车名称\u0026lt;input name=\u0026#34;map[\u0026#39;y\u0026#39;].cname\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; map集合车2：车价格\u0026lt;input name=\u0026#34;map[\u0026#39;y\u0026#39;].cprice\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; （2）执行器方法绑定参数： @requestmapping(\u0026#34;test4\u0026#34;) public string test4(person person){ system.out.println(person); return \u0026#34;main\u0026#34;; } 注意： set集合：---【了解】 （1）set集合必须创建 ：new hashset\u0026lt;\u0026gt;(); （2）set集合提供set 和get 方法 （3）在构造器当中明确set集合当中添加的元素个数 4、数组类型参数（重点） （1）页面定义请求： \u0026lt;form action=\u0026#34;/hello/test5\u0026#34; \u0026gt; 爱好1：\u0026lt;input name=\u0026#34;hobbies\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 爱好2：\u0026lt;input name=\u0026#34;hobbies\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 爱好3：\u0026lt;input name=\u0026#34;hobbies\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; （2）执行器方法绑定参数： @requestmapping(\u0026#34;test5\u0026#34;) public string test5(string[] hobbies){ for(string hobby:hobbies){ system.out.println(hobby); } return \u0026#34;main\u0026#34;; } 5、使用 servletapi 对象作为方法参数 （1）引入servletapi的依赖jar包：（注意jar包作用范围provided:不参与项目部署） \u0026lt;!--web: servlet ,jsp, jstl --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;javax.servlet\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;javax.servlet-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;javax.servlet\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jsp-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;jstl\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jstl\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; （2）执行器方法绑定参数： @requestmapping(\u0026#34;test6\u0026#34;) public void test6(httpservletrequest request, httpservletresponse response,httpsession session) throws servletexception, ioexception { system.out.println(\u0026#34;我在请求转发\u0026#34;); request.getrequestdispatcher(\u0026#34;/hello/test1\u0026#34;).forward(request,response); } 6、请求参数乱码问题 tomacat 对 get 和 post 请求处理方式是不同的： （1）get 请求的编码问题，要改 tomcat 的 server.xml配置文件：【了解】 \u0026lt;!--在实际开发当中， 不允许使用，第一：无权限修改 第二：其对他用户造成影响--\u0026gt; \u0026lt;connector connectiontimeout=\u0026#34;20000\u0026#34; port=\u0026#34;8080\u0026#34;protocol=\u0026#34;http/1.1\u0026#34; redirectport=\u0026#34;8443\u0026#34; uriencoding=\u0026#34;utf-8\u0026#34;/\u0026gt; 使用的方式： 在配置tomcat插件的时候，指定一个tomcat字符集编码。 \u0026lt;uriencoding\u0026gt;utf-8\u0026lt;/uriencoding\u0026gt; （2）post 请求的编码问题，要在web.xml文件中配置编码过滤器： \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;characterencodingfilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.characterencodingfilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;characterencodingfilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 7、静态资源访问： （1）将静态资源交给默认的defaultservlet处理：在springmvc.xml配置文件中加如下配置： \u0026lt;mvc:default-servlet-handler\u0026gt;\u0026lt;/mvc:default-servlet-handler\u0026gt; （2）指定静态资源的访问路径：在springmvc.xml配置文件中加如下配置： \u0026lt;mvc:resources location=\u0026#34;/css/\u0026#34; mapping=\u0026#34;/css/**\u0026#34;/\u0026gt; \u0026lt;mvc:resources location=\u0026#34;/images/\u0026#34; mapping=\u0026#34;/images/**\u0026#34;/\u0026gt; \u0026lt;mvc:resources location=\u0026#34;/js/\u0026#34; mapping=\u0026#34;/js/**\u0026#34;/\u0026gt; （三）自定义参数类型转换器 1、使用场景： springmvc不能自动识别参数转换为我们需要的数据类型，浏览器报400错误，类型转换异常； 默认支持的类型： yyyy/mm/dd 如果需要使用自定义的类型：此时就需要类型转换器 开发步骤： （1）开发一个类型转换器 implements converter\u0026lt;string, date\u0026gt; （2）将自定义的类型转换器配置在工厂当中： （3）在注解当中引用工厂： \u0026lt;mvc:annotation-driven conversion-service=\u0026#34;servicefactorybean\u0026#34; /\u0026gt; 2、使用步骤： （1）定义类型转换器； public class mydateconverter implements converter\u0026lt;string, date\u0026gt; { @override public date convert(string source) { simpledateformat simpledateformat = new simpledateformat(\u0026#34;yyyy-mm-dd\u0026#34;); date date = null; try { date=simpledateformat.parse(source); } catch (parseexception e) { e.printstacktrace(); } return date; } } （2）配置类型转换器； \u0026lt;bean id=\u0026#34;formattingconversionservice\u0026#34; class=\u0026#34;org.springframework.format.support.formattingconversionservicefactorybean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;converters\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.offcn.util.mydateconverter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; （3）引用类型转换器；\t引用自定义的类型转换器： \u0026lt;mvc:annotation-driven conversion-service=\u0026#34;servicefactorybean\u0026#34; /\u0026gt; \u0026lt;form action=\u0026#34;/hello/test7\u0026#34; \u0026gt; 入职日期：\u0026lt;input name=\u0026#34;hiredate\u0026#34; type=\u0026#34;date\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; @requestmapping(\u0026#34;test7\u0026#34;) public string test7(date hiredate){ system.out.println(hiredate); return \u0026#34;main\u0026#34;; } （四）参数绑定默认类型 参数绑定：默认类型：map\u0026lt;string,object\u0026gt; modelandview model modelmap 类型，能够给前台传递。\n@requestmapping(path=\u0026#34;hello01\u0026#34;) public modelandview modelandview(user user, map\u0026lt;string,string\u0026gt; map){ system.out.println(user); modelandview mav = new modelandview(); map.put(\u0026#34;username\u0026#34;,user.getusername()); mav.setviewname(\u0026#34;success\u0026#34;); return mav; } @requestmapping(path=\u0026#34;hello01\u0026#34;) public modelandview modelandview(user user, modelmap model){ system.out.println(user); modelandview mav = new modelandview(); model.addattribute(\u0026#34;username\u0026#34;,user.getusername()); mav.setviewname(\u0026#34;success\u0026#34;); return mav; } @requestmapping(\u0026#34;findbyid\u0026#34;) public modelandview findbyid(integer id, model model){ person person = new person(); person.setage(29); person.setname(\u0026#34;许~\u0026#34;); person.setbirthday(new date()); //视图路径的跳转： modelandview modelandview = new modelandview(); modelandview.setviewname(\u0026#34;success\u0026#34;); //存在model当中： 传递给前台： model.addattribute(\u0026#34;person\u0026#34;,person); return modelandview; } 四、springmvc的注解详解 （0）requestmapping注解 0、requestmapping 注解 用于定义映射路径，建立请求url和控制层方法之间的对应关系； （1）注解位置： a.类上：定义一级映射路径； b.方法上：定义二级映射路径； （2）注解属性：\tvalue：用于指定映射路径url。它和 path 属性的作用是一样的。 method：用于指定请求的方式。method = {requestmethod.post } 只能处理post请求。 状态码405 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。eg:params = {\u0026#34;username\u0026#34;}，表示请求参数必须有 username; 如果没有携带username的参数：前端浏览器400 bad request ​\n（一）requestparam 1、requestparam注解介绍 使用在方法入参位置，用于指定请求参数名称，将该请求参数绑定到注解参数位置。 属性：name:指定要绑定的请求参数名称； required：指定请求参数是否必传； true：表明必须提交参数， 没有400 defaultvalue：指定当没有传入请求参数时的默认取值； 2、requestparam注解使用案例 @requestmapping(\u0026#34;test1\u0026#34;) public string test1(@requestparam(name = \u0026#34;pname\u0026#34;,required = true,defaultvalue = \u0026#34;李四\u0026#34;)string name){ system.out.println(name); return \u0026#34;main\u0026#34;; } 3、requestparam注解测试结果 详见课堂案例结果 （二）requestheader 1、requestheader注解介绍 注解在方法入参位置，用于获取请求头信息。 2、requestheader注解使用案例 value：指定头的名称； require：是否是必须， true，必须传递， 没传递。400 defaultvalue： 如果前台没传递头信息， 指定默认值。 require冲突。 @requestmapping(\u0026#34;test2\u0026#34;) public string test2(@requestheader(\u0026#34;upgrade-insecure-requests\u0026#34;)string data){ system.out.println(data); return \u0026#34;main\u0026#34;; } 3、requestheader注解测试结果 详见课堂案例结果 （三）requestbody 1、requestbody注解介绍 用于方法入参位置，获取请求体内容。直接使用得到是 key=value\u0026amp;key=value...结构的数据。get 请求方式不适用。通常用于将json格式字符串绑定到bean对象中； 2、requestbody注解使用案例 （1）直接获取请求体内容： \u0026lt;form action=\u0026#34;/annotation/test3\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 用户名：\u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 年龄：\u0026lt;input name=\u0026#34;age\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; @requestmapping(\u0026#34;test3\u0026#34;) public string test3(@requestbody string data){ system.out.println(data); return \u0026#34;main\u0026#34;; } （2）将json格式请求参数绑定到指定对象bean中： \u0026lt;button onclick=\u0026#34;sendcar()\u0026#34;\u0026gt;发起ajax请求\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function sendcar() { $.ajax({ type: \u0026#34;post\u0026#34;, url: \u0026#34;/annotation/test4\u0026#34;, data: \u0026#39;{\u0026#34;cname\u0026#34;:\u0026#34;宝马\u0026#34;,\u0026#34;cprice\u0026#34;:\u0026#34;20\u0026#34;}\u0026#39;, contenttype:\u0026#34;application/json\u0026#34;, success: function(msg){ alert( \u0026#34;data saved: \u0026#34; + msg ); } }); } \u0026lt;/script\u0026gt; @requestmapping(\u0026#34;test4\u0026#34;) public string test4(@requestbody car car){ system.out.println(car); return \u0026#34;main\u0026#34;; } 注意： 使用json 需要引入json的解析器~ \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jackson-databind\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.9.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 3、requestbody注解测试结果 详见课堂案例结果 （四）cookievalue 1、cookievalue注解介绍 用于方法入参位置，把指定 cookie 名称的值传入控制器方法参数。 2、cookievalue注解使用案例 //1 : 获得所有的cookie //2: cookie //3 getname(\u0026#34;jsessionid\u0026#34;) -value @requestmapping(\u0026#34;test5\u0026#34;) public string test5(@cookievalue(\u0026#34;jsessionid\u0026#34;) string data){ system.out.println(data); return \u0026#34;main\u0026#34;; } //通过@cookievalue 获得cookie对象 @requestmapping(\u0026#34;cookie2\u0026#34;) public modelandview cookie2(integer id, @cookievalue(\u0026#34;jsessionid\u0026#34;) cookie cookie) { system.out.println(\u0026#34;cookie:\u0026#34;+cookie); //cookie 的api信息~ modelandview modelandview = new modelandview(); modelandview.setviewname(\u0026#34;success\u0026#34;); return modelandview; } 3、cookievalue注解测试结果 详见课堂案例结果 （五）modelattribute 1、modelattribute注解介绍 该注解是springmvc4.3版本以后新加入的。它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。 2、modelattribute注解使用案例 （1）注解在方法上： @modelattribute(\u0026#34;shareparam\u0026#34;) public string test6(){ system.out.println(\u0026#34;我是公共方法\u0026#34;); return \u0026#34;公共参数\u0026#34;; } （2）注解在参数位置： @requestmapping(\u0026#34;test7\u0026#34;) public string test7(@modelattribute(\u0026#34;shareparam\u0026#34;)string data){ system.out.println(data); return \u0026#34;main\u0026#34;; } 3、modelattribute注解测试结果 详见课堂案例结果 （六）sessionattributes 1、sessionattributes注解介绍 注解在类上，作用将请求域中的参数存放到session域中，用于参数共享。 2、sessionattributes注解使用案例 //将参数存放到请求域 @requestmapping(\u0026#34;test8\u0026#34;) public modelandview test8(modelandview modelandview){ modelandview.addobject(\u0026#34;aa\u0026#34;,\u0026#34;aa1\u0026#34;); modelandview.addobject(\u0026#34;bb\u0026#34;,\u0026#34;bb1\u0026#34;); modelandview.addobject(\u0026#34;cc\u0026#34;,\u0026#34;cc1\u0026#34;); modelandview.setviewname(\u0026#34;main\u0026#34;); return modelandview; } //将请求域参数存放到session域中 @controller @requestmapping(\u0026#34;annotation\u0026#34;) @sessionattributes(value = {\u0026#34;aa\u0026#34;,\u0026#34;bb\u0026#34;}) public class annotationcontroller { ... } 3、sessionattributes注解测试结果 详见课堂案例结果 springmvc第二天 springmvc： web层的轻量级框架， servlet\nspringmvc的执行流程： 图\nspringmvc的入门案例：\n参数的绑定：\na： 获得前段页面的参数。\nb： 原生servletapi\nc： 绑定一些默认类型：map model modelmap 向前台传递值。\nspringmvc常用的注解：\n一、rest风格编程 （一）rest风格url规范介绍 1、什么是restful? restful架构，就是目前最流行的一种互联网软件架构风格，并不是开发规范。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。rest这个词，是roy thomas fielding在他2000年的博士论文中提出的. fielding将他对互联网软件的架构原则，定名为rest，即representational state transfer的缩写。即\u0026#34;表现层状态转化\u0026#34;。如果一个架构符合rest原则，就称它为restful架构。值得注意的是 rest 并没有一个明确的标准，而更像是一种设计的风格。 它本身并没有什么实用性，其核心价值在于如何设计出符合 rest 风格的网络接口。 2、restful的优点： 它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 3、restful 的特性【体现】 （1）资源（resources）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 uri（统一资源定位符）指向它，每种资源对应一个特定的 uri 。要获取这个资源，访问它的 uri 就可以，因此 uri 即为每一个资源的独一无二的识别符。 （2）表现层（representation）：把资源具体呈现出来的形式，叫做它的表现层 （representation）。比如，文本可以用 txt 格式表现，也可以用 html 格式、xml 格式、json 格式表现，甚至可以采用二进制格式。 （3）状态转化（state transfer）：每发出一个请求，就代表了客户端和服务器的一次交互过程。http 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”（state transfer）。而这种转化是建立在表现层之上的，所以就是“表现层状态转化”。具体说，就是 http 协议里面，四个表示操作方式的动词：get 、post 、put、delete。它们分别对应四种基本操作：get 用来获取资源，post 用来新建资源，put 用来更新资源，delete 用来删除资源。 （4）传统请求url: 新增：http://localhost:8888/annotation/addperson post 修改：http://localhost:8888/annotation/updateperson post 删除：http://localhost:8888/annotation/deleteperson?id=1 get 查询：http://localhost:8888/annotation/findperson?id=1 get （4）rest风格请求： 新增：http://localhost:8888/annotation/person post 修改：http://localhost:8888/annotation/person put 删除：http://localhost:8888/annotation/person/1 delete 查询：http://localhost:8888/annotation/person/1 get 2： 传递的参数可以作为url地址的一部分。 http://localhost:8888/annotation/person/1 （二）pathvariable注解【重要】 该注解用于绑定 url 中的占位符。例如：请求 url 中/annotation/test9/{id}，这个{id}就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是springmvc 支持 rest 风格 url 的一个重要标志。 属性： value：用于指定 url 中占位符名称。 required：是否必须提供占位符。 localhost:8080/hello3/250 url: /** * 获得url地址当中的变量值： * @param modelandview * @param id * @return */ @requestmapping(\u0026#34;hello3/{xx}\u0026#34;) public modelandview hello3(modelandview modelandview, @pathvariable(value = \u0026#34;xx\u0026#34;,required = false) integer id){ system.out.println(\u0026#34;id:\u0026#34;+id); //模型数据： modelandview.addobject(\u0026#34;key1\u0026#34;,\u0026#34;value1\u0026#34;);//request.attribute() //视图数据： modelandview.setviewname(\u0026#34;success\u0026#34;); return modelandview; } （三）pathvariable案例 1、构建页面发起请求 rest风格编程： 新增： \u0026lt;form action=\u0026#34;/annotation/person\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 用户名：\u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 年龄：\u0026lt;input name=\u0026#34;age\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 修改： \u0026lt;form action=\u0026#34;/annotation/person\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;put\u0026#34;\u0026gt; 用户名：\u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; 年龄：\u0026lt;input name=\u0026#34;age\u0026#34; type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 删除： \u0026lt;form action=\u0026#34;/annotation/person/1\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;delete\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 查询： \u0026lt;a href=\u0026#34;/annotation/person/1\u0026#34;\u0026gt;查询用户\u0026lt;/a\u0026gt; 2、定义控制层执行器处理请求 @requestmapping(value = \u0026#34;person\u0026#34;,method = requestmethod.post) @getting(\u0026#34;/person\u0026#34;) public string addperson(string username,int age){ system.out.println(\u0026#34;新增用户：\u0026#34;+username); return \u0026#34;main\u0026#34;; } @requestmapping(value = \u0026#34;person\u0026#34;,method = requestmethod.put) public string updateperson(string username,int age){ system.out.println(\u0026#34;修改用户：\u0026#34;+username); return \u0026#34;main\u0026#34;; } @requestmapping(value = \u0026#34;person/{id}\u0026#34;,method = requestmethod.delete) public string deleteperson(@pathvariable(value = \u0026#34;id\u0026#34;)int id){ system.out.println(\u0026#34;删除用户：id\u0026#34;+id); return \u0026#34;main\u0026#34;; } @requestmapping(value = \u0026#34;person/{id}\u0026#34;,method = requestmethod.get) public string findperson(@pathvariable(value = \u0026#34;id\u0026#34;)int id){ system.out.println(\u0026#34;查询用户信息：id\u0026#34;+id); return \u0026#34;main\u0026#34;; } 3.引入请求方式转换过滤器 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;hiddenmethodfilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.hiddenhttpmethodfilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;hiddenmethodfilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 二、响应数据和结果视图 （一）返回值分类 1、返回值为字符串 用于指定返回的逻辑视图名称； 控制器代码： @requestmapping(\u0026#34;test1\u0026#34;) public string test1(string pname){ system.out.println(pname); system.out.println(\u0026#34;返回string类型测试\u0026#34;); return \u0026#34;main\u0026#34;; } 运行结果：详见课堂案例结果 2、void类型 /** * 方法的返回值void： * （1） 默认情况下， void也会进行路径的跳转。 * 跳转位置： 经过视图解析器 + 访问位置 寻找对应的页面。 * * （2）void 的应用场景： * a:字符流或者是字节流向客户端浏览器异步返回数据。 * b：使用原生servlet进行 页面的转换或者是重定向时候， 可以使用void类型。 */ @requestmapping(\u0026#34;/void\u0026#34;) public void voidtest(httpservletrequest request,httpservletresponse response){ system.out.println(\u0026#34;void方法被执行了~\u0026#34;); // response.getwriter().println(\u0026#34;xxx\u0026#34;); // request.getrequestdispatcher().forward(); // response.sendredirect(); }\t3、modelandview 用于绑定参数和指定返回视图名称； 控制器代码： @requestmapping(\u0026#34;test3\u0026#34;) public modelandview test3(modelandview modelandview){ modelandview.addobject(\u0026#34;aa\u0026#34;,\u0026#34;aa1\u0026#34;); modelandview.setviewname(\u0026#34;main\u0026#34;); return modelandview; } modelandview 对象： 封装模型数据 封装视图数据。 注意:对象是springmvc底层对象，使用很少~ 4： 自定义类型【重要】 @getmapping(\u0026#34;getdata\u0026#34;) @responsebody//引入依赖包： public string getdate1(){ return \u0026#34;ok\u0026#34;; } @getmapping(\u0026#34;getdata2\u0026#34;) @responsebody//引入依赖包： public person getdata2(){ person person = new person(); person.setid(1001); person.setname(\u0026#34;许8\u0026#34;); return person;//异步返回数据：{\u0026#34;id\u0026#34;:1001,\u0026#34;name\u0026#34;:\u0026#34;许8\u0026#34;} } @getmapping(\u0026#34;getdata3\u0026#34;) @responsebody//引入依赖包： public list\u0026lt;person\u0026gt; getdata3(){ list\u0026lt;person\u0026gt; list = new arraylist\u0026lt;\u0026gt;(); person person = new person(); person.setid(1001); person.setname(\u0026#34;许8\u0026#34;); person person2 = new person(); person2.setid(1002); person2.setname(\u0026#34;康7\u0026#34;); person person3 = new person(); person3.setid(1003); person3.setname(\u0026#34;夏66\u0026#34;); list.add(person); list.add(person2); list.add(person3); return list;//异步返回数据：[{\u0026#34;id\u0026#34;:1001,\u0026#34;name\u0026#34;:\u0026#34;许8\u0026#34;},{},{}] } @getmapping(\u0026#34;getdata4\u0026#34;) @responsebody//引入依赖包： public map\u0026lt;string,person\u0026gt; getdata4(){// map\u0026lt;string,person\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); person person = new person(); person.setid(1001); person.setname(\u0026#34;许8\u0026#34;); person person2 = new person(); person2.setid(1002); person2.setname(\u0026#34;康7\u0026#34;); person person3 = new person(); person3.setid(1003); person3.setname(\u0026#34;夏66\u0026#34;); map.put(\u0026#34;person1\u0026#34;,person); map.put(\u0026#34;person2\u0026#34;,person2); map.put(\u0026#34;person3\u0026#34;,person3); return map;//异步返回数据：{person1:{},person2:{}} } 注意： 使用@responsebody 必须引入jackson-databind json解析器。 （二）转发和重定向 1、forward请求转发 控制器代码： @requestmapping(\u0026#34;test4\u0026#34;) public string test4(){ system.out.println(\u0026#34;我是请求转发\u0026#34;); return \u0026#34;forward:/response/test1\u0026#34;; } 运行结果：详见课堂案例结果\t2、redirect重定向 控制器代码： @requestmapping(\u0026#34;test5\u0026#34;) public string test5(redirectattributes redirectattributes,string pname){ system.out.println(\u0026#34;我是重定向\u0026#34;); // redirectattributes.addattribute(\u0026#34;pname\u0026#34;,pname); redirectattributes.addflashattribute(\u0026#34;pname\u0026#34;,pname); return \u0026#34;redirect:/response/test1\u0026#34;; } 运行结果：详见课堂案例结果 //注意：重定向携带参数，需要使用对象redirectattributes，该对象提供两个方法封装参数addattribute()和addflashattribute()，第一个方法参数会明文显示在浏览器地址栏，第二个方法参会会隐藏，使用第二种方法传参时，获取参数时需要加注解@modelattribute; 三、postman工具使用 （一）postman工具介绍 用户在开发或者调试网络程序或者是网页b/s模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的firebug等网页调试工具。今天给大家介绍的这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的http请求！postman在发送网络http请求方面可以说是chrome插件类产品中的代表产品之一。 （二）postman工具的下载安装 1、下载地址：https://www.postman.com/downloads/ 2、安装步骤： （1）下载安装文件 （2）运行安装程序 （3）重启电脑自动安装 （4）运行 （三）postman工具的使用 四、springmvc中的父子容器解析 （一）springmvc中的父子容器解析 spring和springmvc的容器具有父子关系，spring容器为父容器，springmvc为子容器，子容器可以引用父容器中的bean，而父容器不可以引用子容器中的bean。 配置spring的配置文件时，排出扫描控制层注解： \u0026lt;context:component-scan base-package=\u0026#34;com.offcn\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.controller\u0026#34;/\u0026gt; \u0026lt;/context:component-scan\u0026gt; 配置springmvc的配置文件时，扫描控制层注解： \u0026lt;context:component-scan base-package=\u0026#34;com.offcn.controller\u0026#34;\u0026gt; \u0026lt;context:include-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.controller\u0026#34;/\u0026gt; \u0026lt;/context:component-scan\u0026gt; 五、springmvc中的文件上传 （一）文件上传的必要前提： 1、form 表单的 enctype 取值必须是：multipart/form-data(默认值是:application/x-www-form-urlencoded)enctype:是表单请求正文的类型 2、 method 属性取值必须是 post 3、提供一个文件选择域\u0026lt;input type=”file”/\u0026gt; （二）文件上传原理分析 当 form 表单的 enctype 取值不是默认值后，request.getparameter()将失效。 enctype=”application/x-www-form-urlencoded”时，form 表单的正文内容是：key=value\u0026amp;key=value\u0026amp;key=value; 当 form 表单的 enctype 取值为 mutilpart/form-data 时，请求正文内容就变成：每一部分都是 mime 类型描述的正文; （三）springmvc的文件上传 1、构建maven工程添加相关依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;commons-fileupload\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;commons-fileupload\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、编写 jsp 页面 \u0026lt;form enctype=\u0026#34;multipart/form-data\u0026#34; method=\u0026#34;post\u0026#34; action=\u0026#34;/file/fileupload\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 3、编写控制器 @requestmapping(\u0026#34;fileupload\u0026#34;) public string fileupload(multipartfile file){ file dest = new file(\u0026#34;c:\\\\users\\\\mwx\\\\pictures\\\\\u0026#34;+file.getoriginalfilename()); //文件上传 try { file.transferto(dest); } catch (ioexception e) { e.printstacktrace(); } return \u0026#34;main\u0026#34;; } 4、配置文件解析器 \u0026lt;bean id=\u0026#34;multipartresolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.commonsmultipartresolver\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 5、测试文件上传的运行结果 详见课堂案例结果 六、springmvc中的异常处理 （一）项目开发中异常处理的方式介绍 系统中异常包括两类：预期异常和运行时异常 runtimeexception，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 （二）异常处理的设计思路 系统的 dao、service、controller 出现都通过 throws exception 向上抛出，最后由 springmvc 前端控制器交由异常处理器进行异常处理。 （三）异常处理的步骤 1、编写异常类和错误页面 @requestmapping(\u0026#34;test2\u0026#34;) public string test2(){ system.out.println(\u0026#34;模拟出现异常\u0026#34;); int i = 10/0; return \u0026#34;main\u0026#34;; } 页面error.jsp详见具体课堂案例； 2、自定义异常处理器 public class myexceptionhandler implements handlerexceptionresolver { @override public modelandview resolveexception(httpservletrequest request, httpservletresponse response, object handler, exception ex) { ex.printstacktrace(); system.out.println(\u0026#34;自定义异常处理\u0026#34;); modelandview modelandview = new modelandview(); modelandview.setviewname(\u0026#34;error\u0026#34;); return modelandview; } } 3、配置异常处理器 \u0026lt;bean class=\u0026#34;com.offcn.util.myexceptionhandler\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 4、测试异常处理的运行结果 详见课堂案例结果 七、springmvc中的拦截器使用 （一）拦截器的介绍和作用 springmvc 的处理器拦截器类似于 servlet 开发中的过滤器 filter，用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。谈到拦截器，还要向大家提一个词——拦截器链（interceptor chain）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 （二）拦截器与过滤器的区别【面试题目】 过滤器： 过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 过滤器在web.xml中的 url-pattern 标签中配置了/*： 可以对所有要访问的资源拦截。 /* html css js 底层实现基于回调函数实现： 拦截器： 拦截器是 springmvc 框架自己的，只有使用了springmvc框架的工程才能用。 拦截器在springmvc.xml当中进行配置： 只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者js是不会进行拦截的： /** aop 思想的具体应用。 （三）自定义拦截器的步骤 1、编写一个普通类实现 handlerinterceptor 接口 public class myintercepter implements handlerinterceptor { /** * 控制层执行器方法前的拦截器 * @param request * @param response * @param handler * @return * @throws exception */ @override public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler) throws exception { system.out.println(\u0026#34;我是控制层执行器方法前的拦截器\u0026#34;); //校验用户是否登录 httpsession session = request.getsession(); string pname=(string)session.getattribute(\u0026#34;pname\u0026#34;); if(pname!=null){ //当前用户已经登录，放行 return true; }else{ //当前用户未登录，拦截跳转到登录页面 request.getrequestdispatcher(\u0026#34;/login.jsp\u0026#34;).forward(request,response); return false; } //返回true表示继续执行控制层执行器方法，返回false表示方法结束，不会执行控制层执行器方法 } /** * 控制层方法返回时拦截器 * @param request * @param response * @param handler * @param modelandview * @throws exception */ @override public void posthandle(httpservletrequest request, httpservletresponse response, object handler, @nullable modelandview modelandview) throws exception { system.out.println(\u0026#34;我是控制层执行器方法返回时拦截器\u0026#34;); } /** * 控制层方法结束后的拦截器 * @param request * @param response * @param handler * @param ex * @throws exception */ @override public void aftercompletion(httpservletrequest request, httpservletresponse response, object handler, @nullable exception ex) throws exception { system.out.println(\u0026#34;我是控制层执行器方法结束后的拦截器\u0026#34;); } } 2、配置拦截器 \u0026lt;!--springmvc配置文件中注册拦截器--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026#34;/file/login\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.offcn.util.myintercepter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 3、测试拦截器的运行结果 详见课堂案例结果 （四）拦截器的注意事项 1、拦截器的放行 拦截器中的放行指的是：如果有下一个拦截器就执行下一个，如果该拦截器处于拦截器链的最后一个，则执行控制器中的方法。 public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler)方法返回true表示继续执行控制层执行器方法，返回false表示方法结束，不会执行控制层执行器方法。 2、拦截器中方法的说明 public class myinterceptor2 implements handlerinterceptor { /** * 控制层执行器方法前的拦截器（该方法时在控制层执行器方法前调用，当该方法返回结果为true则继续调用下一个拦截器，如果已经时最后 * 一个拦截器，则调用控制层中的执行器方法；当该方法返回结果为false，则不会继续执行控制层执行器中的方法） * @param request * @param response * @param handler * @return * @throws exception */ @override public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler) throws exception { system.out.println(\u0026#34;我是控制器方法前拦截器2\u0026#34;); return true; } /** * 控制层方法返回时拦截器（该方法是控制层执行器方法执行之后，由dispatcherservlet在将结果响应给浏览器前调用的方法） * @param request * @param response * @param handler * @param modelandview * @throws exception */ @override public void posthandle(httpservletrequest request, httpservletresponse response, object handler, @nullable modelandview modelandview) throws exception { system.out.println(\u0026#34;我是控制层执行器方法返回时拦截器2\u0026#34;); } /** * 控制层方法结束后的拦截器（该方法在请求业务处理执行完全结束之后由dispatcherservlet调用执行） * @param request * @param response * @param handler * @param ex * @throws exception */ @override public void aftercompletion(httpservletrequest request, httpservletresponse response, object handler, @nullable exception ex) throws exception { system.out.println(\u0026#34;我是控制层执行器方法结束后的拦截器2\u0026#34;); } } 3、拦截器的作用路径 \u0026lt;!--拦截器注册--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt;\u0026lt;!--用于指定拦截的 url--\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026#34;/file/login\u0026#34;/\u0026gt;\u0026lt;!--用于指定排除的 url--\u0026gt; \u0026lt;bean class=\u0026#34;com.offcn.util.myintercepter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 4、多个拦截器的执行顺序 （1）多个拦截器放行的情况： 拦截器1： public class myinterceptor1 implements handlerinterceptor { /** * 控制层执行器方法前的拦截器（该方法时在控制层执行器方法前调用，当该方法返回结果为true则继续调用下一个拦截器，如果已经时最后 * 一个拦截器，则调用控制层中的执行器方法；当该方法返回结果为false，则不会继续执行控制层执行器中的方法） * @param request * @param response * @param handler * @return * @throws exception */ @override public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler) throws exception { system.out.println(\u0026#34;我是控制器方法前拦截器1\u0026#34;); return true; } /** * 控制层方法返回时拦截器（该方法是控制层执行器方法执行之后，由dispatcherservlet在将结果响应给浏览器前调用的方法） * @param request * @param response * @param handler * @param modelandview * @throws exception */ @override public void posthandle(httpservletrequest request, httpservletresponse response, object handler, @nullable modelandview modelandview) throws exception { system.out.println(\u0026#34;我是控制层执行器方法返回时拦截器1\u0026#34;); } /** * 控制层方法结束后的拦截器（该方法在请求业务处理执行完全结束之后由dispatcherservlet调用执行） * @param request * @param response * @param handler * @param ex * @throws exception */ @override public void aftercompletion(httpservletrequest request, httpservletresponse response, object handler, @nullable exception ex) throws exception { system.out.println(\u0026#34;我是控制层执行器方法结束后的拦截器1\u0026#34;); } } 拦截器2： public class myinterceptor2 implements handlerinterceptor { /** * 控制层执行器方法前的拦截器（该方法时在控制层执行器方法前调用，当该方法返回结果为true则继续调用下一个拦截器，如果已经时最后 * 一个拦截器，则调用控制层中的执行器方法；当该方法返回结果为false，则不会继续执行控制层执行器中的方法） * @param request * @param response * @param handler * @return * @throws exception */ @override public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler) throws exception { system.out.println(\u0026#34;我是控制器方法前拦截器2\u0026#34;); return true; } /** * 控制层方法返回时拦截器（该方法是控制层执行器方法执行之后，由dispatcherservlet在将结果响应给浏览器前调用的方法） * @param request * @param response * @param handler * @param modelandview * @throws exception */ @override public void posthandle(httpservletrequest request, httpservletresponse response, object handler, @nullable modelandview modelandview) throws exception { system.out.println(\u0026#34;我是控制层执行器方法返回时拦截器2\u0026#34;); } /** * 控制层方法结束后的拦截器（该方法在请求业务处理执行完全结束之后由dispatcherservlet调用执行） * @param request * @param response * @param handler * @param ex * @throws exception */ @override public void aftercompletion(httpservletrequest request, httpservletresponse response, object handler, @nullable exception ex) throws exception { system.out.println(\u0026#34;我是控制层执行器方法结束后的拦截器2\u0026#34;); } } 执行结果如下： （2）多个拦截器阻断的情况： 第一个拦截器返回true,第二个拦截器返回false时，执行结果如下： 第一个拦截器返回false,第二个拦截器返回true时，执行结果如下： 八、拦截器的简单案例（验证用户是否登录） （一）实现思路分析 1、定义登录页面，并定义请求映射。 2、判断用户名密码是否正确 3、如果正确 向 session 中写入用户信息 4、返回登录成功。 5、拦截用户请求，判断用户是否登录 6、如果用户已经登录。放行 7、如果用户未登录，跳转到登录页面 （二）案例代码 1、登录页面login.jsp定义： \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/file/login\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;pname\u0026#34;\u0026gt; 密码：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;登录\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2、控制器实现： @requestmapping(\u0026#34;login\u0026#34;) public string login(string pname, string password, httpsession session){ system.out.println(\u0026#34;登录校验成功\u0026#34;); //将登录成功的用户名存放到session中 session.setattribute(\u0026#34;pname\u0026#34;,pname); return \u0026#34;main\u0026#34;; } 3、拦截器实现： @override public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler) throws exception { system.out.println(\u0026#34;我是控制层执行器方法前的拦截器\u0026#34;); //校验用户是否登录 httpsession session = request.getsession(); string pname=(string)session.getattribute(\u0026#34;pname\u0026#34;); if(pname!=null){ //当前用户已经登录，放行 return true; }else{ //当前用户未登录，拦截跳转到登录页面 request.getrequestdispatcher(\u0026#34;/login.jsp\u0026#34;).forward(request,response); return false; } //返回true表示继续执行控制层执行器方法，返回false表示方法结束，不会执行控制层执行器方法 } 4、注册拦截器： \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt;\u0026lt;!--用于指定拦截的 url--\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026#34;/file/login\u0026#34;/\u0026gt;\u0026lt;!--用于指定排除的 url--\u0026gt; \u0026lt;bean class=\u0026#34;com.offcn.util.myintercepter\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; spring :\nspringmvc :\nxmind:【选做】 有道云笔记 。\nlinux： 安装， 配置好网络： 静态分配~ 【必须】\n","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220526160511/","summary":"SpringMVC第一天 一、SpringMVC的基本概念（了解） （一）三层架构和MVC 1、三层架构概述 我们的开发架构一般都是基于两种形式，一种是 C/S 架构，也就是客","title":"spring-mvc"},{"content":"一、系统架构演变 随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。\n从单一应用，到垂直拆分，到分布式服务，到soa，以及现在火热的微服务架构。让我们来看一下它们各自的特点：\n1.1 集中式架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(orm)是影响项目开发的关键。\n存在的问题：\n· 代码耦合，开发维护困难\n· 无法针对不同模块进行针对性优化\n· 无法水平扩展\n· 单点容错率低，并发能力差\n1.2 垂直拆分 当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：\n优点：\n· 系统拆分实现了流量分担，解决了并发问题\n· 可以针对不同模块进行优化\n· 方便水平扩展，负载均衡，容错率提高\n缺点：\n· 系统间相互独立，会有很多重复开发工作，影响开发效率\n1.3 分布式服务 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心， 使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。\n优点：\n· 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率\n缺点：\n· 系统间耦合度变高，调用关系错综复杂，难以维护\n1.4 服务治理（soa） 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(soa)是关键\n以前出现了什么问题？\n· 服务越来越多，需要管理每个服务的地址\n· 调用关系错综复杂，难以理清依赖关系\n· 服务过多，服务状态难以管理，无法根据服务情况动态管理\n服务治理要做什么？\n· 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址\n· 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系\n· 动态监控服务状态监控报告，人为控制服务状态\n缺点：\n· 服务间会有依赖关系，一旦某个环节出错会影响较大\n· 服务关系复杂，运维、测试部署困难，不符合devops（开发部署等一体化）思想\n1.5 微服务概述 1.5.1 什么是微服务 目前的微服务并没有一个统一的标准，一般是以业务来划分将传统的一站式应用，拆分成一个个的服务，彻底去耦合，一个微服务就是单功能业务，只做一件事。 1.5.2 微服务与微服务架构 微服务是一种架构模式或者一种架构风格，提倡将单一应用程序划分成一组小的服务独立部署，服务之间相互配合、相互协调，每个服务运行于自己的进程中。\n服务与服务间采用轻量级通讯，如http的restful api等\n避免统一的、集中式的服务管理机制\n1.5.3 微服务的优缺点 优点\n每个服务足够内聚，足够小，比较容易聚焦 开发简单且效率高，一个服务只做一件事情 开发团队小，一般2-5人足以（当然按实际为准） 微服务是松耦合的，无论开发还是部署都可以独立完成 微服务能用不同的语言开发 易于和第三方集成，微服务允许容易且灵活的自动集成部署（持续集成工具有jenkins,hudson,bamboo等） 微服务易于被开发人员理解，修改和维护，这样可以使小团队更加关注自己的工作成果，而无需一定要通过合作才能体现价值 微服务允许你融合最新的技术 微服务只是业务逻辑的代码，不会和html,css或其他界面组件融合。 每个微服务都可以有自己的存储能力，数据库可自有也可以统一，十分灵活。 缺点\n开发人员要处理分布式系统的复杂性 多服务运维难度，随着服务的增加，运维的压力也会增大 依赖系统部署 服务间通讯的成本 数据的一致性 系统集成测试 性能监控的难度 二、远程调用方式 2.1调用方式介绍 无论是微服务还是soa，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？\n常见的远程调用方式有以下几种：\nrpc：remote produce call远程过程调用，类似的还有rmi(remote method invocation，远程方法调用)。自定义数据格式，基于原生tcp通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是rpc的典型\nhttp：http其实是一种网络传输协议，基于tcp，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。现在热门的rest风格，就可以通过http协议来实现。\n2.2 认识rpc 概念解释：\nrpc，即 remote procedure call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。\n说得通俗一点就是：a计算机提供一个服务，b计算机可以像调用本地服务那样调用a计算机的服务。\n作用体现：\n通过上面的概念，我们可以知道，实现rpc主要是做到两点：\n实现远程调用其他计算机的服务\n像调用本地服务一样调用远程服务\n问题思考：\n要实现远程调用，肯定是通过网络传输数据。a程序提供服务，b程序通过网络将请求参数传递给a，a程序接收参数调用本地服务执行后得到结果，再将结果返回给b程序。这里需要关注的有两点：\n1）采用何种网络通讯协议？\n​\t现在比较流行的rpc框架，都会采用tcp作为底层传输协议\n2）数据传输的格式怎样？\n​\t两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。\n如果仅仅是远程调用，还不算是rpc，因为rpc强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。\n所以rpc一定要对调用的过程进行封装\n2.3 认识http 概念解释：\nhttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用tcp协议作为底层传输协议。说到这里，大家可能觉得，http与rpc的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。\nhttp和rpc差别：\n· rpc并没有规定数据传输格式，这个格式可以任意指定，不同的rpc协议，数据格式不一定相同。\n· http中定义了资源定位的路径，rpc中并不需要\n· 最重要的一点：rpc需要满足像调用本地服务一样调用远程服务，也就是对调用过程在api层面进行封装。http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。\n优点：rpc方式更加透明，对用户更方便。http方式更灵活，没有规定api和语言，跨语言、跨平台\n缺点：rpc方式需要在api层面进行封装，限制了开发的语言环境\n例如我们通过浏览器访问网站，就是通过http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。\n2.4 如何选择 既然两种方式都可以实现远程调用，我们该如何选择呢？\n· 速度来看，rpc要比http更快，虽然底层都是tcp，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。\n· 难度来看，rpc实现较为复杂，http相对比较简单\n· 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。\n因此，两者都有不同的使用场景：\n· 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用rpc还是不错的。\n· 如果需要更加灵活，跨语言、跨平台，显然http更合适\n那么我们该怎么选择呢？\n微服务，更加强调的是独立、自治、灵活。而rpc方式的限制较多，因此微服务框架中，一般都会采用基于http的rest风格服务。\n三、springcloud入门概述 spring的三大模块：springboot（构建），spring cloud（协调），spring cloud data flow（连接）\n3.1、springcloud是什么？ spring cloud是一系列框架的有序集合。它利用spring boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、熔断器、数据监控等，都可以用spring boot的开发风格做到一键启动和部署。spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过spring boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\nspring cloud项目的官方网址：https://spring.io/projects/spring-cloud\n3.2、 springcloud和springboot的关系 spring boot 是 spring 的一套快速配置脚手架，可以基于spring boot 快速开发单个微服务，spring cloud是一个基于spring boot实现的云应用开发工具；\nspring boot专注于快速方便开发单个微服务个体，spring cloud关注全局的服务治理框架，它将springboot开发的一个个微服务整合并管理起来，为各个服务之间提供 服务发现、负载均衡、断路器、路由、配置管理、微代理，消息总线、全局锁、分布式会话等集成服务；\nspring boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，spring cloud很大的一部分是基于spring boot来实现，可以不基于spring boot吗？不可以。\nspring boot可以离开spring cloud独立使用开发项目，但是spring cloud离不开spring boot，属于依赖的关系。\n3.3、 springcloud主要框架 服务发现——netflix eureka\n服务调用——netflix feign\n熔断器——netflix hystrix\n服务网关——netflix zuul\n分布式配置——spring cloud config\n消息总线 —— spring cloud bus\n四、服务发现组件eureka 4.1、eureka简介 eureka 是spring cloud netflix 微服务套件中的一部分， 它基于netflix eureka 做了二次封装， 主要负责完成微服务架构中的服务治理功能。我们只需通过简单引入依赖和注解配置就能让spring boot 构建的微服务应用轻松地与eureka 服务治理体系进行整合。\neureka包含两个组件：eureka server和eureka client。\neureka server提供服务注册服务。\neureka client是一个java客户端，用来简化与eureka server的交互、客户端同时也就是一个内置的、使用轮询(round-robin)负载算法的负载均衡器。 4.2、springcloud父工程创建 1.创建父工程 springboot项目hello-parent\n2.修改父工程配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.3.8.release\u0026lt;/version\u0026gt; \u0026lt;relativepath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;hello-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;hello-parent\u0026lt;/name\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-dependencies\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;hoxton.release\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 3.删除其余文件\n只留下 iml文件 和 父工程的pom文件即可 其余的没有用 包括src\n4.3、eureka服务端开发 1.创建eurekaserver01模块（maven工程即可）\n2.导入pom文件\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt;\t\u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 3.编写配置文件\n#内置的tomcat服务启动监听端口号 server: port: 8888 #应用名称 spring: application: name: eurekaserver01 #eurekaserver配置 eureka: instance: hostname: localhost server: #关闭自我保护模式（缺省为打开） enable-self-preservation: false #扫描失效服务的间隔时间（缺省为60*1000ms） eviction-interval-timer-in-ms: 1000 client: register-with-eureka: false #此eurekaserver不在注册到其他的注册中心 fetch-registry: false #不在从其他中心中心拉取服务器信息 service-url: defaultzone: http://${eureka.instance.hostname}:${server.port}/eureka #注册中心访问地址 4.编写启动类\n@springbootapplication @enableeurekaserver public class eurekaserver01start { public static void main(string[] args) { springapplication.run(eurekaserver01start.class, args); } } 5.启动测试结果\n然后在浏览器地址栏输入 http://localhost:8888/ 运行效果如下：\n主界面中system status为系统信息 general info为一般信息 instances currently\nregistered with eureka为注册到注册中心的所有微服务列表\n4.4基于eureka入门接口模块 1.创建hellointerface01模块\n2.编写接口\npackage com.offcn.service; public interface helloservice { public string sayhello(); } 3.安装到本地仓库\n注意：\nhello-parent父工程的pom.xml不需要声明springboot的maven编译插件，这样就可以避免把所有继承父工程的项目打包成springboot的jar包。\n\u0026lt;!-- \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; --\u0026gt; 4.5基于eureka入门生产者服务 1.创建helloprovider01模块\n2.编写pom文件\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;hellointerface01\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 3.编写yml文件\nspring: application: name: helloprovider01 server: port: 9001 eureka: client: service-url: defaultzone: http://localhost:8888/eureka 4.编写接口的实现类\npackage com.offcn.service.impl; import com.offcn.service.helloservice; import org.springframework.stereotype.service; @service public class helloserviceimpl implements helloservice { @override public string sayhello() { return \u0026#34;hello eureka!\u0026#34;; } } 5.编写hellocontroller实现类\npackage com.offcn.controller; import com.offcn.service.helloservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller public class hellocontroller { @autowired private helloservice helloservice; @getmapping(\u0026#34;/hello\u0026#34;) public string sayhello(){ return helloservice.sayhello(); } } 6.编写启动类\npackage com.offcn; import org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; import org.springframework.cloud.client.discovery.enablediscoveryclient; @springbootapplication @enablediscoveryclient public class helloprovider01start { public static void main(string[] args) { springapplication.run(helloprovider01start.class,args); } } 7.启动服务\n查看eureka管理控制台，可以看到服务已经注册上去！ 4.6、基于eureka入门消费者服务‘ 1.创建helloconsumer01模块\n2.导入pom依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;hellointerface01\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 3.yml配置文件\nspring: application: name: helloconsumer01 server: port: 9002 eureka: client: service-url: defaultzone: http://localhost:8888/eureka 4.编写启动类\n@springbootapplication @enablediscoveryclient public class helloconsumer01start { public static void main(string[] args) { springapplication.run(helloconsumer01start.class,args); } } 5.编写配置类（也可以在启动类中进行配置）实例化远程调用模板类\n@bean public resttemplate resttemplate(){ return new resttemplate(); } 6.编写实现类\npackage com.offcn.service.impl; import com.offcn.service.helloservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.cloud.client.serviceinstance; import org.springframework.cloud.client.discovery.discoveryclient; import org.springframework.http.httpstatus; import org.springframework.http.responseentity; import org.springframework.stereotype.service; import org.springframework.web.client.resttemplate; import java.util.list; @service public class helloserviceimpl implements helloservice { @autowired private discoveryclient discoveryclient; //是一个服务查询工具，可以连接到eurekaserver，根据服务名称去查询服务信息，注意别导错包了 @autowired private resttemplate resttemplate; //调用rest风格接口工具类 //从eurekaserver获取对应服务的地址和端口 public string getserverinfo(){ list\u0026lt;serviceinstance\u0026gt; instancelist = discoveryclient.getinstances(\u0026#34;helloprovider01\u0026#34;); if(instancelist!=null\u0026amp;\u0026amp;instancelist.size()\u0026gt;0){ serviceinstance serviceinstance = instancelist.get(0); //获取对应服务的主机地址 string host = serviceinstance.gethost(); //获取对应服务端口号 int port = serviceinstance.getport(); return \u0026#34;http://\u0026#34;+host+\u0026#34;:\u0026#34;+port; } return null; } @override public string sayhello(){ responseentity\u0026lt;string\u0026gt; responseentity = resttemplate.getforentity(getserverinfo() + \u0026#34;/hello\u0026#34;, string.class); string body = responseentity.getbody(); system.out.println(\u0026#34;调用远程服务返回值:\u0026#34;+body); return body; } } 7.controller调用代码\npackage com.offcn.controller; import com.offcn.service.helloservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller public class hellocontrollerconsumer { @autowired private helloservice helloservice; @requestmapping(\u0026#34;/testhello\u0026#34;) public string sayhello(){ return helloservice.sayhello(); } } 8.启动服务\n9.测试访问\nhttp://localhost:9002/testhello\n4.7、eureka的服务剔除与保护机制 1.服务剔除\n注册到eureka的服务可能由于内存溢出或网络故障等原因使得服务不能正常的工作，而服务注册中心并未收到“服务下线”的请求。服务注册中心在启动时会创建一个定时任务，默认每隔一段时间（默认为60秒）将当前清单中超时（默认为90秒）没有续约的服务剔除，这个操作被称为失效剔除。\n2.服务保护\n我们关停一个服务，很可能会在eureka面板看到一条警告：\n这是触发了eureka的自我保护机制。当服务未按时进行心跳续约时，eureka会统计服务实例最近15分钟心跳续约的比例是否低于了85%。\n在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。\neureka在这段时间内不会剔除任何服务实例，直到网络恢复正常。生产环境下这很有效，保证了大多数服务依然可用，不过也有可能获取到失败的服务实例，因此服务调用者必须做好服 务的失败容错。\n可以通过下面的配置来关停自我保护：\n五、eureka高可用 5.1高可用介绍 eurekaserver可以是一个集群，形成高可用的eureka注册中心\n多个eureka server之间也会互相注册为服务，当服务提供者注册到eureka server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。\n因此，无论客户端访问到eureka server集群中的哪一个节点，都可以获取到完整的服务列表信息。\n5.2高可用实现 1.创建第二个eureka2\n2.修改eureka1的yml文件配置\n#内置的tomcat服务启动监听端口号 server: port: 10086 #应用名称 spring: application: name: eurekaserver #eurekaserver配置 eureka: instance: hostname: localhost server: #关闭自我保护模式（缺省为打开） enable-self-preservation: false #扫描失效服务的间隔时间（缺省为60*1000ms） eviction-interval-timer-in-ms: 1000 client: register-with-eureka: true #需要设置为true允许去其他eurekaserver注册 fetch-registry: true #允许从其他中心中心拉取服务器信息 service-url: defaultzone: http://${eureka.instance.hostname}:10087/eureka #注册中心访问地址,指向另外一台eurekaserver 3.编写eureka2的yml文件\n#内置的tomcat服务启动监听端口号 server: port: 10087 #应用名称 spring: application: name: eurekaserver #eurekaserver配置 eureka: instance: hostname: localhost server: #关闭自我保护模式（缺省为打开） enable-self-preservation: false #扫描失效服务的间隔时间（缺省为60*1000ms） eviction-interval-timer-in-ms: 1000 client: register-with-eureka: true #此eurekaserver不在注册到其他的注册中心 fetch-registry: true #不在从其他中心中心拉取服务器信息 service-url: defaultzone: http://${eureka.instance.hostname}:10086/eureka #注册中心访问地址,指向另外一台eurekaserver 4.启动两个eureka\n启动项目eurekaserver1、eurekaserver2\n5.修改提供者和消费者的注册中心地址\n#配置eurekaserver注册中心服务器地址 eureka: client: service-url: defaultzone: http://localhost:10086/eureka,http://localhost:10087/eureka 此时配置文件同时指向两个配置中心\n6.启动测试\n六、服务调用组件 在上节课，我们启动了一个服务作为生产者，通过discoveryclient来获取服务实例信息，然后获取ip和端口来访问。但是实际环境中，我们往往会开启很多个服务的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？\n一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。\n不过springcolud中已经帮我们集成了一系列负载均衡组件：loadbalancerclient、ribbon、feign，简单修改代码即可使用。\n6.1基于loadbalance服务调用 6.1.1原理介绍 6.1.2代码实现 6.1.2.1创建接口模块userinterface 1.创建实体类com.offcn.pojo.user 提供属性 id、name、age等属性，提供getset 全参和空参构造器、tostring方法等\npackage com.offcn.pojo; import java.io.serializable; public class user implements serializable { private long id; private string username; private integer age; //省略getset方法 空参数 全参数构造器 以及tostring方法 3.创建接口com.offcn.service.userservice,提供方法list\u0026lt;user\u0026gt;findall();\npackage com.offcn.service; import com.offcn.pojo.user; import java.util.list; public interface userservice { map\u0026lt;string,object\u0026gt; findall(); } 4.安装模块到本地仓库\n6.1.2.2创建提供者 1.创建两个提供者模块测试负载均衡\n创建新模块userprovider01、 userprovider02 参考模块helloprovider01，引入依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;userinterface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2.修改两个模块的yml文件\nspring: application: name: userprovider server: port: 8001 eureka: client: service-url: defaultzone: http://localhost:10086/eureka,http://localhost:10087/eureka spring: application: name: userprovider server: port: 8002 eureka: client: service-url: defaultzone: http://localhost:10086/eureka,http://localhost:10087/eureka 3.创建接口的实现类实现接口方法（两个模块一样）\npackage com.offcn.service.impl; import com.offcn.pojo.user; import com.offcn.service.userservice; import org.springframework.stereotype.service; import java.util.arraylist; import java.util.list; @service public class userserviceimpl implements userservice { @override public map\u0026lt;string,object\u0026gt; findall() { list\u0026lt;user\u0026gt; list=new arraylist\u0026lt;user\u0026gt;(); list.add(new user(1l,\u0026#34;zhangsan1\u0026#34;,21)); list.add(new user(2l,\u0026#34;zhangsan2\u0026#34;,22)); list.add(new user(3l,\u0026#34;zhangsan3\u0026#34;,23)); map\u0026lt;string,object\u0026gt; map=new hashmap\u0026lt;string,object\u0026gt;(); map.put(\u0026#34;list\u0026#34;,list); return map; } } 4.修改两个controller方法\npackage com.offcn.controller; import com.offcn.pojo.user; import com.offcn.service.userservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.restcontroller; import java.util.hashmap; import java.util.list; import java.util.map; @restcontroller @requestmapping(\u0026#34;/user\u0026#34;) public class usercontroller { @autowired private userservice userservice; //获取全部用户数据 @getmapping(\u0026#34;/\u0026#34;) public map\u0026lt;string,object\u0026gt; findall(){ map\u0026lt;string,object\u0026gt; map=userservice.findall(); map.put(\u0026#34;version\u0026#34;,\u0026#34;userprovider01\u0026#34;); return map; } } package com.offcn.controller; import com.offcn.pojo.user; import com.offcn.service.userservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.restcontroller; import java.util.hashmap; import java.util.list; import java.util.map; @restcontroller @requestmapping(\u0026#34;/user\u0026#34;) public class usercontroller { @autowired private userservice userservice; //获取全部用户数据 @getmapping(\u0026#34;/\u0026#34;) public map\u0026lt;string,object\u0026gt; findall(){ map\u0026lt;string,object\u0026gt; map=userservice.findall(); map.put(\u0026#34;version\u0026#34;,\u0026#34;userprovider02\u0026#34;); return map; } } 为了区分访问的具体微服务，存储version字段作为区别\n5.编写启动类\npackage com.offcn; import org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; import org.springframework.cloud.client.discovery.enablediscoveryclient; @springbootapplication @enablediscoveryclient public class userprovider01start { public static void main(string[] args) { springapplication.run(userprovider01start.class,args); } } package com.offcn; import org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; import org.springframework.cloud.client.discovery.enablediscoveryclient; @springbootapplication @enablediscoveryclient public class userprovider02start { public static void main(string[] args) { springapplication.run(userprovider02start.class,args); } } 5.启动两个工程查看注册中心\n1.新建模块userweb(参考helloconsumer01)，引入依赖如下\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;userinterface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2.编写yml文件\nserver: port: 9001 spring: thymeleaf: prefix: classpath:/templates/ #在构建url时预先查看名称的前缀 suffix: .html #构建url时附加到查看名称的后缀 cache: false application: name: userweb eureka: client: service-url: defaultzone: http://localhost:10086/eureka,http://localhost:10087/eureka 3.远程调用业务类代码\n@service public class userserviceimpl implements userservice { //远程服务调用客户端 @autowired resttemplate resttemplate; //支持负载均衡的调用客户端 @autowired loadbalancerclient loadbalancerclient;\t/*** * 通过客户端负载均衡器获取生产者服务器基础地址 * @return */ public string getserverurl() {\t//通过客户端调用服务均衡器查找服务 serviceinstance inst = loadbalancerclient.choose(\u0026#34;userprovider\u0026#34;); //获取服务提供者服务器ip、端口号 string ip = inst.gethost(); int port = inst.getport(); //拼接调用地址 string url=\u0026#34;http://\u0026#34;+ip+\u0026#34;:\u0026#34;+port; return url; } @override public map\u0026lt;string,object\u0026gt; findall() { string url=getserverurl(); map\u0026lt;string,object\u0026gt; map = resttemplate.getforobject(url + \u0026#34;/user/\u0026#34;, map.class); return map; } } 注意：loadbalancerclient 具备负载均衡功能，可以根据服务名从多个实例中选择一个实例\n4.controller代码\npackage com.offcn.controller; import com.offcn.service.userservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.getmapping; import java.util.map; @controller public class usercontroller { @autowired private userservice userservice; //查询全部用户数据，显示列表 @getmapping(\u0026#34;/\u0026#34;) public string findall(model model){ map\u0026lt;string, object\u0026gt; map = userservice.findall(); model.addattribute(\u0026#34;page\u0026#34;,map.get(\u0026#34;list\u0026#34;)); //获取服务提供者信息 model.addattribute(\u0026#34;version\u0026#34;,map.get(\u0026#34;version\u0026#34;)); system.out.println(\u0026#34;version:\u0026#34;+map.get(\u0026#34;version\u0026#34;)); return \u0026#34;user/list\u0026#34;; } } 4.创建list.html页面代码\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 th:text=\u0026#34;${version}\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;table width=\u0026#34;200\u0026#34; style=\u0026#34;text-align: center;\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;index\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr th:each=\u0026#34; user,iterstat : ${page}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${user.id}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${user.username}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${user.age}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${iterstat.index}\u0026#34;\u0026gt;index\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5.编写主启动类\nimport org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; import org.springframework.cloud.client.discovery.enablediscoveryclient; import org.springframework.context.annotation.bean; import org.springframework.web.client.resttemplate; @springbootapplication @enablediscoveryclient public class userwebapplication { public static void main(string[] args) { springapplication.run(userwebapplication.class,args); } @bean public resttemplate resttemplate(){ return new resttemplate(); } } 6.测试效果\n顺序启动项目eurekaserver01、eurekaserver02、userprovdier01、userprovdier02、userweb\n访问eureka管理控制台界面，可以看到各个服务以及注册成功\n访问消费者工程userweb02地址：http://localhost:9001\n多次刷新后可以看见 控制台在 provider1和provider2之间切换\n6.2基于ribbon的远程调用 6.2.1ribbon介绍 spring cloud ribbon是基于netflix ribbon实现的一套客户端负载均衡的工具。它是一个基于http和tcp的客户端负载均衡器。\n下面我们带领大家使用ribbon来实现客户端服务调用。\n6.2.2 消费者项目创建 1、创建新模块userweb02\n​\t复制工程userweb的内容到userweb02\n2、修改pom.xml引入ribbon依赖包\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 3.修改userweb02工程中配置文件application.yml\n#服务器端口号 server: port: 9002 spring: thymeleaf: prefix: classpath:/templates/ #在构建url时预先查看名称的前缀 suffix: .html #构建url时附加到查看名称的后缀 cache: false application: name: userweb02 4.修改项目启动类appstartapplication 在resttemplate定义上增加注解@loadbalanced，即可开启ribbon\n5.修改类userserviceimpl\n@service public class userserviceimpl implements userservice { @autowired private resttemplate resttemplate; //rest接口调用工具 //编写查询服务方法 public string getserverurl(){ return \u0026#34;http://userprovider\u0026#34;; } @override public map\u0026lt;string,object\u0026gt; findall() { string url=getserverurl(); map\u0026lt;string,object\u0026gt; map = resttemplate.getforobject(url + \u0026#34;/user/\u0026#34;, map.class); return map; } } 6.测试效果\n访问消费者工程userweb02地址：http://localhost:9002\n可以看到不停刷新页面，显示的用户服务信息发生变化，在2个生产者服务之间来回切换。 后台打印：\n6.2.3负载均衡规则配置[了解] 1.规则分类\n默认情况下ribbon的负载均衡策略是轮询，ribbon常用的负载均衡规则：\n1、简单轮询策略（roundrobinrule）\n​ 以轮询的方式依次将请求调度不同的服务器\n2、随机策略 （randomrule）\n​ 随机选择状态为up的server\n3、加权响应时间策略 （weightedresponsetimerule）\n​ 根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。\n4、区域权重策略（zoneawarerule）\n​ 综合判断server所在区域的性能和server的可用性选择server\n5、最低并发策略(bestavailablerule)\n​ 逐个查看server，选择一个并发连接最低的server\n6、重试策略(retryrule)\n​ 对选定的负载均衡策略机上重试机制\n7、可用过滤策略(availabilityfilteringrule)\n​ 过滤掉一直失败并被标记为circuit tripped的server\n8、responsetimeweightedrule\n​ 已废弃，作用同weightedresponsetimerule\n2.规则配置\nyml文件配置指定服务的负载均衡策略\n# com.netflix.loadbalancer.randomrule #配置规则 随机\n# com.netflix.loadbalancer.roundrobinrule #配置规则 轮询\n# com.netflix.loadbalancer.retryrule #配置规则 重试\n# com.netflix.loadbalancer.weightedresponsetimerule #配置规则 响应时间权重\n# com.netflix.loadbalancer.bestavailablerule #配置规则 最空闲连接策略\n针对每个服务来在消费端如userweb02的application.yml中配置负载均衡规则\nuserprovider: #服务名称 ribbon: nfloadbalancerruleclassname: com.netflix.loadbalancer.randomrule 6.2.4重试机制[了解] 1.重试机制理解\n当我们选择轮询负载均衡策略的时候，如果一个服务停掉，因为服务剔除的延迟，消费者并不会立即得到最新的服务列表，此时再次访问你会得到错误提示：\nspring cloud 整合了spring retry 来增强resttemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。\n2.重试机制实现\n1.修改配置文件application.yml\nspring: #开启spring cloud的重试功能 cloud: loadbalancer: retry: enabled: true userprovider: ribbon: #配置指定服务的负载均衡策略 nfloadbalancerruleclassname: com.netflix.loadbalancer.roundrobinrule # 是否对所有操作都进行重试,默认支持读造作，不支持写操作 #(写操作要保证接口 幂等性：防止多次操作造成数异常) oktoretryonalloperations: true connecttimeout: 250 # ribbon的连接超时时间 readtimeout: 1000 # ribbon的数据读取超时时间 # 切换实例的重试次数 maxautoretriesnextserver: 1 # 对当前实例的重试次数 maxautoretries: 1 注意：使用重试，要设置负载均衡策略为轮询com.netflix.loadbalancer.roundrobinrule\n2.修改pom文件引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.retry\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-retry\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 4.测试效果\n重启项目userweb02，\n访问地址：http://127.0.0.1:9002/\n不断刷新页面，可以看到用户服务显示内容在变化，负载均衡效果已经生效，到此ribbon消费者成功\n如图：\n关闭生产者项目providerservice002\n再次访问http://127.0.0.1:9002/\n重试机制生效不会再产生刚才的调用错误。\n注意：重试过于频繁后台也会出现异常，但是页面不会再次出现错误。\n一、基于feign的远程调用 1.feign介绍 feign是一个声明式的web服务客户端，它使编写web服务客户端变得更加容易。创建一个接口并添加一个fegin的注解@feignclient，就可以通过该接口调用生产者提供的服务。spring cloud对feign进行了增强，使得feign支持了spring mvc注解\n两点：1、feign采用的是接口加注解的声明式服务调用;\n​ 2、fegin整合ribbon及eureka，支持负载均衡\n接下带领大家创建一个消费者项目，体验feign的使用方式。\n2.消费者项目创建 2.1 创建新模块userweb03 复制工程userweb02的内容到userweb03\n2.2 修改pom.xml引入feign依赖包 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 2.3 修改应用启动类 增加注解@enablefeignclients 2.4 配置文件application.yml 进行如下修改 server: port: 9003 spring: thymeleaf: cache: false application: name: userweb03 eureka: client: service-url: defaultzone: http://localhost:10086/eureka,http://localhost:10087/eureka 2.5 在com.offcn.service中添加接口userservice @feignclient(value = \u0026#34;userprovider\u0026#34;) public interface userservice { //查询全部 @getmapping(\u0026#34;/user/\u0026#34;) public map\u0026lt;string,object\u0026gt; findall(); } 2.6 删除实现类userserviceimpl，以及依赖pom.xml移除对接口userinterface的依赖 2.7 usercontroller直接调用接口userservice @controller public class usercontroller{ @autowired userservice userservice; } 2.7 访问userweb03可以看到一样得到访问结果 访问http://localhost:9003/\n3. 开启调用日志 @feignclient注解修改的客户端在被代理时，都会创建一个新的fegin.logger实例。我们需要额外指定这个日志的级别才可以。\n3.1修改application.yml设置对应包的日志级别 #设置消费者指定包日志级别 logging: level: com.offcn : debug 3.2编写配置类，定义日志级别 这里指定的level级别是full，feign支持4种级别：\nnone：不记录任何日志信息，这是默认值。\nbasic：仅记录请求的方法，url以及响应状态码和执行时间\nheaders：在basic的基础上，额外记录了请求和响应的头信息\nfull：记录所有请求和响应的明细，包括头信息、请求体、元数据。\n创建类feignconfig ，配置feign日志级别定义\npackage com.offcn.config; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; import feign.logger; @configuration public class feignconfig { @bean public logger.level getfeignlogger(){ return logger.level.full; } } 3.3 修改接口userservice 修改注解：@feignclient，指定feign日志配置文件\n3.4 重启工程userweb03 访问地址http://localhost:9003/\n查看控制台即可看到feign调用日志：\n3.5、设置feign默认超时时间 feign: client: config: default: connecttimeout: 10000 #连接超时配置 readtimeout: 60000 #执行超时配置 二、熔断器组件netflix hystrix 1 熔断器hystix介绍 hystix是netflix的针对微服务分布式系统的熔断保护中间件，一个有关延迟和失败容错的开源库包，用于隔离访问远程服务、第三方库，防止出现级联失败。\nhystix是netflix的针对微服务分布式系统的熔断保护中间件，是一个有关延迟和失败容错的开源库包，用来设计隔离访问远程服务、第三方库等，防止出现级联式失败。\n主页：https://github.com/netflix/hystrix/\n2 熔断器hystix的原理和作用 熔断器机制的原理很简单，像家里的电路保险丝，如果电路发生短路能立刻熔断电路，避免发生灾难。\n在分布式系统中应用这一模式之后，服务调用方可以自己进行判断某些服务反应慢或者存在大量超时的情况时，能够主动熔断，防止整体系统被拖垮。\n不同于电路熔断只能断不能自动重连，hystrix可以实现弹性容错，当情况好转之后，可以自动重连。\n正常工作的情况下，客户端请求调用服务api接口：\n当有服务出现异常时，直接进行失败回滚，服务降级处理：\n3 ribbon使用hystix 3.1 修改项目userweb02，引入hystix熔断器 pom.xml增加hystix依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 3.2修改应用启动类。增加注解@enablecircuitbreaker允许hystix熔断器生效 3.3 修改业务实现类userserviceimpl @override @hystrixcommand(fallbackmethod =\u0026#34;findallcallback\u0026#34; ) public map\u0026lt;string,object\u0026gt; findall() { string url=getserverurl(); map\u0026lt;string,object\u0026gt; map = resttemplate.getforobject(url + \u0026#34;/user/\u0026#34;, map.class); return map; } //熔断触发后，回调方法 public map\u0026lt;string,object\u0026gt; findallcallback() { map\u0026lt;string,object\u0026gt; map=new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;list\u0026#34;,new arraylist\u0026lt;\u0026gt;()); map.put(\u0026#34;version\u0026#34;,\u0026#34;熔断被触发，远程调用失败\u0026#34;); return map; } @hystrixcommand(fallbackmethod=\u0026ldquo;findallcallback\u0026rdquo;)：\n声明一个失败回滚处理函数findallcallback，当findall执行超时（默认是1000毫秒），就会执行findallcallback函数，返回错误提示。\n为了方便查看熔断的触发时机，我们记录请求访问时间。\n3.4 修改服务提供者userprovdier01、userprovdier02 让服务随机休眠一段时间，以触发熔断\n//获取全部用户数据 @getmapping(\u0026#34;/\u0026#34;) public map\u0026lt;string,object\u0026gt; findall(){ map\u0026lt;string,object\u0026gt; map=userservice.findall(); map.put(\u0026#34;version\u0026#34;,\u0026#34;userprovider01\u0026#34;); //随机睡 0-1500毫秒 try { thread.sleep(new random().nextint(1500)); } catch (interruptedexception e) { e.printstacktrace(); } return map; } 3.5 测试 启动应用，访问地址：http://localhost:9002/\n可以看到当请求时间超过1000毫秒是发生熔断 4 优化ribbon使用hystix 虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？\n其实这里是因为我们的ribbon超时时间设置的是1000ms userprovider: #服务名称 ribbon: #配置指定服务的负载均衡策略 nfloadbalancerruleclassname: com.netflix.loadbalancer.roundrobinrule # ribbon的连接超时时间 connecttimeout: 250 # ribbon的数据读取超时时间 readtimeout: 1000 # 是否对所有操作都进行重试 oktoretryonalloperations: true # 切换实例的重试次数 maxautoretriesnextserver: 1 # 对当前实例的重试次数 maxautoretries: 1 而hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。\n注意，针对resttemplate发起调用设置超时时间\n所以，resttemplate、ribbon的超时时间一定要小于hystix的超时时间。\n@bean @loadbalanced public resttemplate resttemplate(){ httpcomponentsclienthttprequestfactory factory = new httpcomponentsclienthttprequestfactory(); factory.setreadtimeout(250); factory.setconnecttimeout(250); return new resttemplate(factory); } 4.1 设定消费者userweb02熔断超时时间 修改application.yml\n#设定hystrix熔断超时时间 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 6000 4.2 修改服务提供者userprovdier01、userprovdier02 让服务随机休眠一段时间（1-6000毫秒） 4.3 重启相关项目，发现重试机制已经生效，不会再发生错误 重试已经生效\n5 feign使用hystix feign默认也有对hystix的集成，只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：\n5.1修改项目userweb03的application.yml # 开启feign的熔断功能 feign: hystrix: enabled: true #总连接超时时间=（切换服务实例次数+1）*（每个实例重试次数+1）*连接超时时间 userprovider: #服务名称 ribbon: #配置指定服务的负载均衡策略 nfloadbalancerruleclassname: com.netflix.loadbalancer.roundrobinrule # ribbon的连接超时时间 connecttimeout: 250 # ribbon的数据读取超时时间 readtimeout: 250 # 是否对所有操作都进行重试 oktoretryonalloperations: true # 切换实例的重试次数 maxautoretriesnextserver: 1 # 对当前实例的重试次数 maxautoretries: 1 #设定hystrix熔断超时时间 ，理论上熔断时间应该大于总连接超时时间 hystrix: command: default: execution: isolation: thread: timeoutinmilliseconds: 6000 5.2 导入熔断所需依赖包 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 5.3 编写feign声明接口userservice的实现类userserviceimpl（注意要声明为@service） @service public class userserviceimpl implements userservice { @override public map\u0026lt;string, object\u0026gt; findall() { map\u0026lt;string,object\u0026gt; map=new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;list\u0026#34;,new arraylist\u0026lt;\u0026gt;()); map.put(\u0026#34;version\u0026#34;,\u0026#34;调用远程服务失败,熔断被触发!\u0026#34;); return map; } } 5.4 在feign调用接口userservice中，使用注解@feignclient声明熔断调用实现类 @feignclient(value=\u0026#34;userprovider\u0026#34;, configuration=feignconfig.class, fallback=userserviceimpl.class) 5.5 重启动项目userweb03 访问地址http://localhost:9003/\n超时后熔断被触发 6 hystix监控服务器搭建【了解】 断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是hystrixcommand和hystrixobservablecommand实例在执行过程中记录的重要度量信息，它们除了hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。这些指标信息会以“滚动时间窗”与“桶”结合的方式进行汇总，并在内存中驻留一段时间，以供内部或外部进行查询使用，hystrix dashboard就是这些指标内容的消费者之一。\n接下来搭建使用hystix监控\n6.1 新建一个模块hystrix-dashboard，编辑pom.xml导入所需依赖包 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-hystrix-dashboard\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 6.2 为应用主类加上@enablehystrixdashboard，启用hystrix dashboard功能 @springbootapplication @enablehystrixdashboard public class hystrixdashboardstart { public static void main(string[] args) { springapplication.run(hystrixdashboardstart.class, args); } } 6.3 修改yml文件 spring: application: name: hystrix-dashboard server: port: 1301 hystrix: dashboard: proxy-stream-allow-list: \u0026#34;*\u0026#34; 6.4 启动该应用，并访问 http://localhost:1301/hystrix，我们可以看到如下页面：\n7 启动客户端监控 项目：userweb03的userservice接口实现使用了@feignclient修饰，feign是自带断路器功能的,并且已经开启了断路器功能，所以这个接口的调用情况会被hystrix记录下来，以用来给断路器和hystrix dashboard使用。\n7.1 修改项目userweb04的pom.xml增加hystrix监控所需依赖包 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.cloud\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; 7.2 在服务实例的主类中已经使用@enablecircuitbreaker或@enablehystrix注解，开启断路器功能。 同时增加监控路径访问地址定义/hystrix.stream可以访问\n@springbootapplication @enablediscoveryclient @enablefeignclients @enablehystrix //开启断路器 @enablehystrixdashboard //启用hystrixdashboard public class appstartapplication { public static void main(string[] args) { springapplication.run(appstartapplication.class, args); } @bean\t@loadbalanced public resttemplate getresttemplate() { return new resttemplate(); } @bean public servletregistrationbean getservlet(){ hystrixmetricsstreamservlet streamservlet = new hystrixmetricsstreamservlet(); servletregistrationbean registrationbean = new servletregistrationbean(streamservlet); registrationbean.setloadonstartup(1); //系统启动时加载顺序 registrationbean.addurlmappings(\u0026#34;/hystrix.stream\u0026#34;);//路径 registrationbean.setname(\u0026#34;hystrixmetricsstreamservlet\u0026#34;); return registrationbean; } } 7.3 重启应用，访问地址:http://localhost:9004/hystrix.stream 注意：如果没有访问消费者使用hystrix熔断的接口，监控数据看不到任何数据。\n需要首先访问消费者接口:http://localhost:9003/\n才能看到hystrix监控数据。 4.使用hystrix dashboard对hystrix监控数据进行图形化监控\n访问http://localhost:9004/hystrix，在出现的hystrix dashboard的首页中输入http://localhost:9004/hystrix.stream，\n点击“monitor stream”按钮，此时我们可以看到如下页面：\n","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220526235888/","summary":"一、系统架构演变 随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。 从单一应用，到垂直拆分，到分","title":"springcloud"},{"content":"ssm整合 （一） ssm框架整合思路的介绍和分析 介绍：ssm（spring+springmvc+mybatis）整合，就是三个框架协同开发。\nspring整合mybatis 就是将mybatis核心配置文件当中数据源的配置，事务的管理，以及工厂的配置，mapper接口的实现类等交给spring管理。\nspring整合springmvc，就是在web.xml当中添加监听器，当服务器启动，监听器触发，监听器执行了spring的核心配置文件，核心配置文件被加载。\n整合核心步骤：\nspring 基础框架单独运行\nspringmvc 框架单独运行\nspring 整合springmvc 框架\nspring 整合mybatis 框架\n测试ssm 整合结果\n（二）准备ssm整合环境 1 创建数据库和表结构 create table `role` ( `roleid` int(11) not null auto_increment comment \u0026#39;主键值\u0026#39;, `rolename` varchar(32) default null comment \u0026#39;角色名称\u0026#39;, `roledes` varchar(32) default null comment \u0026#39;角色描述\u0026#39;, primary key (`roleid`) ) engine=innodb default charset=utf8; 2 创建 maven 工程 3 导入核心坐标 \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceencoding\u0026gt;utf-8\u0026lt;/project.build.sourceencoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.7\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.7\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;spring-version\u0026gt;5.2.5.release\u0026lt;/spring-version\u0026gt; \u0026lt;mybatis-version\u0026gt;3.4.6\u0026lt;/mybatis-version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--mybatis相关包--\u0026gt; \u0026lt;!--mysql的驱动包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.38\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis核心--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${mybatis-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--日志包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;log4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;log4j\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--分页插件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.github.pagehelper\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;pagehelper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring相关的--\u0026gt; \u0026lt;!--springioc包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jdbc--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--织入器包：--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.aspectj\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;aspectjweaver\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.9.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--springmvc依赖：--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-webmvc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--解析器包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jackson-databind\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.9.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--文件上传--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;commons-fileupload\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;commons-fileupload\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- servlet --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;javax.servlet\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;javax.servlet-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jsp--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;javax.servlet.jsp\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jsp-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--jstl--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;jstl\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jstl\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring整合mybatis--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-spring\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--spring整合junit--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-test\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 4 编写数据模型实体类 /** * @author offcn * 角色实体类 **/ public class role implements serializable { private integer roleid;//角色id private string rolename;//角色名称 private string roledes;//角色的描述 public integer getroleid() { return roleid; } public void setroleid(integer roleid) { this.roleid = roleid; } public string getrolename() { return rolename; } public void setrolename(string rolename) { this.rolename = rolename; } public string getroledes() { return roledes; } public void setroledes(string roledes) { this.roledes = roledes; } @override public string tostring() { return \u0026#34;role{\u0026#34; + \u0026#34;roleid=\u0026#34; + roleid + \u0026#34;, rolename=\u0026#39;\u0026#34; + rolename + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, roledes=\u0026#39;\u0026#34; + roledes + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } 5 编写持久层接口 /** * @author offcn **/ public interface rolemapper { role findbyid(integer id); list\u0026lt;role\u0026gt; findall(); void insert(role role); void update(role role); void delete(integer id); } 6 编写持久层接口对应的sql配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.offcn.mapper.rolemapper\u0026#34;\u0026gt; \u0026lt;resultmap id=\u0026#34;baseresultmap\u0026#34; type=\u0026#34;com.offcn.pojo.role\u0026#34; \u0026gt; \u0026lt;id column=\u0026#34;roleid\u0026#34; property=\u0026#34;roleid\u0026#34; jdbctype=\u0026#34;integer\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;rolename\u0026#34; property=\u0026#34;rolename\u0026#34; jdbctype=\u0026#34;varchar\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;roledes\u0026#34; property=\u0026#34;roledes\u0026#34; jdbctype=\u0026#34;varchar\u0026#34; /\u0026gt; \u0026lt;/resultmap\u0026gt; \u0026lt;!-- role findbyid(integer id);--\u0026gt; \u0026lt;select id=\u0026#34;findbyid\u0026#34; resultmap=\u0026#34;baseresultmap\u0026#34;\u0026gt; select * from role where roleid =#{roleid} \u0026lt;/select\u0026gt; \u0026lt;!-- list\u0026lt;role\u0026gt; findall();--\u0026gt; \u0026lt;select id=\u0026#34;findall\u0026#34; resultmap=\u0026#34;baseresultmap\u0026#34;\u0026gt; select * from role \u0026lt;/select\u0026gt; \u0026lt;!--void insert(role role);--\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; parametertype=\u0026#34;com.offcn.pojo.role\u0026#34; \u0026gt; insert into role(rolename,roledes) values(#{rolename},#{roledes}) \u0026lt;/insert\u0026gt; \u0026lt;!-- void update(role role);--\u0026gt; \u0026lt;update id=\u0026#34;update\u0026#34; parametertype=\u0026#34;com.offcn.pojo.role\u0026#34;\u0026gt; update role set roleid = #{roleid} , rolename = #{rolename} , roledes = #{roledes} where roleid = #{roleid} \u0026lt;/update\u0026gt; \u0026lt;!--void delete(integer id);--\u0026gt; \u0026lt;delete id=\u0026#34;delete\u0026#34; parametertype=\u0026#34;int\u0026#34;\u0026gt; delete from role where roleid=#{roleid} \u0026lt;/delete\u0026gt; \u0026lt;/mapper\u0026gt; 7 编写业务层接口 /** * @author offcn **/ public interface roleservice { role findbyid(integer id); list\u0026lt;role\u0026gt; findall(); void insert(role role); void update(role role); void delete(integer id); } 8 编写业务层接口实现类 /** * @author offcn **/ public class roleserviceimpl implements roleservice { @override public role findbyid(integer id) { return null; } @override public list\u0026lt;role\u0026gt; findall() { return null; } @override public void insert(role role) { } @override public void update(role role) { } @override public void delete(integer id) { } } （三）ssm整合步骤 1 spring 框架在 web 工程中独立运行 1.1 创建 spring 配置文件beans_core.xml并导入约束 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--开启注解扫描器--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.offcn\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;/beans\u0026gt; 1.2 使用注解配置业务层 @service(\u0026#34;roleservice\u0026#34;) //使用注解配置业务层对象 public class roleserviceimpl implements roleservice { @override public role findbyid(integer id) { return null; } ... } 1.3 测试 spring 独立运行 @runwith(springjunit4classrunner.class) @contextconfiguration(\u0026#34;classpath:applicationcontext.xml\u0026#34;) public class testspring { @autowired private roleservice roleservice; @test public void testioc(){ system.out.println(roleservice); } } //运行结果： com.offcn.service.roleserviceimpl@478190fc //说明： springioc 功能能够正常使用 2 springmvc 在 web 工程中运行 2.1 在 web.xml 中配置核心控制器（dispatcherservlet） \u0026lt;!--配置前端控制器： --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherservlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.dispatcherservlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--加载springmvc的配置文件：--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextconfiglocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--设置加载时机： --\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!-- 设置servlet的映射路径--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherservlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 2.2 编写 springmvc 的配置文件 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--配置注解扫描器--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.offcn.controller\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!--处理器配置--\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;\u0026lt;/mvc:annotation-driven\u0026gt; \u0026lt;!--配置视图解析器：--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.internalresourceviewresolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 2.3 编写 controller /** * @author offcn **/ @controller @requestmapping(\u0026#34;role\u0026#34;) public class rolecontroller { @requestmapping(\u0026#34;findrole\u0026#34;) @responsebody public role findrole(integer roleid){ role role = new role(); role.setroleid(roleid); role.setrolename(\u0026#34;管理员\u0026#34;); role.setroledes(\u0026#34;管理整个网站\u0026#34;); return role; } } 2.4 编写index.jsp测试 \u0026lt;%@ page contenttype=\u0026#34;text/html;charset=utf-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;角色详情页面\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;根据id唯一性查询角色信息\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/role/findrole\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; id: \u0026lt;input name=\u0026#34;roleid\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;button\u0026gt;查询\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3 整合 spring 和 springmvc：web.xml中添加监听器 \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextconfiglocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationcontext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;!--配置了一个监听器: servletcontext--\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.contextloaderlistener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; 4 spring整合mybatis配置 4.1 spring 接管 mybatis 的 session 工厂 jdbc.driver=com.mysql.jdbc.driver jdbc.url=jdbc:mysql://localhost:3306/blog jdbc.username=root jdbc.password=root \u0026lt;!--数据源--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:dbconfig.properties\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.druiddatasource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverclassname\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--mybatis的核心工厂对象--\u0026gt; \u0026lt;bean id=\u0026#34;sessionfactory\u0026#34; class=\u0026#34;org.mybatis.spring.sqlsessionfactorybean\u0026#34;\u0026gt; \u0026lt;!--注入数据源--\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;!--别名--\u0026gt; \u0026lt;property name=\u0026#34;typealiasespackage\u0026#34; value=\u0026#34;com.offcn.pojo\u0026#34;/\u0026gt; \u0026lt;!--mapper 文件的位置--\u0026gt; \u0026lt;property name=\u0026#34;mapperlocations\u0026#34; value=\u0026#34;classpath:com/offcn/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;!--配置分页插件--\u0026gt; \u0026lt;property name=\u0026#34;plugins\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;bean class=\u0026#34;com.github.pagehelper.pageinterceptor\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;properties\u0026#34;\u0026gt; \u0026lt;value\u0026gt; helperdialect=mysql reasonable=true supportmethodsarguments=true params=count=countsql autoruntimedialect=true \u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 4.2 配置自动扫描所有 mapper 接口和文件 \u0026lt;!--指定扫描器： 扫描mapper接口，生成代理类： --\u0026gt; \u0026lt;bean id=\u0026#34;mapperscannerconfigurer\u0026#34; class=\u0026#34;org.mybatis.spring.mapper.mapperscannerconfigurer\u0026#34;\u0026gt; \u0026lt;!--指定扫描的包位置--\u0026gt; \u0026lt;property name=\u0026#34;basepackage\u0026#34; value=\u0026#34;com.offcn.mapper\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 4.3 配置 spring 的事务 \u0026lt;!--事务管理器平台--\u0026gt; \u0026lt;bean id=\u0026#34;transactionmanager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.datasourcetransactionmanager\u0026#34;\u0026gt; \u0026lt;!--注入一个数据源--\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--开启注解式事务--\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;transactionmanager\u0026#34;\u0026gt;\u0026lt;/tx:annotation-driven\u0026gt; （四）测试 ssm 整合结果 1 编写测试jsp文件 \u0026lt;%@ page contenttype=\u0026#34;text/html;charset=utf-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;角色详情页面\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;根据id唯一性查询角色信息\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/role/findrole\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; id: \u0026lt;input name=\u0026#34;roleid\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;button\u0026gt;查询\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;a href=\u0026#34;/role/findall\u0026#34;\u0026gt;查询所有角色\u0026lt;/a\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;h2\u0026gt;添加角色\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/role/insert\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 角色名称: \u0026lt;input name=\u0026#34;rolename\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt;\u0026lt;br/\u0026gt; 角色描述: \u0026lt;input name=\u0026#34;roledes\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;button\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;h2\u0026gt;更新角色\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/role/update\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; id: \u0026lt;input name=\u0026#34;roleid\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt;\u0026lt;br/\u0026gt; 角色名称: \u0026lt;input name=\u0026#34;rolename\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt;\u0026lt;br/\u0026gt; 角色描述: \u0026lt;input name=\u0026#34;roledes\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;button\u0026gt;更新\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;h2\u0026gt;删除角色\u0026lt;/h2\u0026gt; \u0026lt;form action=\u0026#34;/role/delete\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; id: \u0026lt;input name=\u0026#34;roleid\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt;\u0026lt;br/\u0026gt; \u0026lt;button\u0026gt;删除\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2 修改控制器中的方法和业务层当中方法 package com.offcn.controller; import com.offcn.pojo.role; import com.offcn.service.roleservice; import org.springframework.beans.factory.annotation.autowired; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.responsebody; import java.util.list; /** * @author offcn **/ @controller @requestmapping(\u0026#34;role\u0026#34;) public class rolecontroller { @autowired private roleservice roleservice; @requestmapping(\u0026#34;findrole\u0026#34;) @responsebody public role findrole(integer roleid){ role role = roleservice.findbyid(roleid); return role; } @requestmapping(\u0026#34;findall\u0026#34;) @responsebody public list\u0026lt;role\u0026gt; findall(){ list\u0026lt;role\u0026gt; listroles = roleservice.findall(); return listroles; } @requestmapping(\u0026#34;insert\u0026#34;) @responsebody public string insert(role role){ try { roleservice.insert(role); return \u0026#34;ok\u0026#34;; } catch (exception e) { e.printstacktrace(); } return \u0026#34;fail\u0026#34;; } @requestmapping(\u0026#34;update\u0026#34;) @responsebody public string update(role role){ try { roleservice.update(role); return \u0026#34;ok\u0026#34;; } catch (exception e) { e.printstacktrace(); } return \u0026#34;fail\u0026#34;; } @requestmapping(\u0026#34;delete\u0026#34;) @responsebody public string delete(integer roleid){ try { roleservice.delete(roleid); return \u0026#34;ok\u0026#34;; } catch (exception e) { e.printstacktrace(); } return \u0026#34;fail\u0026#34;; } } /** * @author offcn **/ @service(\u0026#34;roleservice\u0026#34;) public class roleserviceimpl implements roleservice { @autowired private rolemapper rolemapper; @override public role findbyid(integer id) { return rolemapper.findbyid(id); } @override public list\u0026lt;role\u0026gt; findall() { return rolemapper.findall(); } @override public void insert(role role) { rolemapper.insert(role); } @override public void update(role role) { rolemapper.update(role); } @override public void delete(integer id) { rolemapper.delete(id); } } 3 测试运行并展示运行结果 \u0026lt;!--引入外部的tomcat7插件--\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.apache.tomcat.maven\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt; \u0026lt;port\u0026gt;8080\u0026lt;/port\u0026gt; \u0026lt;uriencoding\u0026gt;utf-8\u0026lt;/uriencoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; ssm集成 主要内容 ssm集成\n登陆\n拦截器\n退出\n客户列表\n一、创建一个maven web工程 把****pom.xml中packaging改成war 添加web工程所需要的webapp 和web-inf、web.xml 一、引入依赖(mybatis依赖，spring依赖，springmvc依赖) 引入依赖 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.2.5.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--导入junit单元测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入spring的context坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-test\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入jdbc模块依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入mysql 驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入c3p0连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.mchange\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;c3p0\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--aop--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.aspectj\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;aspectjweaver\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.8.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis-spring适配包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-spring\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis orm框架 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--分页依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.github.pagehelper\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;pagehelper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--springmvc依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-webmvc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--springmvc依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-web\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--解析json依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jackson-databind\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.9.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--servlet依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;javax.servlet\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;servlet-api\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--文件上传依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;commons-fileupload\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;commons-fileupload\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- jsp相关 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;jstl\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;jstl\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 把java和resources中的资源添加到classpath中 \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src\\main\\java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src\\main\\resources\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.properties\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 使用maven tomcat插件 \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.apache.tomcat.maven\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--指定编码格式--\u0026gt; \u0026lt;uriencoding\u0026gt;utf-8\u0026lt;/uriencoding\u0026gt; \u0026lt;!--指定项目启动后的访问路径--\u0026gt; \u0026lt;path\u0026gt;/\u0026lt;/path\u0026gt; \u0026lt;!--指定访问端口号--\u0026gt; \u0026lt;port\u0026gt;8080\u0026lt;/port\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; 一、创建数据库 把oa.sql右键保存成文件，然后利用sqlyog导入到数据库中 ","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220526162071/","summary":"SSM整合 （一） SSM框架整合思路的介绍和分析 介绍：SSM（Spring+SpringMVC+MyBatis）整合，就是三个框架协同开发。 Spring整合Myb","title":"ssm整合"},{"content":"zookeeper 一、zookeeper的介绍 （一）zookeeper概述 1.介绍 zookeeper是一个开源的分布式的，为分布式应用提供协调服务的apache项目。它是一种集中式服务，用于维护配置信息，命名，提供分布式同步和提供组服务。所有这些类型的服务都以分布式应用程序的某种形式使用。每次实施它们都需要做很多工作来修复不可避免的错误和竞争条件。由于难以实现这些类型的服务，应用程序最初通常会吝啬它们，这使得它们在变化的情况下变得脆弱并且难以管理。即使正确完成，这些服务的不同实现也会在部署应用程序时导致管理复杂性。 2.工作机制 基于观察者模式设计的分布式服务管理框架。 （二）zookeeper的特点 zookeeper官方架构图 1.zookeeper：一个领导级别的存在，监测和管理多个服务。 2.集群中只要有半数以上节点存活，zookeeper集群就能正常服务。 3.数据一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 zookeeper 中去。 4.更新请求顺序进行：来自同一个client的更新请求按照其发送顺序依次执行。 5.原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中 所有的机器都成功应用了某一个事务，要么都没有应用。 6.实时性：在一定时间范围，client能读到最新的数据。 （三）zookeeper的数据结构 zookeeper数据模型的结构与unix文件系统很类似，都是树结构。树上有若干个节点，每个节点能够存储1mb的数据，同时每个节点都是通过其路径可以唯一标识的。 （四）zookeeper企业应用场景 zookeeper服务包括：统一命名服务、统一配置管理、统一集群管理、软负载均衡等。 1.统一命名服务 命名服务是分布式系统中较为常见的一类场景，分布式系统中，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象等。通过命名服务，客户端可以根据指定名字来获取资源的实体、服务地址和提供者信息。例如一般用户都是通过域名来访问应用而不是ip。阿里开源分布式服务框架dubbo中使用zookeeper来作为其命名服务，维护全局的服务列表。 2.统一配置管理 （1）配置文件同步，集群中所有配置文件的信息都是一致的，对配置文件修改后，快速同步到各个节点上。 （2）zookeeper实现配置管理。将配置信息写入到zookeeper上的节点，然后各个客户端服务器监听这个节点，一但节点中的数据发生变化，zookeeper将通知到各个客户端服务器。 3.统一集群管理 zookeeper的两大特性：节点特性和watcher机制 （1）分布式环境中实时掌握每个节点的状态，并根据节点实时状态做出一定的调整。 （2）在实时监测到节点变化后，将节点的信息写入到zookeeper上的节点，通过监听该节点来获取它的实时状态变化。 4.负载均衡 zookeeperk实现负载均衡就是通过watcher机制和临时节点判断哪些节点宕机来获取可用的节点来实现的, zookeeperk会维护一个树形的数据结构，类似于window的资源管理器目录，其中 ephemeral(临时）节点会随着创建它的客户端端口而被删除，利用这个特性很容易实现软负载均衡。 5.服务器动态上下线 二、zookeeper的安装与配置 （一）zookeeper下载安装 1、zookeeper下载 下载地址：https://zookeeper.apache.org/releases.html#download 2．安装前准备 （1）安装jdk （2）拷贝zookeeper安装包到linux系统下 （3）解压到指定目录 tar -zxvf apache-zookeeper-3.4.10-bin.tar.gz -c /opt/pro/zk 3．配置修改 （1）将/opt/pro/zk/apache-zookeeper-3.4.10-bin/conf这个路径下的zoo_sample.cfg修改为zoo.cfg； mv zoo_sample.cfg zoo.cfg （2）打开zoo.cfg文件，修改datadir路径： vim zoo.cfg 修改如下内容： datadir=/opt/pro/zk/apache-zookeeper-3.4.10-bin/zkdata （3）在/opt/pro/zk/apache-zookeeper-3.4.10-bin这个目录上创建zkdata文件夹 mkdir zkdata 4．操作zookeeper （1）启动zookeeper 在/opt/pro/zk/apache-zookeeper-3.4.10-bin目录下执行 bin/zkserver.sh start （2）jps查看进程是否启动 4020 jps 4001 quorumpeermain （3）查看状态： 在/opt/pro/zk/apache-zookeeper-3.4.10-bin目录下执行 bin/zkserver.sh status 显示状态： zookeeper jmx enabled by default using config: /opt/pro/zk/apache-zookeeper-3.4.10-bin/bin/../conf/zoo.cfg mode: standalone （4）启动客户端： 在/opt/pro/zk/apache-zookeeper-3.4.10-bin目录下执行 bin/zkcli.sh （5）quit退出客户端： （6）停止zookeeper 在/opt/pro/zk/apache-zookeeper-3.4.10-bin目录下执行 bin/zkserver.sh stop （二）配置参数解读 zookeeper中的配置文件zoo.cfg中参数含义解读如下 1．ticktime =2000：通信心跳数，zookeeper服务器与客户端心跳时间，单位毫秒 zookeeper使用的基本时间，服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个ticktime时间就会发送一个心跳，时间单位为毫秒。 它用于心跳机制，并且设置最小的session超时时间为两倍心跳时间。(session的最小超时时间是2*ticktime) 2．initlimit =10：lf初始通信时限 集群中的follower跟随者服务器与leader领导者服务器之间初始连接时能容忍的最多心跳数（ticktime的数量），用它来限定集群中的zookeeper服务器连接到leader的时限。 3．synclimit =5：lf同步通信时限 集群中leader与follower之间的最大响应时间单位，假如响应超过synclimit * ticktime，leader认为follwer死掉，从服务器列表中删除follwer。 4．datadir：数据文件目录+数据持久化路径 主要用于保存zookeeper中的数据。 5．clientport =2181：客户端连接端口 监听客户端连接的端口。 三、zookeeper的内部原理 （一）选举机制 1）半数机制：集群中半数以上机器存活，集群可用。所以zookeeper适合安装奇数台服务器。 2）zookeeper虽然在配置文件中并没有指定master和slave。但是，zookeeper工作时，是有一个节点为leader，其他则为follower，leader是通过内部的选举机制临时产生的。 3）以一个简单的例子来说明整个选举的过程。 假设有五台服务器组成的zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么，如图所示。 图中zookeeper的选举机制 （1）服务器1启动，此时只有它一台服务器启动了，它发出去的报文没有任何响应，所以它的选举状态一直是looking状态。 （2）服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以id值较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3)，所以服务器1、2还是继续保持looking状态。 （3）服务器3启动，根据前面的理论分析，服务器3成为服务器1、2、3中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的leader。 （4）服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。 （5）服务器5启动，同4一样当小弟。 （二）节点类型 1.持久节点（persistent）：服务端和客户端断开连接后，创建的节点不删除； 持久化目录节点：服务端和客户端断开连接后，该节点仍然存在； 持久化顺序编号目录节点：服务端和客户端断开连接后，该节点仍然存在；只是zook给该节点名称进行顺序编号。 2.短暂节点(ephemeral)：服务端和客户端断开连接后，创建的节点自己删除； 临时目录节点：客户端与zookeeper断开连接后，该节点被删除 临时顺序编号目录节点：客户端与zookeeper断开连接后，该节点被删除，只是zook给该节点名称进行顺序编号。 注意：在分布式系统中，顺序号可以被用于为为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。节点上的顺序号是一个单调递增的计数器，由父节点维护。 （三）zookeepr写和读数据流程 （读写机制） 1.写数据流程 以3台服务器的zookeeper集群为例，一个leader，两个follower即server1和server2。 （1）client向zookeeper的server1发送一个写请求，客户端写数据到服务器1上； （2）如果server1不是leader，那么server1会把接收到的写请求转发给leader；然后leader会将写请求转发 给每个server； server1和server2负责写数据，并且两个follower的写入数据是一致的，保存相同的数据副本； server1和server2写数据成功后，通知leader; （3）当leader收到集群半数以上的节点写成功的消息后，说明该写操作执行成功； 例如：这里是3台服务器，只要2台follower服务器写成功就ok 因为client访问的是server1，所以leader会告知server1集群中数据写成功； （4）被访问的server1进一步通知client数据写成功，这时，客户端就知道整个写操作成功了。 2.读数据 相比写数据流程，读数据流程就简单得多；因为每台server中数据一致性都一样，所以随便访问哪台server 读数据就行；没有写数据流程中请求转发、数据同步、成功通知这些步骤。 二、zookeeper分布式安装部署 （一）集群规划 在zk01、zk02和zk04三个节点上部署zookeeper。 （二）集群中的角色和作用 a.leader角色 leader服务器是整个zookeeper集群的核心，主要的工作任务有两项 1. 事物请求的唯一调度和处理者，保证集群事物处理的顺序性 2. 集群内部各服务器的调度者 b.follower角色 follower角色的主要职责是 1. 处理客户端非事物请求、转发事物请求给leader服务器 2. 参与事物请求proposal 的投票（需要半数以上服务器 通过才能通知leader commit数据;leader发起的提案， 要求follower投票） 3. 参与leader选举的投票 c.observer角色 observer 是 zookeeper3.3 开始引入的一个全新的服务器 角色，从字面来理解，该角色充当了观察者的角色。 观察zookeeper集群中的最新状态变化并将这些状态变化 同步到 observer 服务器上。observer的工作原理与follower角色基本一致，而它和follower角色唯一的不同在于observer 不参与任何形式的投票，包括事物请求 proposal的投票和leader选举的投票。简单来说，observe服务器只提供非事物请求服务，通常在于不影响集群事物 处理能力的前下提升集群非事物处理的能力. （三）解压安装 （1）解压zookeeper安装包到/opt/pro/zk目录下 tar -zxvf apache-zookeeper-3.6.2-bin.tar.gz -c /opt/pro/zk （2）拷贝/opt/pro/zk/apache-zookeeper-3.6.2-bin目录内容到另外两台服务器。 （四）配置服务器编号 （1）在/opt/pro/zk/apache-zookeeper-3.6.2-bin这个目录下创建zkdata mkdir -p zkdata （2）在/opt/pro/zk/apache-zookeeper-3.6.2-bin/zkdata目录下创建一个myid的文件 touch myid 添加myid文件，注意一定要在linux里面创建，在notepad++里面很可能乱码 （3）编辑myid文件 vi myid 在文件中添加与server对应的编号2： （4）在其他两台服务器上分别创建zkdata目录，并在目录中创建myid文件，myid文件中内容为3、4 （五）配置zoo.cfg文件 （1）在三台服务器上重命名/opt/pro/zk/apache-zookeeper-3.6.2-bin/conf这个目录下的zoo_sample.cfg为zoo.cfg mv zoo_sample.cfg zoo.cfg （2）打开zoo.cfg文件 vim zoo.cfg 修改数据存储路径配置 datadir=/opt/pro/zk/apache-zookeeper-3.6.2-bin/zkdata 增加如下配置 #######################cluster########################## server.2=192.168.164.136:2888:3888 server.3=192.168.164.137:2888:3888 server.4=192.168.164.138:2888:3888 （3）其他两台服务器同样完成以上两步关于zoo.cfg配置文件的操作 （六）集群操作 （1）分别启动zookeeper bin/zkserver.sh start （2）查看状态 bin/zkserver.sh status 伪分布式 此处以伪集群为例搭建集群过程。\n第一台zookeeper配置 1. 把zookeeper进行解压缩命令名为zk01 2. 在zk01下创建一个data目录 mkdir data 3. 在data目录下创建一个myid文件,在文件输入1 4. 修改zoo.cfg clientport=2181 datadir=/usr/local/zkcluster/zk01/data server.1=192.168.18.201:2881:3881 server.2=192.168.18.201:2882:3882 server.3=192.168.18.201:2883:3883 第二台zookeeper配置 1. 把zookeeper进行解压缩命令名为zk02 2. 在zk02下创建一个data目录 mkdir data 3. 在data目录下创建一个myid文件,在文件输入2 4. 修改zoo.cfg clientport=2182 datadir=/usr/local/zkcluster/zk02/data server.1=192.168.18.201:2881:3881 server.2=192.168.18.201:2882:3882 server.3=192.168.18.201:2883:3883 第三台zookeeper配置 5. 把zookeeper进行解压缩命令名为zk03 6. 在zk03下创建一个data目录 mkdir data 7. 在data目录下创建一个myid文件,在文件输入3 8. 修改zoo.cfg clientport=2183 datadir=/usr/local/zkcluster/zk03/data server.1=192.168.18.201:2881:3881 server.2=192.168.18.201:2882:3882 server.3=192.168.18.201:2883:3883 一、zookeeper的常用命令 1．启动客户端 bin /zkcli.sh 2．显示所有操作命令 help 3．查看当前znode中所包含的内容 ls / 4．查看当前节点详细数据 ls –s / 5．分别创建2个普通节点 create /shuihu \u0026#34;songjiang\u0026#34; create /shuihu/liangshan \u0026#34;liubei\u0026#34; 6．获得节点的值 get /shuihu 7．创建短暂节点 create -e /shuihu/liangshan \u0026#34;likui\u0026#34; （1）在当前客户端是能查看到的 ls /shuihu （2）退出当前客户端然后再重启客户端 quit:退出 bin/zkcli.sh重新进入 （3）再次查看根目录下短暂节点已经删除 ls /shuihu 8．创建带序号的节点 （1）先创建一个普通的根节点/shuihu/liangshan create /shuihu/liangshan/daxia \u0026#34;yanqing\u0026#34; created /shuihu/liangshan/daxia （2）创建带序号的节点 create -s /shuihu/laingshan/yishi \u0026#34;lujunyi\u0026#34; 如果原来没有序号节点，序号从0开始依次递增。如果原节点下已有2个节点，则再排序时从2开始，以此类推。 9．修改节点数据值 set /shuihu/liangshan \u0026#34;lishishi\u0026#34; 10．节点的值变化监听 （1）在hadoop104主机上注册监听/shuihu节点数据变化 get /shuhui watch （2）在hadoop103主机上修改/shuihu节点的数据 set /shuihu \u0026#34;huangdi\u0026#34; （3）观察hadoop104主机收到数据变化的监听 watcher:: watchedevent state:syncconnected type:nodedatachanged path:/shuihu 11．节点的子节点变化监听（路径变化） （1）在hadoop104主机上注册监听/sanguo节点的子节点变化 ls /liangshan watch （2）在hadoop103主机/liangshan节点上创建子节点 create /shuihu/chaoting \u0026#34;huarong\u0026#34; （3）观察hadoop104主机收到子节点变化的监听 watcher:: watchedevent state:syncconnected type:nodechildrenchanged path:/shuihu 12．删除节点 delete /shuihu/chaoting 13．递归删除节点 deleteall /shuihu/liangshan 14．查看节点状态 stat /shuihu 二、zookeeper的api应用 （一）．创建一个maven工程 （二）．添加pom文件 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;release\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.logging.log4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;log4j-core\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.8.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.zookeeper\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;zookeeper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.6.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; （三）．log4j.properties文件 需要在项目的src/main/resources目录下，新建一个文件，命名为“log4j.properties”，在文件中填入。\nlog4j.rootlogger=info, stdout log4j.appender.stdout=org.apache.log4j.consoleappender log4j.appender.stdout.layout=org.apache.log4j.patternlayout log4j.appender.stdout.layout.conversionpattern=%d %p [%c] - %m%n log4j.appender.logfile=org.apache.log4j.fileappender log4j.appender.logfile.file=target/spring.log log4j.appender.logfile.layout=org.apache.log4j.patternlayout log4j.appender.logfile.layout.conversionpattern=%d %p [%c] - %m%n （四）.创建zookeeper客户端 4.1定义实例化zookeeper\nprivate static string connectstring = \u0026#34;192.168.164.136:2181,192.168.164.137:2181,192.168.164.138:2181\u0026#34;; private static int sessiontimeout = 60000; private zookeeper zkclient = null; @before public void init() throws exception { zkclient = new zookeeper(connectstring, sessiontimeout, new watcher() { public void process(watchedevent event) { // 收到事件通知后的回调函数（用户的业务逻辑） system.out.println(event.gettype() + \u0026#34;--\u0026#34; + event.getpath()); // 再次启动监听 try { zkclient.getchildren(\u0026#34;/\u0026#34;, true); } catch (exception e) { e.printstacktrace(); } } }); } 4.2 创建子节点\n// 创建子节点 @test public void create(){ // 参数1：要创建的节点的路径； 参数2：节点数据 ； 参数3：节点权限 ；参数4：节点的类型 try { string nodecreated = zkclient.create(\u0026#34;/offcn\u0026#34;, \u0026#34;youjiuye\u0026#34;.getbytes(), zoodefs.ids.open_acl_unsafe, createmode.persistent); } catch (keeperexception e) { e.printstacktrace(); } catch (interruptedexception e) { e.printstacktrace(); } } 4.3获取子节点并监听节点变化\n// 获取子节点 @test public void getchildren() throws exception { list\u0026lt;string\u0026gt; children = zkclient.getchildren(\u0026#34;/\u0026#34;, true); for (string child : children) { system.out.println(child); } // 延时阻塞 thread.sleep(long.max_value); } 4.4 判断znode是否存在\n// 判断znode是否存在 @test public void exist() throws exception { stat stat = zkclient.exists(\u0026#34;/shuihu\u0026#34;, false); system.out.println(stat == null ? \u0026#34;not exist\u0026#34; : \u0026#34;exist\u0026#34;); } ","date":"2022-05-26","permalink":"https://lovemjh.vercel.app/posts/tool/20220526205691/","summary":"Zookeeper 一、Zookeeper的介绍 （一）Zookeeper概述 1.介绍 Zookeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。它是一种集","title":"zookeeper"},{"content":"延迟加载策略 延迟加载的简介：什么是延迟加载，为什么要使用延迟加载 1.什么是延迟加载? 延迟加载(lazy load)是(也称为懒加载)关联关系对象默认的加载方式，延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓延迟加载就是当在真正需要数据的时候，才真正执行数据加载操作。 延迟加载，可以简单理解为，只有在使用的时候，才会发出sql语句进行查询。 2.为什么要使用延迟加载? 减少访问数据库的频率，我们要访问的数据量过大时，明显用缓存不太合适，因为内存容量有限为了减少并发量，减少系统资源的消耗。 配置延迟加载策略，并测试结果 在mybatis中使用resultmap来实现一对一，一对多，多对多关系的操作。主要是通过 association、collection 实现一对一及一对多映射。association、collection 具备延迟加载功能。 局部延时加载 departmentdao.xml配置文件 \u0026lt;select id=\u0026#34;getdepartmentbyid\u0026#34; resultmap=\u0026#34;departemntresultmap\u0026#34;\u0026gt; select * from department where d_id=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;departemntresultmap\u0026#34; type=\u0026#34;department\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;d_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;d_name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;emps\u0026#34; oftype=\u0026#34;employee\u0026#34; column=\u0026#34;d_id\u0026#34; select=\u0026#34;cn.offcn.mapper.employeemapper.getemployeebydepartid\u0026#34; fetchtype=”lazy”\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultmap\u0026gt; 相关联的查询标签上加 fetchtype=”lazy” fetchtype默认值为eager 立即加载,lazy为延时加载。 测试类 @test public void testgetdepartentbyid() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 departmentdao departmentdao = session.getmapper(departmentdao.class); department dept=departmentdao.getdepartentbyid(1); //打印 system.out.println(dept.getname); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } 2.全局延时加载 如果希望所有关联都需要延时加载，可以在mybatis的核心配置文件中进行配置，不用在collection或association中指定。默认全局开启。\n\u0026lt;settings\u0026gt; \u0026lt;!--开启延时加载开关--\u0026gt; \u0026lt;setting name=\u0026#34;lazyloadingenabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!--关闭立即加载，实施按需加载--\u0026gt; \u0026lt;setting name=\u0026#34;aggressivelazyloading\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; mybatis的逆向工程 逆向工程绍 mybatis的一个主要的特点就是需要程序员自己编写sql，那么如果表太多的话，难免会很麻烦，所以mybatis官方提供了一个逆向工程，可以针对单表自动生成mybatis执行所需要的代码（包括mapper.xml、mapper.java、po..）。一般在开发中，常用的逆向工程方式是通过数据库的表生成代码。\n构建项目环境 构建maven工程并导入依赖 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis.generator\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-generator-core\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.3.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;log4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;log4j\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写配置框架配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;!doctype configuration public \u0026#34;-//mybatis.org//dtd config 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026#34;db.properties\u0026#34;\u0026gt;\u0026lt;/properties\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;lazyloadingenabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!--开启二级缓存--\u0026gt; \u0026lt;setting name=\u0026#34;cacheenabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;typealiases\u0026gt; \u0026lt;package name=\u0026#34;cn.offcn.entity\u0026#34;\u0026gt;\u0026lt;/package\u0026gt; \u0026lt;/typealiases\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026#34;com.github.pagehelper.pageinterceptor\u0026#34;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionmanager type=\u0026#34;jdbc\u0026#34;\u0026gt;\u0026lt;/transactionmanager\u0026gt; \u0026lt;datasource type=\u0026#34;pooled\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/datasource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--在核心配置文件中注册mapper--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;cn.offcn.mapper\u0026#34;\u0026gt;\u0026lt;/package\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 编写逆向工程的配置文件generator.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype generatorconfiguration public \u0026#34;-//mybatis.org//dtd mybatis generator configuration 1.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt; \u0026lt;generatorconfiguration\u0026gt; \u0026lt;context id=\u0026#34;testtables\u0026#34; targetruntime=\u0026#34;mybatis3\u0026#34;\u0026gt; \u0026lt;commentgenerator\u0026gt; \u0026lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --\u0026gt; \u0026lt;property name=\u0026#34;suppressallcomments\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/commentgenerator\u0026gt; \u0026lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --\u0026gt; \u0026lt;jdbcconnection driverclass=\u0026#34;com.mysql.jdbc.driver\u0026#34; connectionurl=\u0026#34;jdbc:mysql://localhost:3306/mybatis828_002\u0026#34; userid=\u0026#34;root\u0026#34; password=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;/jdbcconnection\u0026gt; \u0026lt;!-- 默认false，把jdbc decimal 和 numeric 类型解析为 integer，为 true时把jdbc decimal 和 numeric 类型解析为java.math.bigdecimal --\u0026gt; \u0026lt;javatyperesolver\u0026gt; \u0026lt;property name=\u0026#34;forcebigdecimals\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/javatyperesolver\u0026gt; \u0026lt;!-- targetproject:生成实体类的位置 --\u0026gt; \u0026lt;javamodelgenerator targetpackage=\u0026#34;cn.offcn.entity\u0026#34; targetproject=\u0026#34;.\\src\\main\\java\u0026#34;\u0026gt; \u0026lt;!-- enablesubpackages:是否让schema作为包的后缀 --\u0026gt; \u0026lt;property name=\u0026#34;enablesubpackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;!-- 从数据库返回的值被清理前后的空格 --\u0026gt; \u0026lt;property name=\u0026#34;trimstrings\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/javamodelgenerator\u0026gt; \u0026lt;!-- targetproject:mapper映射文件生成的位置 --\u0026gt; \u0026lt;sqlmapgenerator targetpackage=\u0026#34;cn.offcn.mapper\u0026#34; targetproject=\u0026#34;.\\src\\main\\java\u0026#34;\u0026gt; \u0026lt;!-- enablesubpackages:是否让schema作为包的后缀 --\u0026gt; \u0026lt;property name=\u0026#34;enablesubpackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/sqlmapgenerator\u0026gt; \u0026lt;!-- targetpackage：mapper接口生成的位置 --\u0026gt; \u0026lt;javaclientgenerator type=\u0026#34;xmlmapper\u0026#34; targetpackage=\u0026#34;cn.offcn.mapper\u0026#34; targetproject=\u0026#34;.\\src\\main\\java\u0026#34;\u0026gt; \u0026lt;!-- enablesubpackages:是否让schema作为包的后缀 --\u0026gt; \u0026lt;property name=\u0026#34;enablesubpackages\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/javaclientgenerator\u0026gt; \u0026lt;!-- 指定数据库表 --\u0026gt; \u0026lt;table tablename=\u0026#34;department\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tablename=\u0026#34;employee\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tablename=\u0026#34;person\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tablename=\u0026#34;idcard\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tablename=\u0026#34;student\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tablename=\u0026#34;teacher_student\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;table tablename=\u0026#34;teacher\u0026#34;\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorconfiguration\u0026gt; 调用官方api实现逆向工程 package cn.test; import org.mybatis.generator.api.mybatisgenerator; import org.mybatis.generator.config.configuration; import org.mybatis.generator.config.xml.configurationparser; import org.mybatis.generator.internal.defaultshellcallback; import java.io.file; import java.util.arraylist; import java.util.list; public class generatortest { public static void main(string[] args) throws exception{ list\u0026lt;string\u0026gt; warnings = new arraylist\u0026lt;string\u0026gt;(); boolean overwrite = true; //指定 逆向工程配置文件 file configfile = new file(\u0026#34;f:\\\\828class\\\\workspace\\\\mybatis\\\\mybatis004_reflect\\\\generatorconfig.xml\u0026#34;); configurationparser cp = new configurationparser(warnings); configuration config = cp.parseconfiguration(configfile); defaultshellcallback callba ck = new defaultshellcallback(overwrite); mybatisgenerator mybatisgenerator = new mybatisgenerator(config, callback, warnings); mybatisgenerator.generate(null); } } 逆向工程自动生成的文件解析 使用逆向工程完成数据crud //添加员工 public static void addemployee(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employee employee=new employee(); employee.setename(\u0026#34;马大力\u0026#34;); employee.setegender(\u0026#34;男\u0026#34;); employee.seteage(23); employee.setedepartid(1); employeemapper.insert(employee); session.commit(); mybatisutils.close(session); } //根据id查询员工 public static void queryemployeebyid(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employee emp=employeemapper.selectbyprimarykey(2); system.out.println(emp); session.commit(); mybatisutils.close(session); } //根据年龄查询员工 public static void queryemployeebyage(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employeeexample employeeexample=new employeeexample(); employeeexample.criteria criteria=employeeexample.createcriteria(); criteria.andeagegreaterthan(20); list\u0026lt;employee\u0026gt; employeelist=employeemapper.selectbyexample(employeeexample); for (employee employee : employeelist) { system.out.println(employee); } session.commit(); mybatisutils.close(session); } //根据年龄和性别查询员工 public static void queryemployeebyageandgender(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employeeexample employeeexample=new employeeexample(); employeeexample.criteria criteria=employeeexample.createcriteria(); criteria.andeagegreaterthan(20); criteria.andegenderequalto(\u0026#34;男\u0026#34;); list\u0026lt;employee\u0026gt; employeelist=employeemapper.selectbyexample(employeeexample); for (employee employee : employeelist) { system.out.println(employee); } session.commit(); mybatisutils.close(session); } //根据id修改员工 public static void updateemployeebyid(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employee employee= employeemapper.selectbyprimarykey(1); employee.setegender(\u0026#34;女\u0026#34;); employee.setedepartid(2); employeemapper.updatebyprimarykey(employee); session.commit(); mybatisutils.close(session); } //根据id删除员工 public static void deleteemployeebyid(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employeemapper.deletebyprimarykey(10); session.commit(); mybatisutils.close(session); } //根据姓名更新员工 public static void updateemployeebyname(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employee employee= employeemapper.selectbyprimarykey(1); employee.setegender(\u0026#34;男\u0026#34;); employee.seteage(24); employeeexample employeeexample=new employeeexample(); employeeexample.criteria criteria = employeeexample.createcriteria(); criteria.andenameequalto(employee.getename()); employeemapper.updatebyexample(employee,employeeexample); session.commit(); mybatisutils.close(session); } //分页查询员工 public static void queryemployees(int currentpage,int pagesize){ pagehelper.startpage(currentpage,pagesize); sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employeeexample employeeexample=new employeeexample(); list\u0026lt;employee\u0026gt; employeelist=employeemapper.selectbyexample(employeeexample); pageinfo\u0026lt;employee\u0026gt; pageinfo=new pageinfo\u0026lt;\u0026gt;(employeelist); list\u0026lt;employee\u0026gt; emplist=pageinfo.getlist(); //取当前页的所有记录 long totalrecored=pageinfo.gettotal();//总记录数 int totalpages=pageinfo.getpages(); //总页数 system.out.println(\u0026#34;总记录数:\u0026#34;+totalrecored); system.out.println(\u0026#34;总页数:\u0026#34;+totalpages); for (employee employee : emplist) { system.out.println(employee); } session.commit(); mybatisutils.close(session); } //根据性别和部门查询员工 public static void queryemployeebygendernum(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employeeexample employeeexample=new employeeexample(); employeeexample.criteria criteria = employeeexample.createcriteria(); criteria.andegenderequalto(\u0026#34;男\u0026#34;); criteria.andedepartidequalto(1); long count= employeemapper.countbyexample(employeeexample); system.out.println(count); session.commit(); mybatisutils.close(session); } //根据部门查询员工 public static employee queryemployeedepartmentbyid(int eid){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); employee employee=employeemapper.selectbyprimarykey(eid); //查部门 departmentmapper departmentmapper=session.getmapper(departmentmapper.class); department department=departmentmapper.selectbyprimarykey(employee.getedepartid()); employee.setdepart(department); session.commit(); mybatisutils.close(session); return employee; } public static void main(string[] args) { addemployee(); queryemployeebyid(); queryemployeebyage(); queryemployeebyageandgender(); updateemployeebyid(); updateemployeebyname(); deleteemployeebyid(); queryemployees(); queryemployeebygendernum(); employee employee=queryemployeedepartmentbyid(1); system.out.println(employee.getename()+\u0026#34;\\t\u0026#34; +employee.getdepart().getdname()); queryemployees(1,2); } mybatis 缓存 缓存简介 缓存是存在于内存中的临时数据，使用缓存的目的是减少和数据库的交互次数，提高执行效率。像大多数的持久化框架一样，mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能，mybatis 中缓存分为一级缓存，二级缓存。\n一级缓存 一级缓存介绍 mybatis一级缓存一种是session级别的，针对同一个会话sqlsession中，执行多次条件完全相同的同一个sql，那么会共享这一缓存。\n一级缓存结构图 编写用户持久层 dao 接口 public interface employeedao { public employee getemployeebyid(int id); } 编写用户持久层映射文件 \u0026lt;select id=\u0026#34;getemployeebyid\u0026#34; resultmap=\u0026#34;employeeresultmap\u0026#34;\u0026gt; select * from employee where e_id=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;employeeresultmap\u0026#34; type=\u0026#34;employee\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;e_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;e_name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;e_gender\u0026#34; property=\u0026#34;gender\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;e_age\u0026#34; property=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultmap\u0026gt; 编写测试方法 public static void firstcahce(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); //第一次查询 employee employee1=employeemapper.getemployeebyid(1); system.out.println(employee1.getname()); //第二次查询 employee employee2=employeemapper.getemployeebyid(1); system.out.println(employee2.getname()); mybatisutils.close(session); } 一级缓存的分析 从上面的代码可以出，我们写了两次查询操作，但在访问数据时，只有一次。第一次先从一级缓存中获取，因为session是新创建的，一级缓存中没有数据，于是就查询数据获取数据，然后把查询的数据放到一级缓存中，此时一定要注意的是，一级缓存是一个map集合，map的key是你的查询条件字符串，值就是查询出来的对象。等第二次查询时，先从一缓存中获取，因为上一次查询后已经放到一级缓存中了，所以从一级缓存中获取到了，就不用访问数据库了，减少和数据次的一次交互，提高了执行效率。 测试一级缓存的清空 当我们在两次查询之间做增、删、改操作都会把一级缓存清空，因为不清空就不能保证缓存中的数据与数据库中数据的一致性，可能会读取不正确的数据。 public static void firstcahce(){ sqlsession session = mybatisutils.getsession(); employeemapper employeemapper=session.getmapper(employeemapper.class); //第一次查询 employee employee1=employeemapper.getemployeebyid(1); system.out.println(employee1.getname()); //新增员工 employeemapper.addemployee(new employee(\u0026#34;张小志\u0026#34;,\u0026#34;男\u0026#34;,18)); //第二次查询 employee employee2=employeemapper.getemployeebyid(1); system.out.println(employee2.getname()); mybatisutils.close(session); } 二级缓存 二级缓存简介 二级缓存是 mapper 映射级别的缓存，多个 sqlsession 去操作同一个 mapper 映射的 sql 语句，多个 sqlsession 可以共用二级缓存，二级缓存是跨 sqlsession 的。\n二级缓存结构图 二级缓存的开启与关闭 在sqlmapconfig.xml 文件开启二级缓存 \u0026lt;settings\u0026gt; \u0026lt;!-- 开启二级缓存的支持 --\u0026gt; \u0026lt;setting name=\u0026#34;cacheenabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; 因为 cacheenabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为 false 代表不开启二级缓存。 配置相关的 mapper 映射文件 \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.dao.employeedao\u0026#34;\u0026gt; \u0026lt;!-- 开启二级缓存的支持 --\u0026gt; \u0026lt;cache\u0026gt;\u0026lt;/cache\u0026gt; \u0026lt;/mapper\u0026gt; 配置 statement 上面的 usecache 属性 \u0026lt;select id=\u0026#34;getemployeebyid\u0026#34; resultmap=\u0026#34;employeeresultmap\u0026#34; usecache=\u0026#34;true\u0026#34;\u0026gt; select * from employee where e_id=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;employeeresultmap\u0026#34; type=\u0026#34;employee\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;e_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;e_name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;e_gender\u0026#34; property=\u0026#34;gender\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;e_age\u0026#34; property=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultmap\u0026gt; 将 employeedao.xml 映射文件中的\u0026lt;select\u0026gt;标签中设置 usecache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。 注意：针对每次查询都需要最新的数据 sql，要设置成 usecache=false，禁用二级缓存。 二级缓存测试 public static void secondcahce(){ sqlsession session1 = mybatisutils.getsession(); sqlsession session2 = mybatisutils.getsession(); employeemapper employeemapper1=session1.getmapper(employeemapper.class); //第一次查询 employee employee1=employeemapper1.getemployeebyid(1); system.out.println(employee1.getname()); session1.commit(); mybatisutils.close(session1); //第二次查询 employeemapper employeemapper2=session2.getmapper(employeemapper.class); employee employee2=employeemapper2.getemployeebyid(1); system.out.println(employee2.getname()); session2.commit(); mybatisutils.close(session2); } 经过上面的测试，我们发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二 次查询时，我们发现并没有对数据库发出 sql 语句，所以此时的数据就只能是来自于我们所说的二级缓存。 mybatis分页插件 分页插件的介绍 分页是一种将所有数据分段展示给用户的技术.用户每次看到的不是全部数据,而是其中的一部分,如果在其中没有找到自己想要的内容,用户可以通过制定页码或是翻页的方式转换可见内容,直到找到自己想要的内容为止。\n分页的的好处：\n1.提高性能，一次查20个，比一次查20000个性能肯定更好；另外如果数据量很大，一次性将内容都查询出来，查询出来的结果是放在内存存里面的，会增加cpu的开销造成内存的浪费，效率极低。\n2.展现层面的考虑：如果一次展现太多的数据，不管是排版，还是美观上都不好。\n分页插件的引入和配置 1.在pom.xml中引入插件依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.github.pagehelper\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;pagehelper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.在mybatis核心配置文件中进行配置 \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026#34;com.github.pagehelper.pageinterceptor\u0026#34;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; 定义接口方法getinfo public class employeedao{ public void getinfo(); } 配置sql语句对应接口方法 \u0026lt;select id=\u0026#34;getinfo\u0026#34; resulttype=\u0026#34;cn.offcn.entity.employee\u0026#34;\u0026gt; select * from employee \u0026lt;/select\u0026gt; 测试分页插件作用 @test public void queryemployees(){ //在查询前设置当前页与每页显示的记录数 pagehelper.startpage(1,5); sqlsession session = mybatisutils.getsession(); employeedao employeedao=session.getmapper(employeedao.class); //查询 list\u0026lt;employee\u0026gt; employeelist=employeedao.getinfo(); //创建一个pageinfo对象，把查询出的结果集合当做参数传入 pageinfo\u0026lt;employee\u0026gt; pageinfo=new pageinfo\u0026lt;\u0026gt;(employeelist); list\u0026lt;employee\u0026gt; emplist=pageinfo.getlist(); //取当前页的所有记录 long totalrecored=pageinfo.gettotal();//总记录数 int totalpages=pageinfo.getpages(); //总页数 system.out.println(\u0026#34;总记录数:\u0026#34;+totalrecored); system.out.println(\u0026#34;总页数:\u0026#34;+totalpages); for (employee employee : emplist) { system.out.println(employee); } session.commit(); mybatisutils.close(session); } mybatis的注解开发 注解开发的背景介绍 注解提供了一种简单的方式来实现简单映射语句,而不会引入大量的开销。能够读懂别人写的代码，特别是框架相关的代码。本来可能需要很多配置文件，需要很多逻辑才能实现的内容，就可以使用一个或者多个注解来替代，这样就使得编程更加简洁，代码更加清晰。 常用注解介绍 这几年来注解开发越来越流行，mybatis 也可以使用注解开发方式，这样我们就可以减少编写 mapper 映射文件了。本次我们先围绕一些基本的 crud 来学习，再学习复杂映射关系及延迟加载。 @insert:实现新增 @update:实现更新 @delete:实现删除 @select:实现查询 @result:实现结果集封装 @results:可以与@result 一起使用，封装多个结果集 @resultmap:实现引用@results 定义的封装 @one:实现一对一结果集封装 @many:实现一对多结果集封装 @selectprovider: 实现动态 sql 映射 @cachenamespace:实现注解二级缓存的使用 项目环境搭建 构建maven工程，导入依赖 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;log4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;log4j\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 使用 mybatis 注解实现基本 crud 编写实体类 public class worker { private integer id; private string name; private string gender; private integer age; public worker(){} public worker(string name, string gender, integer age) { this.name = name; this.gender = gender; this.age = age; } public integer getid() { return id; } public void setid(integer id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getgender() { return gender; } public void setgender(string gender) { this.gender = gender; } public integer getage() { return age; } public void setage(integer age) { this.age = age; } @override public string tostring() { return \u0026#34;worker{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, gender=\u0026#39;\u0026#34; + gender + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 使用注解方式开发持久层接口 public interface workermapper { @insert(\u0026#34;insert into worker (w_name,w_gender,w_age) \u0026#34; + \u0026#34;values(#{name},#{gender},#{age})\u0026#34;) public void saveworker(worker worker); @update(\u0026#34;update worker set w_name=#{name},w_gender=#{gender},w_age=#{age} where w_id=#{id}\u0026#34;) public void updateworker(worker worker); @delete(\u0026#34;delete from worker where w_id=#{id}\u0026#34;) public void deleteworkerbyid(integer id); @select(\u0026#34;select * from worker where w_id=#{id}\u0026#34;) @results({ @result(column = \u0026#34;w_id\u0026#34;,property=\u0026#34;id\u0026#34;), @result(column = \u0026#34;w_name\u0026#34;,property=\u0026#34;name\u0026#34;), @result(column = \u0026#34;w_gender\u0026#34;,property=\u0026#34;gender\u0026#34;), @result(column = \u0026#34;w_age\u0026#34;,property=\u0026#34;age\u0026#34;) }) public worker getworkerbyid(integer id); @select(\u0026#34;select * from worker\u0026#34;) @results({ @result(column = \u0026#34;w_id\u0026#34;,property=\u0026#34;id\u0026#34;), @result(column = \u0026#34;w_name\u0026#34;,property=\u0026#34;name\u0026#34;), @result(column = \u0026#34;w_gender\u0026#34;,property=\u0026#34;gender\u0026#34;), @result(column = \u0026#34;w_age\u0026#34;,property=\u0026#34;age\u0026#34;) }) public list\u0026lt;worker\u0026gt; getworkers(); } 编写 sqlmapconfig 配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype configuration public \u0026#34;-//mybatis.org//dtd config 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 配置 mybatis的环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置环境 --\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置事务的类型 --\u0026gt; \u0026lt;transactionmanager type=\u0026#34;jdbc\u0026#34;\u0026gt;\u0026lt;/transactionmanager\u0026gt; \u0026lt;!-- 配置连接数据库的信息:用的是数据源【连接池】--\u0026gt; \u0026lt;datasource type=\u0026#34;pooled\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/datasource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;cn.offcn.dao\u0026#34;\u0026gt;\u0026lt;/package\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 编写测试方法 import cn.offcn.dao.workermapper; import cn.offcn.entity.worker; import cn.offcn.utils.mybatisutils; import org.apache.ibatis.session.sqlsession; import org.junit.test; import java.util.list; public class workertest { @test public void testsaveworker(){ sqlsession session = mybatisutils.getsession(); workermapper workermapper = session.getmapper(workermapper.class); worker worker=new worker(\u0026#34;白晓云\u0026#34;,\u0026#34;女\u0026#34;,20); workermapper.saveworker(worker); session.commit(); mybatisutils.close(session); } @test public void testupdateworker(){ sqlsession session = mybatisutils.getsession(); workermapper workermapper = session.getmapper(workermapper.class); worker worker=new worker(1,\u0026#34;白晓云\u0026#34;,\u0026#34;男\u0026#34;,22); workermapper.updateworker(worker); session.commit(); mybatisutils.close(session); } @test public void testdeleteworkerbyid(){ sqlsession session = mybatisutils.getsession(); workermapper workermapper = session.getmapper(workermapper.class); workermapper.deleteworkerbyid(1); session.commit(); mybatisutils.close(session); } @test public void testgetworkerbyid(){ sqlsession session = mybatisutils.getsession(); workermapper workermapper = session.getmapper(workermapper.class); worker worker= workermapper.getworkerbyid(2); system.out.println(worker); mybatisutils.close(session); } @test public void testgetworkers(){ sqlsession session = mybatisutils.getsession(); workermapper workermapper = session.getmapper(workermapper.class); list\u0026lt;worker\u0026gt; workerlist=workermapper.getworkers(); workerlist.foreach(system.out::println); mybatisutils.close(session); } } 使用注解实现复杂关系映射开发 复杂关系映射的注解介绍 @results 注解 代替的是标签\u0026lt;resultmap\u0026gt; 该注解中可以使用单个@result 注解，也可以使用@result 集合 @results（{@result（），@result（）}）或@results（@result（）） @resutl 注解 代替了 \u0026lt;id\u0026gt; 标签和\u0026lt;result\u0026gt; 标签 @result 中 属性介绍： id 是否是主键字段 column 数据库的列名 property 需要装配的属性名 one 需要使用的@one 注解（@result（one=@one）（））） many 需要使用的@many 注解（@result（many=@many）（））） @one 注解（一对一） 代替了\u0026lt;assocation\u0026gt; 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @one 注解属性介绍： select 指定用的 来多表查询的 sqlmapper fetchtype 会覆盖全局的配置参数 lazyloadingenabled。 使用格式： @result(column=\u0026#34; \u0026#34;,property=\u0026#34;\u0026#34;,one=@one(select=\u0026#34;\u0026#34;)) @many 注解（多对一） 代替了\u0026lt;collection\u0026gt; 标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的 java 实体类的属性，属性的 javatype （一般为 arraylist）但是注解中可以不定义； 使用格式： @result(property=\u0026#34;\u0026#34;,column=\u0026#34;\u0026#34;,many=@many(select=\u0026#34;\u0026#34;)) 使用注解实现一对一复杂关系映射及延迟加载 添加 person实体类及 idcard 实体类 person实体类: public class person { private int id; private string name; private idcard idcard; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public idcard getidcard() { return idcard; } public void setidcard(idcard idcard) { this.idcard = idcard; } } idcard实体类: public class idcard { private int id; private string cardno; private date uselife; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getcardno() { return cardno; } public void setcardno(string cardno) { this.cardno = cardno; } public date getuselife() { return uselife; } public void setuselife(date uselife) { this.uselife = uselife; } } 添加idcard的持久层接口并使用注解配置 public interface idcardmapper { @select(\u0026#34;select * from idcard where c_id=#{id}\u0026#34;) @results({ @result(column = \u0026#34;c_id\u0026#34;,property = \u0026#34;id\u0026#34;), @result(column = \u0026#34;c_cardno\u0026#34;,property = \u0026#34;cardno\u0026#34;), @result(column = \u0026#34;e_uselife\u0026#34;,property = \u0026#34;uselife\u0026#34;) }) public idcard getidcardbypersonid(int id); } 添加person持久层接口并使用注解配置 public interface personmapper { @select(select * from person where p_id=#{id}) @results({ @result(column = \u0026#34;p_id\u0026#34;,property = \u0026#34;id\u0026#34;), @result(column = \u0026#34;p_name\u0026#34;,property = \u0026#34;name\u0026#34;), @result(property = \u0026#34;idcard\u0026#34;, javatype = idcard.class, column = \u0026#34;p_id\u0026#34;, one = @one(select = \u0026#34;cn.offcn.dao.idcarddao.getidcardbypersonid\u0026#34;,fetchtype = fetchtype.lazy) ) }) public person getpersonbyid(int id); } 测试一对一关联及延迟加载 @test public void testgetpersonbyid(){ sqlsession session=mybatisutils.getsession(); personmapper personmapper=session.getmapper(personmapper.class); person person=personmapper.getpersonbyid(1); system.out.println(person) mybatisutils.close(session); } 使用注解实现一对多复杂关系映射 构建department和employee实体类 department实体类: public class department { private int id; private string name; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } } employee实体类: public class employee { private int id; private string name; private string gender; private integer age; public employee(){} public employee(int id,string name, string gender, int age) { this.id=id; this.name = name; this.gender = gender; this.age = age; } public employee(string name, string gender, int age) { this.name = name; this.gender = gender; this.age = age; } public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getgender() { return gender; } public void setgender(string gender) { this.gender = gender; } public integer getage() { return age; } public void setage(integer age) { this.age = age; } } department实体类加入 list\u0026lt;employee\u0026gt; private list\u0026lt;employee\u0026gt; emps; public list\u0026lt;employee\u0026gt; getemps() { return emps; } public void setemps(list\u0026lt;employee\u0026gt; emps) { this.emps = emps; } 编写employeemapper持久层接口并使用注解配置 public interface employeemapper{ @select(\u0026#34;select * from employee where e_depart_id=#{id}\u0026#34;) @results({ @result(column = \u0026#34;e_id\u0026#34;,property = \u0026#34;id\u0026#34;), @result(column = \u0026#34;e_name\u0026#34;,property = \u0026#34;name\u0026#34;), @result(column = \u0026#34;e_gender\u0026#34;,property = \u0026#34;gender\u0026#34;), @result(column = \u0026#34;e_age\u0026#34;,property = \u0026#34;age\u0026#34;) }) public list\u0026lt;employee\u0026gt; getemployeebydepartid(int id); } 编写departmentmapper持久层接口并使用注解配置 public interface departmentdao { @select(\u0026#34;select d_id id,d_name name from department where d_id=#{id}\u0026#34;) public department getdepartmentbyid(int id); @select(\u0026#34;select * from department where d_id=#{id}\u0026#34;) @results({ @result(column = \u0026#34;d_id\u0026#34;,property = \u0026#34;id\u0026#34;), @result(column = \u0026#34;d_name\u0026#34;,property = \u0026#34;name\u0026#34;), @result(property = \u0026#34;emps\u0026#34;, column = \u0026#34;d_id\u0026#34;, many = @many(select = \u0026#34;cn.offcn.dao.employeemapper.getemployeebydepartid\u0026#34;,fetchtype = fetchtype.lazy)) }) public department getdepartmentbyid(int id); } 添加测试方法 public void testgetdepartmentbyid(){ sqlsession session=mybatisutils.getsession(); departmentmapper departmentmapper=session.getmapper(departmentmapper.class); department department=departmentmapper.getdepartmentbyid(1); system.out.println(department) mybatisutils.close(session); } ","date":"2022-05-25","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220430215722/","summary":"延迟加载策略 延迟加载的简介：什么是延迟加载，为什么要使用延迟加载 1.什么是延迟加载? 延迟加载(lazy load)是(也称为懒加载)关联关系对象默认的加载方式，延","title":"mybatis-3"},{"content":"一 spring概述 （一） spring是什么（掌握） 话术： spring是一个分层的java se/ee full-stack（一站式）轻量级开源框架，以 ioc（inverse of control：反转控制，控制翻转， 控制反向）和 aop（aspect oriented programming：面向切面编程）为内核。 在java三层架构当中分别提供了相应技术： 表现层（web层） ：springmvc 框架，servlet 业务层（service层） ：bean管理（ioc容器，在三层都有体现） 声明式事务 持久层（dao层） ：jdbctemplate模板对象以及提供了orm模块整合其他优秀的持久层技术 ps: 工具统一配置： 文件的忽略~ 设置文件的编码： utf-8 必须设置 工程统一maven： maven的版本信息 maven的配置信息 maven 的本地仓库 【必须配置】 配置当前工程的自动编译： compile当中~ 配置自动导报： 忽略大小写进行代码提示： （二） spring框架发展历程（了解） 话术： oracle： java mysql oracle websphere ibm: db2 eclipse 1997 年，ibm提出了ejb 的思想 1998 年，sun制定开发标准规范 ejb1.0 1999 年，ejb1.1 发布 2001 年，ejb2.0 发布 2003 年，ejb2.1 发布 2006 年，ejb3.0 发布 rod johnson （ spring 之父） expert one-to-one j2ee design and development(2002) 阐述了 j2ee 使用ejb 开发设计的优点及解决方案 expert one-to-one j2ee development without ejb(2004) 阐述了 j2ee 开发不使用 ejb的解决方式（spring 雏形） 2017 年 9 月份发布了 spring 的最新版本 spring5.0 通用版（ga） （三）spring框架的优势(掌握) 方便解耦，简化开发:spring 就是一个大工厂，可以管理所有对象的创建和依赖关系维护，交给spring管理 aop 编程的支持：可以方便的实现对程序进行权限拦截，日志记录，运行的监控 声明式事务的支持：通过配置方式完成对事务的管理，无需手动编程 方便程序的测试：对junit支持，可以通过注解方便的对spring程序进行测试 整合外部优秀技术：spring内部提供了对各种优秀框架（hibernate，mybatis，quartz等）的直接支持 javaee技术的封装 ：spring对javaee开发当中复杂难用的api（javaemail, rmi等）进行封装，降低了这些api的使用难度。 （四） spring的体系结构（掌握） spring的核心是容器（ioc）： beans core context spel表达式 中间层技术：aop aspects aop web： servler springmvc data access： 数据访问层： jdbc orm 整合外部的优秀框架 transaction 事务 基于test测试： spring 整合junit junit4.x 官方网站： https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core 二 程序的耦合和解耦合 （一） 什么是程序的耦合 话术： 程序的耦合是程序之间的关联性，也就是多个类的联系是否紧密，多个对象之间的关系是否密切。 耦合度高： （1）不利于扩展 （2）不利于程序的维护。 生活中的案例： 你的房子里面有窗子，那么房子和窗子就有了关联 耦合度是松还是紧就看你的关联是强还是弱，也就是修改的代价，比如你窗子是扣死在墙里的那么你修改窗子就必须修改墙 这就比较紧密了，反应在程序上就是耦合度高，不利于程序的扩展和维护。 但是如果你窗子是按照某种规格的 可以自由拆装的，那么修改的代价就小，耦合度也就低了，反应在程序上就是耦合度低，利于程序的扩展和维护。 我们写程序的目标就是 高内聚 低耦合！ 这样修改起来 就不会有太多的联系，不用改一个地方其他的都要修改。 （二） 解决程序耦合的思路 1 编译不依赖，运行时才依赖 当我们讲解jdbc时，是通过反射来注册驱动的，代码如下:\nclass.forname(\u0026#34;com.mysql.jdbc.driver\u0026#34;);//使用的驱动类是指定了一个字符串 底层： drivermanager.regist(new com.mysql.jdbc.driver()); connection connection = drivermanager.getconnection(\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;); ​ 此时的好处式，我们的类中在编译阶段不再需要具体的驱动类，就算删除mysql的驱动jar包，依然可以通过编译。在运行阶段才会依赖驱动包。实际开发当中，我们应该做到编译不依赖，运行时才依赖。\n​ 上述代码产生的新问题，mysql驱动类的全限定类名作为一个字符串java类中是写死的，一旦发生改变，还需要修改源码。\n​ 使用配置文件结合反射就可以解决上述问题。\n2 使用工厂模式解耦合 ​ 在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的 方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。\n那么，这个读取配置文件，创建和获取三层对象的类就是工厂。\nservice 调用dao：\n原生： new xxxdaoimpl(); 问题： service实现类当中出现了 new关键字， 出现了dao 层具体的实现类。 不满足java设计原则： 面向接口开发~ 总结： 耦合度高~\n工厂模式： xxxfactory.getinstance(); 获得接口的实现类： xxxdao接口接收~ 解决了： new关键字， 业务层的实现类当中， 不在出现dao层的实现类。 总结： 松耦合~\n三 springioc 机制的详解 （一） ioc概述及作用【重要】 1 ioc的简介，设计思想 springioc：ioc 是 inversion of control 的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。\n就是将对象的创建和维护的权利交给spring 框架。\n1996 年，michael mattson 在一篇有关探讨面向对象框架的文章中，首先提出了 ioc 这个概念。简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。\nioc 理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦 如下图\n大家看到了吧，由于引进了中间位置的“第三方”，也就是ioc容器，使得a、b、c、d这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了， 全部对象的控制权全部上缴给“第三方”ioc容器，所以，ioc容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合 在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把ioc容器比喻成“粘合剂”的由来。 我们再来做个试验：把上图中间的ioc容器拿掉，然后再来看看这套系统：\n我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，a、b、c、d这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话， 当你在实现a的时候，根本无须再去考虑b、c和d了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现ioc容器，对于系统开发而言，这将是 一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！\n总结：\nioc容器就是创建对象， 并且维护对象和对象之间的关联关系。\n2 ioc作用 ioc本质上就是一个大工厂，大容器。主要作用就是创建和管理对象的依赖关系，削减计算机程序的耦合（解除我们代码中的依赖关系），提高程序的可扩展性和可维护性。\n（二） springioc入门案例前期准备 1 构建maven工程，添加spring框架的依赖 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.2.5.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!--导入spring的context坐标，context依赖core、beans、expression aop--\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2 创建持久层接口和实现类 public interface userdao { public void save(); } public class userdaoimpl implements userdao { @override public void save() { system.out.println(\u0026#34;userdao save method running...... \u0026#34;); } } 3 创建业务层接口和实现类 public interface userservice { public void saveservice(); } public class userserviceimpl implements userservice { @override public void saveservice() { system.out.println(\u0026#34;userserivce save method running......\u0026#34;); } } 4 在resources文件夹中创建一个任意名称的xml文件 xml文件名称： applicationcontext.xml ,注意文件名称不是必须。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; 5 让spring管理资源，在配置文件中配置service和dao \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--配置userdaoimpl--\u0026gt; \u0026lt;bean id=\u0026#34;userdao\u0026#34; class=\u0026#34;com.ujiuye.dao.impl.userdaoimpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--配置userserviceimpl--\u0026gt; \u0026lt;bean id=\u0026#34;userservice\u0026#34; class=\u0026#34;com.ujiuye.service.userserviceimpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 6 测试ioc 配置是否成功 @test public void test1(){ //1：获得spring ioc容器对象： applicationcontext applicationcontext = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); //2:从容器当中根据id获得userdaoimpl 对象,执行userdao对象的save方法 userdao userdao = (userdao) applicationcontext.getbean(\u0026#34;userdao\u0026#34;); userdao.save(); //3:从容器当中根据id获得userserviceimpl 对象,执行userservice对象的saveservice方法 userservice userservice = (userservice)applicationcontext.getbean(\u0026#34;userservice\u0026#34;); userservice.saveservice(); } 运行结果：\n（三）spring基于xml的ioc细节 1 ioc配置文件详解：配置标签书写规范，配置标签的属性 话术： bean标签： 用于配置对象交给spring 来创建。 默认情况下他会调用类中无参数的构造器，如果没有无参数构造器则不能成功创建 基本属性： id ： bean实例对象在spring容器当中的唯一标识 class ： bean的全限定类名 name ： 了解，给对象命名操作 2 springioc机制源码解析 2.1 ioc容器解析 （面试题目） ioc思想基于ioc容器完成，ioc容器底层就是对象工厂，spring 中工厂的类结构图如下：\n话术： 1）beanfactory ：该接口是顶层接口， ioc容器的基本实现，是spring内部使用的接口，不提供开发人员使用，加载配置文件时，不会创建对象，在获得（使用）对象时才采取创建对象。对象的创建时机，getbean()创建【稍后演示】 2）hierarchicalbeanfactory：这个工厂接口非常简单，实现了bean工厂的分层。 工厂接口也是继承自beanfacotory，也是一个二级接口，相对于父接口，它只扩展了一个重要的功能——工厂分层 3）autowirecapablebeanfactory：该接口有自动装配能力，需要注意的是，applicationcontext接口并没有实现此接口，因为应用代码很少用到此功能，如果确实需要的话，可以调用applicationcontext的getautowirecapablebeanfactory方法，来获取此接口的实例。 4）listablebeanfactory：获取bean时,spring 鼓励使用这个接口定义的api，如查看bean的个数、获取某一类型bean的配置名、查看容器中是否包括某一bean等方法。 5）applicationcontext： beanfactory接口的子接口，提供更多强大的功能，一般由开发人员使用.接口提供了bean基础性操作同时，扩展了国际化等功能。applicationcontext接口在加载配置文件时候就会配置文件当中的对象进行创建，存放在ioc容器当中 6）annotationconfigapplicationcontext： 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 7）classpathxmlapplicationcontext： 它是从类的根路径下加载配置文件 推荐使用这种 8）filesystemxmlapplicationcontext： 【不用~】 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 重点掌握： beanfactory applicationcontext\n面试题目： beanfactory \u0026amp; applicationcontext 联系和区别：\nbeanfactory ： 顶层接口， 接口当中实现了基础性的功能。 提供给框架设计者使用。\n​ 加载配置文件的时候， 对象不创建。 getbean();才会创建对象。\napplicationcontext ：是beanfactory 接口的子接口。 提供了基础性功能之外， 功能进行了扩展，开发者使用。\n​ 加载配置文件的时候， 对象就创建成功， 并且存放在ioc 容器当中。\nclasspathxmlapplicationcontext： 从类路径下获得资源文件。\nannotationconfigapplicationcontext： 基于主机模式使用的实现类。\n2.2 ioc容器底层bean初始化过程（了解） 话术： 1）beanfactorypostprocessor 作用：定义了在bean工厂对象创建后，bean对象创建前执行的动作，用于对工厂进行创建后业务处理 运行时机： 操作用于对工厂进行处理，仅运行一次 2）beanpostprocessor 作用： 定义了所有bean初始化前后进行的统一动作，用于对bean进行创建前业务处理与创建后业务处理 运行时机：当前操作伴随着每个bean的创建过程，每次创建bean均运行该操作 3）initializingbean 【了解】 作用：定义了每个bean的初始化前进行的动作，属于非统一性动作，用于对bean进行创建前业务处理。类似于 init-method。 运行时机：当前操作伴随着任意一个bean的创建过程，保障其个性化业务处理 （四） 手动实现自己的ioc容器 1 分析ioc 实现思路 讲解思路： 1、创建工厂对象，加载spring核心配置文件 2、使用xml解析技术，获得bean标签当中id属性以及class属性对应的值 3、底层使用反射技术，创建对象 4、准备临时容器，存放创建的对象 5、提供getbean方法，对外提供对象 6、测试自定义的工厂对象 2 ioc原理实现-环境搭建：构建maven工程，引入依赖 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.2.5.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--导入spring的context坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入junit单元测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 3 设计接口和类以及编写配置文件 //设定userdao接口 public interface userdao { public void save(); } //设定userdao接口实现类 public class userdaoimpl implements userdao { @override public void save() { system.out.println(\u0026#34;userdao save method running...... \u0026#34;); } } \u0026lt;!--配置userdaoimpl--\u0026gt; \u0026lt;bean id=\u0026#34;userdao\u0026#34; class=\u0026#34;com.ujiuye.dao.impl.userdaoimpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 4 使用xml技术解析配置文件 \u0026lt;!--引入dom4j 是xml解析。 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;dom4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dom4j\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; /** * 创建自己的工厂类 */ public class mybeanfactory { //创建一个map集合，模拟ioc容器 private static map\u0026lt;string,object\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); static{ try { //使用dom4j 解析xml文件： //第一步：获得一个解析器： saxreader reader = new saxreader(); //第二： 读取外部的配置文件： string path = \u0026#34;src/main/resources/applicationcontext.xml\u0026#34;; //第三: 读取了整个文档对象 document document = reader.read(path); //第四： 获得根节点： element rootelement = document.getrootelement();//beans //第五： 获得根节点下的所有的bean 标签对应的节点： list\u0026lt;element\u0026gt; bean = rootelement.elements(\u0026#34;bean\u0026#34;);// bean for (element element : bean) { //获得id属性对应的值： string id1 = element.attributevalue(\u0026#34;id\u0026#34;); //获得class属性对应的值：【全限定类名】 string aclass = element.attributevalue(\u0026#34;class\u0026#34;);//获得class对应的值： 全限定类名。 //通过反射创建对象： class clz = class.forname(aclass); object object = clz.newinstance(); //存容器 id做key，创建出来的对象value map.put(id1,object); } } catch (exception e) { e.printstacktrace(); } } /** * 根据id从容器当中获得对象 * @param id id的名称 * @return 返回object类型对象 */ public static object getbean(string id){ object o = map.get(id); return o; } } 总结： ioc容器自定义时候； xml解析技术： 反射技术 工厂模式 5 编写测试文件，展示测试结果 @test public void testmyfactory(){ //1：创建工厂对象 mybeanfactory factory =new mybeanfactory(); //2：从容器当中根据id获得对象 userdao userdao = (userdao) factory.getbean(\u0026#34;userdao\u0026#34;); system.out.println(userdao); userdao.save(); } 运行结果：\n（五）spring管理bean细节 1 bean实例化介绍： bean 对象创建~\n2 bean实例化方式【面试问题】 2.1 构造方法的方式 它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败\n2.1.1 创建user类 public class user implements serializable { public user(){ system.out.println(\u0026#34;user created...\u0026#34;); } } 2.1.2 配置spring容器管理user 类型对象 \u0026lt;!--配置user对象--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.ujiuye.pojo.user\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 2.1.3 测试容器实例化user对象是否成功 @test public void testuser(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); user user = (user) context.getbean(\u0026#34;user\u0026#34;); system.out.println(user); } 2.2 静态工厂方式 2.2.1 创建静态工厂itemfactory public class itemfactory { //静态方法返回实例bean public static user createuser(){ system.out.println(\u0026#34;static method running create bean ......\u0026#34;); return new user(); } } 2.2.2 配置spring容器管理user类型对象 \u0026lt;!--静态工厂实例化对象: 工厂方法的返回值存放在ioc容器当中 --\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.ujiuye.factory.itemfactory\u0026#34; factory-method=\u0026#34;createuser\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 2.2.3 测试容器实例化user对象是否成功 @test public void testitemfactory(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); user user = (user) context.getbean(\u0026#34;user\u0026#34;); system.out.println(user); } 2.3 实例工厂方式 2.3.1 创建实例工厂newitemfactory public class newitemfactory { //工厂的非静态方法返回bean实例 public user createuser(){ system.out.println(\u0026#34;dynamic method running create bean ......\u0026#34;); return new user(); } } 2.3.2 配置spring容器管理newitemfactory类型对象 \u0026lt;!--实例工厂： 步骤一； 创建对象 步骤二： 通过对象调用方法，方法的返回值存在ioc容器当中。 --\u0026gt; \u0026lt;bean id=\u0026#34;itemfactory\u0026#34; class=\u0026#34;com.ujiuye.factory.newitemfactory\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; factory-bean=\u0026#34;itemfactory\u0026#34; factory-method=\u0026#34;createuser\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 2.3.3 测试容器实例化user对象是否成功 @test public void testnewitemfactory(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); user user = (user) context.getbean(\u0026#34;user\u0026#34;); system.out.println(user); } 3 bean作用域【面试问题】 3.1 bean作用域介绍 web的四大域： pagecontext request session application ： jsp九大内置对象： ~ 话术： 所谓bean的作用域其实就是指spring给我们创建出的对象的存活范围，在配置文件中通过bean的scope属性指定 \u0026lt;bean id=\u0026#34;\u0026#34; class=\u0026#34;\u0026#34; scope=\u0026#34;\u0026#34;\u0026gt; scope:指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request web 项目中，spring 创建一个 bean 的对象，将对象存入到 request 域中 session web 项目中，spring 创建一个 bean 的对象，将对象存入到 session 域中 global session web 项目中，应用在 portlet 环境，如果没有 portlet 环境那么globalsession 相当于 session 3.2 bean作用域的解析 3.2.1 当scope的取值为singleton时 ​ bean的实例化个数：1个\n​ bean的实例化时机：当spring核心文件被加载时，实例化配置的bean实例\n3.2.2 当scope的取值为prototype时 ​ bean的实例化个数：多个\n​ bean的实例化时机：当调用getbean()方法时实例化bean\n​ 注意： 多例对象，不会随容器而创建， 不会随容器销毁而销毁。\n​ 在内存当中， 由垃圾回收器定期回收~\n3.2.3 当scope的取值为其他值 ​ scope指定为其他值，需要在特定的环境下使用， 只需要作为一个了解知识，面试能够回答出来即可\n4 bean的生命周期 4.1 bean生命周期介绍 话术： 在这里所谓的bean的生命周期其实指的是bean创建到销毁的这么一段时间。 在spring中可以通过配置的形式，指定bean在创建后和销毁前要调用的方法。 属性： init-method:指定bean在创建后调用的方法 destroy-method：对象在销毁前调用的方法 \u0026lt;bean id=\u0026#34;xxx\u0026#34; class=\u0026#34;xxx\u0026#34; init-method=\u0026#34;\u0026#34; destroy-method=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 4.2 单例对象的生命周期 4.2.1 在userservice中添加方法init和destory public class userserviceimpl implements userservice { public void init(){ system.out.println(\u0026#34;init method running...\u0026#34;); } @override public void saveservice() { system.out.println(\u0026#34;userserivce save method running......\u0026#34;); } public void destroy(){ system.out.println(\u0026#34;destroy method running...\u0026#34;); } } 4.2.2 在spring.xml配置文件中配置userservice \u0026lt;!--配置userserviceimpl--\u0026gt; \u0026lt;bean id=\u0026#34;userservice\u0026#34; class=\u0026#34;com.ujiuye.service.userserviceimpl\u0026#34; init-method=\u0026#34;init\u0026#34; destroy-method=\u0026#34;destroy\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 4.2.3 测试代码验证单例对象的生命周期 @test public void test1(){ classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); userservice userservice = (userservice) applicationcontext.getbean(\u0026#34;userservice\u0026#34;); userservice.saveservice(); //关闭工厂： applicationcontext.close(); } 单例对象总结：\n对象创建：当应用加载，创建容器时，对象就被创建了\n对象运行：只要容器在，对象一直活着\n对象销毁：当应用卸载，销毁容器时，对象就被销毁了\n4.3 多例对象的生命周周期 4.3.1 修改spring配置文件scope属性 \u0026lt;!--配置userserviceimpl--\u0026gt; \u0026lt;bean id=\u0026#34;userservice\u0026#34; class=\u0026#34;com.ujiuye.service.userserviceimpl\u0026#34; init-method=\u0026#34;init\u0026#34; destroy-method=\u0026#34;destroy\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 4.3.2 测试代码验证多例对象的生命周期 @test public void test1(){ classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); userservice userservice = (userservice) applicationcontext.getbean(\u0026#34;userservice\u0026#34;); userservice.saveservice(); //关闭工厂： applicationcontext.close(); } 多例对象总结：\n对象创建：当使用对象时(getbean)，创建新的对象实例\n对象运行：只要对象在使用中，就一直活着\n对象销毁：当对象长时间不用时，被 java 的垃圾回收器回收了， 对destroy-method属性针对多例不生效。\n四 spring依赖注入【~~~】 （一） 依赖注入的介绍:什么是依赖注入，为什么需要依赖注入 话术： 依赖注入（dependency injection）：简称di，它是 spring 框架核心 ioc 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。 ioc 解耦只是降低他们的依赖关系，但不会消除。 例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 简单理解： 依赖注入就是spring ioc 容器在创建对象的时候， 给属性赋值。 （二） spring中依赖注入方式 1 构造函数注入 1.1 构建account类，提供所有属性的构造方法 顾名思义，就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置 的方式，让 spring 框架来为我们注入。具体代码如下\npublic class account { private string name; private integer age; private date birthday; public account(string name, integer age, date birthday) { this.name = name; this.age = age; this.birthday = birthday; } } 1.2 在spring.xml文件中配置account类(使用构造方法注入依赖数据) \u0026lt;!--使用构造函数的方式：给account中的属性赋值 要求： 类中需要提供一个对应参数列表的构造器函数 涉及的标签： constructor-arg: 属性： name： 执行参数在构造器中的名称 value：它能赋的值是基本数据类型和 string 类型 ref：它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean --\u0026gt; \u0026lt;bean id=\u0026#34;now\u0026#34; class=\u0026#34;java.util.date\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.ujiuye.pojo.account\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;王达\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;20\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;birthday\u0026#34; ref=\u0026#34;now\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; 1.3 构造函数注入测试方法 @test public void testdi(){ classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); account account = (account) applicationcontext.getbean(\u0026#34;account\u0026#34;); system.out.println(\u0026#34;name:\u0026#34;+account.getname()+\u0026#34; age:\u0026#34;+account.getage()+\u0026#34; birthday:\u0026#34;+account.getbirthday()); //打印结果： name:王达 age:20 birthday:thu feb 04 13:53:45 cst 2021 } 2 setter注入 2.1 修改account类，添加属性的setter方法 顾名思义，就是在类中提供需要注入成员的 set 方法。具体代码如下：\npublic class account { private string name; private integer age; private date birthday; public account() { } public account(string name, integer age, date birthday) { this.name = name; this.age = age; this.birthday = birthday; } public string getname() { return name; } public void setname(string name) { this.name = name; } public integer getage() { return age; } public void setage(integer age) { this.age = age; } public date getbirthday() { return birthday; } public void setbirthday(date birthday) { this.birthday = birthday; } } 2.2 在spring.xml文件中配置account类(利用setter方法注入依赖数据) \u0026lt;!--使用set方法的方式给属性赋值 涉及的标签： property 属性： name：找的是类中set方法后面的部分 ref： 给属性赋值是其他bean类型的 value：给属性赋值是基本数据类型和 string 类型的 实际开发当中， 此种方式用的比较多，推荐使用 --\u0026gt; \u0026lt;bean id=\u0026#34;now\u0026#34; class=\u0026#34;java.util.date\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.ujiuye.pojo.account\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;张三丰\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;31\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;birthday\u0026#34; ref=\u0026#34;now\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 2.3 setter注入测试方法 @test public void testdi(){ classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); account account = (account) applicationcontext.getbean(\u0026#34;account\u0026#34;); system.out.println(\u0026#34;name:\u0026#34;+account.getname()+\u0026#34; age:\u0026#34;+account.getage()+\u0026#34; birthday:\u0026#34;+account.getbirthday()); //测试结果： name:张三丰 age:31 birthday:thu feb 04 14:05:19 cst 2021 } 补充：\np名称空间注入： 语法： p:属性名称=“”\n在xml当中引入p名称空间 xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; 语法： \u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.offcn.pojo.account\u0026#34; p:name=\u0026#34;唐晓飞\u0026#34; p:age=\u0026#34;21\u0026#34; p:birthday-ref=\u0026#34;birthday\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; spel 表达式注入：\n\u0026lt;!--spel注入： spring el expression (1) 底层是调用了set方法 (2) #{} spring el 语法 (3) 不管是普通属性或者是对象属性， 都使用value 赋值。 （4）功能最强大 ， 属性赋值的时候，可以调用对象的属性， 可以调用对象的方法。 --\u0026gt; \u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.offcn.pojo.account\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;#{\u0026#39;admin\u0026#39;}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;#{account.calcullatorage()}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;birthday\u0026#34; value=\u0026#34;#{birthday}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 3 注入集合数据 3.1 修改account类，添加集合属性 顾名思义，就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。\n我们这里介绍注入数组，list,set,map,properties。具体代码如下：\npublic class account { //注入数组，list集合，set集合，map集合，properties集合属性 private string[] mystrs; private list\u0026lt;string\u0026gt; mylist; private set\u0026lt;string\u0026gt; myset; private map\u0026lt;string,string\u0026gt; mymap; private properties myprops; public account() { } public string[] getmystrs() { return mystrs; } public void setmystrs(string[] mystrs) { this.mystrs = mystrs; } public list\u0026lt;string\u0026gt; getmylist() { return mylist; } public void setmylist(list\u0026lt;string\u0026gt; mylist) { this.mylist = mylist; } public set\u0026lt;string\u0026gt; getmyset() { return myset; } public void setmyset(set\u0026lt;string\u0026gt; myset) { this.myset = myset; } public map\u0026lt;string, string\u0026gt; getmymap() { return mymap; } public void setmymap(map\u0026lt;string, string\u0026gt; mymap) { this.mymap = mymap; } public properties getmyprops() { return myprops; } public void setmyprops(properties myprops) { this.myprops = myprops; } } 3.2 在spring.xml文件中配置account类(利用setter注入依赖集合数据) \u0026lt;!--注入集合类型数据： 涉及到标签： list结构： array list set map结构： map entry props prop --\u0026gt; \u0026lt;bean id=\u0026#34;account\u0026#34; class=\u0026#34;com.ujiuye.pojo.account\u0026#34;\u0026gt; \u0026lt;!--注意：在注入集合数据时，只要是结构相同，标签可以互换--\u0026gt; \u0026lt;!--注入数组数据--\u0026gt; \u0026lt;property name=\u0026#34;mystrs\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;array-aaa\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;array-bbb\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;array-ccc\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--注入list集合数据--\u0026gt; \u0026lt;property name=\u0026#34;mylist\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;list-aaa\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;list-bbb\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;list-ccc\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--注入set集合数据--\u0026gt; \u0026lt;property name=\u0026#34;myset\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;set-aaa\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;set-bbb\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;set-ccc\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--注入map集合--\u0026gt; \u0026lt;property name=\u0026#34;mymap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;map-a\u0026#34; value=\u0026#34;aaa\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;map-b\u0026#34;\u0026gt; \u0026lt;value\u0026gt;bbb\u0026lt;/value\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--注入properties集合--\u0026gt; \u0026lt;property name=\u0026#34;myprops\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;pro-a\u0026#34;\u0026gt;aaa\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;pro-b\u0026#34;\u0026gt;bbb\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 3.3 集合注入测试方法 @test public void testdi(){ classpathxmlapplicationcontext applicationcontext = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); account account = (account) applicationcontext.getbean(\u0026#34;account\u0026#34;); system.out.println(\u0026#34;array:\u0026#34;+ arrays.tostring(account.getmystrs())); system.out.println(\u0026#34;list:\u0026#34;+account.getmylist()); system.out.println(\u0026#34;set:\u0026#34;+account.getmyset()); system.out.println(\u0026#34;map:\u0026#34;+account.getmymap()); system.out.println(\u0026#34;props:\u0026#34;+account.getmyprops()); /* 测试结果： array:[array-aaa, array-bbb, array-ccc] list:[list-aaa, list-bbb, list-ccc] set:[set-aaa, set-bbb, set-ccc] map:{map-a=aaa, map-b=bbb} props:{pro-b=bbb, pro-a=aaa} */ } 五 spring配置文件模块化 讲解思路： 1、配置文件模块化的业务背景，为什么要进行配置文件模块化 2、配置文件模块化的具体实现 方式一： 创建多个并列的配置文件 方式二： 创建一个主配置，多个从配置，主配置当中引入从配置 （一） spring模块化的介绍：为什么需要配置文件进行模块操作，如何实现配置文件模块化 话术： 我们现在的配置都集中配在了一个applicationcontext.xml文件中，当开发人员过多时， 如果所有bean都配 置到同一个配置文件中，会使这个文件巨大，而且也不方便维护。 针对这个问题，spring提供了多配置文件的方式，也就是所谓的配置文件模块化 （二） spring模块化的配置 1 spring模块化配置方式一 并列的多个配置文件 直接编写多个配置文件，比如说beans1.xml，beans2.xml\u0026hellip;\u0026hellip;, 然后在创建applicationcontext的时候，直接传入多个配置文件。\napplicationcontext act = new classpathxmlapplicationcontext(\u0026#34;beans1.xml\u0026#34;,\u0026#34;beans2.xml\u0026#34;,\u0026#34;...\u0026#34;); 2 spring模块化配置方式二 主从配置文件 先配置一个主配置文件，然后在里面导入其它的配置文件。\n\u0026lt;import resource=\u0026#34;beans1.xml\u0026#34; /\u0026gt; \u0026lt;import resource=\u0026#34;beans2.xml\u0026#34; /\u0026gt; 注意：\n同一个xml文件中不能出现相同名称的bean,如果出现会报错\n多个xml文件如果出现相同名称的bean，不会报错，但是后加载的会覆盖前加载的bean，所以企业开发中尽 量保证bean的名称是唯一的。\n六 模板设计模式解析 讲解思路：： 1、了解什么是设计模式，将常见的模式简单复习 2、模板设计模式的介绍 3、模板设计模式的使用场景，结合已经学习到技术解释模板设计模式 4、模板设计模式具体案例的实现 5、引出spring中jdbctemplate模板对象 设计模式是java编程当中非常重要的思想， 不管是实际开发还是面试过程当中，经常涉及。所以凡是涉及到设计模式的内容都是重点。 （一）模板设计模式介绍 话术： 模板类： 模板方法（template method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 模板方法模式的静态结构图如下：\n（二） 模板设计模式的应用场景 在多个子类中拥有相同的方法，而且逻辑相同时，可以将这些方法抽出来放到一个模板抽象类中\n程序主框架相同，细节不同的情况下，也可以使用模板方法\n举例说明：\na：使用过servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫httpservlet的抽象类。httpservice类提供了一个service()方法，这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。这些do方法需要由httpservlet的具体子类提供，因此这是典型的模板方法模式。\nb：持久层对数据库的操作，spring提供了jdbctemplate模板对象， 完成crud操作。\n（三） 模板设计模式实现 1 需求：用模板方法模式实现出国留学手续设计程序。 分析：出国留学手续一般经过以下流程：索取学校资料，提出入学申请，办理因私出国护照、出境卡和公证，申请签证，体检、订机票、准备行装，抵达目标学校等，其中有些业务对各个学校是一样的，但有些业务因学校不同而不同，所以比较适合用模板方法模式来实现。\n在本实例中，我们先定义一个出国留学的抽象类 studyabroad，里面包含了一个模板方法 templatemethod()，该方法中包含了办理出国留学手续流程中的各个基本方法，其中有些方法的处理由于各国都一样，所以在抽象类中就可以实现，但有些方法的处理各国是不同的，必须在其具体子类（如美国留学类 studyinamerica）中实现。如果再增加一个国家，只要增加一个子类就可以了。\n图 2 所示是其结构图\n2 程序代码实现 //抽象类: 出国留学 public abstract class studyabroad { //定义抽象方法，索取学校资料 public abstract void lookingforschool(); //定义抽象方法，定义入学申请 public abstract void applyforenrol(); //定义入学申请方法： public void applyforpassport() { system.out.println(\u0026#34;三.办理因私出国护照、出境卡和公证：\u0026#34;); system.out.println(\u0026#34; 1）持录取通知书、本人户口簿或身份证向户口所在地公安机关申请办理因私出国护照和出境卡。\u0026#34;); system.out.println(\u0026#34; 2）办理出生公证书，学历、学位和成绩公证，经历证书，亲属关系公证，经济担保公证。\u0026#34;); } //定义申请签证方法 public void applyforvisa() { system.out.println(\u0026#34;四.申请签证：\u0026#34;); system.out.println(\u0026#34; 1）准备申请国外境签证所需的各种资料，包括个人学历、成绩单、工作经历的证明；个人及家庭收入、资金和财产证明；家庭成员的关系证明等；\u0026#34;); system.out.println(\u0026#34; 2）向拟留学国家驻华使(领)馆申请入境签证。申请时需按要求填写有关表格，递交必需的证明材料，缴纳签证。有的国家(比如美国、英国、加拿大等)在申请签证时会要求申请人前往使(领)馆进行面试。\u0026#34;); } //体检、订机票、准备行装 方法 public void readygoabroad() { system.out.println(\u0026#34;五.体检、订机票、准备行装：\u0026#34;); system.out.println(\u0026#34; 1）进行身体检查、免疫检查和接种传染病疫苗；\u0026#34;); system.out.println(\u0026#34; 2）确定机票时间、航班和转机地点。\u0026#34;); } //定义抵达抽象方法 public abstract void arriving(); //定义模板方法： public void templatemethod(){ (1)(2).... } } //定义具体的子类，美国留学 public class studyinamerica extends studyabroad { //索取资料的具体实现 @override public void lookingforschool() { system.out.println(\u0026#34;一.索取学校以下资料：\u0026#34;); system.out.println(\u0026#34; 1）对留学意向国家的政治、经济、文化背景和教育体制、学术水平进行较为全面的了解；\u0026#34;); system.out.println(\u0026#34; 2）全面了解和掌握国外学校的情况，包括历史、学费、学制、专业、师资配备、教学设施、学术地位、学生人数等；\u0026#34;); system.out.println(\u0026#34; 3）了解该学校的住宿、交通、医疗保险情况如何；\u0026#34;); system.out.println(\u0026#34; 4）该学校在中国是否有授权代理招生的留学中介公司？\u0026#34;); system.out.println(\u0026#34; 5）掌握留学签证情况；\u0026#34;); system.out.println(\u0026#34; 6）该国政府是否允许留学生合法打工？\u0026#34;); system.out.println(\u0026#34; 8）毕业之后可否移民？\u0026#34;); system.out.println(\u0026#34; 9）文凭是否受到我国认可？\u0026#34;); } //入学申请的具体实现 @override public void applyforenrol() { system.out.println(\u0026#34;二.入学申请：\u0026#34;); system.out.println(\u0026#34; 1）填写报名表；\u0026#34;); system.out.println(\u0026#34; 2）将报名表、个人学历证明、最近的学习成绩单、推荐信、个人简历、托福或雅思语言考试成绩单等资料寄往所申请的学校；\u0026#34;); system.out.println(\u0026#34; 3）为了给签证办理留有充裕的时间，建议越早申请越好，一般提前1年就比较从容。\u0026#34;); } //抵达的具体实现 @override public void arriving() { system.out.println(\u0026#34;六.抵达目标学校：\u0026#34;); system.out.println(\u0026#34; 1）安排住宿；\u0026#34;); system.out.println(\u0026#34; 2）了解校园及周边环境。\u0026#34;); } } public class studyabroadprocess { public static void main(string[] args) { studyabroad tm = new studyinamerica(); tm.templatemethod(); } } 3 运行结果如下： 一.索取学校以下资料： 1）对留学意向国家的政治、经济、文化背景和教育体制、学术水平进行较为全面的了解； 2）全面了解和掌握国外学校的情况，包括历史、学费、学制、专业、师资配备、教学设施、学术地位、学生人数等； 3）了解该学校的住宿、交通、医疗保险情况如何； 4）该学校在中国是否有授权代理招生的留学中介公司？ 5）掌握留学签证情况； 6）该国政府是否允许留学生合法打工？ 8）毕业之后可否移民？ 9）文凭是否受到我国认可？ 二.入学申请： 1）填写报名表； 2）将报名表、个人学历证明、最近的学习成绩单、推荐信、个人简历、托福或雅思语言考试成绩单等资料寄往所申请的学校； 3）为了给签证办理留有充裕的时间，建议越早申请越好，一般提前1年就比较从容。 三.办理因私出国护照、出境卡和公证： 1）持录取通知书、本人户口簿或身份证向户口所在地公安机关申请办理因私出国护照和出境卡。 2）办理出生公证书，学历、学位和成绩公证，经历证书，亲属关系公证，经济担保公证。 四.申请签证： 1）准备申请国外境签证所需的各种资料，包括个人学历、成绩单、工作经历的证明；个人及家庭收入、资金和财产证明；家庭成员的关系证明等； 2）向拟留学国家驻华使(领)馆申请入境签证。申请时需按要求填写有关表格，递交必需的证明材料，缴纳签证。有的国家(比如美国、英国、加拿大等)在申请签证时会要求申请人前往使(领)馆进行面试。 五.体检、订机票、准备行装： 1）进行身体检查、免疫检查和接种传染病疫苗； 2）确定机票时间、航班和转机地点。 六.抵达目标学校： 1）安排住宿； 2）了解校园及周边环境。 七 spring整合jdbc实现用户的crud 讲解思路： 1、简单复习jdbc技术操作数据库的步骤，jdbc开发的弊端问题 2、介绍spring在持久层提供的jdbctemplate模板对象 3、jdbctemplate模板对象的使用步骤，常见的读写方法 4、扩展jdbcdaosupport工具类当中注入jdbctemplate原理 （一） 整合思路分析 话术： spring提供了ioc容器，管理jdbc操作数据库的过程中需要的数据库连接对象，同时spring提供了整合jdbc操作数据库的工具类jdbcdaosupport 和模板工具 jdbctemplate，在jdbctemplate中提供了大量的操作数据库的方式供用户使用。所以我们只需要获取模板工具类然后调用方法就可以完成jdbc的操作了。 （二）构建maven工程，添加技术依赖 \u0026lt;dependencies\u0026gt; \u0026lt;!--导入spring的context坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入jdbc模块依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入mysql 驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入c3p0连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.mchange\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;c3p0\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入junit单元测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; （三） 构建数据库表并编写实体类account public class account implements serializable { private integer id; private string name; private double money; public integer getid() { return id; } public void setid(integer id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public double getmoney() { return money; } public void setmoney(double money) { this.money = money; } @override public string tostring() { return \u0026#34;account{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, money=\u0026#34; + money + \u0026#39;}\u0026#39;; } } （四）编写持久层代码accountdao以及实现类accountdaoimp public interface accountdao { public void save(account account); public void delete(integer id); public void update(account account); public account findbyid(integer id); public integer gettotalrecords(); public list\u0026lt;account\u0026gt; findall(); } public class accountdaoimpl implements accountdao { private jdbctemplate jdbctemplate; public void setjdbctemplate(jdbctemplate jdbctemplate) { this.jdbctemplate = jdbctemplate; } @override public void save(account account) { string sql =\u0026#34;insert into account(name,money) values(?,?)\u0026#34;; jdbctemplate.update(sql,account.getname(),account.getmoney()); } @override public void delete(integer id) { string sql =\u0026#34;delete from account where id = ? \u0026#34;; jdbctemplate.update(sql,id); } @override public void update(account account) { string sql =\u0026#34;update account set money = ? , name=? where id= ?\u0026#34;; jdbctemplate.update(sql,account.getmoney(),account.getname(),account.getid()); } @override public account findbyid(integer id) { string sql =\u0026#34;select * from account where id = ? \u0026#34;; account account = jdbctemplate.queryforobject(sql, new beanpropertyrowmapper\u0026lt;account\u0026gt;(account.class),id); return account; } @override public long gettotalrecords() { long count = jdbctemplate.queryforobject(\u0026#34;select count(*) from account\u0026#34;, long.class); system.out.println(count); return count; } @override public list\u0026lt;account\u0026gt; findall() { string sql =\u0026#34;select * from account\u0026#34;; list\u0026lt;account\u0026gt; accountlist = jdbctemplate.query(sql, new beanpropertyrowmapper\u0026lt;account\u0026gt;(account.class)); return accountlist; } } （五）编写业务层代码accountservice以及实现类accountserviceimpl public interface accountservice { public void save(account account); public void delete(integer id); public void update(account account); public account findbyid(integer id); public long gettotalrecords(); public list\u0026lt;account\u0026gt; findall(); } public class accountserviceimpl implements accountservice { private accountdao accountdao; public void setaccountdao(accountdao accountdao) { this.accountdao = accountdao; } @override public void save(account account) { accountdao.save(account); } @override public void delete(integer id) { accountdao.delete(id); } @override public void update(account account) { accountdao.update(account); } @override public account findbyid(integer id) { return accountdao.findbyid(id); } @override public long gettotalrecords() { return accountdao.gettotalrecords(); } @override public list\u0026lt;account\u0026gt; findall() { return accountdao.findall(); } } （六）创建并编写配置文件：配置容器管理对象 将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护\njdbc.driver=com.mysql.jdbc.driver jdbc.url=jdbc:mysql://localhost:3306/test jdbc.username=root jdbc.password=root \u0026lt;!--数据源对象--\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.combopooleddatasource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverclass\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;jdbcurl\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置jdbctemplate模板对象--\u0026gt; \u0026lt;bean id=\u0026#34;jdbctemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.jdbctemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置accountdaoimpl对象--\u0026gt; \u0026lt;bean id=\u0026#34;accountdao\u0026#34; class=\u0026#34;com.ujiuye.dao.impl.accountdaoimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;jdbctemplate\u0026#34; ref=\u0026#34;jdbctemplate\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置accountserviceimpl对象--\u0026gt; \u0026lt;bean id=\u0026#34;accountservice\u0026#34; class=\u0026#34;com.ujiuye.service.accountserviceimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accountdao\u0026#34; ref=\u0026#34;accountdao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; （七）测试代码 //测试save方法 @test public void testjdbctemplatesave(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); accountservice service = (accountservice) context.getbean(\u0026#34;accountservice\u0026#34;); account account = new account(); account.setname(\u0026#34;jack\u0026#34;); account.setmoney(1001d); service.save(account); } //测试update方法 @test public void testjdbctemplateupdate(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); accountservice service = (accountservice) context.getbean(\u0026#34;accountservice\u0026#34;); account account = new account(); account.setname(\u0026#34;jack2\u0026#34;); account.setmoney(999d); account.setid(1008); service.update(account); } //测试delete方法 @test public void testjdbctemplatedelete(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); accountservice service = (accountservice) context.getbean(\u0026#34;accountservice\u0026#34;); service.delete(1001); } //测试唯一性查询findbyid @test public void testjdbctemplatefindbyid(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); accountservice service = (accountservice) context.getbean(\u0026#34;accountservice\u0026#34;); account account = service.findbyid(1001); system.out.println(account); } //测试总记录数 @test public void testjdbctemplategettotalrecords(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); accountservice service = (accountservice) context.getbean(\u0026#34;accountservice\u0026#34;); long totalrecords = service.gettotalrecords(); system.out.println(\u0026#34;表当中的总记录数为：\u0026#34;+totalrecords); } //测试账户列表 @test public void testjdbctemplategetall(){ applicationcontext context = new classpathxmlapplicationcontext(\u0026#34;applicationcontext.xml\u0026#34;); accountservice service = (accountservice) context.getbean(\u0026#34;accountservice\u0026#34;); list\u0026lt;account\u0026gt; accountlist = service.findall(); accountlist.foreach((account -\u0026gt; { system.out.println(account); })); } ","date":"2022-05-25","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220526003427/","summary":"一 Spring概述 （一） Spring是什么（掌握） 话术： Spring是一个分层的Java SE/EE full-stack（一站式）轻量级开源框架，以 IoC（Inverse","title":"spring-1"},{"content":"复习回顾：\ndi： 依赖注入 依赖注入的方式： 构造器注入： setter注入u: p名称空间注入： spel表达式注入： ioc的注解版本： @component 所属的类没有明确的层级划分， 此时就可以使用该注解。 @repository dao层 @service service层： @controller web层： di的相关注解： @value(\u0026#34;\u0026#34;) 能够获得配置文件当中的内容： @autowire 根据类型自动装配。 如果容器当中有多个对象， 此时就会根据名称进行装配。 @qualifier 根据对象的名称进行装配。 @resource java提供的， @autowire+@qualifier jdbctemplate模板对象： query() | queryforobject() update() spring整合junit： （1）引入依赖包： （2）引入注解： 0、实现转账业务 一： 实现转账业务 1 底层数据库表： account 2 实现类： account public class account implements serializable { private integer id; private string name; private double money; getter 和 setter ... } 3 accountdao 层接口 \u0026amp; accountdaoimpl package com.offcn.dao; import com.offcn.pojo.account; public interface accountdao {// data access object /** * 根据id进行唯一性查询 * @param id * @return */ public account findbyid(integer id); /** * 更新账户的方法： * @param account */ public void update(account account); } package com.offcn.dao.impl; import com.offcn.dao.accountdao; import com.offcn.pojo.account; import org.apache.commons.dbutils.queryrunner; import org.apache.commons.dbutils.handlers.beanhandler; import java.sql.sqlexception; public class accountdaoimpl implements accountdao { //private jdbctemplate jdbctemplate; private queryrunner queryrunner ; public queryrunner getqueryrunner() { return queryrunner; } public void setqueryrunner(queryrunner queryrunner) { this.queryrunner = queryrunner; } @override public account findbyid(integer id) { try { string sql =\u0026#34;select * from account where id=?\u0026#34;; account account = queryrunner.query(sql, new beanhandler\u0026lt;account\u0026gt;(account.class), id); return account; } catch (sqlexception throwables) { throwables.printstacktrace(); } return null; } @override public void update(account account) { try { string sql =\u0026#34;update account set money=? where id=?\u0026#34;; queryrunner.update(sql,account.getmoney(),account.getid()); } catch (sqlexception throwables) { throwables.printstacktrace(); } } } 4 accountservice层接口 \u0026amp; accountserviceimpl package com.offcn.service; public interface accountservice { /** * 定义转账方法： * @param sourceid 来源账户 * @param targetid 目标账户 * @param money 转账金额 */ public void transfer(integer sourceid, integer targetid, double money); } package com.offcn.service.impl; import com.offcn.dao.accountdao; import com.offcn.pojo.account; import com.offcn.service.accountservice; public class accountserviceimpl implements accountservice { private accountdao accountdao; @override public void transfer(integer sourceid, integer targetid, double money) { //1: 查询来源账户,查询目标账户 account sacc = accountdao.findbyid(sourceid); account tacc = accountdao.findbyid(targetid); //2: 内存当中修改金额 sacc.setmoney(sacc.getmoney() - money); tacc.setmoney(tacc.getmoney() + money); //3: 更新到数据库当中： accountdao.update(sacc); accountdao.update(tacc); } public accountdao getaccountdao() { return accountdao; } public void setaccountdao(accountdao accountdao) { this.accountdao = accountdao; } } 5: applicationcontext.xml 管理对象 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--datasource--\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.druiddatasource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverclassname\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--构建queryrunner 对象 queryrunner qr = new queryrunner(datasource datasource); --\u0026gt; \u0026lt;bean id =\u0026#34;queryrunner\u0026#34; class=\u0026#34;org.apache.commons.dbutils.queryrunner\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;ds\u0026#34; ref=\u0026#34;datasource\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--accountdao--\u0026gt; \u0026lt;bean id=\u0026#34;accountdao\u0026#34; class=\u0026#34;com.offcn.dao.impl.accountdaoimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;queryrunner\u0026#34; ref=\u0026#34;queryrunner\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--accountservice--\u0026gt; \u0026lt;bean id=\u0026#34;accountservice\u0026#34; class=\u0026#34;com.offcn.service.impl.accountserviceimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accountdao\u0026#34; ref=\u0026#34;accountdao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 6 转账测试 package com.offcn; import com.offcn.service.accountservice; import org.junit.test; import org.junit.runner.runwith; import org.springframework.beans.factory.annotation.autowired; import org.springframework.test.context.contextconfiguration; import org.springframework.test.context.junit4.springjunit4classrunner; @runwith(springjunit4classrunner.class) @contextconfiguration(\u0026#34;classpath:applicationcontext.xml\u0026#34;) public class testtransfer { @autowired private accountservice accountservice; @test public void test1(){ accountservice.transfer(1001,1002,100d); } } 二、事务相关内容复习 1、事务的定义\n2、事务的特性\n3、事务的隔离级别\n4、不同事务隔离级别，产生不同的错误数据。\n5、事务相关的代码： connection ~\n三、事务控制-threadlocal 1.定义了一个连接的工具类 /** * 管理连接的工具类： */ public class connectionutil { private datasource datasource;//准备连接对象： /** * threadlocal: map * map.put(线程对象，value); * map.get(线程对象); */ private threadlocal\u0026lt;connection\u0026gt; threadlocal = new threadlocal\u0026lt;\u0026gt;(); public connection getconnection(){ connection connection = threadlocal.get(); if (connection == null){ try { connection = datasource.getconnection(); //绑定在threadlocal当中： threadlocal.set(connection); return connection; } catch (sqlexception throwables) { throwables.printstacktrace(); } } return connection; } } 2、改造了accountdaoimpl package com.offcn.dao.impl; import com.offcn.dao.accountdao; import com.offcn.pojo.account; import com.offcn.utils.connectionutil; import org.apache.commons.dbutils.queryrunner; import org.apache.commons.dbutils.handlers.beanhandler; import java.sql.sqlexception; public class accountdaoimpl implements accountdao { //private jdbctemplate jdbctemplate; private queryrunner queryrunner ; private connectionutil connectionutil; public connectionutil getconnectionutil() { return connectionutil; } public void setconnectionutil(connectionutil connectionutil) { this.connectionutil = connectionutil; } public queryrunner getqueryrunner() { return queryrunner; } public void setqueryrunner(queryrunner queryrunner) { this.queryrunner = queryrunner; } @override public account findbyid(integer id) { try { string sql =\u0026#34;select * from account where id=?\u0026#34;; account account = queryrunner.query(connectionutil.getconnection(),sql, new beanhandler\u0026lt;account\u0026gt;(account.class), id); return account; } catch (sqlexception throwables) { throwables.printstacktrace(); } return null; } @override public void update(account account) { try { string sql =\u0026#34;update account set money=? where id=?\u0026#34;; queryrunner.update(connectionutil.getconnection() ,sql,account.getmoney(),account.getid()); } catch (sqlexception throwables) { throwables.printstacktrace(); } } } 3、定义了事务管理的工具类 package com.offcn.utils; import java.sql.connection; import java.sql.sqlexception; /** * 定义和事务相关的代码： * 事务的开启 提交 回滚 * */ public class transactionmanager { private connectionutil connectionutil; //开启事务： public void begintransaction(){ try { connection connection = connectionutil.getconnection(); connection.setautocommit(false); } catch (sqlexception throwables) { throwables.printstacktrace(); } } //事务提交 public void commit(){ try { connection connection = connectionutil.getconnection(); connection.commit(); } catch (sqlexception throwables) { throwables.printstacktrace(); } } //事务提交 public void rollback(){ try { connection connection = connectionutil.getconnection(); connection.rollback(); } catch (sqlexception throwables) { throwables.printstacktrace(); } } //定义释放资源： public void release() { try { connection connection = connectionutil.getconnection(); connection.close(); } catch (sqlexception throwables) { throwables.printstacktrace(); } } } 4、改造accountserviceimpl package com.offcn.service.impl; import com.offcn.dao.accountdao; import com.offcn.pojo.account; import com.offcn.service.accountservice; import com.offcn.utils.transactionmanager; public class accountserviceimpl implements accountservice { private accountdao accountdao; private transactionmanager transactionmanager; @override public void transfer(integer sourceid, integer targetid, double money) { try { //开启事务： transactionmanager.begintransaction(); //1: 查询来源账户,查询目标账户 account sacc = accountdao.findbyid(sourceid); account tacc = accountdao.findbyid(targetid); //2: 内存当中修改金额 sacc.setmoney(sacc.getmoney() - money); tacc.setmoney(tacc.getmoney() + money); //3: 更新到数据库当中： accountdao.update(sacc); int i= 1/0; accountdao.update(tacc); //事务的提交： transactionmanager.commit(); } catch (exception e) { e.printstacktrace(); transactionmanager.rollback(); } finally { //资源释放： transactionmanager.release(); } } public accountdao getaccountdao() { return accountdao; } public void setaccountdao(accountdao accountdao) { this.accountdao = accountdao; } } 5、配置文件改造 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!--datasource--\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.druiddatasource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverclassname\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--构建queryrunner 对象 queryrunner qr = new queryrunner(datasource datasource); --\u0026gt; \u0026lt;bean id =\u0026#34;queryrunner\u0026#34; class=\u0026#34;org.apache.commons.dbutils.queryrunner\u0026#34;\u0026gt; \u0026lt;!--为了保证在同一个事务使用同一个连接，不能在构建qr的时候，执行指定datasource--\u0026gt; \u0026lt;!-- \u0026lt;constructor-arg name=\u0026#34;ds\u0026#34; ref=\u0026#34;datasource\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt;--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--connectionutil--\u0026gt; \u0026lt;bean id=\u0026#34;connectionutil\u0026#34; class=\u0026#34;com.offcn.utils.connectionutil\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--transactionmanager--\u0026gt; \u0026lt;bean id=\u0026#34;transactionmanager\u0026#34; class=\u0026#34;com.offcn.utils.transactionmanager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;connectionutil\u0026#34; ref=\u0026#34;connectionutil\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--accountdao--\u0026gt; \u0026lt;bean id=\u0026#34;accountdao\u0026#34; class=\u0026#34;com.offcn.dao.impl.accountdaoimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;queryrunner\u0026#34; ref=\u0026#34;queryrunner\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;connectionutil\u0026#34; ref=\u0026#34;connectionutil\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--accountservice--\u0026gt; \u0026lt;bean id=\u0026#34;accountservice\u0026#34; class=\u0026#34;com.offcn.service.impl.accountserviceimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accountdao\u0026#34; ref=\u0026#34;accountdao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;transactionmanager\u0026#34; ref=\u0026#34;transactionmanager\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 6、测试转账-考虑事务 package com.offcn; import com.offcn.service.accountservice; import org.junit.test; import org.junit.runner.runwith; import org.springframework.beans.factory.annotation.autowired; import org.springframework.test.context.contextconfiguration; import org.springframework.test.context.junit4.springjunit4classrunner; @runwith(springjunit4classrunner.class) @contextconfiguration(\u0026#34;classpath:applicationcontext.xml\u0026#34;) public class testtransfer { @autowired private accountservice accountservice; @test public void test1(){ accountservice.transfer(1001,1002,100d); } } 四、 事务控制-动态代理 1、动态代理模式【23】 你 【 中介 】 买房 买房~\n代理的角色：\n​ 代理类： 代理对象【中介】\n​ 被代理类： 被代理对象【买房人】\n​ 目标方法： 核心业务\n作用： 对某个类的某个方法进行功能增强。\n动态代理分类：\n​ （1）基于接口的动态代理（jdk的动态代理）： 被代理的类必须实现接口。 重要【jdk提供的】\n​ （2）cglib代理： 地方提供的代理,需要引入第三方包。\n2、动态代理的入门案例 需求： 公司part ， person 完成晚会， sing dance\npackage com.offcn.proxy; public interface companyparty { public void sing(double money); public void dance(double money); } 创建接口的实现类对象：\npackage com.offcn.proxy; public class person implements companyparty { @override public void sing(double money) { system.out.println(\u0026#34;给你\u0026#34;+money+\u0026#34;sing\u0026#34;); } @override public void dance(double money) { system.out.println(\u0026#34;给你\u0026#34;+money+\u0026#34;dance\u0026#34;); } } 使用jdk的动态代理，获得person类的代理类对象，完成业务方法\npackage com.offcn; import com.offcn.proxy.companyparty; import com.offcn.proxy.person; import org.junit.test; import java.lang.reflect.invocationhandler; import java.lang.reflect.method; import java.lang.reflect.proxy; public class testproxy { @test public void test1(){ //被代理：person person person = new person(); //person.dance(1001d); //person.sing(1008d) ; /** * jdk的动态代理 * proxy: 反射包当中提供的类： * newproxyinstance(p1,p2,p3)： 获得代理类的方法：返回值是object类型。 * p1: classloader 类的加载器。 * 目标对象(被代理对象)的类加载器。 * * p2: 获得了接口当中所有的方法。 * 目的： 代理类和被代理类对象有着相同的行为： * * p3: invocationhandler 定义代理对象和被代理对象之间的代理策略。 * * */ companyparty proxy =(companyparty) proxy.newproxyinstance( person.getclass().getclassloader(), person.getclass().getinterfaces(), new invocationhandler() { /** * * @param proxy 一般情况不适用。 * @param method 封装了执行的目标方法。 * @param args 封装了执行目标方法的参数。 * @return object 执行了目标方法，目标方法的返回值。 * @throws throwable 执行目标方法，遇到异常信息 * */ @override public object invoke(object proxy, method method, object[] args) throws throwable { string name = method.getname();//获得执行方法的名称。； double money = (double) args[0];//获得目标方法的参数信息： object obj=null; if (\u0026#34;sing\u0026#34;.equals(name) \u0026amp;\u0026amp; money \u0026gt;=1000){ //真正执行目标方法： p1:目标对象 p2: 目标方法需要的参数信息。 obj = method.invoke(person, args); } if (\u0026#34;dance\u0026#34;.equals(name)\u0026amp;\u0026amp; money\u0026gt;=2000){ obj = method.invoke(person, args); } return obj; } } ); proxy.sing(1005d); proxy.dance(2005d); } } 3 使用动态代理控制事务 创建了工厂类， 生成代理类对象： package com.offcn.factory; import com.offcn.service.accountservice; import com.offcn.utils.transactionmanager; import java.lang.reflect.invocationhandler; import java.lang.reflect.method; import java.lang.reflect.proxy; /** * 工厂对象用来生成代理类对象； */ public class beanfactory { //目标对象： public accountservice accountservice; private transactionmanager transactionmanager; public accountservice getproxy(){ return (accountservice)proxy.newproxyinstance( accountservice.getclass().getclassloader(), accountservice.getclass().getinterfaces(), new invocationhandler() {//达成具体的代理策略 @override public object invoke(object proxy, method method, object[] args) throws throwable { object invoke= null; try { //开启事务： transactionmanager.begintransaction(); invoke = method.invoke(accountservice, args); //提交事务： transactionmanager.commit(); return invoke; } catch (exception e) { e.printstacktrace(); //执行业务方法， 遇到了异常信息： transactionmanager.rollback(); } finally { transactionmanager.release(); } return invoke; } } ); } public accountservice getaccountservice() { return accountservice; } public void setaccountservice(accountservice accountservice) { this.accountservice = accountservice; } public transactionmanager gettransactionmanager() { return transactionmanager; } public void settransactionmanager(transactionmanager transactionmanager) { this.transactionmanager = transactionmanager; } } 业务层改造：\n@override public void transfer(integer sourceid, integer targetid, double money) { //1: 查询来源账户,查询目标账户 account sacc = accountdao.findbyid(sourceid); account tacc = accountdao.findbyid(targetid); //2: 内存当中修改金额 sacc.setmoney(sacc.getmoney() - money); tacc.setmoney(tacc.getmoney() + money); //3: 更新到数据库当中： accountdao.update(sacc); int i= 1/0; accountdao.update(tacc); } beanfactory配置在applicationcontext.xml当中：\n\u0026lt;!--beanfactory: 配置了一个实例工厂： factory-bean 指定的工厂的实例对象 factory-method：工厂方法，方法的返回值存在ioc容器当中 --\u0026gt; \u0026lt;bean id=\u0026#34;factory\u0026#34; class=\u0026#34;com.offcn.factory.beanfactory\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;transactionmanager\u0026#34; ref=\u0026#34;transactionmanager\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;accountservice\u0026#34; ref=\u0026#34;accountservice\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean factory-bean=\u0026#34;factory\u0026#34; factory-method=\u0026#34;getproxy\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 测试：\npackage com.offcn; import com.offcn.service.accountservice; import org.junit.test; import org.junit.runner.runwith; import org.springframework.beans.factory.annotation.autowired; import org.springframework.beans.factory.annotation.qualifier; import org.springframework.test.context.contextconfiguration; import org.springframework.test.context.junit4.springjunit4classrunner; @runwith(springjunit4classrunner.class) @contextconfiguration(\u0026#34;classpath:applicationcontext.xml\u0026#34;) public class testtransfer { @autowired @qualifier(\u0026#34;proxy\u0026#34;)//获得对象是代理对象 private accountservice proxy; @test public void test1(){ //accountservice.transfer(1001,1002,100d); proxy.transfer(1001,1002,100d); } } 一、 springaop机制详解 （一）aop 概述 1 什么是 aop 话术： aop 为 aspect oriented programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 aop:面向切面编程 底层： 动态代理 反射： java语言， 是一个静态语言， 但是可以通过反射技术， 体现出来动态性。 2 aop编程思想 话术： aop 面向切面编程是一种编程思想，是 oop（面向对象） 的延续，是软件开发中的一个热点，也是spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用aop可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 应用场景： aop 事务控制， 权限校验， 日志记录， 性能统计 3 spring中的常用术语 话术： joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点。 所有有机会被增强的方法就就似乎链接点。 pointcut（切点）：真正被增强的方法， 就是切点。 案例： transfer 方法。 advice（通知/ 增强）：所谓通知是指拦截到 joinpoint 之后所要做的事情就是通知。 在transfer方法上， 进行了事务代码的增强。 事务代码就是通知~ 通知的类型：前置通知,正常返回通知,异常返回通知,最终通知,环绕通知。【面试问题】 target（目标对象）：代理的目标对象 [被代理对象] proxy （代理）：一个类被 aop 织入增强后，就产生一个结果代理类，代理类产生代理对象 weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程 aspect（切面）：是切入点和通知（引介）的结合 切面描述了： 具体的通知应用在具体的哪个切点上。 4 aop 的作用及优势 话术： 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 （二）spring基于xml的aop配置 讲解思路： 1、搭建maven工程，沿用上一章节转账的业务场景 2、准备好通知类transactionmanager 3、讲解基于xml形式的aop配置，详细介绍每个标签，每个标签当中属性的作用 4、测试使用aop进行事务配置 5、常用通知类型的总结 6、详解切入点表达式的语法，常用案例的列举 1 环境搭建 1.1 构建maven工程添加依赖 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.2.5.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.aspectj\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;aspectjweaver\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.8.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.2 沿用转账业务的代码 搭建了转账环境~\n1.3 创建 spring 的配置文件并导入约束 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; 1.4 配置 spring 的 ioc \u0026lt;!-- 配置数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.combopooleddatasource\u0026#34;\u0026gt; \u0026lt;!--连接数据库的必备信息--\u0026gt; \u0026lt;property name=\u0026#34;driverclass\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcurl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置connection的工具类 connectionutils --\u0026gt; \u0026lt;bean id=\u0026#34;connectionutils\u0026#34; class=\u0026#34;com.offcn.utils.connectionutils\u0026#34;\u0026gt; \u0026lt;!-- 注入数据源--\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置queryrunner--\u0026gt; \u0026lt;bean id=\u0026#34;queryrunner\u0026#34; class=\u0026#34;org.apache.commons.dbutils.queryrunner\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--配置accountdao--\u0026gt; \u0026lt;bean id=\u0026#34;accountdao\u0026#34; class=\u0026#34;com.offcn.dao.impl.accountdaoimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;queryrunner\u0026#34; ref=\u0026#34;queryrunner\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;connectionutils\u0026#34; ref=\u0026#34;connectionutils\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置accountservice--\u0026gt; \u0026lt;bean id=\u0026#34;accountservice\u0026#34; class=\u0026#34;com.offcn.service.impl.accountserviceimpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accountdao\u0026#34; ref=\u0026#34;accountdao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 1.5 抽取公共代码制作成通知(增强代码) /** * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接 */ public class transactionmanager { private connectionutils connectionutils; public void setconnectionutils(connectionutils connectionutils) { this.connectionutils = connectionutils; } /** * 开启事务 */ public void begintransaction(){ try { connectionutils.getthreadconnection().setautocommit(false); }catch (exception e){ e.printstacktrace(); } } /** * 提交事务 */ public void commit(){ try { connectionutils.getthreadconnection().commit(); }catch (exception e){ e.printstacktrace(); } } /** * 回滚事务 */ public void rollback(){ try { connectionutils.getthreadconnection().rollback(); }catch (exception e){ e.printstacktrace(); } } /** * 释放连接 */ public void release(){ try { connectionutils.removeconnection(); connectionutils.getthreadconnection().close();//还回连接池中 }catch (exception e){ e.printstacktrace(); } } } 2 aop 配置步骤 2.1 把通知类用 bean 标签配置起来 \u0026lt;!--配置通知：txmanager--\u0026gt; \u0026lt;bean id=\u0026#34;txmanager\u0026#34; class=\u0026#34;com.offcn.utils.transactionmanager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;connectionutils\u0026#34; ref=\u0026#34;connectionutils\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 2.2 使用 aop:config 声明 aop 配置 aop:config: 作用： 开始声明aop配置 \u0026lt;aop:config\u0026gt; \u0026lt;!-- 配置的代码都写在此处 --\u0026gt; \u0026lt;/aop:config\u0026gt; 2.3 使用 aop:aspect 配置切面 aop：aspect 作用： 用于配置切面 属性： id ：给切面提供一个唯一标识。 ref：引用配置好的通知类 bean 的 id。 \u0026lt;aop:aspect id=\u0026#34;tdadvice\u0026#34; ref=\u0026#34;txmanager\u0026#34;\u0026gt; \u0026lt;!--配置通知的类型要写在此处--\u0026gt; \u0026lt;/aop:aspect\u0026gt; 2.4 使用 aop:pointcut 配置切入点表达式 aop:pointcut 作用： 用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。 属性： expression：用于定义切入点表达式。 id：用于给切入点表达式提供一个唯一标识 \u0026lt;aop:pointcut id=\u0026#34;point1\u0026#34; expression=\u0026#34;execution( public void com.offcn.service.impl.accountserviceimpl.transfer(java.lang.string,java.lang.string,java.lang.double))\u0026#34;/\u0026gt; 2.5 使用 aop:xxx 配置对应的通知类型 aop：before 作用：用于配置前置通知。指定增强的方法在切入点方法之前执行 属性： method:用于指定通知类中的增强方法名称 ponitcut-ref：用于指定切入点的表达式的引用 poinitcut：用于指定切入点表达式 执行时间点： 切入点方法执行之前执行 \u0026lt;aop:before method=\u0026#34;begintransaction\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34;\u0026gt;\u0026lt;/aop:before\u0026gt; aop:after-returning 作用： 用于配置后置通知 属性： method：指定通知中方法的名称。 pointct：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 执行时间点： 切入点方法正常执行之后。它和异常通知只能有一个执行 \u0026lt;aop:after-returning method=\u0026#34;commit\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34;/\u0026gt; aop:after-throwing 作用： 用于配置异常通知 属性： method：指定通知中方法的名称。 pointct：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 执行时间点： 切入点方法执行产生异常后执行。它和后置通知只能执行一个 \u0026lt;aop:after-throwing method=\u0026#34;rollback\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34;/\u0026gt;\taop:after 作用： 用于配置最终通知 属性： method：指定通知中方法的名称。 pointct：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 执行时间点： 无论切入点方法执行时是否有异常，它都会在其后面执行。 \u0026lt;aop:after method=\u0026#34;release\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34;/\u0026gt; 3 切入点表达式说明 3.1 切点表达式的语法 execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如：\n全匹配方式\npublic void com.ujiuye.service.impl.accountserviceimpl.saveaccount(com.ujiuye.domain.account) 访问修饰符可以省略\nvoid com.ujiuye.service.impl.accountserviceimpl.saveaccount(com.ujiuye.domain.account) 返回值可以使用*号，表示任意返回值\n* com.ujiuye.service.impl.accountserviceimpl.saveaccount(com.ujiuye.domain.account) 包名可以使用 * 号，表示任意包，但是有几级包，需要写几个 *\n* *.*.*.*.accountserviceimpl.saveaccount(com.ujiuye.domain.account) 使用..来表示当前包，及其子包\n* com..accountserviceimpl.saveaccount(com.ujiuye.domain.account) 类名可以使用*号，表示任意类\n* com..*.saveaccount(com.ujiuye.domain.account) 方法名可以使用*号，表示任意方法\n* com..*.*( com.ujiuye.domain.account) 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数\n* com..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型\n* com..*.*(..) 全通配方式：\n* *..*.*(..) 注意： 通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。\nexecution(* com.ujiuye.service.impl.*.*(..)) 4 环绕通知配置事务管理 在transactionmanager类当中添加方法\n/** * 环绕通知: * spring 框架为我们提供了一个接口：proceedingjoinpoint，它可以作为环绕通知的方法参数。 * 在环绕通知执行时，spring 框架会为我们提供该接口的实现类对象，我们直接使用就行。 * @param pjp * @return */ public object transactionaround(proceedingjoinpoint pjp) { //定义返回值 object returnvalue = null; try { //获取方法执行所需的参数 object[] args = pjp.getargs(); //前置通知：开启事务 begintransaction(); //执行方法 returnvalue = pjp.proceed(args); //后置通知：提交事务 commit(); }catch(throwable e) { //异常通知：回滚事务 rollback(); e.printstacktrace(); }finally { //最终通知：释放资源 release(); } return returnvalue; } aop:around： 作用： 用于配置环绕通知 属性： method：指定通知中方法的名称。 pointct：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 说明： 它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 注意：通常情况下，环绕通知都是独立使用的 \u0026lt;aop:config\u0026gt; \u0026lt;aop:aspect id=\u0026#34;tdadvice\u0026#34; ref=\u0026#34;txmanager\u0026#34;\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;point1\u0026#34; expression=\u0026#34;execution(* com.offcn.service.impl.*.*(..))\u0026#34;/\u0026gt; \u0026lt;!-- 配置环绕通知 --\u0026gt; \u0026lt;aop:around method=\u0026#34;transactionaround\u0026#34; pointcut-ref=\u0026#34;point1\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; （三）spring基于注解的aop配置 话术： aop注解方式和xml方式完成的功能是一样的，只是采用了两种开发方式而已。将原有的xml方式使用注解逐一替代。 1 环境搭建 1.1 构建maven工程添加aop注解的相关依赖 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.2.5.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.aspectj\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;aspectjweaver\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.8.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.2 沿用上一章节资源 copy account accountdao accountdaoimpl accountservice accountserviceimpl\n1.3 在配置文件中导入 context 的名称空间且配置 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; 1.4 资源使用注解配置 \u0026lt;!-- 配置数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.combopooleddatasource\u0026#34;\u0026gt; \u0026lt;!--连接数据库的必备信息--\u0026gt; \u0026lt;property name=\u0026#34;driverclass\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcurl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置queryrunner--\u0026gt; \u0026lt;bean id=\u0026#34;queryrunner\u0026#34; class=\u0026#34;org.apache.commons.dbutils.queryrunner\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; 1.5 在配置文件中指定 spring 要扫描的包 \u0026lt;!-- 告知 spring，在创建容器时要扫描的包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.offcn\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; 2 配置步骤 1.1 通知类使用注解配置 /** * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接 */ @component(\u0026#34;txmanager\u0026#34;) public class transactionmanager { @autowired private connectionutils connectionutils; } 1.2 在通知类上使用@aspect 注解声明为切面 /** * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接 */ @component(\u0026#34;txmanager\u0026#34;) @aspect //表明当前类是一个切面类 public class transactionmanager { @autowired private connectionutils connectionutils; } 1.3 在增强的方法上使用注解配置通知 @before 作用： 把当前方法看成是前置通知 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 //开启事务 @before(\u0026#34;execution(* com.offcn.service.impl.*.*(..)))\u0026#34;) public void begintransaction(){ try { system.out.println(\u0026#34;before..........................\u0026#34;); connectionutils.getthreadconnection().setautocommit(false); }catch (exception e){ e.printstacktrace(); } } @afterreturning 作用： 把当前方法看成是后置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 // 提交事务 @afterreturning(\u0026#34;execution(* com.offcn.service.impl.*.*(..)))\u0026#34;) public void commit(){ try { connectionutils.getthreadconnection().commit(); }catch (exception e){ e.printstacktrace(); } } @afterthrowing 作用： 把当前方法看成是异常通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 //回滚事务 @afterthrowing(\u0026#34;execution(* com.offcn.service.impl.*.*(..)))\u0026#34;) public void rollback(){ try { connectionutils.getthreadconnection().rollback(); }catch (exception e){ e.printstacktrace(); } } @after 作用： 把当前方法看成是最终通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 //释放连接 @after(\u0026#34;execution(* com.offcn.service.impl.*.*(..)))\u0026#34;) public void release(){ try { connectionutils.removeconnection(); connectionutils.getthreadconnection().close();//还回连接池中 }catch (exception e){ e.printstacktrace(); } } 1.4 在 spring 配置文件中开启 spring 对注解 aop 的支持 \u0026lt;!-- 开启 spring 对注解 aop 的支持 --\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt; 1.5 环绕通知注解配置 @around 作用： 把当前方法看成是环绕通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 // 环绕通知: @around(\u0026#34;execution(* com.offcn.service.impl.*.*(..)))\u0026#34;) public object transactionaround(proceedingjoinpoint pjp) { //定义返回值 object returnvalue = null; try { //获取方法执行所需的参数 object[] args = pjp.getargs(); //前置通知：开启事务 begintransaction(); //执行方法 returnvalue = pjp.proceed(args); //后置通知：提交事务 commit(); }catch(throwable e) { //异常通知：回滚事务 rollback(); e.printstacktrace(); }finally { //最终通知：释放资源 release(); } return returnvalue; } 1.6 切入点表达式注解 @pointcut(\u0026#34;execution(* com.offcn.service.impl.*.*(..))\u0026#34;) private void point1() {} // 环绕通知: @around(\u0026#34;point1()\u0026#34;)///注意：千万别忘了写括号 public object transactionaround(proceedingjoinpoint pjp) { //定义返回值 object returnvalue = null; try { //获取方法执行所需的参数 object[] args = pjp.getargs(); //前置通知：开启事务 begintransaction(); //执行方法 returnvalue = pjp.proceed(args); //后置通知：提交事务 commit(); }catch(throwable e) { //异常通知：回滚事务 rollback(); e.printstacktrace(); }finally { //最终通知：释放资源 release(); } return returnvalue; } 作业： aop 控制事务， 纯注解开发~\n二、 spring事务详解 讲解思路： 1、介绍spring当中进行事务控制的常用对象以及作用 2、事务的隔离级别，不同隔离级别产生的错误数据 3、扩展事务的传播行为，事务传播行为的对应几种情况，面试问题 4、完成基于xml形式事务配置 （一）spring中事务的api详解 1 platformtransactionmanager作用【掌握】 platformtransactionmanager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。\n注意：\nplatformtransactionmanager 是接口类型，不同的 dao 层技术则有不同的实现类，例如：dao 层技术是jdbc 或 mybatis 时，jdbctemplate 对象：org.springframework.jdbc.datasource.datasourcetransactionmanager\ndao 层技术是hibernate时：org.springframework.orm.hibernate5.hibernatetransactionmanager\n2 transactiondefinition作用 transactiondefinition 是事务的定义信息对象，里面有如下方法\n2.1 事务隔离级别 设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。\n事务隔离级别 说明 isolation_default 默认级别，归属下列某一种 isolation_read_uncommitted 未提交读，可以读取未提交数据 isolation_read_committed 已提交读，只能读取已提交数据，解决脏读问题（oracle默认级别） isolation_repeatable_read 可重复读，解决不可重复度问题（mysql默认级别） isolation_serializable 串行化，节约幻读（虚读）问题 2.2 事务传播行为 事务传播行为 说明 required 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） supports 支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） mandatory 使用当前的事务，如果当前没有事务，就抛出异常 requers_new 新建事务，如果当前在事务中，把当前事务挂起。 not_supported 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 never 以非事务方式运行，如果当前存在事务，抛出异常 nested 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 required 类似的操作 2.3 事务超时时间 默认值是-1，没有超时限制。如果有，以秒为单位进行设置。\n2.4 是否是只读事务 建议查询时设置为只读。\n3 transactionstatus作用 transactionstatus 接口提供的是事务具体的运行状态，方法介绍如下。\n4 上述三个对象关系 platformtransactionmanager 根据transactiondefinition 定义的事务属性，进行事务的管理， 在事务管理的过程当中产生的状态信息保存在transactionstatus。\n（二）spring基于xml的事务配置 讲解思路： 1、准备转账的业务场景，演示没有事务控制时，数据一致性受损 2、在xml配置文件当中，使用spring提供的声明式事务进行控制，详解事务控制的每个步骤，每个步骤当中涉及的每个标签，讲解的过程当中复习巩固aop当中的相关概念，加深学员对概念的理解 3、测试基于xml声明式事务是否生效 1 环境搭建 1.1 构建maven工程，添加相关技术依赖 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.2.5.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--导入junit单元测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入spring的context坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-test\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入jdbc模块依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入mysql 驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入c3p0连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.mchange\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;c3p0\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--aop--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.aspectj\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;aspectjweaver\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.8.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 1.2 创建spring 的配置文件并导入约束 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemalocation=\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- 告知 spring，在创建容器时要扫描的包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.offcn\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 配置数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.combopooleddatasource\u0026#34;\u0026gt; \u0026lt;!--连接数据库的必备信息--\u0026gt; \u0026lt;property name=\u0026#34;driverclass\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcurl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--jdbctemplate--\u0026gt; \u0026lt;bean id=\u0026#34;jdbctemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.jdbctemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.3 沿用转账业务的代码 copy account accountdao accountdaoimpl accontservice accountserviceimpl 代码：\n注意： accountdaoimpl 具体使用使用spring提供的jdbctemplate模板对象实现\n@repository(\u0026#34;accountdao\u0026#34;) public class accountdaoimpl implements accountdao { @autowired private jdbctemplate jdbctemplate; @override public account findbyname(string name) { string sql =\u0026#34;select * from account where name =? \u0026#34;; account account = this.jdbctemplate.queryforobject(sql, new beanpropertyrowmapper\u0026lt;\u0026gt;(account.class), name); return account; } @override public void update(account account) { string sql =\u0026#34;update account set money =? where name =? \u0026#34;; this.jdbctemplate.update(sql, account.getmoney(), account.getname()); } } 2 事务管理配置步骤 2.1 配置事务管理器 \u0026lt;!--平台事务管理器--\u0026gt; \u0026lt;bean id=\u0026#34;transactionmanager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.datasourcetransactionmanager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 2.2 配置事务的通知引用事务管理器 \u0026lt;!--事务的配置--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txadvice\u0026#34; transaction-manager=\u0026#34;transactionmanager\u0026#34;\u0026gt; \u0026lt;/tx:advice\u0026gt; 2.3 配置事务的属性 \u0026lt;!-- 指定方法名称：是业务核心方法 read-only：是否是只读事务。默认 false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。 没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。 --\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;tx:method name=\u0026#34;*\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; 2.4 配置 aop 切入点表达式 \u0026lt;!--事务的aop增强--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;mypointcut\u0026#34; expression=\u0026#34;execution(* com.offcn.service.impl.*.*(..))\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; 2.5 配置切入点表达式和事务通知的对应关系 \u0026lt;!--在aop：config标签内部：建立事务的通知和切入点表达式的关系--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txadvice\u0026#34; pointcut-ref=\u0026#34;mypointcut\u0026#34;\u0026gt;\u0026lt;/aop:advisor\u0026gt; 三、 spring事务详解-注解 （一） spring基于注解的事务配置 1 环境搭建 1.1 构建maven工程，添加相关技术依赖 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.2.5.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--导入junit单元测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入spring的context坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-test\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入jdbc模块依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入mysql 驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入c3p0连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.mchange\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;c3p0\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--aop--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.aspectj\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;aspectjweaver\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.8.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1.2 创建 spring 的配置文件并导入约束 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemalocation=\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- 告知 spring，在创建容器时要扫描的包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.offcn\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 配置数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.combopooleddatasource\u0026#34;\u0026gt; \u0026lt;!--连接数据库的必备信息--\u0026gt; \u0026lt;property name=\u0026#34;driverclass\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcurl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--jdbctemplate--\u0026gt; \u0026lt;bean id=\u0026#34;jdbctemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.jdbctemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.3 沿用转账业务的代码：dao实现类和service实现类采用注解的形式，添加到容器中管理 copy account accountdao accountimpl accountservice accountserviceimpl 到工程当中复用\n2 事务管理配置步骤(重点) 2.1 配置事务管理器并注入数据源 \u0026lt;!-- 配置事务管理器 --\u0026gt; \u0026lt;bean id=\u0026#34;transactionmanager\u0026#34;class=\u0026#34;org.springframework.jdbc.datasource.datasourcetransactionmanager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 2.2 在业务层使用@transactional 注解 /** 该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。 出现接口上，表示该接口的所有实现类都有事务支持。 出现在类上，表示类中所有方法有事务支持 出现在方法上，表示方法有事务支持。 以上三个位置的优先级：方法\u0026gt;类\u0026gt;接口 */ @service(\u0026#34;accountservice\u0026#34;) @transactional(readonly = true,propagation = propagation.supports) public class accountserviceimpl implements accountservice { //依赖dao层 @autowired private accountdao accountdao ; @transactional(readonly = false,propagation = propagation.required) @override public void transfer(string sourceaccountname, string targetaccountname, double money) { account saccount = accountdao.findbyname(sourceaccountname); account taccount = accountdao.findbyname(targetaccountname); //来源账户减钱，目标账户加钱 saccount.setmoney(saccount.getmoney()-money); taccount.setmoney(taccount.getmoney()+money); //持久化到数据库 accountdao.update(saccount); //模拟异常发生 //int i=1/0; accountdao.update(taccount); } } 2.3 在配置文件中开启 spring 对注解事务的支持 \u0026lt;!-- 开启 spring 对注解事务的支持 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;transactionmanager\u0026#34;/\u0026gt; 作业： 全注解开发~\n四、 spring整合mybatis实现用户的crud （一）整合思路分析 mybatis框架是一个持久层orm框架，而spring则是一个综合性一站式框架。所以整合是mybatis往spring上整合。就是让spring框架接管mybatis的组件。\nmybatis单独运行时，数据源的管理，事务的管理， sqlsessionfactory 以及接口的实现类都是mybatis管理的，整合后以上组件交给spring管理。\n（二）构建maven工程，添加技术依赖 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;5.2.5.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--导入junit单元测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入spring的context坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-test\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入jdbc模块依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入mysql 驱动--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--导入c3p0连接池--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.mchange\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;c3p0\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--aop--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.aspectj\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;aspectjweaver\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.8.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis-spring适配包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-spring\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.0.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis orm框架 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; （三）构建数据库表并创建实体user create table user( id int primary key auto_increment, name varchar(32) not null, address varchar(32) not null, birthday date ); public class user implements serializable { private integer id; private string name; private string address; private date birthday; public integer getid() { return id; } public void setid(integer id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getaddress() { return address; } public void setaddress(string address) { this.address = address; } public date getbirthday() { return birthday; } public void setbirthday(date birthday) { this.birthday = birthday; } @override public string tostring() { return \u0026#34;user{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, address=\u0026#39;\u0026#34; + address + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, birthday=\u0026#34; + birthday + \u0026#39;}\u0026#39;; } } （四）编写dao层的接口usermapper public interface usermapper { int insert(user user); int update(user user); int delete(integer id); user findbyid(integer id); list\u0026lt;user\u0026gt; findall(); } （五）构建mapper接口对应的sql配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.offcn.mapper.usermapper\u0026#34;\u0026gt; \u0026lt;resultmap id=\u0026#34;baseresultmap\u0026#34; type=\u0026#34;com.offcn.pojo.user\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; jdbctype=\u0026#34;integer\u0026#34; property=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; jdbctype=\u0026#34;varchar\u0026#34; property=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;address\u0026#34; jdbctype=\u0026#34;varchar\u0026#34; property=\u0026#34;address\u0026#34; /\u0026gt; \u0026lt;result column=\u0026#34;birthday\u0026#34; jdbctype=\u0026#34;date\u0026#34; property=\u0026#34;birthday\u0026#34; /\u0026gt; \u0026lt;/resultmap\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; parametertype=\u0026#34;com.offcn.pojo.user\u0026#34;\u0026gt; insert into user (name, birthday, address) values (#{name}, #{birthday},#{address}) \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update user set name= #{name}, birthday=#{birthday}, address = #{address} where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;delete\u0026#34;\u0026gt; delete from user where id =#{id} \u0026lt;/delete\u0026gt; \u0026lt;select id=\u0026#34;findbyid\u0026#34; resultmap=\u0026#34;baseresultmap\u0026#34;\u0026gt; select * from user where id=#{id} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;findall\u0026#34; resultmap=\u0026#34;baseresultmap\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; （六）构建服务层接口userservice public interface userservice { int insert(user user); int update(user user); int delete(integer id); user findbyid(integer id); list\u0026lt;user\u0026gt; findall(); } （七）构建服务层实现类userserviceimpl @service public class userserviceimpl implements userservice { @autowired private usermapper usermapper; @override public int insert(user user) { int num = usermapper.insert(user); return num; } @override public int update(user user) { int num = usermapper.update(user); return num; } @override public int delete(integer id) { int num = usermapper.delete(id); return num; } @override public user findbyid(integer id) { user user = usermapper.findbyid(id); return user; } @override public list\u0026lt;user\u0026gt; findall() { list\u0026lt;user\u0026gt; userlist = usermapper.findall(); return userlist; } } （八）构建spring框架的配置文件applicationcontext.xml,配置ioc管理的对象【重点】 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemalocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--开启包扫描--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.offcn\u0026#34;\u0026gt; \u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 配置数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;datasource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.combopooleddatasource\u0026#34;\u0026gt; \u0026lt;!--连接数据库的必备信息--\u0026gt; \u0026lt;property name=\u0026#34;driverclass\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcurl\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--mybatis 核心对象： 工厂对象--\u0026gt; \u0026lt;bean id=\u0026#34;sqlsessionfactory\u0026#34; class=\u0026#34;org.mybatis.spring.sqlsessionfactorybean\u0026#34;\u0026gt; \u0026lt;!--工厂创建必须注入一个数据源--\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;!--指定mapper文件位置--\u0026gt; \u0026lt;property name=\u0026#34;mapperlocations\u0026#34; value=\u0026#34;classpath:com/offcn/mapper/*mapper.xml\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--引入mybatis的核心配置文件： 如果mybaits的核心配置要保留，需要再此处配置： --\u0026gt; \u0026lt;property name=\u0026#34;configlocation\u0026#34; value=\u0026#34;classpath:sqlmapconfig.xml\u0026#34;/\u0026gt; \u0026lt;!--别名配置--\u0026gt; \u0026lt;property name=\u0026#34;typealiasespackage\u0026#34; value=\u0026#34;com/offcn/pojo\u0026#34;/\u0026gt; \u0026lt;!--进行分页插件的配置--\u0026gt; \u0026lt;property name=\u0026#34;plugins\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;bean class=\u0026#34;com.github.pagehelper.pageinterceptor\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;properties\u0026#34;\u0026gt; \u0026lt;value\u0026gt; helperdialect=mysql reasonable=true supportmethodsarguments=true params=count=countsql autoruntimedialect=true \u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置接口的扫描--\u0026gt; \u0026lt;bean id=\u0026#34;mapperscannerconfigurer\u0026#34; class=\u0026#34;org.mybatis.spring.mapper.mapperscannerconfigurer\u0026#34;\u0026gt; \u0026lt;!--指定了包： 能够将包下的接口生成实现类： --\u0026gt; \u0026lt;property name=\u0026#34;basepackage\u0026#34; value=\u0026#34;com.offcn.mapper\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置平台管理器--\u0026gt; \u0026lt;bean id=\u0026#34;transactionmanager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.datasourcetransactionmanager\u0026#34;\u0026gt; \u0026lt;!--注入数据源--\u0026gt; \u0026lt;property name=\u0026#34;datasource\u0026#34; ref=\u0026#34;datasource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;transactionmanager\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; （九）测试代码 @runwith(springjunit4classrunner.class) @contextconfiguration(locations = \u0026#34;classpath:applicationcontext.xml\u0026#34;) public class testaccounttransfer { @autowired private userservice userservice; //save @test public void testinsert(){ user user = new user(); user.setname(\u0026#34;admin\u0026#34;); user.setaddress(\u0026#34;china\u0026#34;); user.setbirthday(new date()); int num = userservice.insert(user); system.out.println(\u0026#34;num:\u0026#34;+num); } //update @test public void testupdate(){ user user = new user(); user.setname(\u0026#34;marry\u0026#34;); user.setaddress(\u0026#34;america\u0026#34;); user.setbirthday(new date()); user.setid(1); int num = userservice.update(user); system.out.println(\u0026#34;num:\u0026#34;+num); } //delete: @test public void testdelete(){ int num = userservice.delete(1); system.out.println(\u0026#34;num:\u0026#34;+num); } //findbyid @test public void testfindbyid(){ user user = userservice.findbyid(2); system.out.println(\u0026#34;user:\u0026#34;+user); } //findall @test public void testfindbyall(){ list\u0026lt;user\u0026gt; userlist = userservice.findall(); system.out.println(\u0026#34;userlist:\u0026#34;+userlist); } } ","date":"2022-05-25","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220526005077/","summary":"复习回顾： DI： 依赖注入 依赖注入的方式： 构造器注入： setter注入u: P名称空间注入： SpEL表达式注入： IOC的注解版本： @Component 所属的类没有明确的层级划分， 此时","title":"spring-2"},{"content":"\n服务器 理解 web服务器一般是指网站服务器，为软件提供后台服务的软件。相当于远程的一台计算机包含磁盘 cpu 内存和服务器软件等。我们这里的服务器指 服务器软件 常见服务器软件： tomcat(apacha) 目前最流行的javaweb服务器软件。开源免费 jboss weblogic ...... tomcat的使用 1. 下载 解压 apache-tomcat-8.5.20-windows-x64.zip 解压的目录不要过深 不要有中文 2. 配置好jdk 需要配置java_home环境变量 目录： bin：tomcat二进制启动文件 conf：tomcat配置文件 lib: tomcat依赖包 logs: tomcat运行的日志信息 temp：临时文件 webapps: web工程 work：编译文件 idea与tomcat整合 ","date":"2022-05-24","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430214937/","summary":"服务器 理解 web服务器一般是指网站服务器，为软件提供后台服务的软件。相当于远程的一台计算机包含磁盘 CPU 内存和服务器软件等。我们这里的服务器指 服务器软件 常见服务器软","title":"html dom"},{"content":"","date":"2022-05-24","permalink":"https://lovemjh.vercel.app/posts/001/20220524212885/","summary":"","title":"jdbc"},{"content":"sql片段 sql的配置文件中出现sql冗余 在开发中，sql的拼接很常见，有很多对拼接的sql具有重复性高的特点，有sql冗余，不仅不美观还导致映射文件配置臃肿，这时最好把重复的sql抽取出来，作为公用的sql片段，尤其在动态sql中应用中更加显著，提高可重用性。\n定义sql片段 \u0026lt;!--使用sql标签定义一个sql片段--\u0026gt; \u0026lt;sql id=\u0026#34;basecolumn \u0026#34;\u0026gt; id,name,gender,age \u0026lt;/sql\u0026gt; 使用sql片段 \u0026lt;select id=\u0026#34;getusers\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select \u0026lt;include refid= \u0026#34;basecolumn\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; from user \u0026lt;/select\u0026gt; 动态sql语句 动态sql介绍 动态sql的概念 顾名思义，sql 是动态拼接成的，根据传入的变量值进行逻辑操作并动态拼接，方便实现多条件下的数据库操作。在业务逻辑复杂，即简单 sql 无法完成时，需要拼接时就要使用动态sql。\n动态sql解决的问题 动态sql主要解决根据条件判断附加条动态sql主要解决多条件变化查询，实现自动判断记录字段是否需要更新，根据条件判断附加条sql条件，实现批量添加数据、批量修改数据、批量修删除数据等，优化sql语句，提高执行效率。\n构建测试环境 创建maven项目 添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;log4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;log4j\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 创建bean\npublic class user implements serializable { private integer id; private string name; private string gender; private integer age; private date birthday; public user() {} public user(string name, string gender, integer age, date birthday) { this.name = name; this.gender = gender; this.age = age; this.birthday = birthday; } //生成getter和setter方法 } 创建接口\npublic interface usermapper { } 编写框架配置文件和sql映射文件 编写框架配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype configuration public \u0026#34;-//mybatis.org//dtd config 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 配置 mybatis的环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置环境 --\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置事务的类型 --\u0026gt; \u0026lt;transactionmanager type=\u0026#34;jdbc\u0026#34;\u0026gt;\u0026lt;/transactionmanager\u0026gt; \u0026lt;!-- 配置连接数据库的信息:用的是数据源【连接池】--\u0026gt; \u0026lt;datasource type=\u0026#34;pooled\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/datasource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!-- 注册userdao接品映射文件位置 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;cn/offcn/mapper/usermapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;x sql映射文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.mapper.usermapper\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt; where标签 where标签简介 where标签用于代替sql中的where关键字，可以根据条件判断是否附加where关键字。如果where标签中有条件成立就会附加where关键字，如果没有成立的条件就不会附加where关键字. 可以去掉离他最近一个无关的and 或or关键字.where标签的书写格式为\u0026lt;where\u0026gt;添写附加条件\u0026lt;/where\u0026gt; where标签使用 编写接口方法findbyuser /** * 根据user中的字段进行查询 * @return */ public list\u0026lt;user\u0026gt; findbyuser(user user); 使用where标签进行sql处理 \u0026lt;select id=\u0026#34;findbyuser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user \u0026lt;where\u0026gt; and name=#{name} and age=#{age} \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 测试findbyuser方法 @test public void testfindbyuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //创建user对象 user user=new user(); user.setname(\u0026#34;张三\u0026#34;); user.setage(22); list\u0026lt;user\u0026gt; userlist = usermapper.findbyuser(user); //遍历 userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } if标签标签的应用 if标签简介 if标签表示逻辑条件判断，如果条件成立就附加\u0026lt;if\u0026gt;\u0026lt;/if\u0026gt;之间的sql语句,如果条件不成立就不附加\u0026lt;if\u0026gt;\u0026lt;/if\u0026gt;之间的sql语句。书写格式为:\u0026lt;if test=\u0026#34;表达式\u0026#34;\u0026gt;sql语句\u0026lt;/if\u0026gt; if标签使用 编写接口方法findusersbycondition /** * 根据条件查询 * @param user * @return */ public list\u0026lt;user\u0026gt; findusersbycondition(user user); 使用if标签进行sql处理 \u0026lt;select id=\u0026#34;findusersbycondition\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age!=null\u0026#34;\u0026gt; and age=#{age} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; and gender=#{gender} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 测试findusersbycondition方法 @test public void testfindusersbycondition() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //创建user对象 user user=new user(); user.setname(\u0026#34;王五\u0026#34;); user.setage(20); user.setgender(\u0026#34;男\u0026#34;); list\u0026lt;user\u0026gt; userlist = usermapper.findusersbycondition(user); //遍历 userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } 通过产生的sql语句可以看出，当if标签中test属性表达式为true时，就会附加if标签之间的条件。 注意：\u0026lt;if\u0026gt;标签的 test 属性中写的是对象的属性名，如果是包装类的对象要使用 ognl 表达式的写法。 set标签的应用 set标签简介 set标签用于更新语句中，代替set关键字，可以有效对指定字段进行更新，提升sql的执行效率。，当set标签中有条件成立时就会附加set标签，set标签会去除无关的逗号。set标签中一般嵌套if标签进行使用其格式为 \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name\u0026#34;\u0026gt; name=#{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age\u0026#34;\u0026gt; age=#{age}, \u0026lt;/if\u0026gt; ...... \u0026lt;/set\u0026gt; set标签使用 编写接口方法updateuser /** * 更新user * @param user */ public void updateuser(user user); 使用set标签进行sql处理 \u0026lt;update id=\u0026#34;updateuser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; update user \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; gender=#{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age!=null\u0026#34;\u0026gt; age=#{age} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;birthday!=null\u0026#34;\u0026gt; birthday=#{birthday} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; 测试updateuser方法 @test public void testupdateuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //创建user对象 user user=new user(); user.setname(\u0026#34;王五\u0026#34;); user.setage(20); //更新user usermapper.updateuser(user); //提交事务 mybatisutils.close(session); //关闭连接 mybatisutils.close(session); } 通过产生的sql语句可以看出，当set标签中有条件成立时就会附加set关键字，字段为null时该列不会被更新。set可以忽略与sql无关的逗号。 trim标签 trim标签简介 trim标签为万能标签，可用于set或where等。prefix表示要附加的前缀关键字，suffix表示要附加的后缀关键字,prefixoverrides表示要忽略前置字符，suffixoverrides表示要忽略后置字符。 格式: \u0026lt;trim prefix=\u0026#34;where\u0026#34; prefixoverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age!=null\u0026#34;\u0026gt; age=#{age} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; gender=#{gender} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; trim标签使用 修改where标签和set标签 1)应用于where \u0026lt;select id=\u0026#34;findusersbycondition\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user \u0026lt;trim prefix=\u0026#34;where\u0026#34; prefixoverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age!=null\u0026#34;\u0026gt; age=#{age} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; gender=#{gender} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; ​ 2)用于set标签 \u0026lt;update id=\u0026#34;updateuser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; update user \u0026lt;trim prefix=\u0026#34;set\u0026#34; suffixoverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name=#{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; gender=#{gender}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age!=null\u0026#34;\u0026gt; age=#{age}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;birthday!=null\u0026#34;\u0026gt; birthday=#{birthday} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; 测试方法测试updateuser和findusersbycondition方法 @test public void testfindusersbycondition() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //创建user对象 user user=new user(); user.setname(\u0026#34;王五\u0026#34;); user.setage(20); user.setgender(\u0026#34;男\u0026#34;); list\u0026lt;user\u0026gt; userlist = usermapper.findusersbycondition(user); //遍历 userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } @test public void testupdateuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //创建user对象 user user=new user(); user.setname(\u0026#34;王五\u0026#34;); user.setage(20); //更新user usermapper.updateuser(user); //提交事务 mybatisutils.close(session); //关闭连接 mybatisutils.close(session); } choose标签 + 标签简介 choose标签作用条件判断来拼接指定的条件，它和if不太相同，choose似类于java中的switch语句用法，直要有条件成立，其它判断将得不到执行，如果所有条件都不成立则执行otherwise标签中的内容。 格式: \u0026lt;choose\u0026gt; \u0026lt;when test=条件1\u0026gt; 执行的代码； \u0026lt;/when\u0026gt; \u0026lt;when test=条件2\u0026gt; 执行的代码； \u0026lt;/when\u0026gt; ...... \u0026lt;otherwise\u0026gt; 执行的代码； \u0026lt;/when\u0026gt; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; choose标签使用 编写接口方法getinfobyuser /** * 查询符合条件的所有user对象 * @param user * @return */ public list\u0026lt;user\u0026gt; getinfobyuser(user user); 使用choose标签进行sql处理 \u0026lt;select id=\u0026#34;getinfobyuser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;name!=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;age!=null\u0026#34;\u0026gt; age=#{age} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;gender!=null\u0026#34;\u0026gt; gender=#{gender} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; birthday=\u0026#39;1991-10-10\u0026#39; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 测试接口方法getinfobyuser @test public void testgetinfobyuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //创建user对象 user user=new user(); user.setname(\u0026#34;张三\u0026#34;); user.setage(22); list\u0026lt;user\u0026gt; userlist = usermapper.getinfobyuser(user); //遍历 userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } foreach标签 foreach标签简介 foreach标签表示循环，对sql中有重复的部分可以使用此循环来动态拼接sql语句。可以实现批量添加、批量删除、批量更新操作。foreach标签中有很多的属性，请参考下面的foreach标签属性表。 属性名称 含义 collection 指定你要使用的集合类型 item 集合中每个元素。 open 在起始时，需要附加字符串，只附加一次。 close 在结束时，需要附加字符，只附加一次。 separator 在每个循环结时需要附加的字符串。 index 每个循环的索引值。 foreach标签使用 在接口中创建 addbatchuser、updatebatchuser、deletebatchuser /** * 批量添加 * @param userlist */ public void addbatchuser(list\u0026lt;user\u0026gt; userlist); /** * 批量更新 * @param userlist */ public void updatebatchuser(list\u0026lt;user\u0026gt; userlist); /** * 批量删除 * @param ids */ public void deletebatchuser(list\u0026lt;integer\u0026gt; ids); 使用forcach标签进行sql处理 \u0026lt;!--批量添加--\u0026gt; \u0026lt;insert id=\u0026#34;addbatchuser\u0026#34;\u0026gt; insert into user (name,gender,age,birthday) values \u0026lt;foreach collection=\u0026#34;list\u0026#34; item=\u0026#34;user\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; (#{user.name},#{user.gender},#{user.age},#{user.birthday}) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;!--批量更新--\u0026gt; \u0026lt;update id=\u0026#34;updatebatchuser\u0026#34;\u0026gt; \u0026lt;foreach collection=\u0026#34;list\u0026#34; item=\u0026#34;user\u0026#34; separator=\u0026#34;;\u0026#34;\u0026gt; update set user name=#{user.name},gender=#{user.gender},age=#{user.age},birthday=#{user.birthday} where id=#{id} \u0026lt;/foreach\u0026gt; \u0026lt;/update\u0026gt; \u0026lt;!--批量删除--\u0026gt; \u0026lt;delete id=\u0026#34;deletebatchuser\u0026#34;\u0026gt; delete from user where id in \u0026lt;foreach collection=\u0026#34;list\u0026#34; item=\u0026#34;userid\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{userid} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; 测试 //批量添加测试 @test public void testaddbatchuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); list\u0026lt;user\u0026gt; userlist=new arraylist\u0026lt;\u0026gt;(); userlist.add(new user(\u0026#34;赵丽\u0026#34;,\u0026#34;女\u0026#34;,22,new date())); userlist.add(new user(\u0026#34;李宁\u0026#34;,\u0026#34;女\u0026#34;,25,new date())); userlist.add(new user(\u0026#34;王海涛\u0026#34;,\u0026#34;男\u0026#34;,20,new date())); usermapper.addbatchuser(userlist); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } //批量更新测试 @test public void testupdatebatchuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); list\u0026lt;user\u0026gt; userlist=new arraylist\u0026lt;\u0026gt;(); userlist.add(new user(1,\u0026#34;赵刚\u0026#34;,\u0026#34;男\u0026#34;,24,new date())); userlist.add(new user(2,\u0026#34;白雪\u0026#34;,\u0026#34;女\u0026#34;,25,new date())); userlist.add(new user(3,\u0026#34;王海燕\u0026#34;,\u0026#34;女\u0026#34;,20,new date())); usermapper.updatebatchuser(userlist); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } //批量删除测试 @test public void testdeletebatchuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); list\u0026lt;integer\u0026gt; ids=arrays.aslist(1,2,3); usermapper.deletebatchuser(ids); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } 注意：mysql本身不支持批量更新，如果需要批量更新时在url中附加allowmultiqueries=true \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql:///mybatis002?allowmultiqueries=true\u0026#34;/\u0026gt; 多表联合查询 多表联合查询概述 在开发过程中单表查询不能满足项目需求分析功能，对于复杂业务来讲，关联的表有几张，甚至几十张并且表与表之间的关系相当复杂。为了能够实业复杂功能业务，就必须进行多表查询，在mybatis中提供了多表查询的结果时映射标签，可以实现表之间的一对一、一对多、多对一、多对多关系映射。\nmybatis多表查询之一对一 构建数据库表:person(个人表) idcard(身份证表) #person表 create table person( p_id int not null auto_increment, p_name varchar(30), primary key(p_id) ); #idcard表 create table idcard( c_id int not null auto_increment, c_cardno varchar(18), c_uselife date, c_person_id int not null, primary key(c_id), foreign key(c_person_id) references person(p_id), unique key(c_cardno), unique key(c_person_id) ); insert into person(p_name) values(\u0026#39;张三\u0026#39;),(\u0026#39;李四\u0026#39;); insert into idcard(c_cardno,c_uselife,c_person_id) values(\u0026#39;110112199012127821\u0026#39;,\u0026#39;2029-10-10\u0026#39;,1); insert into idcard(c_cardno,c_uselife,c_person_id) values(\u0026#39;120114199911103491\u0026#39;,\u0026#39;2030-12-01\u0026#39;,2); 准备项目环境 构建maven项目，添加依赖 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;log4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;log4j\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写框架配置文件sqlmapconfig.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype configuration public \u0026#34;-//mybatis.org//dtd config 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 配置 mybatis的环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置环境 --\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置事务的类型 --\u0026gt; \u0026lt;transactionmanager type=\u0026#34;jdbc\u0026#34;\u0026gt;\u0026lt;/transactionmanager\u0026gt; \u0026lt;!-- 配置连接数据库的信息:用的是数据源【连接池】--\u0026gt; \u0026lt;datasource type=\u0026#34;pooled\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis002\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/datasource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;cn.offcn.dao\u0026#34;\u0026gt;\u0026lt;/package\u0026gt; \u0026lt;/mappers \u0026lt;/configuration\u0026gt; 方式一：嵌套结果方式 创建数据模型person,idcard package cn.offcn.entity; public class person { private int id; private string name; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } } public class idcard { private int id; private string cardno; private date uselife; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getcardno() { return cardno; } public void setcardno(string cardno) { this.cardno = cardno; } public date getuselife() { return uselife; } public void setuselife(date uselife) { this.uselife = uselife; } } 编写sql语句 实现查询个人信息时，也要查询个人所对应的身份证信息。 select p.*,c.* from person p, idcard c where p.p_id=c.c_person_id and p.p_id=1; 编写personidcard类 public class personidcard extends person{ private string cardno; private date uselife; public string getcardno() { return cardno; } public void setcardno(string cardno) { this.cardno = cardno; } public date getuselife() { return uselife; } public void setuselife(date uselife) { this.uselife = uselife; } } 定义持久层接口persondao public interface persondao{ /** * 根据id查询person对象 */ public personidcard getpersonbyid(int id); } 定义 persondao.xml 文件中的查询配置信息 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.dao.persondao\u0026#34;\u0026gt; \u0026lt;!-- 配置查询操作--\u0026gt; \u0026lt;select id=\u0026#34;getpersonbyid\u0026#34; resultmap=\u0026#34;personresultmap\u0026#34;\u0026gt; select p.*,c.* from person p, idcard c where p.p_id=c.c_person_id and p.p_id=#{id}; \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;personresultmap\u0026#34; type=\u0026#34;cn.offcn.entity.personidcard\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;p_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;p_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;p_name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;c_cardno\u0026#34; property=\u0026#34;cardno\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;c_uselife\u0026#34; property=\u0026#34;uselife\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultmap\u0026gt; \u0026lt;/mapper\u0026gt; 创建 persontest 测试类 @test public void testgetpersonbyid() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 persondao persondao = session.getmapper(persondao.class); personidcard personidcard=persondao.getpersonbyid(1); //打印 system.out.println(personidcard); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } 方式二：嵌套查询方式 修改person类:添加idcard属性 public class person { private int id; private string name; private idcard idcard; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public idcard getidcard() { return idcard; } public void setidcard(idcard idcard) { this.idcard = idcard; } } 修改 persondao 接口中的方法 public interface persondao{ /** * 根据id查询person对象 */ public person getpersonbyid(int id); } 定义身份证的持久层接口idcarddao public interface idcarddao{ /** * 根据c_person_id查询idcard对象 */ public person getidcardbypersonid(int id); } 定义 idcarddao.xml 文件中的查询配置信息 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.dao.idcard\u0026#34;\u0026gt; \u0026lt;!-- 配置查询操作--\u0026gt; \u0026lt;select id=\u0026#34;getidcardbypersonid\u0026#34; resultmap=\u0026#34;idcardresultmap\u0026#34;\u0026gt; select * from idcard c where c_person_id=#{id}; \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;idcardresultmap\u0026#34; type=\u0026#34;cn.offcn.entity.idcard\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;c_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;c_cardno\u0026#34; property=\u0026#34;cardno\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;c_uselife\u0026#34; property=\u0026#34;uselife\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultmap\u0026gt; \u0026lt;/mapper\u0026gt; 修改persondao.xml 文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.dao.persondao\u0026#34;\u0026gt; \u0026lt;!-- 配置查询操作--\u0026gt; \u0026lt;select id=\u0026#34;getpersonbyid\u0026#34; resultmap=\u0026#34;personresultmap\u0026#34;\u0026gt; select * from person p, where p_id=#{id}; \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;personresultmap\u0026#34; type=\u0026#34;cn.offcn.entity.person\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;p_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;p_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;p_name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;!--映射person类中的复杂字段idcard对象属性--\u0026gt; \u0026lt;association property=\u0026#34;idcard\u0026#34; javatype=\u0026#34;idcard\u0026#34; column=\u0026#34;p_id\u0026#34; select=\u0026#34;cn.offcn.dao.idcard.getidcardbypersonid\u0026#34;\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultmap\u0026gt; \u0026lt;/mapper\u0026gt; column:表示取上次查询出来的指定列的值，做为select属性所指定的查询的输入值。 select:表示指定的查询. persontest 类中加入测试方法 @test public void testgetpersonbyid() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 persondao persondao = session.getmapper(persondao.class); person person=persondao.getpersonbyid(1); //打印 system.out.println(person); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } mybatis实现一对多查询 创建数据库表:department(部门表),employee(员工表)同时设定部门和员工表的关系 create table department( d_id int not null auto_increment, d_name varchar(100), primary key(d_id) ); create table employee( e_id int not null auto_increment, e_name varchar(30), e_gender varchar(6), e_age int, e_depart_id int, primary key(e_id), foreign key(e_depart_id) references department(d_id) ); 方式一:嵌套结果的方式 创建数据模型department和employee public class department { private int id; private string name; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } } public class employee { private int id; private string name; private string gender; private integer age; public employee(){} public employee(int id,string name, string gender, int age) { this.id=id; this.name = name; this.gender = gender; this.age = age; } public employee(string name, string gender, int age) { this.name = name; this.gender = gender; this.age = age; } public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } public string getgender() { return gender; } public void setgender(string gender) { this.gender = gender; } public integer getage() { return age; } public void setage(integer age) { this.age = age; } } 编写一对多的sql查询语句 select d.*,e.* from department d, employee e where e.e_depart_id=d.d_id and d.d_id=#{id} department类中加入list\u0026lt;employee\u0026gt;属性 private list\u0026lt;employee\u0026gt; emps; public list\u0026lt;employee\u0026gt; getemps() { return emps; } public void setemps(list\u0026lt;employee\u0026gt; emps) { this.emps = emps; } 部门持久层departmentdao 接口中加入查询方法 import cn.offcn.entity.department; public interface departmentmapper { public department getdepartmentbyid(int id); } 部门持久层 departmentdao.xml 映射文件配置 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.mapper.departmentdao\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;getdepartmentbyid\u0026#34; resultmap=\u0026#34;departemntresultmap2\u0026#34;\u0026gt; select d.*,e.* from department d, employee e where e.e_depart_id=d.d_id and d.d_id=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;departemntresultmap\u0026#34; type=\u0026#34;department\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;d_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;d_name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;emps\u0026#34; oftype=\u0026#34;employee\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;e_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;e_name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;e_gender\u0026#34; property=\u0026#34;gender\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;e_age\u0026#34; property=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultmap\u0026gt; collection：当属性为集合时，使用collection标签进行映射。 测试方法 @test public void testgetdepartentbyid() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 departmentdao departmentdao = session.getmapper(departmentdao.class); department dept=departmentdao.getdepartentbyid(1); //打印 system.out.println(dept); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } 方式二:嵌套查询的方式 定义员工的持久层接口employeedao public interface employeedao { public list\u0026lt;employee\u0026gt; getemployeebydepartid(int id); } 定义 employeedao.xml 文件中的查询配置信息 \u0026lt;select id=\u0026#34;getemployeebydepartid\u0026#34; resulttype=\u0026#34;employee\u0026#34;\u0026gt; select e_id id,e_name name,e_gender gender,e_age age from employee where e_depart_id=#{id} \u0026lt;/select\u0026gt; 修改departmentdao.xml配置文件 \u0026lt;select id=\u0026#34;getdepartmentbyid\u0026#34; resultmap=\u0026#34;departemntresultmap\u0026#34;\u0026gt; select * from department where d_id=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;departemntresultmap\u0026#34; type=\u0026#34;department\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;d_id\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;d_name\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;emps\u0026#34; oftype=\u0026#34;employee\u0026#34; column=\u0026#34;d_id\u0026#34; select=\u0026#34;cn.offcn.mapper.employeemapper.getemployeebydepartid\u0026#34;\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultmap\u0026gt; 此处变为单表查询，使分表查询方式进行查询。 测试方法 @test public void testgetdepartentbyid() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 departmentdao departmentdao = session.getmapper(departmentdao.class); department dept=departmentdao.getdepartentbyid(1); //打印 system.out.println(dept); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } mybatis实现多对多查询 创建数据库表:student(学生表),teacher(老师表) create table student( sid int not null auto_increment, sname varchar(30), primary key(sid) ); create table teacher( tid int not null auto_increment, tname varchar(30), primary key(tid) ); create table student_teacher( s_id int not null, t_id int not null, primary key(s_id,t_id), foreign key(s_id) references student(sid), foreign key(t_id) references teacher(tid) ); insert into student(sname) values(\u0026#39;张三\u0026#39;),(\u0026#39;李四\u0026#39;); insert into teacher (tname) values(\u0026#39;刘老师\u0026#39;),(\u0026#39;李老师\u0026#39;); insert into student_teacher(s_id,t_id) values(1,1),(1,2),(2,1) 方式一:嵌套结果方式 创建数据模型:student,teacher,studentteacher public class student { private int id; private string name; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } } public class teacher { private int id; private string name; public int getid() { return id; } public void setid(int id) { this.id = id; } public string getname() { return name; } public void setname(string name) { this.name = name; } } public class studentteacher { private int sid; private int tid; public int getsid() { return sid; } public void setsid(int sid) { this.sid = sid; } public int gettid() { return tid; } public void settid(int tid) { this.tid = tid; } 编写多对多的sql语句 select s.*,ts.*,t.* from student s,student_teacher st,teacher t where s.sid=st.s_id and st.t_id=t.tid and s.sid=1 student类中加入list\u0026lt;studentteacher\u0026gt;属性 private list\u0026lt;studentteacher\u0026gt; studentteacherlist; public list\u0026lt;studentteacher\u0026gt; getstudentteacherlist() { return studentteacherlist; } public void setstudentteacherlist(list\u0026lt;studentteacher\u0026gt; studentteacherlist) { this.studentteacherlist = studentteacherlist; } studentteacher中加入teacher属性 private teacher teacher; public student getstudent() { return student; } public void setstudent(student student) { this.student = student; } 学生持久层studentdao接口中加入查询方法 import cn.offcn.entity.student; public interface studentdao { public student getstudentbyid(int id); } 学生持久层sudentdao.xml映射文件配置 \u0026lt;select id=\u0026#34;getstudentbyid\u0026#34; resultmap=\u0026#34;studentresultmap\u0026#34;\u0026gt; select s.*,ts.*,t.* from student s,teacher_student ts,teacher t where s.sid=ts.s_id and ts.t_id=t.tid and s.sid=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;studentresultmap\u0026#34; type=\u0026#34;student\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;collection property=\u0026#34;studentteacherlist\u0026#34; oftype=\u0026#34;studentteacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;s_id\u0026#34; property=\u0026#34;sid\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;t_id\u0026#34; property=\u0026#34;tid\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javatype=\u0026#34;teacher\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;tid\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;tname\u0026#34; property=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultmap\u0026gt; 测试 @test public void testgetstudentbyid() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 studentdao接口的代理对象 studentdao studentdao = session.getmapper(studentdao.class); student student= studentdao.getstudentbyid(1); //打印 system.out.println(tudent); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } 方式二:嵌套查询方式 定义中间表的持久层接口studentteacherdao public interface studentteacherdao { public list\u0026lt;studentteacher\u0026gt; getstudentteacherbysid(int sid); } 定义studentteacherdao.xml文件中的查询配置信息 \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.dao.studentteacherdao\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;getstudentteacherbysid\u0026#34; resultmap=\u0026#34;studentteacherresultmap\u0026#34;\u0026gt; select * from teacher_student where s_id=#{sid} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;studentteacherresultmap\u0026#34; type=\u0026#34;studentteacher\u0026#34;\u0026gt; \u0026lt;result column=\u0026#34;s_id\u0026#34; property=\u0026#34;sid\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;t_id\u0026#34; property=\u0026#34;tid\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;teacher\u0026#34; javatype=\u0026#34;teacher\u0026#34; column=\u0026#34;t_id\u0026#34; select=\u0026#34;cn.offcn.dao.teachermapper.getteacherbytid\u0026#34;\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultmap\u0026gt; \u0026lt;/mapper\u0026gt; 定义老师持久层的接口teacherdao public interface teacherdao { public teacher getteacherbytid(int tid); } 定义老师持久层teacherdao.xml映射文件配置 \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.dao.teacherdao\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;getteacherbytid\u0026#34; resulttype=\u0026#34;teacher\u0026#34;\u0026gt; select tid id,tname name from teacher where tid=#{tid} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 修改studentdao持久层的方法 public interface studentmapper { public student getstudentbyid(int id); } 修改studentdao.xml的查询配置信息 \u0026lt;select id=\u0026#34;getstudentbyid\u0026#34; resultmap=\u0026#34;studentresultmap\u0026#34;\u0026gt; select * from student where sid=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;studentresultmap\u0026#34; type=\u0026#34;student\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;sid\u0026#34; property=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;sname\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;collection property=\u0026#34;studentteacherlist\u0026#34; oftype=\u0026#34;studentteacher\u0026#34; column=\u0026#34;sid\u0026#34; select=\u0026#34;cn.offcn.mapper.studentteachermapper.getstudentteacherbysid\u0026#34;\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultmap\u0026gt; 测试方法 @test public void testgetstudentbyid() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 studentdao接口的代理对象 studentdao studentdao = session.getmapper(studentdao.class); student student= studentdao.getstudentbyid(1); //打印 system.out.println(tudent); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } ","date":"2022-05-24","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220524223082/","summary":"sql片段 sql的配置文件中出现sql冗余 在开发中，SQL的拼接很常见，有很多对拼接的sql具有重复性高的特点，有sql冗余，不仅不美观还导致映射文件配置臃肿，","title":"mybatis-2"},{"content":"概述 正则表达式，又称规则表达式\n正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本\njava提供的类 pattern\nstring提供的正则的判断的方法 matches(string regex) 通过参数正则，来判断字符串对象是否符合要求\npackage com.demo; /** 1.用户名3-6位，并且只能是由字母 数字 _组成 2.正则的规则： 该位置可以出现的字符 该字符可以出现的次数 3.greedy 数量词 x? x，一次或一次也没有 x* x，零次或多次 x+ x，一次或多次 x{n} x，恰好 n 次 x{n,} x，至少 n 次 x{n,m} x，至少 n 次，但是不超过 m 次 4.预定义字符类 . 任何字符（与行结束符可能匹配也可能不匹配） \\d 数字：[0-9] \\d 非数字： [^0-9] \\s 空白字符：[ \\t\\n\\x0b\\f\\r] \\s 非空白字符：[^\\s] \\w 单词字符：[a-za-z_0-9] \\w 非单词字符：[^\\w] */ public class 正则表达式 { public static void main(string[] args) { // string name = \u0026#34;\u0026#34;;//? // system.out.println(name.length()\u0026gt;=3 \u0026amp;\u0026amp; name.length()\u0026lt;=6); // name.tochararray() /* string name1 = \u0026#34;abc123\u0026#34;; system.out.println(name1.matches(\u0026#34;[a-za-z0-9_]{3,6}\u0026#34;));*/ //qq号 数字 6-10 \\d 表示0-9 /* string regqq=\u0026#34;[1-9]\\\\d{5,9}\u0026#34;; system.out.println(\u0026#34;12345\u0026#34;.matches(regqq));*/ //邮箱规则： 字母 数字 _ @ 字母 数字 _ .com 123@126.com //点表示任意字符，如果要表示点，必须要转义 /* string regemail= \u0026#34;\\\\w+@\\\\w+\\\\.com\u0026#34;; system.out.println(\u0026#34;123@126.com\u0026#34;.matches(regemail));*/ string regtel=\u0026#34;(1[35-9][0-9])([0-9]{4})([0-9]{4})\u0026#34;; string tel = \u0026#34;13312345678\u0026#34;; system.out.println(tel.replaceall(regtel, \u0026#34;$1****$3\u0026#34;)); } } ","date":"2022-05-24","permalink":"https://lovemjh.vercel.app/posts/001/20220524210558/","summary":"概述 正则表达式，又称规则表达式 正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本 java提供的类 Pattern String提供的正则的判断的方法 matches(String regex) 通过参数正则，","title":"正则表达式"},{"content":"linux 理解 linux就是基于unix一款开源免费的操作系统。由于系统的稳定和安全性 几乎成为都有程序代码的最佳运行环境。由于开源 衍生出了很多liunx的产品：centos、redcat、ubuntu等\n特点 1. 开源免费、高效安全、处理高并发能力很强 2. 服务器版：不安全图形化界面 直接使用命令 类似于dos 是我们架设服务器最佳的环境 3. 图形化界面版（不推荐使用）\n安装 - 安装 虚拟机 vmware - 创建一个虚拟机 - 安装 linux（centos7） - 配置网络连接 centos7 默认不会自动连接网络 命令：vi /etc/sysconfig/network-scripts/ifcfg-ens33\n命令：service network restart # 重启网络 命令：ping www.baidu.com # 测试\nlinux目录 linux文件操作系统，一切皆文件\n➢ /bin (/usr/bin 、 /usr/local/bin) • 是binary的缩写, 这个目录存放着最经常使用的命令 ➢ /sbin (/usr/sbin 、 /usr/local/sbin) • s就是super user的意思，这里存放的是系统管理员使用的系统管理程序。 ➢ /home • 存放普通用户的主目录，在linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 ➢ /root • 该目录为系统管理员，也称作超级权限者的用户主目录。 ➢ /lib • 系统开机所需要最基本的动态连接共享库，其作用类似于windows里的dll文件。几乎所有的应用程序都需要用到这些共享库。 ➢ /lost+found • 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 ➢ /etc • 所有的系统管理所需要的配置文件和子目录 ➢ /usr • 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 ➢ /boot • 这里存放的是启动linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里 ➢ /proc • 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 ➢ /srv • service缩写，该目录存放一些服务启动之后需要提取的数据。 ➢ /sys • 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 ➢ /tmp • 这个目录是用来存放一些临时文件的。 ➢ /dev • 类似于windows的设备管理器，把所有的硬件用文件的形式存储。 ➢ /media • linux系统会自动识别一些设备，例如u盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 ➢ /mnt • 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 ➢ /opt • 这是给主机额外安装软件所摆放的目录。比如你安装一个oracle数据库则就可以放到这个目录下。默认是空的。 ➢ /usr/local • 这是另一个给主机额外安装软件所摆放的目录。一般是通过编译源码方式安装的程序。 ➢ /var • 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 ➢ /selinux • selinux是一种安全子系统,它能控制程序只能访问特定文件。 linux命令 目录操作 ① 切换目录 cd 目录名 # 切换到指定目录 cd / # 切换到根目录 cd .. # 切换到上一级目录 cd - # 返回到跳转前的目录 pwd # 显示所在的目录 ② 列出目录中的列表 ls # 显示整个目录中的目录名 ls -a # 显示包含隐藏文件的目录 ls -l # 显示目录中所有目录的详情信息 ls -al # 显示目录中包含隐藏文件的详细信息 补充： clear # 清屏 ctrl+l # q清屏 ③ 目录的创建和删除 mkdir 目录名 # 创建一个目录 mkdir -p 目录 # 创建多层目录 rmdir 目录 # 删除空目录 文件操作 ① 创建文件 touch 文件名 # 创建一个空文件 ② 拷贝文件 cp a.txt 目录 # 拷贝文件 cp a.txt 目录/b.txt # 拷贝并重命名 ③ 移动文件 mv a.txt 目录 # 移动文件 mv a.txt 目录/b.txt # 移动并重命名 ④ 删除文件 rm 文件名 # 带询问的删除 rm -f 文件名 # 不带询问的删除 rm -r 目录 # 带询问删除目录可以是多级目录 rm -rf 目录 # 不带询问删除目录可以是多级目录 rm -rf * # 自杀 rm -rf /* # 自杀 文件内容操作 ① 查看文件内容 cat 文件名 # 查看文件中的内容 more 文件名 # 查看文件的内容 一屏一屏显示 (查看下一屏 空格键 查看下一行数据 回车键 tail -10 文件名 # 查看文件的后10行数据 tail -f xx.log # 动态查看文件的内容 ② 搜索文件 find / -name \u0026#34;ser*\u0026#34; # 搜索以ser开头文件名的文件 find / -user root # 搜索 root权限的文件 ③ 搜索符合条件字符串的文件 grep 字符串 文件名 # 在文件中查找字符串内容 文件的打包和压缩 tar -cvf xx.tar 目录 # 将目录打成tar包 tar -zcvf xx.tar.gz 目录 # 将目录打包并压缩 tar -zxvf xx.tar.gz -c 目录 # 将压缩版解压到指定的目录下 说明： c：创建一个新的tar文件 v：显示打包的过程 f：指定文件名 z：调用gzip 压缩文件 x：解开tar文件 文件内容编辑 vi 是文件内容的编译命令 三种模式：命令行模式 插入模式 低行模式 进入命令模式： vi 文件名 进入到插入模式： i：插入当前光标的前面 i：插入当前行的前面 a：插入当前光标的后面 a：插入当前行的尾部 o：插入当前行的下一行 o：插入当前行的上一行 进入低行模式：esc 冒号 w保存 q退出 !强制 常见命令： vi 文件名 # 进入命令行模式 i/i/a/a/o/o # 进入到插入模式 修改内容 esc -\u0026gt; :wq # 保存退出 命令行中常见的命令： dd：删除一行 yy：复制一行 p：粘贴 nyy：复制n行 低行模式命令 /内容 搜索文件中包含该内容的第一个位置 权限命令 ① 修改权限： 可读 r=4 可写 w=2 可执行 x=1 chmod u-w,g+w 文件名 # 可以添加或者删除指定权限 chmod 755 文件 # 指定文件或目录的权限 ② 用户和组 cat /etc/passwd # 查看 用户结构信息 用户操作： useradd 用户名 # 添加一个用户 userdel -r 用户名 # 删除用户和对应的结构信息 passwd 用户名 # 设置密码 groups 用户名 # 查看用户所属组 组操作： groupadd 组名 # 添加一个组 groupdel 组名 # 删除组 gpasswd -a 用户名 组名 # 将一个用户添加到组中 gpasswd -d 用户名 组名 # 将用户从组中移除 补充： su 用户名 # 切换用户 操作环境不变 su - 用户名 # 切换用户 并切换操作环境 whoami # 查看当前用户 重定向输出 将一个文件内容到另一个文件中 cat 文件1 \u0026gt; 文件2 # 将文件1的内容输出到文件2中 覆盖老的内容 cat 文件1 \u0026gt;\u0026gt; 文件2 # 将文件1的内容追加到文件2中 进程命令 ps -ef # 查看所有进程 ps -ef|grep 进程名 # 查看某个进程 kill -9 进程id # 强制杀死进程 shell编程 shell命令解释型语言，用户可以通过编写shell命令 编写一些程序。通常运维或者大数据的开发者编写shell脚本管理服务器集群 编写规范：\n1. 创建以.sh为后缀的文件 2. 首行 #!/bin/bash 3. 赋予可执行的权限 chmod u+x 4. ./xx.sh 执行 rpm rpm 类似win的软件安装包 可以通过.rpm安装文件 安装软件或者卸载软件 ① 安装 rmp -ivh rpm安装包 # 安装rpm软件 ② 查看安装 rpm -qa|grep 软件名 ③ 卸载 rpm安装 rpm -e --nodeps 安装名 参数： i # 安装 install v # 安装信息 h # 安装进度 q # 查询 a # 查询所有的包 e # 卸载 nodeps # 不检查依赖性 yum yum是一个可以从指定的服务器中自动下载并且按照的软件包管理器，自动处理依赖，一次性安装所有依赖的软件包。 1. 下载安装 yum install 软件名 2. 查看yum安装的软件 yum list installed 3. 卸载安装 yum uninstall 安装包名 4. 查看安装位置 rpm -ql 安装包 linux安装环境 安装jdk ① 将 jdk-8u144-linux-x64.tar.gz 通过ftp上传到 /usr/ujiuye ② 解压到当前目录下 tar -zxvf jdk-8u144-linux-x64.tar.gz ③ 配置环境变量 1. vi /etc/profile 中： java_home=/usr/ujiuye/jdk1.8.0_144 classpath=.:$java_home/lib/tools.jar path=$java_home/bin:$path export java_home classpath path 2. 保存退出 3. 刷新环境变量 source /etc/profile 4. 测试 java -version 安装mysql ① 安装之前先清除 自带的mysql rpm -qa|grep mysql rpm -qa|grep mariadb rpm -e --nodeps 安装软件名 # 卸载 ② 将win下下载的安装包 上传到 /usr/ujiuye rpm -ivh mysql-server-5.5.54-1.linux2.6.x86_64.rpm -force --nodeps rpm -ivh mysql-client-5.5.54-1.linux2.6.x86_64.rpm -force --nodeps ③ 启动 service mysql start 问题： starting mysql. error! the server quit without updating pid file (/var/lib/mysql/localhost.pid). 解决： 执行命令：/usr/bin/mysql_install_db --user=mysql 又引发问题： installing mysql system tables... /usr/sbin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: no such file or directory 再解决： yum install libaio 最后再执行：/usr/bin/mysql_install_db --user=mysql 最后： 启动服务：service mysql start ④ 连接数据库 默认 5.5 没有密码 mysql -uroot -p ⑤ 设置密码 set password = password(\u0026#39;密码\u0026#39;) ⑥ 重新连接 设置权限 grant all privileges on *.* to \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;root\u0026#39;; flush privileges; ⑦ 关闭防火墙 firewall-cmd --state # 查看防火墙状态 systemctl stop firewalld.service # 关闭防火墙 systemctl disable firewalld.service # 禁止开机启动防火墙 安装tomcat ① 将win下的apache-tomcat-8.5.43.tar.gz 上传到/usr/ujiuye ② 解压两份 tar -zxvf apache-tomcat-8.5.43.tar.gz ③ 其中一个修改 conf/server.xml文件 ④ 执行 bin/startup.sh 部署项目 后台代码部署 ① 修改连接池数据源配置文件的 ② 修改项目中跳转路径\n③ maven打包 部署前台页面 ① 修改页面中访问路径 在每个页面中 将请求后台路径 localhost:8080/ 改为 ip:8080/ 在每个页面中 将页面之间的跳转 127.0.0.1:5500/ 改为 ip:8081/ ② 将页面 上传到 tomcat_before/webapps中即可 ","date":"2022-05-23","permalink":"https://lovemjh.vercel.app/posts/tool/20220523233691/","summary":"Linux 理解 linux就是基于Unix一款开源免费的操作系统。由于系统的稳定和安全性 几乎成为都有程序代码的最佳运行环境。由于开源 衍生出了很多Liunx的产品：cent","title":"linux常用命令"},{"content":"项目简介 后台管理系统 - 用户管理 用户添加 用户修改 用户详情 删除用户 搜索用户 分页展示 - 课程管理 课程的上传 课程的修改 课程的删除 课程的明细(章节) 搜索 分页 - 选课管理 选课的修改 选课的详情 选课的删除 搜索 分页 用户系统 - 用户注册和登录 - 首页分类展示 - 全部课程展示(分类、分页和搜索) - 课程详情 - 购买课程 - 课程播放 - 个人中心课程展示 开发项目 搭建环境 ① 导入页面\n② 创建项目 ③ 先引入依赖 pom.xml ④ 搭建目录结构 ⑤ 引入 工具类 配置文件 等 ⑥ 导入数据库 验证码实现 ① 创建servlet生成验证码\npackage com.ujiuye.web.servlet.back; import cn.dsna.util.images.validatecode; import javax.servlet.servletexception; import javax.servlet.annotation.webservlet; import javax.servlet.http.httpservlet; import javax.servlet.http.httpservletrequest; import javax.servlet.http.httpservletresponse; import javax.servlet.http.httpsession; import java.io.ioexception; import java.io.printwriter; /** * 生成验证码 */ @webservlet(name = \u0026#34;imgcodeservlet\u0026#34;, urlpatterns = \u0026#34;/imgcode\u0026#34;) public class imgcodeservlet extends httpservlet { protected void dopost(httpservletrequest request, httpservletresponse response) throws servletexception, ioexception { doget(request, response); } protected void doget(httpservletrequest request, httpservletresponse response) throws servletexception, ioexception { // 1. 生成验证码 // 1.1 创建核心对象 // 参数1：宽度 参数2：高度 参数3：字符个数 参数4：干扰元素线的条数 validatecode code = new validatecode(100, 30, 4, 100); // 将生成的验证码字符 保存到session中 httpsession session = request.getsession(); session.setattribute(\u0026#34;code\u0026#34;, code.getcode()); // 1.2 响应 code.write(response.getoutputstream()); } } ② 后台登录页面 显示验证码 login.html 登录实现 ① 登录页面点击登录按钮 // 点击登录按钮 submitform(ruleform){ // 校验表单 this.$refs[ruleform].validate(valid =\u0026gt; { if(valid){ let p = new urlsearchparams() p.append(\u0026#34;method\u0026#34;, \u0026#34;login\u0026#34;) p.append(\u0026#34;username\u0026#34;, this.ruleform.username) p.append(\u0026#34;password\u0026#34;, this.ruleform.password) p.append(\u0026#34;imagecode\u0026#34;, this.ruleform.imagecode) // 校验通过 提交表单信息到后台校验 axios.post(\u0026#34;http://localhost:8080/smallu_1012/user\u0026#34;, p).then(resp =\u0026gt; { // 返回结果 消息提示 // console.log(resp) if(resp.data.code == 500){ // 提示警告信息 this.$message({ message: resp.data.msg, type: \u0026#34;warning\u0026#34; }) }else { // 提示成功信息 this.$message({ message: resp.data.msg, type: \u0026#34;success\u0026#34; }) // 跳转到首页 2s后跳 window.settimeout(\u0026#34;window.location.href=\u0026#39;http://127.0.0.1:5500/smallu_back/html/index.html\u0026#39;\u0026#34;, 2000) } }) }else{ // 校验失败 消息提示 this.$message({ message: \u0026#34;表单校验未通过\u0026#34;, type: \u0026#34;warning\u0026#34; }) } }) } ② 请求到userservlet中\n// 处理登录的方法 public void login(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求参数 string username = request.getparameter(\u0026#34;username\u0026#34;); string password = request.getparameter(\u0026#34;password\u0026#34;); string imagecode = request.getparameter(\u0026#34;imagecode\u0026#34;); httpsession session = request.getsession(); string code = (string) session.getattribute(\u0026#34;code\u0026#34;); // 2. 判断验证码 if(code.equalsignorecase(imagecode)){ // 验证码正确 调用业务 处理登录判断 user user = serivce.checklogin(username, password); if(user==null){ // 登录失败 提示用户名和密码不匹配 vo = new resultvo(500, \u0026#34;用户名和密码不匹配！\u0026#34;, null); }else{ // 校验角色 状态 if(user.getstatus()==1 \u0026amp;\u0026amp; user.getrole()==1){ // 登录成功 session.setattribute(\u0026#34;user\u0026#34;, user); vo = new resultvo(200, \u0026#34;登录成功！\u0026#34;, user); }else{ // 登录失败 提示权限不足 vo = new resultvo(500, \u0026#34;权限不足！\u0026#34;, null); } } }else{ // 验证码错误 vo = new resultvo(500, \u0026#34;验证码输入有误！\u0026#34;, null); } // 响应 信息 string json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 首页权限 正常登录成功跳转到首页，如果没有登录成功不允许跳转首页。 ① 加载index.html之前 判断管理员是否登录 ② servlet中判断用户是否登录 响应对应信息\n// 判断管理员是否登录 public void isuserlogin(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取session httpsession session = request.getsession(); // 2. 获取用户信息 user user = (user) session.getattribute(\u0026#34;user\u0026#34;); // 3. 根据结果 响应信息 if(user==null){ vo = new resultvo(500, \u0026#34;获取用户信息失败！\u0026#34;, null); }else{ vo = new resultvo(200, \u0026#34;获取用户信息成功！\u0026#34;, user); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 首页信息回显和退出登录 ① 页面回显用户信息 ② 退出登录 后台处理清除session的用户信息\n// 退出登录 public void loginout(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取session httpsession session = request.getsession(); // 2. 清除用户信息 session.removeattribute(\u0026#34;user\u0026#34;); // 3. 响应结果 vo = new resultvo(200, \u0026#34;退出成功！\u0026#34;, null); json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 用户管理 首页数据获取 ① 后台的首页index.html中点击用户管理按钮 ② 在user/index.html中通过钩子函数 请求后台获取数据 // 获取数据 findbypage() { // 请求后台获取数据 分页 let url = \u0026#34;http://localhost:8080/smallu_1012/user?method=findbypage\u0026amp;currentpage=\u0026#34;+this.currentpage+\u0026#34;\u0026amp;pagesize=\u0026#34;+this.pagesize axios.get(url).then(resp =\u0026gt; { // 获取数据 if(resp.data.code==200){ this.currentpage = resp.data.data.currentpage this.pagesize = resp.data.data.pagesize this.totalcount = resp.data.data.totalcount this.totalpage = resp.data.data.totalpage this.tabledata = resp.data.data.list } }) } ③ 后台servlet处理\n// 用户分页查询 public void findbypage(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 string currentpage = request.getparameter(\u0026#34;currentpage\u0026#34;); string pagesize = request.getparameter(\u0026#34;pagesize\u0026#34;); // 2. 调用业务层 获取分页数据 pagebean pagebean = serivce.finduserbypage(currentpage, pagesize); // 3. 封装响应数据 vo = new resultvo(200, \u0026#34;获取数据成功！\u0026#34;, pagebean); json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } ④ 后台业务层 封装的pagebean对象\n@override public pagebean finduserbypage(string currentpage, string pagesize) { // 处理分页 // 1. 创建pagebean对象 pagebean\u0026lt;user\u0026gt; pagebean = new pagebean\u0026lt;\u0026gt;(); // 2. 一页显示个数 int ps = integer.parseint(pagesize); pagebean.setpagesize(ps); // 3. 数据总个数 int totalcount = dao.findusercount(); pagebean.settotalcount(totalcount); // 4. 总页码 int totalpage = (int)math.ceil(totalcount*1.0/ps); pagebean.settotalpage(totalpage); // 5. 当前页的页码 int cp = integer.parseint(currentpage); pagebean.setcurrentpage(cp); // 6. 当前页的数据 list\u0026lt;user\u0026gt; list = dao.finduserbypage(cp, ps); pagebean.setlist(list); return pagebean; } ⑤ user/index.html中获取响应的数据 用户添加 ① user/index.html 点击用户点击按钮 ② 在adduser.html中输入 用户信息 提交后台保存即可 发送请求提交数据到后台\n// 点击提交按钮 submitform(formname) { // 提交数据到后台 // 1. 校验表单 this.$refs[formname].validate(valid =\u0026gt; { if(valid){ // 校验成功 获取表单数据 发送请求 // 2. 获取表单数据 let p = new urlsearchparams() p.append(\u0026#34;method\u0026#34;, \u0026#34;adduser\u0026#34;) for(let key in this.ruleform){ p.append(key, this.ruleform[key]) } // 3. 发送请求 axios.post(\u0026#34;http://localhost:8080/smallu_1012/user\u0026#34;, p).then(resp =\u0026gt; { // 4. 获取响应结果 if(resp.data.code == 200){ this.$message({ message: resp.data.msg, type: \u0026#39;success\u0026#39; }) // 跳转到 user/index.html window.settimeout(\u0026#34;window.location.href=\u0026#39;http://127.0.0.1:5500/smallu_back/html/user/index.html\u0026#39;\u0026#34;, 2000) }else{ this.$message({ message: resp.data.msg, type: \u0026#39;warnings\u0026#39; }) } }) }else{ // 校验失败 this.$message({ message: \u0026#39;表单校验未通过\u0026#39;, type: \u0026#39;warning\u0026#39; }) } }) } 后台servlet处理\n// 添加用户的方法 public void adduser(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带的参数 map\u0026lt;string, string[]\u0026gt; map = request.getparametermap(); user user = new user(); try { beanutils.populate(user, map); } catch (illegalaccessexception e) { e.printstacktrace(); } catch (invocationtargetexception e) { e.printstacktrace(); } // 2. 调用业务层 处理添加业务 返回结果 boolean b = serivce.saveuser(user); // 3. 根据返回结果 封装响应结果 if(b){ // 添加成功 vo = new resultvo(200, \u0026#34;添加用户成功！\u0026#34;, null); }else{ // 添加失败 vo = new resultvo(500, \u0026#34;添加用户失败！\u0026#34;, null); } // 4. 响应信息 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } ③ 在adduser.html 重置按钮 修改用户 ① user/index.html 点击修改按钮 ② 点击确认按钮 请求后台修改数据库数据 ③ 后台的servlet获取修改后的数据 去修改数据库 // 修改用户信息的方法 public void updateuser(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 map\u0026lt;string, string[]\u0026gt; map = request.getparametermap(); user user = new user(); try { beanutils.populate(user, map); } catch (illegalaccessexception e) { e.printstacktrace(); } catch (invocationtargetexception e) { e.printstacktrace(); } // 2. 调用业务层 处理修改业务 返回结果 boolean b = serivce.updateuser(user); // 3. 根据结果响应信息 if(b){ // 修改成功 vo = new resultvo(200, \u0026#34;修改成功！\u0026#34;, null); }else{ // 修改失败 vo = new resultvo(500, \u0026#34;修改失败！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 用户详情 ① user/index.html中的详情按钮 用户删除 ① 点击删除选中按钮之前 获取删除信息 ② 点击删除选中按钮 执行函数 delall() { // 1. 提示 this.$confirm(`确定要删除吗？`, {type: \u0026#39;warning\u0026#39;}).then(() =\u0026gt; { // 确定 // 2. 获取选中 复选框数据的uid for(let i=0; i \u0026lt; this.multipleselection.length; i++){ this.delarr.push(this.multipleselection[i].uid) } if(this.delarr.length\u0026gt;0){ // 3. 发送请求到后台 axios.get(\u0026#34;http://localhost:8080/smallu_1012/user?method=deluser\u0026amp;uids=\u0026#34;+this.delarr).then(resp =\u0026gt; { // 4. 获取响应数据 if(resp.data.code == 200){ // 删除成功 this.$message.success(resp.data.msg) // 重新加载当前页 window.settimeout(\u0026#34;window.location.href=\u0026#39;http://127.0.0.1:5500/smallu_back/html/user/index.html\u0026#39;\u0026#34;, 2000) }else{ // 删除失败 this.$message.warning(resp.data.msg) } }) }else{ this.$message.warning(\u0026#34;请选择要删除的数据！\u0026#34;) } }).catch(()=\u0026gt;{ // 取消 this.$message.message(\u0026#34;取消删除！\u0026#34;) }) } ③ 后台的servlet中处理删除\n// 删除用户的方法 public void deluser(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 string uids = request.getparameter(\u0026#34;uids\u0026#34;); // 1,2,3,4,5 // 2. 调用业务层 处理删除业务 返回结果 boolean b = serivce.deleteuser(uids); // 3. 根据删除结果 封装响应数据 if(b){ // 删除成功 vo = new resultvo(200, \u0026#34;删除成功！\u0026#34;, null); }else{ // 删除失败 vo = new resultvo(500, \u0026#34;删除失败！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 用户搜索 ① user/index.html中的搜索框输入内容 失去焦点搜索 ② 请求后台获取数据 @override public pagebean finduserbypage(string currentpage, string pagesize, string search) { // 处理分页 // 1. 创建pagebean对象 pagebean\u0026lt;user\u0026gt; pagebean = new pagebean\u0026lt;\u0026gt;(); // 2. 一页显示个数 int ps = integer.parseint(pagesize); pagebean.setpagesize(ps); // 3. 数据总个数 int totalcount = dao.findusercount(search); pagebean.settotalcount(totalcount); // 4. 总页码 int totalpage = (int)math.ceil(totalcount*1.0/ps); pagebean.settotalpage(totalpage); // 5. 当前页的页码 int cp = integer.parseint(currentpage); // 问题：搜索的总页码小于当前页 的话 没有数据 // 解决：如果搜索的总页码小于当前页 的话 当前页 为第一页 if(cp \u0026gt; totalpage){ cp = 1; } pagebean.setcurrentpage(cp); // 6. 当前页的数据 list\u0026lt;user\u0026gt; list = dao.finduserbypage(cp, ps, search); pagebean.setlist(list); return pagebean; } 课程管理 上传课程 ① index.html中点击课程管理按钮\n上传文件 ① course/index.html中点击上传课程按钮\n② 图片和视频的上传 点上传服务器按钮\n③ 提交对应的上传组件 触发:http-request\n④ 执行:http-request对应的函数\n⑤ 后台servlet处理文件上传\n// 处理文件上传的方法 public void uploadfile(httpservletrequest request, httpservletresponse response) throws ioexception, servletexception { // 1. 获取文件上传的内容 part part = request.getpart(\u0026#34;file\u0026#34;); string filename = part.getsubmittedfilename(); string url = \u0026#34;http://localhost:8080/upload_1012/\u0026#34;; // 2. 封装响应内容 if(filename.endswith(\u0026#34;.jpg\u0026#34;) || filename.endswith(\u0026#34;.jpeg\u0026#34;) || filename.endswith(\u0026#34;.png\u0026#34;) || filename.endswith(\u0026#34;.gif\u0026#34;)){ // 图片上传成功 filename = fileuploadutils.uploadfile(part); vo = new resultvo(200, \u0026#34;图片上传成功！\u0026#34;, url+filename); }else if(filename.endswith(\u0026#34;.mp4\u0026#34;)){ // 视频上传成功 filename = fileuploadutils.uploadfile(part); vo = new resultvo(200, \u0026#34;视频上传成功！\u0026#34;, url+filename); }else{ // 格式不合法 vo = new resultvo(500, \u0026#34;上传文件不合法！\u0026#34;, null); } // 3. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 删除上传文件 ① 点击文件上传组件的上传图标\n② 文件删除后台处理\n// 处理文件删除 public void removefile(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取要删除文件的名字 string filename = request.getparameter(\u0026#34;fileurl\u0026#34;); // 2. 获取文件的路径 file file file = new file(\u0026#34;d://upload_1012//\u0026#34;+filename); if(file.exists()){ // 解决删除失败 流信息引用关闭 system.gc(); try { thread.sleep(2000); } catch (interruptedexception e) { e.printstacktrace(); } boolean d = file.delete(); if(d){ if(filename.endswith(\u0026#34;.mp4\u0026#34;)){ vo = new resultvo(200, \u0026#34;视频删除成功！\u0026#34;, null); }else{ vo = new resultvo(200, \u0026#34;图片删除成功！\u0026#34;, null); } }else{ vo = new resultvo(500, \u0026#34;删除失败！\u0026#34;, null); } }else{ vo = new resultvo(500, \u0026#34;文件不存在！\u0026#34;, null); } // 3. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 文件个数限制 课程添加 ① course/addcourse.html中点击 确定按钮\n// 点击确定按钮 submitform(formname) { // 1. 校验表单 this.$refs[formname].validate(valid =\u0026gt; { if(valid){ // 表单校验通过 // 2. 获取表单数据 let p = new formdata() p.append(\u0026#34;method\u0026#34;, \u0026#34;addcourse\u0026#34;) for(let key in this.ruleform){ p.append(key, this.ruleform[key]) } p.append(\u0026#34;courseimage\u0026#34;, this.dialogimageurl.substring(this.dialogimageurl.lastindexof(\u0026#34;/\u0026#34;)+1)) p.append(\u0026#34;coursevideo\u0026#34;, this.dialogvediourl.substring(this.dialogvediourl.lastindexof(\u0026#34;/\u0026#34;)+1)) // 3. 携带信息发送请求 axios.post(\u0026#34;http://localhost:8080/smallu_1012/courses\u0026#34;, p).then(resp =\u0026gt; { // 4. 返回结果 if(resp.data.code==200){ this.$message.success(resp.data.msg) // 跳转到课程首页 window.settimeout(\u0026#34;window.location.href=\u0026#39;http://127.0.0.1:5500/smallu_back/html/course/index.html\u0026#39;\u0026#34;, 2000) }else{ // 失败 提示信息 this.$message.warning(resp.data.msg) } }) }else{ // 表单未通过 this.$message.warning(\u0026#34;表单校验未通过！\u0026#34;) } }) } ② 后台的servlet处理\n// 处理课程添加 public void addcourse(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 map\u0026lt;string, string[]\u0026gt; map = request.getparametermap(); course course = new course(); try { beanutils.populate(course, map); } catch (illegalaccessexception e) { e.printstacktrace(); } catch (invocationtargetexception e) { e.printstacktrace(); } // 2. 调用业务层处理业务 返回结果 boolean b = service.savecourse(course); // 3. 根据结果 封装响应信息 if(b){ // 添加成功 vo = new resultvo(200, \u0026#34;课程添加成功！\u0026#34;, null); }else{ // 添加失败 vo = new resultvo(500, \u0026#34;课程添加失败！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 课程首页展示 ① 访问course/index.html时先执行钩子函数获取数据\n② 调用获取数据的方法\n③ 后台servlet处理\n// 课程首页展示 public void findbypage(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 string currentpage = request.getparameter(\u0026#34;currentpage\u0026#34;); string pagesize = request.getparameter(\u0026#34;pagesize\u0026#34;); // 2. 调用业务层处理业务 返回结果 pagebean pagebean = service.findcoursebypage(currentpage, pagesize); // 3. 封装响应信息 if(pagebean.getlist().size() \u0026gt; 0){ vo = new resultvo(200, \u0026#34;获取数据成功！\u0026#34;, pagebean); }else{ vo = new resultvo(500, \u0026#34;没有数据！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 课程搜索 // 课程首页展示 public void findbypage(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 string currentpage = request.getparameter(\u0026#34;currentpage\u0026#34;); string pagesize = request.getparameter(\u0026#34;pagesize\u0026#34;); string search = request.getparameter(\u0026#34;search\u0026#34;); // 2. 调用业务层处理业务 返回结果 pagebean pagebean = service.findcoursebypage(currentpage, pagesize, search); // 3. 封装响应信息 if(pagebean.getlist().size() \u0026gt; 0){ vo = new resultvo(200, \u0026#34;获取数据成功！\u0026#34;, pagebean); }else{ vo = new resultvo(500, \u0026#34;没有数据！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } @override public pagebean findcoursebypage(string currentpage, string pagesize, string search) { // 处理课程首页的业务 pagebean\u0026lt;course\u0026gt; pagebean = new pagebean\u0026lt;\u0026gt;(); // 1. 将一页显示个数 封装到pagebean int ps = integer.parseint(pagesize); pagebean.setpagesize(ps); // 2. 总个数 封装pagebean int totalcount = dao.findcoursecount(search); pagebean.settotalcount(totalcount); // 3. 总页数 封装到pagebean int totalpage = (int)math.ceil(totalcount*1.0/ps); pagebean.settotalpage(totalpage); // 4. 当前页码 封装pagebean int cp = integer.parseint(currentpage); if(cp \u0026gt; totalpage){ cp = 1; } pagebean.setcurrentpage(cp); // 5. 当前页数据 封装到pagebean list\u0026lt;course\u0026gt; list = dao.findcoursebypage(cp, ps, search); pagebean.setlist(list); return pagebean; } 课程修改 ① 在course/index.html 中点击修改按钮\n② 处理文件上传 和 删除 同课程添加一样\n③ 点击修改对话框中的确认按钮 // 修改确认按钮 submitform(formname) { // 1. 校验表单 this.$refs[formname].validate(valid =\u0026gt; { // 2. 判断 if(valid){ // 表单校验通过 // 3. 获取修改表单的数据 let p = new formdata() p.append(\u0026#34;method\u0026#34;, \u0026#34;updatecourse\u0026#34;) for(let key in this.ruleform){ p.append(key, this.ruleform[key]) } p.append(\u0026#34;courseimage\u0026#34;, this.dialogimageurl.substring(this.dialogimageurl.lastindexof(\u0026#34;/\u0026#34;)+1)) p.append(\u0026#34;coursevideo\u0026#34;, this.dialogvediourl.substring(this.dialogvediourl.lastindexof(\u0026#34;/\u0026#34;)+1)) axios.post(\u0026#34;http://localhost:8080/smallu_1012/courses\u0026#34;, p).then(resp =\u0026gt; { // 4. 获取响应结果 if(resp.data.code == 200){ this.$message.success(resp.data.msg) this.dialogformvisible1 = false }else{ this.$message.warning(resp.data.msg) } }) }else{ // 表单校验失败 this.$message.warning(\u0026#34;表单校验失败！\u0026#34;) } }) } ④ 后台servlet处理\n// 课程首页展示 public void findbypage(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 string currentpage = request.getparameter(\u0026#34;currentpage\u0026#34;); string pagesize = request.getparameter(\u0026#34;pagesize\u0026#34;); string search = request.getparameter(\u0026#34;search\u0026#34;); // 2. 调用业务层处理业务 返回结果 pagebean pagebean = service.findcoursebypage(currentpage, pagesize, search); // 3. 封装响应信息 if(pagebean.getlist().size() \u0026gt; 0){ vo = new resultvo(200, \u0026#34;获取数据成功！\u0026#34;, pagebean); }else{ vo = new resultvo(500, \u0026#34;没有数据！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } // 课程修改的方法 public void updatecourse(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 map\u0026lt;string, string[]\u0026gt; map = request.getparametermap(); course course = new course(); try { beanutils.populate(course, map); } catch (illegalaccessexception e) { e.printstacktrace(); } catch (invocationtargetexception e) { e.printstacktrace(); } // 2. 调用业务层 处理修改业务 返回结果 boolean b = service.updatecourse(course); // 3. 根据结果 封装响应信息 if(b){ vo = new resultvo(200, \u0026#34;修改成功！\u0026#34;, null); }else{ vo = new resultvo(500, \u0026#34;修改失败！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 删除选中 ① 获取选中的内容\n② 点击删除选中按钮\n③ 后台的servlet处理 // 课程的删除选中 public void delcourse(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 string cids = request.getparameter(\u0026#34;cids\u0026#34;); // 2. 调用业务层 处理业务 返回结果 boolean b = service.delcoursebycid(cids); // 3. 根据结果 封装响应信息 if(b){ vo = new resultvo(200, \u0026#34;删除成功！\u0026#34;, null); }else{ vo = new resultvo(500, \u0026#34;删除失败！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 章节的添加 ① course/index.html中点击章节按钮\n② 点击添加章节中的确定按钮\n// 点击章节添加确定按钮 addcdform(formname){ // 1. 校验表单 this.$refs[formname].validate(valid =\u0026gt; { // 2. 判断 if(valid){ // 3. 获取表单的数据 let p = new formdata() p.append(\u0026#34;method\u0026#34;, \u0026#34;addcoursedetail\u0026#34;) p.append(\u0026#34;name\u0026#34;, this.ruleform.name) p.append(\u0026#34;cid\u0026#34;, this.ruleform.cid) p.append(\u0026#34;type\u0026#34;, this.ruleform.type) p.append(\u0026#34;url\u0026#34;, this.ruleform.url.substring(this.ruleform.url.lastindexof(\u0026#34;/\u0026#34;)+1)) p.append(\u0026#34;start_date\u0026#34;, this.ruleform.start_date) // 4. 发送请求 axios.post(\u0026#34;http://localhost:8080/smallu_1012/coursedetail\u0026#34;, p).then(resp =\u0026gt; { // 获取响应信息 if(resp.data.code == 200){ this.$message.success(resp.data.msg) this.dialogformvisible2 = false window.settimeout(\u0026#34;window.location=\u0026#39;http://127.0.0.1:5500/smallu_back/html/course/index.html\u0026#39;\u0026#34;, 2000) }else{ this.$message.warning(resp.data.msg) } }) }else{ this.$message.warning(\u0026#34;表单校验未通过\u0026#34;) } }) }, ③ 请求到servlet中\n// 添加章节的方法 public void addcoursedetail(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带的参数 map\u0026lt;string, string[]\u0026gt; map = request.getparametermap(); coursedetail cd = new coursedetail(); try { beanutils.populate(cd, map); } catch (illegalaccessexception e) { e.printstacktrace(); } catch (invocationtargetexception e) { e.printstacktrace(); } // 2. 调用业务层处理业务 返回结果 boolean b = service.savecd(cd); // 3. 根据结果 封装响应信息 if(b){ vo = new resultvo(200, \u0026#34;章节添加成功！\u0026#34;, null); }else{ vo = new resultvo(500, \u0026#34;章节添加失败！\u0026#34;, null); } // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 前台功能 用户注册 验证码 表单的校验 // 校验表单中的内容 checkv(v, msg){ // 1. 表单非空校验 if(v==null || \u0026#34;\u0026#34;==v.trim()){ this.msg = msg return }else{ let vv = v.trim().length // 表单不为空 if(msg==\u0026#34;用户名不能为空\u0026#34;){ // 1. 校验用户名 长度 if(vv\u0026lt;3 || vv\u0026gt;12){ this.msg = \u0026#34;长度3-12位\u0026#34; return } // 2. 用户名是否可用 是否已经注册过 // 发送请求 axios.get(\u0026#34;http://localhost:8080/smallu_1012/user_b?method=checkname\u0026amp;username=\u0026#34;+v.trim()).then(resp =\u0026gt;{ // 3. 返回结果 if(resp.data.code==500){ this.msg = resp.data.msg }else{ this.msg = \u0026#39;\u0026#39; this.num++ } }) }else if(msg == \u0026#34;手机号不能为空\u0026#34;){ // 校验手机号 // 1. 手机号合法 let reg = /^1[3|5|7|8|9][0-9]{9}$/ if(reg.test(v.trim())){ // 2. 手机是否已经注册 axios.get(\u0026#34;http://localhost:8080/smallu_1012/user_b?method=checkphone\u0026amp;phone=\u0026#34;+v.trim()).then(resp =\u0026gt; { // 3. 获取响应结果 if(resp.data.code == 500){ this.msg = resp.data.msg }else{ this.msg = \u0026#39;\u0026#39; this.num++ } }) }else{ this.msg = \u0026#34;手机号不合法\u0026#34; } }else if(msg == \u0026#34;密码不能为空\u0026#34;){ if(vv \u0026lt; 3 || vv \u0026gt; 24){ this.msg = \u0026#34;长度3-24位\u0026#34; }else{ this.msg = \u0026#39;\u0026#39; this.num++ } }else{ if(v.trim()==null || \u0026#34;\u0026#34;==v.trim()){ this.msg = \u0026#34;验证码不能为空\u0026#34; }else{ this.msg = \u0026#39;\u0026#39; this.num++; } } } } 点击注册按钮 处理\n用户登录 ① 校验表单\n② 点击登录按钮\n首页用户信息展示 ① 判读是否用户登录\n② 首页用户信息页面展示 前台系统 用户退出登录 ① 点击用户信息中的退出登录按钮\n② 在后台清除session的用户信息\n// 退出登录 public void loginout(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取信息 httpsession session = request.getsession(); session.removeattribute(\u0026#34;user\u0026#34;); vo = new resultvo(200, \u0026#34;退出成功！\u0026#34;, null); json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } 首页课程展示 ① 首页展示一部分数据，获取数据\n② 后台的servlet根据类型 调用业务获取数据\n// 根据类别 获取数据 public void getdata(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带的参数 string coursetype = request.getparameter(\u0026#34;coursetype\u0026#34;); // 2. 调用业务层处理业务 list\u0026lt;course\u0026gt; list = service.findcoursebytype(coursetype); // 3. 根据数据响应 信息 vo = new resultvo(200, \u0026#34;获取数据！\u0026#34;, list); json = jsonutils.objtojson(vo, response); // 4. 响应 response.getwriter().print(json); } ③ 渲染数据到视图中\n全部课程 ① index.html中点击 全部课程 跳转到全部课程页面\n② 在全部课程页面 先获取数据\n③ 后台根据条件搜索需要的课程 返回页面\n// 查询全部课程中信息 public void findallcourse(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带参数 string coursetype = request.getparameter(\u0026#34;coursetype\u0026#34;); string currentpage = request.getparameter(\u0026#34;currentpage\u0026#34;); string coursename = request.getparameter(\u0026#34;coursename\u0026#34;); string pagesize = request.getparameter(\u0026#34;pagesize\u0026#34;); // 2. 调用业务层 处理业务 返回结果 pagebean\u0026lt;course\u0026gt; pagebean = service.findallcourse(coursetype, currentpage, coursename, pagesize); // 3. 封装 响应信息 vo = new resultvo(200, \u0026#34;获取数据！\u0026#34;, pagebean); // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } ④ 回显数据 和页码\n课程详情 ① 点击课程图片 跳转到课程详情页面展示\n② 跳转到课程详情页面 videodetail.html中\n③ 页面渲染 章节的显示 ① 进入看课程详情页面 直接根据课程查询章节\n② 后台处理获取章节信息\n// 根据cid查询章节 public void findcdbycid(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取请求携带的参数 string cid = request.getparameter(\u0026#34;cid\u0026#34;); // 2. 调用业务层 处理业务 返回结果 第一章：{},{} 第二章：{}, {}, {} map\u0026lt;string, object\u0026gt; map = service.findcdbycid(cid); // 3. 根据结果 封装响应信息 vo = new resultvo(200, \u0026#34;获取数据成功！\u0026#34;, map); // 4. 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } @override public map\u0026lt;string, object\u0026gt; findcdbycid(string cid) { // 1. 创建map map\u0026lt;string, object\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); // 2. 查询 每个章节的 list\u0026lt;coursedetail\u0026gt; list = dao.findcdbycid(cid); // 3. 获取每一个章节号 for (coursedetail coursedetail : list) { string type = coursedetail.gettype(); list\u0026lt;coursedetail\u0026gt; list1 = dao.findcdbycidtype(cid, type); map.put(type, list1); } return map; } ③ 页面中渲染\n购买课程 支付宝平台 ① 课程详情中如果显示 价格 点击价格 支付(支付宝支付) https://open.alipay.com/ 支付宝平台 https://opendocs.alipay.com/common/02kkv7 开发文档 引入支付 ① 详情页面中点击 支付(个人价格、平团价格)\n② 后台处理付款\n// 处理课程的支付 public void alipay(httpservletrequest request, httpservletresponse response) throws ioexception { //获得初始化的alipayclient alipayclient alipayclient = new defaultalipayclient(alipayconfig.gatewayurl, alipayconfig.app_id, alipayconfig.merchant_private_key, \u0026#34;json\u0026#34;, alipayconfig.charset, alipayconfig.alipay_public_key, alipayconfig.sign_type); //设置请求参数 alipaytradepagepayrequest alipayrequest = new alipaytradepagepayrequest(); // 付款完成之后 回来的路径 string cid = request.getparameter(\u0026#34;cid\u0026#34;); httpsession session = request.getsession(); user user = (user) session.getattribute(\u0026#34;user\u0026#34;); alipayrequest.setreturnurl(\u0026#34;http://localhost:8080/smallu_1012/course_user?method=addcourseuser\u0026amp;cid=\u0026#34;+cid+\u0026#34;\u0026amp;uid=\u0026#34;+user.getuid()); // alipayrequest.setnotifyurl(alipayconfig.notify_url); //商户订单号，商户网站订单系统中唯一订单号，必填 string out_trade_no = uuid.randomuuid().tostring().replace(\u0026#34;-\u0026#34;,\u0026#34;\u0026#34;); //付款金额，必填 string total_amount = request.getparameter(\u0026#34;price\u0026#34;); //订单名称，必填 string subject = request.getparameter(\u0026#34;coursename\u0026#34;); //商品描述，可空 // string body = new string(request.getparameter(\u0026#34;widbody\u0026#34;).getbytes(\u0026#34;iso-8859-1\u0026#34;),\u0026#34;utf-8\u0026#34;); alipayrequest.setbizcontent(\u0026#34;{\\\u0026#34;out_trade_no\\\u0026#34;:\\\u0026#34;\u0026#34;+ out_trade_no +\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34;\\\u0026#34;total_amount\\\u0026#34;:\\\u0026#34;\u0026#34;+ total_amount +\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34;\\\u0026#34;subject\\\u0026#34;:\\\u0026#34;\u0026#34;+ subject +\u0026#34;\\\u0026#34;,\u0026#34; // + \u0026#34;\\\u0026#34;body\\\u0026#34;:\\\u0026#34;\u0026#34;+ body +\u0026#34;\\\u0026#34;,\u0026#34; + \u0026#34;\\\u0026#34;product_code\\\u0026#34;:\\\u0026#34;fast_instant_trade_pay\\\u0026#34;}\u0026#34;); //若想给bizcontent增加其他可选请求参数，以增加自定义超时时间参数timeout_express来举例说明 //alipayrequest.setbizcontent(\u0026#34;{\\\u0026#34;out_trade_no\\\u0026#34;:\\\u0026#34;\u0026#34;+ out_trade_no +\u0026#34;\\\u0026#34;,\u0026#34; //\t+ \u0026#34;\\\u0026#34;total_amount\\\u0026#34;:\\\u0026#34;\u0026#34;+ total_amount +\u0026#34;\\\u0026#34;,\u0026#34; //\t+ \u0026#34;\\\u0026#34;subject\\\u0026#34;:\\\u0026#34;\u0026#34;+ subject +\u0026#34;\\\u0026#34;,\u0026#34; //\t+ \u0026#34;\\\u0026#34;body\\\u0026#34;:\\\u0026#34;\u0026#34;+ body +\u0026#34;\\\u0026#34;,\u0026#34; //\t+ \u0026#34;\\\u0026#34;timeout_express\\\u0026#34;:\\\u0026#34;10m\\\u0026#34;,\u0026#34; //\t+ \u0026#34;\\\u0026#34;product_code\\\u0026#34;:\\\u0026#34;fast_instant_trade_pay\\\u0026#34;}\u0026#34;); //请求参数可查阅【电脑网站支付的api文档-alipay.trade.page.pay-请求参数】章节 //请求 string result = null; try { result = alipayclient.pageexecute(alipayrequest).getbody(); } catch (alipayapiexception e) { e.printstacktrace(); } //输出 response.setcontenttype(\u0026#34;text/html;charset=utf-8\u0026#34;); response.getwriter().println(result); ③ 将该用户购买该课程的记录保存到数据库\n// 支付成功之后 处理 public void addcourseuser(httpservletrequest request, httpservletresponse response) throws ioexception { // system.out.println(\u0026#34;xxxxx\u0026#34;); // 1. 获取请求携带参数 string cid = request.getparameter(\u0026#34;cid\u0026#34;); string uid = request.getparameter(\u0026#34;uid\u0026#34;); // 2. 调用业务层 处理业务 boolean b = service.savecourseuser(cid, uid); // 3. 根据结果 处理响应 if(b){ // 返回详情页面 重定向 response.sendredirect(\u0026#34;http://127.0.0.1:5500/smallu_before/pages/videodetail.html?cid=\u0026#34;+cid); } } 课程学习 ① 在课程详情页面 如果购买之后 点击课程学习 跳转到播放页面\n② 播放页面 显示章节目录 点击章节目录播放视频\n③ 渲染到视图中\n课程中心 ① 个人信息中点击课程中心 进入课程中心页面 回显购买的课程\n② 课程中心页面 通过钩子函数获取数据\n③ 后台处理\n// 根据用户查询 购买的课程 public void getdatabyuid(httpservletrequest request, httpservletresponse response) throws ioexception { // 1. 获取用户id httpsession session = request.getsession(); user user = (user) session.getattribute(\u0026#34;user\u0026#34;); // 2. 调用业务层 获取结果 list\u0026lt;course\u0026gt; courses = service.findbyuid(user.getuid()); // 3. 根据结果响应信息 vo = new resultvo(200, \u0026#34;\u0026#34;, courses); // 响应 json = jsonutils.objtojson(vo, response); response.getwriter().print(json); } ④ 将数据渲染到视图中\n总结 后台管理 - 管理员登录 (验证码) - 用户管理 用户添加 用户修改 用户删除选中 用户详情 用户搜索 用户分页 - 课程管理 (文件上传) 课程的上传 课程的修改 课程删除选中 课程的章节添加 课程的搜索 课程的分页 - 选课管理(作业) 用户系统 - 用户的注册和登录 - 首页分类展示 - 全部课程 (分页 搜索 分类) - 课程详情 (章节) - 课程的购买 (支付宝沙箱支付) - 课程章节的播放 - 课程中心 - 页面对登录用户的信息展示 - 个人资料(作业) ","date":"2022-05-22","permalink":"https://lovemjh.vercel.app/posts/project/20220522222541/","summary":"项目简介 后台管理系统 - 用户管理 用户添加 用户修改 用户详情 删除用户 搜索用户 分页展示 - 课程管理 课程的上传 课程的修改 课程的删除 课程的明细(章节) 搜索 分页 - 选课管理 选课的","title":"小课堂"},{"content":"一、项目概述和环境搭建 (一)项目背景 随着疫情的逐步结束，国民对于个人的身体健康越来越重视，对健康认识不断提高，对健康的需求也在不断增加，健康检查作为防患于未然的主动预防措施在人们思想中已有很深的认识，医疗管家管理系统 致力于建立一座健康管理机构和会员之间的灵活沟通的桥梁，医疗管家管理平台利用计算机对体检工作流程、结果收集、结论汇总、健康评估、会员管理等多种信息进行数字化管理，给会员提供定制化的健康体检方案，并持续追踪会员的健康状态，为会员的健康提供终身的服务。\n(二)原型展示 展示静态原型\n(三)技术架构 (四)功能架构 (五)软件开发流程 需求分析 1.相关系统分析员向用户初步了解需求，然后用相关的工具软件列出要开发的系统的大功能模块，每个大功能模块有哪些小功能模块，对于有些需求比较明确相关的界面时，在这一步里面可以初步定义好少量的界面。\n2.系统分析员深入了解和分析需求，根据自己的经验和需求用word或相关的工具再做出一份文档系统的功能需求文档。这次的文档会清楚列出系统大致的大功能模块，大功能模块有哪些小功能模块，并且还列出相关的界面和界面功能。\n3.系统分析员向用户再次确认需求。\n概要设计 首先，开发者需要对软件系统进行概要设计，即系统设计。概要设计需要对软件系统的设计进行考虑，包括系统的基本处理流程、系统的组织结构、模块划分、功能分配、接口设计、运行设计、数据结构设计和出错处理设计等，为软件的详细设计提供基础\n详细设计 在概要设计的基础上，开发者需要进行软件系统的详细设计。在详细设计中，描述实现具体模块所涉及到的主要算法、数据结构、类的层次结构及调用关系，需要说明软件系统各个层次中的每一个程序(每个模块或子程序)的设计考虑，以便进行编码和测试。应当保证软件的需求完全分配给整个软件。详细设计应当足够详细，能够根据详细设计报告进行编码\n编码 在软件编码阶段，开发者根据《软件系统详细设计报告》中对数据结构、算法分析和模块实现等方面的设计要求，开始具体的编写程序工作，分别实现各模块的功能，从而实现对目标系统的功能、性能、接口、界面等方面的要求。在规范化的研发流程中，编码工作在整个项目流程里最多不会超过1/2，通常在1/3的时间，所谓磨刀不误砍柴功，设计过程完成的好，编码效率就会极大提高，编码时不同模块之间的进度协调和协作是最需要小心的，也许一个小模块的问题就可能影响了整体进度，让很多程序员因此被迫停下工作等待，这种问题在很多研发过程中都出现过。编码时的相互沟通和应急的解决手段都是相当重要的，对于程序员而言，bug永远存在，你必须永远面对这个问题\n测试 测试编写好的系统。交给用户使用，用户使用后一个一个的确认每个功能。软件测试有很多种：按照测试执行方，可以分为内部测试和外部测试；按照测试范围，可以分为模块测试和整体联调；按照测试条件，可以分为正常操作情况测试和异常情况测试；按照测试的输入范围，可以分为全覆盖测试和抽样测试。以上都很好理解，不再解释。总之，测试同样是项目研发中一个相当重要的步骤，对于一个大型软件，3个月到1年的外部测试都是正常的，因为永远都会有不可预料的问题存在。完成测试后，完成验收并完成最后的一些帮助文档，整体项目才算告一段落，当然日后少不了升级，修补等等工作，只要不是想通过一锤子买卖骗钱，就要不停的跟踪软件的运营状况并持续修补升级，直到这个软件被彻底淘汰为止\n交付 在软件测试证明软件达到要求后，软件开发者应向用户提交开发的目标安装程序、数据库的数据字典、《用户安装手册》、《用户使用指南》、需求报告、设计报告、测试报告等双方合同约定的产物。\n《用户安装手册》应详细介绍安装软件对运行环境的要求、安装软件的定义和内容、在客户端、服务器端及中间件的具体安装步骤、安装后的系统配置。\n《用户使用指南》应包括软件各项功能的使用流程、操作步骤、相应业务介绍、特殊提示和注意事项等方面的内容，在需要时还应举例说明。\n验收 用户验收。\n维护 根据用户需求的变化或环境的变化，对应用程序进行全部或部分的修改\n二、项目环境搭建 (一)项目结构 本项目采用maven分模块开发方式，即对整个项目拆分为几个maven工程,父工程提供统一的依赖规范，其余的每个maven 工程存放特定类型的代码,具体如下：\n各模块职责定位：\noffcnpe_parent：父工程，打包方式为pom，统一锁定依赖的版本，同时聚合其他子模块 便于统一执行maven命令\noffcnpe_pojo 数据模型，打包方式为jar，存放项目中使用到表对应的数据模型\noffcnpe_interface：打包方式为jar，存放服务接口。\noffcnpe_provider：dubbo服务模块，打包方式为war，存放服务实现类、dao接 口、mapper映射文件等，作为服务提供方，需要部署到tomcat运行。\noffcnpe_controller：小u健康管理后台，打包方式为war，作为dubbo服务消费方，存放 controller、html页面、js、css、spring配置文件等，需要部署到tomcat运行\noffcnpe_mobile：移动端前台，打包方式为war，作为dubbo服务消费方，存放 controller、html页面、js、css、spring配置文件等，需要部署到tomcat运行.\noffcnpe_util: 工具模块，打包方式为jar，存放项目中使用到的一些工具类、返回结果和常量类\n(二)工程搭建 通过前面的项目功能架构图可以知道本项目分为小u健康管理后台和小u健康前台(移动端)\n1：offcnpe_parent 父工程，打包方式为pom，用于统一管理依赖版本 pom.xml文件内容\n\u0026lt;!--指定当前工程父工程是 2.4.3 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.4.3\u0026lt;/version\u0026gt; \u0026lt;relativepath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_parent\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 当前的工程是父工程 统一控制我们技术版本 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;!--mybatis plus--\u0026gt; \u0026lt;baomidou.version\u0026gt;3.4.2\u0026lt;/baomidou.version\u0026gt; \u0026lt;!--dubbo--\u0026gt; \u0026lt;dubbo.version\u0026gt;2.7.6\u0026lt;/dubbo.version\u0026gt; \u0026lt;!--mysql--\u0026gt; \u0026lt;mysql.version\u0026gt;5.1.47\u0026lt;/mysql.version\u0026gt; \u0026lt;!--接口文档--\u0026gt; \u0026lt;swagger.version\u0026gt;2.6.1\u0026lt;/swagger.version\u0026gt; \u0026lt;!--poi--\u0026gt; \u0026lt;poi.version\u0026gt;3.14\u0026lt;/poi.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- springboot 整合mybatisplus 工具包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${baomidou.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatisplus 代码生成器包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-generator\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据库驱动包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${mysql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 接口文档相关包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger2\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger-ui\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${swagger.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- dubbo 服务相关jar --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.dubbo\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${dubbo.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- poi报表操作包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.poi\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;poi-ooxml\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${poi.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; 2: offcnpe_pojo 数据模型，打包方式为jar，存放项目中使用到表对应的数据模型 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_pojo\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.projectlombok\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;lombok\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.poi\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;poi-ooxml\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 3：offcnpe_util: 工具模块，打包方式为jar，存放项目中使用到的一些工具类、返回结果和常量类 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_util\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_pojo\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-generator\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.velocity\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;velocity-engine-core\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 4: offcnpe_interface：打包方式为jar，存放服务接口 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_interface\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_pojo\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_util\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 5: offcnpe_provider dubbo服务模块 (1)pom.xml文件内容 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_provider\u0026lt;/artifactid\u0026gt; \u0026lt;!-- springboot mybatisplus 数据库驱动 连接池 dubbo zookeeper.. --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.baomidou\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis-plus-generator\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- dubbo的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.dubbo\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zk的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.dubbo\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-dependencies-zookeeper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.7.6\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.slf4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;slf4j-log4j12\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_interface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.1.20\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; (2)application.yml配置文件内容 #端口 访问路径 server: port: 9002 servlet: context-path: / #spring应用名称 spring: application: name: offcnpe_provider #数据源配置 datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql:///offcnpe username: root password: root type: com.alibaba.druid.pool.druiddatasource #mybatis-plus mybatis-plus: configuration: #开启驼峰标识 map-underscore-to-camel-case: true #控制台显示sql语句 log-impl: org.apache.ibatis.logging.stdout.stdoutimpl global-config: #逻辑删除 db-config: logic-not-delete-value: 1 logic-delete-value: 0 #加载我们的xml文件 mapper-locations: classpath:/mappers/xml/*.xml type-aliases-package: com.offcn.pojo #dubbo端口和名称 dubbo: protocol: name: dubbo port: 20880 registry: address: zookeeper://192.168.233.100:2181 timeout: 10000 #扫描我们service注解 scan: base-packages: com.offcn.service.impl (3)构建springboot的启动类 package com.offcn; import org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; @springbootapplication public class peserviceproviderapplication { public static void main(string[] args) { springapplication.run(peserviceproviderapplication.class, args); } } 6：offcnpe_controller健康管家管理后台工程 (1)pom.xml文件内容 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_controller\u0026lt;/artifactid\u0026gt; \u0026lt;!-- 添加依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 项目初期没有用到权限管理的时候将这个依赖暂时注释掉 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-security\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-devtools\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- dubbo的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.dubbo\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zk的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.dubbo\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-dependencies-zookeeper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.7.6\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.slf4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;slf4j-log4j12\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_interface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.1.20\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;fastjson\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.68\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;addresources\u0026gt;true\u0026lt;/addresources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; (2)application.yml文件内容 server: servlet: context-path: / port: 9003 spring: application: name: offcnpe_controller datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql:///offcnpe username: root password: root type: com.alibaba.druid.pool.druiddatasource devtools: restart: enabled: true additional-paths: src/main/java redis: host: 192.168.233.100 port: 6379 password: 123456 dubbo: protocol: name: dubbo port: 20881 registry: address: zookeeper://192.168.233.100:2181 timeout: 10000 (3)构建springboot启动类 package com.offcn; import org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; @springbootapplication public class pecontrollerapplication { public static void main(string[] args) { springapplication.run(pecontrollerapplication.class,args); } } 7：offcnpe_mobile移动端前台工程 (1)pom文件内容 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_mobile\u0026lt;/artifactid\u0026gt; \u0026lt;!-- 添加依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-web\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-devtools\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-starter-test\u0026lt;/artifactid\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- dubbo的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.dubbo\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-spring-boot-starter\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- zk的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.apache.dubbo\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;dubbo-dependencies-zookeeper\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;2.7.6\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;org.slf4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;slf4j-log4j12\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger2\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;io.springfox\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;springfox-swagger-ui\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.offcn\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;offcnpe_interface\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.alibaba\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;druid\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.1.20\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupid\u0026gt;org.springframework.boot\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactid\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; (2)application.yml文件内容 server: servlet: context-path: / port: 9004 spring: application: name: offcnpe_mobile datasource: driver-class-name: com.mysql.jdbc.driver url: jdbc:mysql:///demo username: root password: root type: com.alibaba.druid.pool.druiddatasource dubbo: protocol: name: dubbo port: 20882 registry: address: zookeeper://192.168.233.100:2181 timeout: 10000 (3)构建springboot启动类 @springbootapplication public class pemobileapplication { public static void main(string[] args) { springapplication.run(pemobileapplication.class,args); } } (三)启动服务测试环境大家是否成功 1:启动zookeeper并启动dubbo-admin监控平台 2:启动offcnpe_provider服务器查看是否正常 3:启动offcnpe_controller服务器查看是否正常\n三、预约管理\u0026ndash;检查项管理 (一)需求分析 本章节完成的功能开发是预约管理功能，包括检查项管理、检查组管理、体检套餐管理、预约设置等。预约管理属于系统的基础功能，主要就是管理一些体检的基础数据。\n(二)基础环境搭建 1: 创建数据库offcnpe create database offcnpe\n2: 导入数据表 sqlyong 中执行sql脚本\n3: 导入项目所需工具资源 (1)返回消息常量类messageconstant，放到offcnpe_util工程中 项目开发过程中一般会提供一些公共资源，供多个模块或者系统来使用。 本章节我们导入的公共资源有\n/** * 消息常量 */ public class messageconstant { public static final string delete_checkitem_fail = \u0026#34;删除检查项失败\u0026#34;; public static final string delete_checkitem_success = \u0026#34;删除检查项成功\u0026#34;; public static final string add_checkitem_success = \u0026#34;新增检查项成功\u0026#34;; public static final string add_checkitem_fail = \u0026#34;新增检查项失败\u0026#34;; public static final string edit_checkitem_fail = \u0026#34;编辑检查项失败\u0026#34;; public static final string edit_checkitem_success = \u0026#34;编辑检查项成功\u0026#34;; public static final string query_checkitem_success = \u0026#34;查询检查项成功\u0026#34;; public static final string query_checkitem_fail = \u0026#34;查询检查项失败\u0026#34;; public static final string upload_success = \u0026#34;上传成功\u0026#34;; public static final string add_checkgroup_fail = \u0026#34;新增检查组失败\u0026#34;; public static final string add_checkgroup_success = \u0026#34;新增检查组成功\u0026#34;; public static final string delete_checkgroup_fail = \u0026#34;删除检查组失败\u0026#34;; public static final string delete_checkgroup_success = \u0026#34;删除检查组成功\u0026#34;; public static final string query_checkgroup_success = \u0026#34;查询检查组成功\u0026#34;; public static final string query_checkgroup_fail = \u0026#34;查询检查组失败\u0026#34;; public static final string edit_checkgroup_fail = \u0026#34;编辑检查组失败\u0026#34;; public static final string edit_checkgroup_success = \u0026#34;编辑检查组成功\u0026#34;; public static final string pic_upload_success = \u0026#34;图片上传成功\u0026#34;; public static final string pic_upload_fail = \u0026#34;图片上传失败\u0026#34;; public static final string add_setmeal_fail = \u0026#34;新增套餐失败\u0026#34;; public static final string add_setmeal_success = \u0026#34;新增套餐成功\u0026#34;; public static final string import_ordersetting_fail = \u0026#34;批量导入预约设置数据失败\u0026#34;; public static final string import_ordersetting_success = \u0026#34;批量导入预约设置数据成功\u0026#34;; public static final string get_ordersetting_success = \u0026#34;获取预约设置数据成功\u0026#34;; public static final string get_ordersetting_fail = \u0026#34;获取预约设置数据失败\u0026#34;; public static final string ordersetting_success = \u0026#34;预约设置成功\u0026#34;; public static final string ordersetting_fail = \u0026#34;预约设置失败\u0026#34;; public static final string add_member_fail = \u0026#34;新增会员失败\u0026#34;; public static final string add_member_success = \u0026#34;新增会员成功\u0026#34;; public static final string delete_member_fail = \u0026#34;删除会员失败\u0026#34;; public static final string delete_member_success = \u0026#34;删除会员成功\u0026#34;; public static final string edit_member_fail = \u0026#34;编辑会员失败\u0026#34;; public static final string edit_member_success = \u0026#34;编辑会员成功\u0026#34;; public static final string telephone_validatecode_notnull = \u0026#34;手机号和验证码都不能为空\u0026#34;; public static final string login_success = \u0026#34;登录成功\u0026#34;; public static final string validatecode_error = \u0026#34;验证码输入错误\u0026#34;; public static final string query_order_success = \u0026#34;查询预约信息成功\u0026#34;; public static final string query_order_fail = \u0026#34;查询预约信息失败\u0026#34;; public static final string query_setmeallist_success = \u0026#34;查询套餐列表数据成功\u0026#34;; public static final string query_setmeallist_fail = \u0026#34;查询套餐列表数据失败\u0026#34;; public static final string query_setmeal_success = \u0026#34;查询套餐数据成功\u0026#34;; public static final string query_setmeal_fail = \u0026#34;查询套餐数据失败\u0026#34;; public static final string send_validatecode_fail = \u0026#34;验证码发送失败\u0026#34;; public static final string send_validatecode_success = \u0026#34;验证码发送成功\u0026#34;; public static final string selected_date_cannot_order = \u0026#34;所选日期不能进行体检预约\u0026#34;; public static final string order_full = \u0026#34;预约已满\u0026#34;; public static final string has_ordered = \u0026#34;已经完成预约，不能重复预约\u0026#34;; public static final string order_success = \u0026#34;预约成功\u0026#34;; public static final string get_username_success = \u0026#34;获取当前登录用户名称成功\u0026#34;; public static final string get_username_fail = \u0026#34;获取当前登录用户名称失败\u0026#34;; public static final string get_menu_success = \u0026#34;获取当前登录用户菜单成功\u0026#34;; public static final string get_menu_fail = \u0026#34;获取当前登录用户菜单失败\u0026#34;; public static final string get_member_number_report_success = \u0026#34;获取会员统计数据成功\u0026#34;; public static final string get_member_number_report_fail = \u0026#34;获取会员统计数据失败\u0026#34;; public static final string get_setmeal_count_report_success = \u0026#34;获取套餐统计数据成功\u0026#34;; public static final string get_setmeal_count_report_fail = \u0026#34;获取套餐统计数据失败\u0026#34;; public static final string get_business_report_success = \u0026#34;获取运营统计数据成功\u0026#34;; public static final string get_business_report_fail = \u0026#34;获取运营统计数据失败\u0026#34;; public static final string get_setmeal_list_success = \u0026#34;查询套餐列表数据成功\u0026#34;; public static final string get_setmeal_list_fail = \u0026#34;查询套餐列表数据失败\u0026#34;; } (2)返回结果result和pageresult类，放到offcnpe_util工程中 public class result implements serializable{ private boolean flag;//执行结果，true为执行成功 false为执行失败 private string message;//返回结果信息，主要用于页面提示信息 private object data;//返回数据 public result(boolean flag, string message) { super(); this.flag = flag; this.message = message; } public result(boolean flag, string message, object data) { this.flag = flag; this.message = message; this.data = data; } public boolean isflag() { return flag; } public void setflag(boolean flag) { this.flag = flag; } public string getmessage() { return message; } public void setmessage(string message) { this.message = message; } public object getdata() { return data; } public void setdata(object data) { this.data = data; } } /** * 分页结果封装对象 */ public class pageresult implements serializable{ private long total;//总记录数 private list rows;//当前页结果 public pageresult(long total, list rows) { super(); this.total = total; this.rows = rows; } public long gettotal() { return total; } public void settotal(long total) { this.total = total; } public list getrows() { return rows; } public void setrows(list rows) { this.rows = rows; } } (3)封装查询条件的querypagebean类，放到offcnpe_util工程中 /** * 封装查询条件 */ public class querypagebean implements serializable{ private integer currentpage;//页码 private integer pagesize;//每页记录数 private string querystring;//查询条件 public integer getcurrentpage() { return currentpage; } public void setcurrentpage(integer currentpage) { this.currentpage = currentpage; } public integer getpagesize() { return pagesize; } public void setpagesize(integer pagesize) { this.pagesize = pagesize; } public string getquerystring() { return querystring; } public void setquerystring(string querystring) { this.querystring = querystring; } } (4)html、js、css、图片等静态资源，放到offcnpe_controller工程中 注意：后续随着项目开发还会陆续导入其他一些公共资源。\n(5)使用mybatis-plus逆向工程生成基本文件 在offcn_pe工程中执行逆向工程的代码：\npublic class mybatisplusgenerator { public static void main(string[] args) { // 代码生成器 autogenerator mpg = new autogenerator(); // 全局配置 globalconfig gc = new globalconfig(); //string projectpath = system.getproperty(\u0026#34;user.dir\u0026#34;); gc.setoutputdir(\u0026#34;生成代码的路径\u0026#34;); gc.setauthor(\u0026#34;zs\u0026#34;); gc.setopen(false); //实体属性 swagger2 注解 gc.setswagger2(false); mpg.setglobalconfig(gc); // 数据源配置 datasourceconfig dsc = new datasourceconfig(); //dsc.seturl(\u0026#34;jdbc:mysql://127.0.0.1:3306/demo?servertimezone=utc\u0026amp;useunicode=true\u0026amp;characterencoding=utf-8\u0026amp;zerodatetimebehavior=converttonull\u0026amp;usessl=false\u0026amp;allowpublickeyretrieval=true\u0026#34;); dsc.seturl(\u0026#34;jdbc:mysql:///offcnpe\u0026#34;); dsc.setdrivername(\u0026#34;com.mysql.jdbc.driver\u0026#34;); dsc.setusername(\u0026#34;root\u0026#34;); dsc.setpassword(\u0026#34;root\u0026#34;); mpg.setdatasource(dsc); // 包配置 packageconfig pc = new packageconfig(); pc.setparent(\u0026#34;com.offcn\u0026#34;); pc.setentity(\u0026#34;pojo\u0026#34;); pc.setmapper(\u0026#34;mapper\u0026#34;); pc.setserviceimpl(\u0026#34;service.xml\u0026#34;); mpg.setpackageinfo(pc); // 配置模板 templateconfig templateconfig = new templateconfig(); //默认关闭不需要的生成内容 //templateconfig.setxml(null); templateconfig.setservice(null); templateconfig.setserviceimpl(null); mpg.settemplate(templateconfig); // 策略配置 strategyconfig strategy = new strategyconfig(); strategy.setnaming(namingstrategy.underline_to_camel);//数据库表映射到实体的命名策略 strategy.setcolumnnaming(namingstrategy.underline_to_camel);//数据库表字段映射到实体的命名策略 strategy.setsuperentityclass(\u0026#34;com.baomidou.mybatisplus.extension.activerecord.model\u0026#34;); strategy.setentitylombokmodel(true); strategy.setrestcontrollerstyle(true); strategy.setentitylombokmodel(true); string tablenames=\u0026#34;t_checkgroup,t_checkgroup_checkitem,t_checkitem,t_member,t_menu,\u0026#34; + \u0026#34;t_order,t_ordersetting,\u0026#34; + \u0026#34;t_permission,t_role,t_role_menu,\u0026#34; + \u0026#34;t_role_permission,t_setmeal,t_setmeal_checkgroup,t_user,t_user_role\u0026#34;; strategy.setinclude(tablenames.split(\u0026#34;,\u0026#34;)); strategy.setcontrollermappinghyphenstyle(true); strategy.settableprefix(\u0026#34;t_\u0026#34;); mpg.setstrategy(strategy); mpg.execute(); } } (三)新增检查项功能实现 1：编写页面 (1)弹出新增窗口 页面中已经提供了新增窗口，只是处于隐藏状态。只需要将控制展示状态的属性 dialogformvisible改为true就可以显示出新增窗口。 新建按钮绑定的方法为handlecreate，所以在handlecreate方法中修改 dialogformvisible属性的值为true即可。同时为了增加用户体验度，需要每次点击新建 按钮时清空表单输入项\n// 重置表单 resetform() { this.formdata = {}; }, // 弹出添加窗口 handlecreate() { this.resetform(); this.dialogformvisible = true; } (2)提交表单数据 点击新增窗口中的确定按钮时，触发handleadd方法，所以需要在handleadd方法中进行完善,因为表单中添加了校验，只有校验通过然后发送ajax请求发送数据，如果校验失败表单不能提交成功的。\n/* * 获取表单对象,调用校验方法，使用钩子函数完成数据操作 * */ this.$refs[\u0026#39;dataaddform\u0026#39;].validate((valid) =\u0026gt; { //测试数据是否正常封装 //console.log(this.formdata) if(valid){ //校验成功 axios.post(\u0026#39;/checkitem/add\u0026#39;,this.formdata,).then((res) =\u0026gt; { //res就是我们返回的offcnpe_util中的result对象封装的结果,json数据格式 //关闭新增窗口(不管什么情况都需要关闭窗口) this.dialogformvisible = false; if(res.data.flag){ console.log(\u0026#39;成功\u0026#39;); //调用分页方法 this.findpage(); //弹出提示信息 this.$message({ message : res.data.message, type : \u0026#39;success\u0026#39; }); }else{ console.log(\u0026#39;失败\u0026#39;); //弹出失败信息 this.message().error(res.data.message); } }); }else{ //校验失败 this.message().error(\u0026#39;数据校验失败,请检查执行\u0026#39;); return ; } }); }, 2：后台代码 (1)控制器方法 在offcnpe_controller中的checkitemcontroller添加方法 @requestmapping(\u0026#34;/add\u0026#34;) @responsebody public result add(@requestbody checkitem checkitem){ system.out.println(checkitem); try { checkitemservice.add(checkitem); }catch (exception e){ e.printstacktrace(); return new result(true, messageconstant.add_checkitem_success); } return new result(true,messageconstant.add_checkitem_fail); } (2)服务接口 在offcnpe_interface 创建接口 public interface checkitemservice { public void add(checkitem checkitem); } (3) 服务实现类 在offcnpe_service_provider中实现接口checkitemservice\n@service public class checkitemsserviceimpl implements checkitemservice { @resource private checkitemmapper checkitemmapper; @override public void add(checkitem checkitem) { checkitemmapper.insert(checkitem); } } (四)检查项分页功能 1：功能分析 本项目所有分页功能都是基于ajax的异步请求来完成的，请求参数和后台响应数据格式都 使用json数据格式。 请求参数包括页码、每页显示记录数、查询条件。 请求参数的json格式为：{currentpage:1,pagesize:10,querystring:\u0026lsquo;\u0026lsquo;offcn\u0026rsquo;\u0026rsquo;} 后台响应数据包括总记录数、当前页需要展示的数据集合。 响应数据的json格式为：{total:1000,rows:[]} 如下图所示：\n2：编写页面 (1)定义分页相关模型数据 pagination: {//分页相关模型数据 currentpage: 1,//当前页码 pagesize:10,//每页显示的记录数 total:0,//总记录数 querystring:null//查询条件 }, datalist: [],//当前页要展示的分页列表数据 (2)利用vue的钩子函数执行分页方法 在页面中提供了findpage方法用于分页查询，为了能够在checkitem.html页面加载后直 接可以展示分页数据，可以在vue提供的钩子函数created中调用findpage方法\n//钩子函数，vue对象初始化完成后自动执行 created() { this.findpage(); }, (3)编辑分页方法 //分页查询 findpage() { //封装查询参数 var param = { //当前页 currentpage: this.pagination.currentpage, //每页显示数据条数 pagesize: this.pagination.pagesize, //查询的条件字符串 querystring: this.pagination.querystring }; //ajax请求完成数据的请求和响应 axios.post(\u0026#39;/checkitem/pagequery\u0026#39;,param,).then((res) =\u0026gt; { this.pagination.total=res.data.total; //查询的总条数 this.datalist = res.data.rows; //当前页面展示的数据内容 }); }, (4) 点击查询按钮和点击分页的页码依然需要进行分页查询操作 a: 查询按钮绑定findpage方法 \u0026lt;el-button @click=\u0026#34;findpage()\u0026#34; class=\u0026#34;dalfbut\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; b： 点击页码执行findpage方法 \u0026lt;el-pagination class=\u0026#34;pagiantion\u0026#34; @current-change=\u0026#34;handlecurrentchange\u0026#34; :current-page=\u0026#34;pagination.currentpage\u0026#34; :page-size=\u0026#34;pagination.pagesize\u0026#34; layout=\u0026#34;total, prev, pager, next, jumper\u0026#34; :total=\u0026#34;pagination.total\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; @current-change=\u0026#34;handlecurrentchange\u0026#34; ui框架给我们提供的点击页码自动回调的函数 编写方法handlecurrentchange： //切换页码 handlecurrentchange(currentpage) { //将点击的页码给我们的当前页从新赋值 this.pagination.currentpage = currentpage; //调用分页查询方法 this.findpage(); }, 3：后台代码实现 (1)checkitemcontroller增加方法findpage @requestmapping(\u0026#34;/findpage\u0026#34;) @responsebody public pageresult findpage(@requestbody querypagebean querypagebean){ pageresult pageresult = checkitemservice.findpage(querypagebean); return pageresult; } (2)在checkitemservice服务接口中扩展分页查询方法 pageresult findpage(querypagebean querypagebean); (3)在checkitemserviceimpl服务实现类中实现分页查询方法，基于mybatis-plus分页助手插件实现分页 //分页查询检查项所有的数据内容 @override public pageresult findpage(querypagebean querypagebean) { //构建分页page对象 page\u0026lt;checkitem\u0026gt; page1 = new page\u0026lt;\u0026gt;(querypagebean.getcurrentpage(),querypagebean.getpagesize()); //构建查询条件对象 querywrapper\u0026lt;checkitem\u0026gt; wrapper = new querywrapper\u0026lt;\u0026gt;(); if(querypagebean.getquerystring()!=null \u0026amp;\u0026amp;querypagebean.getquerystring().length()\u0026gt;0){ wrapper.like(\u0026#34;name\u0026#34;,querypagebean.getquerystring()); wrapper.or(); wrapper.like(\u0026#34;code\u0026#34;,querypagebean.getquerystring()); } //分页查询数据 page\u0026lt;checkitem\u0026gt; checkitempage = checkitemmapper.selectpage(page1, wrapper); return new pageresult(checkitempage.gettotal(),checkitempage.getrecords()); } (4)offcnpe_util项目中添加分页工具类 @configuration public class mybatisplusconfig { /** *分页插件 */ @bean public mybatisplusinterceptor mybatisplusinterceptor() { mybatisplusinterceptor mybatisplusinterceptor=new mybatisplusinterceptor(); paginationinnerinterceptor innerinterceptor=new paginationinnerinterceptor(); innerinterceptor.setdbtype(dbtype.mysql); innerinterceptor.setoverflow(true); mybatisplusinterceptor.addinnerinterceptor(innerinterceptor); return mybatisplusinterceptor; } } 一、删除检查项功能 （一）编写页面 为了防止用户误操作，点击删除按钮时需要弹出确认删除的提示，用户点击取消则不做 任何操作，用户点击确定按钮再提交删除请求\n1：绑定单击事件 \u0026lt;el-button size=\u0026#34;mini\u0026#34; type=\u0026#34;danger\u0026#34; @click=\u0026#34;handledelete(scope.row)\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; scope.row：就是当前行的json对象 2：构建删除方法 // 删除 handledelete(row) { this.$confirm(\u0026#34;确认删除当前数据么\u0026#34;,\u0026#34;提示\u0026#34;,{type:\u0026#39;waring\u0026#39;}).then(() =\u0026gt; { //用户点击确认按钮 axios.post(\u0026#34;/checkitem/deleteinfobyid?id=\u0026#34;+row.id).then((res) =\u0026gt; { if(res.data.flag){ //删除成功 this.$message({ message: res.data.message, type: \u0026#39;success\u0026#39; }); this.findpage(); }else{ //删除失败 this.$message().error(res.data.message) } }); }).catch(() =\u0026gt; { //用户点击取消按钮 this.$message({ message: \u0026#39;用户取消了删除操作\u0026#39;, type: \u0026#39;info\u0026#39; }); } ); } （二）后台代码实现 1：控制器方法 //删除检查项 @requestmapping(\u0026#34;/deleteinfobyid\u0026#34;) @responsebody public result deleteinfobyid(integer id){ system.out.println(id); try{ checkitemservice.deleteinfobyid(id); }catch (exception e){ e.printstacktrace(); new result(false,messageconstant.delete_checkitem_fail); } return new result(true,messageconstant.delete_checkitem_success); } 2：服务接口中的方法 void deleteinfobyid(integer id); 3：在checkitemserviceimpl服务实现类实现删除功能 @override public void deleteinfobyid(integer id) { checkitemmapper.deletebyid(id); } 二、编辑检查项功能 (一)编写页面 用户点击编辑按钮时，需要弹出编辑窗口并且将当前记录的数据进行回显，用户修改完 成后点击确定按钮将修改后的数据提交到后台进行数据库操作\n1:给编辑按钮绑定事件 \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34; @click=\u0026#34;handleupdate(scope.row)\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; 对应事件方法 handleupdate(row) { } 2：弹出编辑窗口回显数据 // 弹出编辑窗口 handleupdate(row) { this.resetform(); //显示编辑窗口 this.dialogformvisible4edit = true; //根据当前行的id回显数据 axios.get(\u0026#34;/checkitem/findinfobyid?id=\u0026#34;+row.id).then((res) =\u0026gt; { //true 代表查询到了数据 if(res.data.flag){ console.info(res.data.data); //\u0026lt;el-input v-model=\u0026#34;formdata.code\u0026#34;/\u0026gt; //进行数据回显,基于vue的数据绑定实现的 绑定的对象就是formdata,这个对象有值,就会自动回显到文本框中 this.formdata = res.data.data; }else{ this.$message().error(res.data.message); } }); }, 3：点击确定按钮进行数据更新 在编辑窗口中修改完成后，点击确定按钮需要提交请求，所以需要为确定按钮绑定事件 并提供处理函数handleedit\n\u0026lt;el‐button type=\u0026#34;primary\u0026#34; @click=\u0026#34;handleedit()\u0026#34;\u0026gt;确定\u0026lt;/el‐button\u0026gt; 4：编辑方法绑定函数 //编辑 handleedit() { this.$refs[\u0026#39;dataeditform\u0026#39;].validate((valid) =\u0026gt;{ if(valid){ axios.post(\u0026#39;/checkitem/updateinfobyid\u0026#39;,this.formdata).then((res) =\u0026gt; { if(res.data.flag){ this.$message({ message: res.data.message, type:\u0026#39;success\u0026#39; }); }else{ this.$message().error(res.data.message); } }).finally(() =\u0026gt;{ //无论校验成功还是失败都需要调用分页方法 this.findpage(); //隐藏我们弹出的数据框 this.dialogformvisible4edit = false; }); }else{ this.$message().error(\u0026#34;表单校验失败\u0026#34;); return false; } }); }, （二）后台功能实现 1：控制器方法 //回显检查项数据 @requestmapping(\u0026#34;/findinfobyid\u0026#34;) @responsebody public result findinfobyid(integer id){ checkitem infobyid = null; try{ infobyid = checkitemservice.findinfobyid(id); }catch (exception e){ e.printstacktrace(); new result(false,messageconstant.delete_checkitem_fail); } return new result(true,messageconstant.delete_checkitem_success,infobyid); } //更新检查项数据 @requestmapping(\u0026#34;/updateinfobyid\u0026#34;) @responsebody public result updateinfobyid(@requestbody checkitem checkitem){ try{ checkitemservice.updateinfobyid(checkitem); }catch (exception e){ e.printstacktrace(); return new result(false,messageconstant.edit_checkitem_fail); } return new result(true,messageconstant.edit_checkitem_success); } 2：接口方法 checkitem findinfobyid(integer id); void updateinfobyid(checkitem checkitem); 3：在checkitemserviceimpl服务实现类实现删除功能 @override public checkitem findinfobyid(integer id) { return checkitemmapper.selectbyid(id); } @override public void updateinfobyid(checkitem checkitem) { checkitemmapper.updatebyid(checkitem); } 三、新增检查组 (一) 需求分析 检查组其实就是多个检查项的集合，例如有一个检查组为“一般检查”，这个检查组可以包 括多个检查项：身高、体重、收缩压、舒张压等。所以在添加检查组时需要选择这个检 查组包括的检查项。 检查组对应的实体类为checkgroup，对应的数据表为t_checkgroup。检查组和检查项 为多对多关系，所以需要中间表t_checkgroup_checkitem进行关联。\n(二)回显所有检查项 1：前端内容 (1) 绑定事件 \u0026lt;el-button type=\u0026#34;primary\u0026#34; class=\u0026#34;butt\u0026#34; @click=\u0026#34;handlecreate()\u0026#34;\u0026gt;新建\u0026lt;/el-button\u0026gt; 点击新建按钮弹出dialog并加载出检查项 的相关数据\n(2)事件函数 // 重置表单 resetform() { this.formdata = {}; }, //我们点击新建按钮,在弹出的窗口中需要加载所有的检查项的数据. handlecreate() { //显示隐藏窗口 this.dialogformvisible = true; //默认选中第一个选项卡 this.activename = \u0026#39;first\u0026#39;; //重置表单 this.resetform(); //清除默认勾选的检查项 this.checkitemids = []; //异步请求获取所有检查项信息 axios.get(\u0026#34;/checkitem/showallitem\u0026#34;).then((res) =\u0026gt; { if(res.data.flag){ this.tabledata = res.data.data; }else{ this.$message().error(res.data.messge); } }); }, 2:后台内容 (1)在控制器中添加方法 //展示所有检查项信息 @requestmapping(\u0026#34;/showallitem\u0026#34;) @responsebody public result showallitem(){ list\u0026lt;checkitem\u0026gt; infobyid = null; try{ infobyid = checkitemservice.showallitem(); }catch (exception e){ e.printstacktrace(); new result(false,messageconstant.query_checkitem_fail); } return new result(true,messageconstant.query_checkitem_success,infobyid); } (2)在接口中添加方法 list\u0026lt;checkitem\u0026gt; showallitem(); (3)实现接口方法 @override public list\u0026lt;checkitem\u0026gt; showallitem() { return checkitemmapper.selectlist(null); } (三) 提交按钮完成检查组数据添加 当用户点击新增窗口中的确定按钮时发送ajax请求将数据提交到后台进行数据库操作。提 交到后台的数据分为两部分：检查组基本信息（对应的模型数据为formdata）和检查项 id数组（对应的模型数据为checkitemids）\n1:前端内容 (1)绑定事件 \u0026lt;el‐button type=\u0026#34;primary\u0026#34; @click=\u0026#34;handleadd()\u0026#34;\u0026gt;确定\u0026lt;/el‐button\u0026gt; 点击确定按钮 出发handleadd函数实现检查组添加\n(2)事件函数 handleadd () { axios.post(\u0026#34;/checkgroup/addgroup?checkitemids=\u0026#34;+this.checkitemids,this.formdata).then((res) =\u0026gt; { this.dialogformvisible = false; if(res.data.flag){ this.$message({ message: res.data.message, type: \u0026#39;success\u0026#39; }); }else{ this.message().error(res.data.message); } }).finally(() =\u0026gt; { //从新进行分页查询 this.findpage(); }); }, 2:后台内容 (1)添加控制方法 在checkgroupcontroller中 @requestmapping(\u0026#34;/addgroup\u0026#34;) public result addgroup(@requestbody checkgroup checkgroup,integer [] checkitemids){ try { checkgroupservice.addgroup(checkgroup,checkitemids); }catch (exception e){ e.printstacktrace(); return new result(false, messageconstant.add_checkgroup_fail); } return new result(true,messageconstant.add_checkgroup_success); } (2)服务层接口内容 void addgroup(checkgroup checkgroup, integer[] checkitemids); (3)服务接口的实现类 package com.offcn.service.impl; import com.offcn.mapper.checkgroupcheckitemmapper; import com.offcn.mapper.checkgroupmapper; import com.offcn.pojo.checkgroup; import com.offcn.pojo.checkgroupcheckitem; import com.offcn.service.checkgroupservice; import org.apache.dubbo.config.annotation.service; import org.springframework.transaction.annotation.transactional; import javax.annotation.resource; import java.lang.reflect.array; import java.util.arraylist; import java.util.list; @service(interfaceclass = checkgroupservice.class) @transactional public class checkgroupserviceimpl implements checkgroupservice { @resource private checkgroupmapper checkgroupmapper; @resource private checkgroupcheckitemmapper checkgroupcheckitemmapper; @override public void addgroup(checkgroup checkgroup, integer[] checkitemids) { //添加检查组 checkgroupmapper.insert(checkgroup); for(integer id:checkitemids){ checkgroupcheckitem checkgroupcheckitem = new checkgroupcheckitem(); checkgroupcheckitem.setcheckgroupid(checkgroup.getid()); checkgroupcheckitem.setcheckitemid(id); //添加检查组和检查项的中间表数据 checkgroupcheckitemmapper.insert(checkgroupcheckitem); } } } 医疗管家-检查组信息维护 一、检查组分页显示 (一)前端页面内容 1：编写分页函数 //分页查询 findpage() { //发送ajax的请求完成页面数据加载 var param ={ currentpage: this.pagination.currentpage, pagesize: this.pagination.pagesize, querystring: this.pagination.querystring }; //发送ajax请求 axios.post(\u0026#34;/checkgroup/findpage\u0026#34;,param,).then((res) =\u0026gt; { //给我们的vue的变量赋值 this.pagination.total = res.data.total; this.datalist = res.data.rows; }); }, 2：分页方法执行时机 加载页面的时候使用vue的钩子函数完成分页功能\ncreated() { this.findpage(); }, 点击页码完成分页数据展示 //切换页码 handlecurrentchange(currentpage) { this.pagination.currentpage = currentpage; this.findpage(); }, 查询按钮完成分页显示功能 \u0026lt;el-button @click=\u0026#34;findpage()\u0026#34; class=\u0026#34;dalfbut\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; (二)后台内容 1：控制器方法 //分页显示检查组 @requestmapping(\u0026#34;/findpage\u0026#34;) public pageresult findpage(@requestbody querypagebean querypagebean){ pageresult pageresult = checkgroupservice.findpage(querypagebean); return pageresult; } 2： 服务接口 pageresult findpage(querypagebean querypagebean); 3：接口实现类 @override public pageresult findpage(querypagebean querypagebean) { page\u0026lt;checkgroup\u0026gt; page1 = new page(querypagebean.getcurrentpage(),querypagebean.getpagesize()); querywrapper\u0026lt;checkgroup\u0026gt; querywrapper = new querywrapper\u0026lt;\u0026gt;(); if(querypagebean.getquerystring()!=null \u0026amp;\u0026amp; querypagebean.getquerystring().length()\u0026gt;0){ querywrapper.like(\u0026#34;code\u0026#34;,querypagebean.getquerystring()); querywrapper.or(); querywrapper.like(\u0026#34;name\u0026#34;,querypagebean.getquerystring()); querywrapper.or(); querywrapper.like(\u0026#34;helpcode\u0026#34;,querypagebean.getquerystring()); } page\u0026lt;checkgroup\u0026gt; checkgrouppage = checkgroupmapper.selectpage(page1, querywrapper); return new pageresult(checkgrouppage.gettotal(),checkgrouppage.getrecords()); } 二、编辑检查组功能 (一)回显编辑信息功能 1:前端内容编写 (1)点击按钮弹出编辑窗口并回显检查组数据 // 弹出编辑窗口 handleupdate(row) { this.dialogformvisible4edit = true; //回显当前检查组的基本信息 axios.get(\u0026#34;/checkgroup/findgroupinfobyid?id\u0026#34;+row.id).then((res) =\u0026gt; { //回显数据 if(res.data.flag){ this.formdata = res.data.data; }else{ this.$message.error(res.data.message); } }); //异步请求获取所有检查项信息 axios.get(\u0026#34;/checkitem/showallitem\u0026#34;).then((res) =\u0026gt; { if(res.data.flag){ this.tabledata = res.data.data; //基于双向绑定给我们的checkitemids赋值 就可以默认勾选当前检查项的所有默认检查组 //必须等到我们的检查项的列表加载完毕才可以进行勾选 所有我们的异步请求需要添加到这个位置 // java list\u0026lt;integer\u0026gt; 转换成的json就是这个效果 [3,4,576,] axios.get(\u0026#34;/checkitem/getcheckitemidbygroupid?id=\u0026#34;+row.id).then((res) =\u0026gt; { this.checkitemids = res.data; }); ​ }else{ this.$message().error(res.data.messge); } }); }, 2:后台内容 (1):控制器方法 a:checkgroupcontroller //根据检查组的id获取检查组的信息 @requestmapping(\u0026#34;/findgroupinfobyid\u0026#34;) public result findgroupinfobyid(integer id){ checkgroup checkgroup = null; try { checkgroup = checkgroupservice.findgroupinfobyid(id); }catch (exception e){ e.printstacktrace(); return new result(false,messageconstant.query_checkgroup_fail); } return new result(true,messageconstant.query_checkgroup_success,checkgroup); } b:checkitemcontroller //根据检查组的id获取检查组包含的检查项的id @requestmapping(\u0026#34;/getcheckitemidbygroupid\u0026#34;) @responsebody public list\u0026lt;integer\u0026gt; getcheckitemidbygroupid(integer id){ return checkitemservice.getcheckitemidbygroupid(id); } (2)服务接口方法 a:checkgroupservice checkgroup findgroupinfobyid(integer id); b:checkitemservice list\u0026lt;integer\u0026gt; getcheckitemidbygroupid(integer id); (3)服务接口的实现方法 a:checkgroupserviceimpl @override public checkgroup findgroupinfobyid(integer id) { return checkgroupmapper.selectbyid(id); } b:checkitemsserviceimpl @override public list\u0026lt;integer\u0026gt; getcheckitemidbygroupid(integer id) { lambdaquerywrapper\u0026lt;checkgroupcheckitem\u0026gt; lambdaquerywrapper = new lambdaquerywrapper(); lambdaquerywrapper.eq(checkgroupcheckitem::getcheckgroupid,id); lambdaquerywrapper.select(checkgroupcheckitem::getcheckitemid); return checkgroupcheckitemmapper.selectobjs(lambdaquerywrapper).stream().map(o -\u0026gt; (integer) o).collect(collectors.tolist()); } (二)提交确认按钮完成检查组修改 1：编写前端提交更新函数 //编辑检查组 handleedit() { axios.post(\u0026#34;/checkgroup/editgroup?checkitemids=\u0026#34;+this.checkitemids,this.formdata).then((res) =\u0026gt; { this.dialogformvisible4edit = false; if(res.data.flag){ this.$message({ message: res.data.message, type: \u0026#39;success\u0026#39; }); }else{ this.message().error(res.data.message); } }).finally(() =\u0026gt; { //从新进行分页查询 this.findpage(); }); }, 2：后台内容 (1)控制器方法 //编辑检查项 @requestmapping(\u0026#34;/editgroup\u0026#34;) public result editgroup(@requestbody checkgroup checkgroup,integer [] checkitemids){ try { checkgroupservice.updategroup(checkgroup,checkitemids); }catch (exception e){ e.printstacktrace(); return new result(false, messageconstant.edit_checkgroup_fail); } return new result(true,messageconstant.edit_checkgroup_success); } (2)服务接口内容\nvoid updategroup(checkgroup checkgroup, integer[] checkitemids); (3)接口的实现类内容\n@override public void updategroup(checkgroup checkgroup, integer[] checkitemids) { //更新检查组数据 checkgroupmapper.updatebyid(checkgroup); //删除检查组和检查项的中间关系表数据 map\u0026lt;string,object\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;checkgroup_id\u0026#34;,checkgroup.getid()); checkgroupcheckitemmapper.deletebymap(map); //从新添加检查组和检查项的中间表数据 for(integer id:checkitemids){ checkgroupcheckitem checkgroupcheckitem = new checkgroupcheckitem(); checkgroupcheckitem.setcheckgroupid(checkgroup.getid()); checkgroupcheckitem.setcheckitemid(id); checkgroupcheckitemmapper.insert(checkgroupcheckitem); } } 三、删除检查组操作 (一) 前端页面内容编写 // 删除 handledelete(row) { //删除组操作 this.$confirm(\u0026#34;确认删除选中的数据么?\u0026#34;,\u0026#34;提示\u0026#34;,{type:\u0026#34;warning\u0026#34;}).then(() =\u0026gt; { //使用ajax方式完成数据的删除 axios.get(\u0026#34;/checkgroup/deleteinfobyid?id=\u0026#34;+row.id).then((res) =\u0026gt; { if(res.data.flag){ this.$message({ message: res.data.message, type:\u0026#39;success\u0026#39; }); }else{ this.$message.error(res.data.message); } }).finally(() =\u0026gt; { this.findpage(); }) }).catch(() =\u0026gt; { this.$message({ message: \u0026#39;取消了当前删除检查组操作\u0026#39;, type: \u0026#39;info\u0026#39; }); }); } (二) 删除检查组的后台内容 1：控制器方法 //删除检查组 @requestmapping(\u0026#34;/deleteinfobyid\u0026#34;) public result deleteinfobyid(integer id){ try{ checkgroupservice.deleteinfobyid(id); }catch (exception e){ e.printstacktrace(); return new result(false,messageconstant.delete_checkgroup_fail); } return new result(true,messageconstant.delete_checkgroup_success); } 2: 接口方法 void deleteinfobyid(integer id); 3:接口的实现方法 //删除检查组 @override public void deleteinfobyid(integer id) { //删除中间表数据 map\u0026lt;string,object\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;checkgroup_id\u0026#34;,id); checkgroupcheckitemmapper.deletebymap(map); //删除检查组 checkgroupmapper.deletebyid(id); } 医疗管家-套餐管理维护 一、体检套餐管理 套餐其实就是检查组的集合，例如有一个套餐为“老年套餐”，这个体检套餐可以包括多个检查组：心脑血管检查、甲状腺检查、肺部筛查等。所以在添加套餐时需要选择这 个套餐包括的检查组。 套餐对应的实体类为setmeal，对应的数据表为t_setmeal。套餐和检查组为多对多关 系，所以需要中间表t_setmeal_checkgroup进行关联\n(一)添加套餐功能 添加套餐功能中涉及到两部分，一部分是添加套餐信息还有一部分是添加套餐对应的检查组的信息，所以在点击套餐页面中的新建的时候在弹出一个已经准备好的隐藏框，在弹出的窗口中需要加载出所有的检查组的信息，每个套餐还有对应的配套图片，我们使用element-ui提供的上传组件完成上传功能\n1： 弹出添加套餐窗口 (1)前台页面 a:编写新建套餐按钮事件 // 弹出添加窗口 handlecreate() { //重置表单 this.resetform(); //显示弹出窗口 this.dialogformvisible = true; axios.get(\u0026#34;/checkgroup/showallgroupinfo\u0026#34;).then((res) =\u0026gt; { if(res.data.flag){ this.tabledata = res.data.data; }else{ this.$message.erro(res.data.message); } }); }, b:重置表单事件 // 重置表单 resetform() { //清空表单数据 this.formdata = {}; //清空选中的检查组 this.checkitemids = []; //默认选中第一个选项卡 this.activename = \u0026#39;first\u0026#39;; //清空图片的预览url this.imageurl = null; }, (2)后台代码实现 a:控制器方法 //展示所有的检查组信息 @requestmapping(\u0026#34;/showallgroupinfo\u0026#34;) public result showallgroupinfo(){ list\u0026lt;checkgroup\u0026gt; list = null; try{ list = checkgroupservice.showallgroupinfo(); }catch (exception e){ e.printstacktrace(); return new result(false,messageconstant.query_checkitem_fail); } return new result(true,messageconstant.query_checkgroup_success,list); } b:服务接口 list\u0026lt;checkgroup\u0026gt; showallgroupinfo(); c:实现接口提供服务 @override public list\u0026lt;checkgroup\u0026gt; showallgroupinfo() { return checkgroupmapper.selectlist(null); } 2:处理上传图片功能 (1)前台页面 a:element-ui上传组件 \u0026lt;el-form-item label=\u0026#34;上传图片\u0026#34;\u0026gt; \u0026lt;el-upload class=\u0026#34;avatar-uploader\u0026#34; action=\u0026#34;/setmeal/uploadpic\u0026#34; :auto-upload=\u0026#34;autoupload\u0026#34; name=\u0026#34;imgfile\u0026#34; :show-file-list=\u0026#34;false\u0026#34; :on-success=\u0026#34;handleavatarsuccess\u0026#34; :before-upload=\u0026#34;beforeavatarupload\u0026#34;\u0026gt; \u0026lt;img v-if=\u0026#34;imageurl\u0026#34; :src=\u0026#34;imageurl\u0026#34; class=\u0026#34;avatar\u0026#34;\u0026gt; \u0026lt;i v-else class=\u0026#34;el-icon-plus avatar-uploader-icon\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/el-upload\u0026gt; \u0026lt;/el-form-item\u0026gt; 当前页面使用elementui的上传组件 action: 上传文件的地址 auto-upload: 自动上传 name：上传文件的名称 on-success: 上传成功后的回调函数 before-upload: 上传之前回调的函数\nb:编辑上传组件的js函数 //上传图片之前执行 规范了上传图片的类型和上传图片的大小 beforeavatarupload(file) { const isjpg = file.type === \u0026#39;image/jpeg\u0026#39;; const islt2m = file.size / 1024 / 1024 \u0026lt; 2; if (!isjpg) { this.$message.error(\u0026#39;上传套餐图片只能是 jpg 格式!\u0026#39;); } if (!islt2m) { this.$message.error(\u0026#39;上传套餐图片大小不能超过 2mb!\u0026#39;); } return isjpg \u0026amp;\u0026amp; islt2m; }, //文件上传成功后的钩子，response为服务端返回的值，file为当前上传的文件封装成的js对象 handleavatarsuccess(response, file) { this.imageurl=\u0026#34;http://localhost:9003/setmealpic/\u0026#34;+response.data //设置模型数据（图片名称），后续提交ajax请求时会提交到后台最终保存到数据库 this.formdata.img = response.data; }, (2)后台功能实现代码 a:控制方法 //上传图片方法 @requestmapping(\u0026#34;/uploadpic\u0026#34;) public result uploadpic(@requestparam(\u0026#34;imgfile\u0026#34;) multipartfile multipartfile){ string originalfilename = multipartfile.getoriginalfilename(); int lastindexof = originalfilename.lastindexof(\u0026#34;.\u0026#34;); //获取文件后缀 string suffix = originalfilename.substring(lastindexof - 1); string filename = uuid.randomuuid().tostring()+suffix; file file = new file(\u0026#34;d:/upload/\u0026#34;+filename); try { multipartfile.transferto(file); return new result(false, messageconstant.pic_upload_fail); } catch (exception e) { e.printstacktrace(); } return new result(true,messageconstant.pic_upload_success,filename); } b：设置虚拟路径完成图片的存储和访问 @configuration public class myconfiguration extends webmvcconfigureradapter { @override public void addresourcehandlers(resourcehandlerregistry registry) { registry.addresourcehandler(\u0026#34;/setmealpic/**\u0026#34;).addresourcelocations(\u0026#34;file:d:/upload/\u0026#34;); } } ","date":"2022-05-18","permalink":"https://lovemjh.vercel.app/posts/project/20220518154841/","summary":"一、项目概述和环境搭建 (一)项目背景 随着疫情的逐步结束，国民对于个人的身体健康越来越重视，对健康认识不断提高，对健康的需求也在不断增加，健康检查作为防患于未然的","title":"医疗管家"},{"content":"1 初始化 创建git远程仓库 过滤需要上传的文件 在博客根目录新建名一个为.gitignore的文件,并输入以下内容。 #git同步时不需要上传的文件 .ds_store thumbs.db db.json *.log node_modules/ public/ .deploy*/ .vscode/ /.idea/ .deploy_git*/ .idea themes/butterfly/.git 按顺序输入命令 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -m main git remote add origin git@gitee.com:lovemjh/demo.git git push -u origin \u0026#34;main\u0026#34; 至此,本地代码已经推送到远程仓库。\n2 版本迭代 在博客根目录创建名为gitautopush.sh的文件，输入以下内容。 #!/bin/bash #上面中的 #! 是一种约定标记, 它可以告诉系统这个脚本需要什么样的解释器来执行; echo \u0026#34;gitautopush starting...\u0026#34; time=$(date \u0026#34;+%y-%m-%d %h:%m:%s\u0026#34;) git add . read -t 30 -p \u0026#34;请输入提交注释:\u0026#34; msg if [ ! \u0026#34;$msg\u0026#34; ] ;then echo \u0026#34;[commit message] 默认提交, 提交人: $(whoami), 提交时间: ${time}\u0026#34; git commit -m \u0026#34;默认提交, 提交人: $(whoami), 提交时间: ${time}\u0026#34; else echo \u0026#34;[commit message] $msg, 提交人: $(whoami), 提交时间: ${time}\u0026#34; git commit -m \u0026#34;$msg, 提交人: $(whoami), 提交时间: ${time}\u0026#34; fi #正常提交 #git push -u origin master #强制提交 git push -f origin master echo \u0026#34; gitautopush ending...\u0026#34; 之后更新只需运行这个文件就好。\n误删文章可以以下方法 使用git pull origin master命令,从远程仓库重新拉取。 也可以创建一个名为gitautopull.sh的文件,输入以下内容。\n#!/bin/bash #上面中的 #! 是一种约定标记, 它可以告诉系统这个脚本需要什么样的解释器来执行; git pull origin master 之后只需运行这个文件就好。\n3 远程复用 先使用git clone git@gitee.com:lovemjh/demo.git 命令将远程仓库克隆到本地。 进入博客目录,执行npm install 安装依赖。 ","date":"2022-03-20","permalink":"https://lovemjh.vercel.app/posts/blog/20220430231253/","summary":"1 初始化 创建git远程仓库 过滤需要上传的文件 在博客根目录新建名一个为.gitignore的文件,并输入以下内容。 #git同步时不需要上传的文件 .DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ .vscode/ /.idea/","title":"hexo博客git版本制控制"},{"content":"安装 hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 hexo。\nnpm install -g hexo-cli 安装成功后，查看安装版本\nhexo version 初始化博客\nhexo init \u0026lt;folder\u0026gt; 进入生成博客的目录,安装依赖\ncd \u0026lt;folder\u0026gt; npm install 本地预览\nhexo server 远程部署 在开始之前，必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：\ndeploy: type: git 您可同时使用多个 deployer，hexo 会依照顺序执行每个 deployer。\ndeploy: - type: git repo: - type: heroku repo: git 安装 hexo-deployer-git。\nnpm install hexo-deployer-git --save deploy: type: git repo: gitee: git@gitee.com:lovemjh/lovemjh.git github: git@github.com:lovemjh/lovemjh.github.io.git branch: master 参数 描述 默认 repo 库（repository）地址 branch 分支名称 gh-pages (github) coding-pages (coding.net) master (others) message 自定义提交信息 site updated: {{ now('yyyy-mm-dd hh:mm:ss') }}) token optional token value to authenticate with the repo. prefix with $ to read token from environment variable 生成站点文件并推送至远程库。执行 hexo clean \u0026amp;\u0026amp; hexo deploy。\n本地搜索 npm install hexo-generator-search --save 安装插件 修改主题配置文件\nlocal_search: enable: true 您可以在根中配置此插件。_config.yml\nsearch: path: search.xml field: post #content: true #template: ./search.xml format: html limit: 10000 ","date":"2022-03-20","permalink":"https://lovemjh.vercel.app/posts/blog/20220430231095/","summary":"安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 npm install -g hexo-cli 安装成功后，查看安装版本 hexo version 初始化博客 hexo init \u0026lt;folder\u0026gt; 进入生成博客的目录,安装依赖 cd \u0026lt;folder\u0026gt; npm install 本地预览 hexo server","title":"hexo搭建"},{"content":"mybatis环境搭建 前期准备 创建数据库 create table user( id int not null auto_increment, name varchar(30), gender varchar(6), age int, birthday date, primary key(id) ); 创建maven java项目 打开idear\u0026ndash;\u0026gt;选择file\u0026ndash;\u0026gt;选择new\u0026ndash;\u0026gt;选择project\n导入依赖 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.mybatis\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mybatis\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;3.4.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;mysql\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mysql-connector-java\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;5.1.47\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;log4j\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;log4j\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 搭建项目环境 编写user实体类 package cn.offcn.entity; import java.io.serializable; import java.util.date; public class user implements serializable { private integer id; private string name; private string gender; private integer age; private date birthday; public user() {} public user(string name, string gender, integer age, date birthday) { this.name = name; this.gender = gender; this.age = age; this.birthday = birthday; } //生成getter和setter方法 } 编写持久层user接口 public interface userdao { /** * 查询所有user对象 * @return 返回list集合 */ public list\u0026lt;user\u0026gt; queryallusers(); } 编写持久层user接口映射文件userdao.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype mapper public \u0026#34;-//mybatis.org//dtd mapper 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;cn.offcn.dao.userdao\u0026#34;\u0026gt; \u0026lt;!--配置查询的sql语句--\u0026gt; \u0026lt;select id=\u0026#34;queryallusers\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 编写mybatis主配置文件sqlmapconfig.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype configuration public \u0026#34;-//mybatis.org//dtd config 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 配置 mybatis的环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置环境 --\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置事务的类型 --\u0026gt; \u0026lt;transactionmanager type=\u0026#34;jdbc\u0026#34;\u0026gt;\u0026lt;/transactionmanager\u0026gt; \u0026lt;!-- 配置连接数据库的信息:用的是数据源【连接池】--\u0026gt; \u0026lt;datasource type=\u0026#34;pooled\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/datasource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!-- 注册userdao接品映射文件位置 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;cn/offcn/dao/userdao.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; mybatist入门案例 入门案例编写 编写工具类读取配置文件 利用mybatis对数据库进行操作时，都需要产生mybatis总配置文件的输入流对象、构建sqlsessionfactorybuilder对象、调用build方法进产生sqlsessionfactory工厂对象、调用工厂类opensession()方法创建sqlsession对象，代码冗余量大，步聚颇有繁琐，所以我们对产生sqlsession对象利用工具类进行优化。\npackage cn.offcn; import org.apache.ibatis.io.resources; import org.apache.ibatis.session.sqlsession; import org.apache.ibatis.session.sqlsessionfactory; import org.apache.ibatis.session.sqlsessionfactorybuilder; import java.io.inputstream; public class mybatisutils { //定义静态变量sqlsessionfactory private static sqlsessionfactory sqlsessionfactory; //创建静态块，当mybatisutils类被加载时，自动执行该静态块，始初数据。 static{ try{ //获取mybatis主配置文件sqlmapperconfig.xml的输入流 inputstream inputstream= resources.getresourceasstream(\u0026#34;sqlmapperconfig.xml\u0026#34;); //创建sqlsessionfactorybuilder构建者对象 sqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder(); //调用build方法返回sqlsessionfactory工厂对象 sqlsessionfactory = sqlsessionfactorybuilder.build(inputstream); }catch (exception e){ e.printstacktrace(); system.out.println(\u0026#34;初始化数据失失败\u0026#34;+e.getmessage()); } } //创建getsqlsessionfactory方法返回sqlsessionfactory对象 public static sqlsessionfactory getsqlsessionfactory(){ return sqlsessionfactory; } //创建一个sqlsession对象并返回 public static sqlsession getsession(){ return sqlsessionfactory.opensession(); } //关闭sqlsession方法 public static void close(sqlsession session){ if(session!=null) session.close(); } } 使用代理对象操作数据库 public class usertest { @test public void testqueryallusers() throws exception{ //1.获取mybatis主配置文件sqlmapperconfig.xml的输入流 inputstream inputstream=resources.getresourceasstream(\u0026#34;sqlmapperconfig.xml\u0026#34;); //2.创建sqlsessionfactorybuilder构建者对象 sqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder(); //3.调用build方法返回sqlsessionfactory工厂对象 sqlsessionfactory sqlsessionfactory = sqlsessionfactorybuilder.build(inputstream); //4.调用sqlsessionfactory的opensession方法返回一个session对象 sqlsession sqlsession = sqlsessionfactory.opensession(); //5.调用sqlsession 创建 userdao接口的代理对象 userdao userdao = sqlsession.getmapper(userdao.class); //6.调用代理对象的queryallusers方法查询所有user list\u0026lt;user\u0026gt; users = userdao.queryallusers(); users.foreach(system.out::print); //7.释放资源 sqlsession.close(); inputstream.close(); } @test public void testqueryallusers2() throws exception{ //调用mybatisutils工具创建sqlsession对象 sqlsession sqlsession = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 userdao userdao = sqlsession.getmapper(userdao.class); //调用代理对象的queryallusers方法查询所有user list\u0026lt;user\u0026gt; users = userdao.queryallusers(); users.foreach(system.out::print); //释放资源 sqlsession.close(); inputstream.close(); } } mybatis执行原理分析 配置文件分析 1. 核心配置文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!doctype configuration public \u0026#34;-//mybatis.org//dtd config 3.0//en\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 配置 mybatis 的环境 --\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置的环境 --\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;!-- 配置事务的类型 --\u0026gt; \u0026lt;transactionmanager type=\u0026#34;jdbc\u0026#34;\u0026gt;\u0026lt;/transactionmanager\u0026gt; \u0026lt;!-- 配置连接数据库的信息:用的是数据源【连接池)】--\u0026gt; \u0026lt;datasource type=\u0026#34;pooled\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/datasource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!-- 注册userdao接品映射文件位置 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;cn/offcn/dao/userdao.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 核心配置文件参数详解： (1)environment标签中的id属性值必须和environments标签中的default属性一致。 (2)事务管理器： 第一种采用jdbc事务类型，直接使用了 jdbc的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。 第二种采用managed事务类型，它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 jee 应用服务器的上下文）。默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeconnection 属性设置为 false 来阻止默认的关闭行为。例如: \u0026lt;transactionmanager type=\u0026#34;managed\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;closeconnection\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/transactionmanager\u0026gt; (3) 数据源（datasource） datasource元素使用标准的jdbc数据源接口来配置jdbc连接对象的资源。大多数 mybatis 应用程序会按示例中的例子来配置数据源。 虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。 有三种内建的数据源类型（也就是 type=\u0026#34;[unpooled|pooled|jndi]\u0026#34;） unpooled– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。 pooled– 这种数据源的实现利用“池”的概念将 jdbc 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 web 应用快速响应请求。 jndi – 这个数据源实现是为了能在如 ejb 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个jndi上下文的数据源引用。 (5) mapper中的resource属性用于指定映射文件的位置。mapper中有多个属性可以描述映射文件，分别为： resource=“cn/offcn/dao/userdao.xml” 文件在多级目录中要用分隔符“/”隔开。 class=\u0026#34;cn.offcn.dao.userdao\u0026#34; 指定userdao接口文件位置，但此时userdao.xml必须和接口处在同一个包中并且文件名要 相同。 2. 映射文件 \u0026lt;mapper namespace=\u0026#34;cn.offcn.dao.userdao\u0026#34;\u0026gt; \u0026lt;!--配置查询的sql语句--\u0026gt; \u0026lt;select id=\u0026#34;queryallusers\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 映射文件参数详解： (1) namespace必须为接口的完全限定名（即包名+类名的格式）。 (2) select标签中的id必须和接口中声明的方法同名。 (3) 如果接口中方法有返回值，resyulttype必须跟方法返回值一致并采用返回值的完全限定名来表示。 底层源码分析 1.利用resources的getresourceasstream方法读取mybatis核心配置文件，该配置文件中注册数据源【datasource】和映射文件的位置【mappers标签中的mapper子标签的resource属性】。 \u0026lt;datasource type=\u0026#34;pooled\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis001\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/datasource\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;cn/offcn/dao/userdao.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; 2.展开映射文件【userdao.xml】中定义了查询方法、查询时所封装结果类型和所要执行的sql语句。 \u0026lt;select id=\u0026#34;queryallusers\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; 3.使用构建者模式sqlsessionfactorybuilder类的build方法创建sqlsessionfactory对象，在build方法中从字节输入流中解析数据。 sqlsessionfactorybuilder sqlsessionfactorybuilder = new sqlsessionfactorybuilder(); sqlsessionfactory = sqlsessionfactorybuilder.build(inputstream); //sqlsessionfactorybuilder源码: //sqlsessionfactorybuilder的build方法 public sqlsessionfactory build(inputstream inputstream) { return this.build((inputstream)inputstream, (string)null, (properties)null); } public sqlsessionfactory build(inputstream inputstream) { return this.build((inputstream)inputstream, (string)null, (properties)null); } public sqlsessionfactory build(inputstream inputstream, string environment, properties properties) { sqlsessionfactory var5; try { xmlconfigbuilder parser = new xmlconfigbuilder(inputstream, environment, properties); var5 = this.build(parser.parse()); } catch (exception var14) { throw exceptionfactory.wrapexception(\u0026#34;error building sqlsession.\u0026#34;, var14); } finally { errorcontext.instance().reset(); try { inputstream.close(); } catch (ioexception var13) { ; } } return var5; } public sqlsessionfactory build(configuration config) { return new defaultsqlsessionfactory(config); } //xmlconfigbuilder类的构造方法 public xmlconfigbuilder(inputstream inputstream, string environment, properties props) { this(new xpathparser(inputstream, true, props, new xmlmapperentityresolver()), environment,props); } public xpathparser(inputstream inputstream, boolean validation, properties variables, entityresolver entityresolver) { this.commonconstructor(validation, variables, entityresolver); this.document = this.createdocument(new inputsource(inputstream)); } 上述代码中我们可以看到创建了一个xmlconfigbuilder对象用来解析xml，把配置文件中所有标签及标签中属性值放封装到configuration对象中并返回sqlsessionfactory对象。 4.调用sqlsessionfactory对象的opensession方法返回一个sqlsession对象，sqlsessionfactory是一个接口，我们找到它的实现类 defaultsqlsessionfactory类，点击它的opensession方法，打开opensessionfromdatasource方法。 //defaultsqlsessionfactory源码: private sqlsession opensessionfromdatasource(executortype exectype, transactionisolationlevel level, boolean autocommit) { transaction tx = null; defaultsqlsession var8; try { environment environment = this.configuration.getenvironment(); transactionfactory transactionfactory = this.gettransactionfactoryfromenvironment(environment); //创建一个新事务，从环境中找到数据源。 tx = transactionfactory.newtransaction(environment.getdatasource(), level, autocommit); executor executor = this.configuration.newexecutor(tx, exectype); //创建一个defaultsqlsession对象 var8 = new defaultsqlsession(this.configuration, executor, autocommit); } catch (exception var12) { this.closetransaction(tx); throw exceptionfactory.wrapexception(\u0026#34;error opening session. cause: \u0026#34; + var12, var12); } finally { errorcontext.instance().reset(); } return var8; } 5.调用sqlsession.getmapper(userdao.class)方法返回一个userdao接口的代理类对象。 //defaultsqlsession源码: public \u0026lt;t\u0026gt; t getmapper(class\u0026lt;t\u0026gt; type) { return configuration.\u0026lt;t\u0026gt;getmapper(type, this); } //configuration类源码: public \u0026lt;t\u0026gt; t getmapper(class\u0026lt;t\u0026gt; type, sqlsession sqlsession) { return mapperregistry.getmapper(type, sqlsession); } //mapperregistry类源码: public \u0026lt;t\u0026gt; t getmapper(class\u0026lt;t\u0026gt; type, sqlsession sqlsession) { final mapperproxyfactory\u0026lt;t\u0026gt; mapperproxyfactory = (mapperproxyfactory\u0026lt;t\u0026gt;) knownmappers.get(type); if (mapperproxyfactory == null) { throw new bindingexception(\u0026#34;type \u0026#34; + type + \u0026#34; is not known to the mapperregistry.\u0026#34;); } try { return mapperproxyfactory.newinstance(sqlsession); } catch (exception e) { throw new bindingexception(\u0026#34;error getting mapper instance. cause: \u0026#34; + e, e); } } //mapperproxyfactory类源码: public t newinstance(sqlsession sqlsession) { final mapperproxy\u0026lt;t\u0026gt; mapperproxy = new mapperproxy\u0026lt;t\u0026gt;(sqlsession, mapperinterface, methodcache); return newinstance(mapperproxy); } //通过proxy的newproxyinstance方法创建代理对象 protected t newinstance(mapperproxy\u0026lt;t\u0026gt; mapperproxy) { return (t) proxy.newproxyinstance(mapperinterface.getclassloader(), new class[] { mapperinterface }, mapperproxy); } //mapperproxy类源码: //invoke回调方法 public object invoke(object proxy, method method, object[] args) throws throwable { try { if (object.class.equals(method.getdeclaringclass())) { return method.invoke(this, args); } else if (isdefaultmethod(method)) { return invokedefaultmethod(proxy, method, args); } } catch (throwable t) { throw exceptionutil.unwrapthrowable(t); } final mappermethod mappermethod = cachedmappermethod(method); //调用执行器excute方法 return mappermethod.execute(sqlsession, args); } //mappermethod类源码: public object execute(sqlsession sqlsession, object[] args) { object result; switch (command.gettype()) { case insert: { object param = method.convertargstosqlcommandparam(args); result = rowcountresult(sqlsession.insert(command.getname(), param)); break; } case update: { object param = method.convertargstosqlcommandparam(args); result = rowcountresult(sqlsession.update(command.getname(), param)); break; } case delete: { object param = method.convertargstosqlcommandparam(args); result = rowcountresult(sqlsession.delete(command.getname(), param)); break; } case select: if (method.returnsvoid() \u0026amp;\u0026amp; method.hasresulthandler()) { executewithresulthandler(sqlsession, args); result = null; } else if (method.returnsmany()) { result = executeformany(sqlsession, args); } else if (method.returnsmap()) { result = executeformap(sqlsession, args); } else if (method.returnscursor()) { result = executeforcursor(sqlsession, args); } else { object param = method.convertargstosqlcommandparam(args); result = sqlsession.selectone(command.getname(), param); } break; case flush: result = sqlsession.flushstatements(); break; default: throw new bindingexception(\u0026#34;unknown execution method for: \u0026#34; + command.getname()); } if (result == null \u0026amp;\u0026amp; method.getreturntype().isprimitive() \u0026amp;\u0026amp; !method.returnsvoid()) { throw new bindingexception(\u0026#34;mapper method \u0026#39;\u0026#34; + command.getname() + \u0026#34; attempted to return null from a method with a primitive return type (\u0026#34; + method.getreturntype() + \u0026#34;).\u0026#34;); } return result; } 执行原理图 mybatis基于代理dao实现crud操作 数据保存 定义数据添加的接口方法adduser public class userdao{ /** 新增添加用户方法 */ public void adduser(user user); } 配置文件中配置对应的sql \u0026lt;insert id=\u0026#34;adduser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; insert into user(name,gender,age,birthday) values (#{name},#{gender},#{age},#{birthday}) \u0026lt;/insert\u0026gt; #{}为mybatis的占位符，如果方法中传递的参数为实体类类型，#{实体类属性} 添加测试方法 @test public void testadduser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 userdao userdao = session.getmapper(userdao.class); //创建user对象 user user=new user(\u0026#34;何晓\u0026#34;,\u0026#34;男\u0026#34;,22,new date()); //调用adduser方法进行保存 userdao.adduser(user); //关闭连接 mybatisutils.close(session); } 数据更新 定义数据更新的接口方法updateuser /** * 更新user对象 * @param user */ public void updateuser(user user); 配置文件中配置对应的sql \u0026lt;update id=\u0026#34;updateuser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; update user set name=#{name},gender=#{gender},age=#{age},birthday=#{birthday} where id=#{id} \u0026lt;/update\u0026gt; 添加测试方法 @test public void testupdateuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 userdao userdao = session.getmapper(userdao.class); //创建user对象 user user=new user(\u0026#34;何晓飞\u0026#34;,\u0026#34;女\u0026#34;,21,new date()); //指定要更新id user.setid(1); //调用updateuser方法进行修改 userdao.updateuser(user); //关闭连接 mybatisutils.close(session); } 数据删除 定义数据删除的接口方法deleteuser /** * 根据id删除指定user * @param id */ public void deleteuser(integer id); 配置文件中配置对应的sql \u0026lt;delete id=\u0026#34;deleteuser\u0026#34; parametertype=\u0026#34;int\u0026#34;\u0026gt; delete from user where id=#{id} \u0026lt;/delete\u0026gt; 添加测试方法 @test public void testdeleteuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 userdao userdao = session.getmapper(userdao.class); //调用deleteuser方法进行删除 userdao.deleteuser(2); //关闭连接 mybatisutils.close(session); } #{}和${}的区别 1.#{}是预编译处理，${}是字符串替换。 2.mybatis在处理${}时，就是把${}替换成变量的值。 3.mybatis在处理#{}时，会将 sql 中的#{}替换为?号，调用 preparedstatement 的 set 方法来赋值。 4.使用#{}可以有效的防止 sql 注入，提高系统安全性。 mybatis实现模糊查询 模糊查询在我们开发中是一项必不可缺少的重要内容。对于我们mybatis实现模糊查询有三种方式，以下具体的实现步聚：\n添加模糊查询的接口方法likesearchusers /** * 根据name模糊查询 * @param name * @return */ public list\u0026lt;user\u0026gt; likesearcherusers(string name); 配置接口方法对应的sql文件 配置占位符方式# \u0026lt;select id=\u0026#34;likesearcherusers\u0026#34; parametertype=\u0026#34;string\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user where name like ’%‘ #{name} ’%‘ \u0026lt;/select\u0026gt; 配置拼接字符串方式$ \u0026lt;select id=\u0026#34;likesearcherusers\u0026#34; parametertype=\u0026#34;string\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user where name like \u0026#39;%${value}%\u0026#39; \u0026lt;/select\u0026gt; 我们在上面将原来的#{}占位符，改成了${value}。注意如果用模糊查询的这种写法，那么${value}的写法就是固定的，不能写成其它名字。\n配置mysql函数方式concat \u0026lt;select id=\u0026#34;likesearcherusers\u0026#34; parametertype=\u0026#34;string\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/select\u0026gt; 模糊查询测试 @test public void testsearcheruser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 userdao userdao = session.getmapper(userdao.class); //调用likesearcherusersr方法进行模糊查询 list\u0026lt;user\u0026gt; userlist = userdao.likesearcherusers(\u0026#34;张\u0026#34;); //遍历输出 userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } mybatis的参数处理 parametertype 配置参数 参数的使用说明 上一章节中已经介绍了sql语句传参，使用标签的 parametertype 属性来设定。该属性的取值可以是基本类型，引用类型（例如:string 类型），还可以是实体类类型（pojo 类）。同时也可以使用实体类的包装类，本章节将介绍如何使用实体类的包装类作为参数传递。\n参数配置的注意事项 基本类型和string可以直接写类型名称也可以使用包名.类名的方式，例如：java.lang.string。 实体类类型，目前我们只能使用全限定类名。 究其原因，是mybaits在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。在今天课程的最后一个章节中将讲解如何注册实体类的别名。 mybatis 的官方文档的说明请参考下面表格数据。 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string string byte byte long long short short int integer integer integer double double float float boolean boolean date date decimal bigdecimal bigdecimal bigdecimal object object map map hashmap hashmap list list arraylist arraylist collection collection iterator iterator 这些都是支持的默认别名。我们也可以从源码角度来看它们分别都是如何定义出来的。可以参考 typealiasregistery.class 的源码\n传递 pojo 包装对象 开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数，pojo 类中包含 pojo。 需求：根据用户名查询用户信息，查询条件放到 queryvo 的 user 属性中。\n编写queryvo package cn.offcn.entity; public class queryvo { private user user; public user getuser() { return user; } public void setuser(user user) { this.user = user; } } 编写持久层接口usermapper public interface usermapper { public list\u0026lt;user\u0026gt; getuserbylikename(queryvo queryvo); } 配置接口方法对应的sql文件 \u0026lt;select id=\u0026#34;getuserbylikename\u0026#34; parametertype=\u0026#34;cn.offcn.entity.queryvo\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user where name like #{user.name} \u0026lt;/select\u0026gt; 测试queryvo对象作为参数 @test public void testgetuserbylikename() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //创建user对象 user user=new user(); user.setname(\u0026#34;%李%\u0026#34;); queryvo queryvo=new queryvo(); queryvo.setuser(user); //调用deleteuser方法进行模糊查询 list\u0026lt;user\u0026gt; userlist = usermapper.getuserbylikename(queryvo); userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } map集合数据作为参数的处理方式 添加接口方法参数使用map集合 public list\u0026lt;user\u0026gt; getuserbygenderandage(map\u0026lt;string,object\u0026gt; map); 配置接口对应的sql配置 \u0026lt;!--#{}中参数必须和map集合中的key保存一致，表示取map集合中指定key的值。--\u0026gt; \u0026lt;select id=\u0026#34;getuserbygenderandage\u0026#34; parametertype=\u0026#34;java.util.map\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user where gender=#{sex} and age=#{age} \u0026lt;/select\u0026gt; 测试map集合作为参数 @test public void testgetuserbygenderandage() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); map\u0026lt;string,object\u0026gt; map=new hashmap\u0026lt;string,object\u0026gt;(); map.put(\u0026#34;sex\u0026#34;,\u0026#34;男\u0026#34;); map.put(\u0026#34;age\u0026#34;,22); list\u0026lt;user\u0026gt; userlist = usermapper.getuserbygenderandage(map); userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } @param方式解决多参数处理 @param注解的介绍 @param注解用于给方法内的参数取别名,当方法中拥有多个参数时，我们无法一次性将这些参数进行传递，尤其多个参数具有不同的数据类型时无法传递，所以我们利用@param给每个方法中的参数取一个别名，在映射文件中使用别名进行取值。\n添加接口方法参数使用map集合 public list\u0026lt;user\u0026gt; getuserbygenderandbirthday(@param(\u0026#34;gen\u0026#34;) string gender,param(\u0026#34;birth\u0026#34;) date birthday); 配置接口对应的sql配置 \u0026lt;select id=\u0026#34;getuserbygenderandbirthday\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user where gender=#{gen} and age=#{birth} \u0026lt;/select\u0026gt; 测试注解方法 @test public void testgetuserbygenderandbithday() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); calendar calendar = calendar.getinstance(); calendar.set(calendar.year,1997); calendar.set(calendar.day_of_month,10); calendar.set(calendar.day_of_month,12); date birthday=calendar.gettime(); list\u0026lt;user\u0026gt; userlist = usermapper.getuserbygenderandbirthday(\u0026#34;女\u0026#34;,birthday); userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } mybatis查询结果封装 resulttype结果类型 resulttype属性介绍 resulttype 属性可以指定结果集的类型，它支持基本类型和实体类类型。我们在前面的 crud 案例中已经对此属性进行过应用了。需要注意的是，它和 parametertype 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。例如：我们的实体类此时必须是全限定类名（今天最后一个章节会讲解如何配置实体类的别名）同时，当是实体类名称是，还有一个要求，实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装。\nresulttype属性的使用 基本类型 编写dao接口方法gettotalrecords参数是基本类型 /** * 统计所有记录数 * @return */ public int gettotalrecords(); 配置接口方法对应的sql语句 \u0026lt;select id=\u0026#34;gettotalrecords\u0026#34; resulttype=\u0026#34;int\u0026#34;\u0026gt; select count(*) from user \u0026lt;/select\u0026gt; 测试查询结果 @test public void testgettotalrecords() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //调用gettotalrecords统计记录数 int totalrecords= usermapper.gettotalrecords(); //打印totalrecords system.out.println(\u0026#34;总记录数:\u0026#34;+totalrecords); //关闭连接 mybatisutils.close(session); } 实体类型 编写dao接口方法getallinfo参数是对象类型 public list\u0026lt;user\u0026gt; getusers(); 配置接口方法对应的sql语句 \u0026lt;select id=\u0026#34;getusers\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; 测试查询结果 @test public void testgetuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //调用getusers查询所有记录 list\u0026lt;user\u0026gt; userlist = usermapper.getusers(); //遍历结果 userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } 特殊情况 如果个修改了实体类user中的id属性值，比如修改成了userid,此时查询出的结果没有把表中的id值映射到userid属性中，因为属性和表中的列名不一致，内部无法用反射技术进行映射，所以为空。 public class user implements serializable { private integer userid; private string username; private string gender; private integer age; private date userbirthday; public user() {} public user(string username, string gender, integer age, date userbirthday) { this.username = username; this.gender = gender; this.age = age; this.birthday = userbirthday; } public integer getuserid() { return userid; } public void setuserid(integer userid) { this.userid = userid; } //生成其它属性的getter和setter方法 } @test public void testgetuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //调用getusers查询所有记录 list\u0026lt;user\u0026gt; userlist = usermapper.getusers(); //遍历结果 userlist.foreach(system.out::print); //关闭连接 mybatisutils.close(session); } 经过上述测试结果发现userid属性为null,没有被赋上值。 解决方案：修改映射配置，采用别名设置，让结果集中的列与实体类中的属性对应。 \u0026lt;select id=\u0026#34;getusers\u0026#34; resulttype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; select id userid,name username,gender gender,age age,birthday userbirthday from user \u0026lt;/select\u0026gt; resultmap自定义结果类型 resultmap标签介绍 resultmap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。在 select 标签中使用 resultmap 属性指定引用即可。同时 resultmap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。\n定义接口方法getuserbyid /** * 根据id查询指定user对象 * @param id * @return */ public user getuserbyid(int id); 在sql的配置文件中定义resultmap \u0026lt;select id=\u0026#34;getuserbyid\u0026#34; parametertype=\u0026#34;int\u0026#34; resultmap=\u0026#34;userresultmap\u0026#34;\u0026gt; select * from user where userid=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;userresultmap\u0026#34; type=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; \u0026lt;/resultmap\u0026gt; 此处我们使用resultmap而不是resulttype, resulttype是直接写结果类型，resultmap是映射结果集与类中属性对应关系。 resultmap标签中的id表示一个唯一标记是resultmap的名称。 type: 表示该resultmap返回的类型。 使用定义的resultmap配置查询的sql语句 \u0026lt;resultmap id=\u0026#34;userresultmap\u0026#34; type=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; property=\u0026#34;userid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;gender\u0026#34; property=\u0026#34;gender\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;age\u0026#34; property=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;birthday\u0026#34; property=\u0026#34;userbirthday\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultmap\u0026gt; id 标签：用于指定主键字段 result 标签：用于指定非主键字段 column 属性：用于指定数据库列名 property 属性：用于指定实体类属性名称 测试查询结果 @test public void testgetuserbyid() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //查询user user user = usermapper.getuserbyid(1); //打印user system.out.println(user); //关闭连接 mybatisutils.close(session); } sqlmapconfig.xml配置文件内容解析 在主配置sqlmapconfig.xml中，定义了很多标签，我们现在只是使用了一部分标签 ，主配置文件中可以出现的标签 用dtd文 件进行约束。下面介绍其它标签的使用含义。\n标签的配置规范，查看dtd规范文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;!-- copyright 2009-2016 the original author or authors. licensed under the apache license, version 2.0 (the \u0026#34;license\u0026#34;); you may not use this file except in compliance with the license. you may obtain a copy of the license at http://www.apache.org/licenses/license-2.0 unless required by applicable law or agreed to in writing, software distributed under the license is distributed on an \u0026#34;as is\u0026#34; basis, without warranties or conditions of any kind, either express or implied. see the license for the specific language governing permissions and limitations under the license. --\u0026gt; \u0026lt;!element configuration (properties?, settings?, typealiases?, typehandlers?, objectfactory?, objectwrapperfactory?, reflectorfactory?, plugins?, environments?, databaseidprovider?, mappers?)\u0026gt; \u0026lt;!element databaseidprovider (property*)\u0026gt; \u0026lt;!attlist databaseidprovider type cdata #required \u0026gt; \u0026lt;!element properties (property*)\u0026gt; \u0026lt;!attlist properties resource cdata #implied url cdata #implied \u0026gt; \u0026lt;!element property empty\u0026gt; \u0026lt;!attlist property name cdata #required value cdata #required \u0026gt; \u0026lt;!element settings (setting+)\u0026gt; \u0026lt;!element setting empty\u0026gt; \u0026lt;!attlist setting name cdata #required value cdata #required \u0026gt; \u0026lt;!element typealiases (typealias*,package*)\u0026gt; \u0026lt;!element typealias empty\u0026gt; \u0026lt;!attlist typealias type cdata #required alias cdata #implied \u0026gt; \u0026lt;!element typehandlers (typehandler*,package*)\u0026gt; \u0026lt;!element typehandler empty\u0026gt; \u0026lt;!attlist typehandler javatype cdata #implied jdbctype cdata #implied handler cdata #required \u0026gt; \u0026lt;!element objectfactory (property*)\u0026gt; \u0026lt;!attlist objectfactory type cdata #required \u0026gt; \u0026lt;!element objectwrapperfactory empty\u0026gt; \u0026lt;!attlist objectwrapperfactory type cdata #required \u0026gt; \u0026lt;!element reflectorfactory empty\u0026gt; \u0026lt;!attlist reflectorfactory type cdata #required \u0026gt; \u0026lt;!element plugins (plugin+)\u0026gt; \u0026lt;!element plugin (property*)\u0026gt; \u0026lt;!attlist plugin interceptor cdata #required \u0026gt; \u0026lt;!element environments (environment+)\u0026gt; \u0026lt;!attlist environments default cdata #required \u0026gt; \u0026lt;!element environment (transactionmanager,datasource)\u0026gt; \u0026lt;!attlist environment id cdata #required \u0026gt; \u0026lt;!element transactionmanager (property*)\u0026gt; \u0026lt;!attlist transactionmanager type cdata #required \u0026gt; \u0026lt;!element datasource (property*)\u0026gt; \u0026lt;!attlist datasource type cdata #required \u0026gt; \u0026lt;!element mappers (mapper*,package*)\u0026gt; \u0026lt;!element mapper empty\u0026gt; \u0026lt;!attlist mapper resource cdata #implied url cdata #implied class cdata #implied \u0026gt; \u0026lt;!element package empty\u0026gt; \u0026lt;!attlist package name cdata #required \u0026gt; properties标签详解 在使用 properties 标签配置时,在xml中可以引用properties属性文件中key的值，日后修改properties属性文 件中key的值时，不用修改xml文件，从而提高了效率。\n新建一个dbconfig.properties属性文件 jdbc.driver=com.mysql.jdbc.driver jdbc.url=jdbc:mysql:///mybatis001 jdbc.username=root jdbc.password=root 在sqlmapperconfig.xml中可以引用属性文件中key的值 \u0026lt;properties resource=\u0026#34;dbconfig.properties\u0026#34;\u0026gt;\u0026lt;/properties\u0026gt; \u0026lt;datasource type=\u0026#34;pooled\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/datasource\u0026gt; typealiases标签详解 在前面我们讲的 mybatis 支持的默认别名，我们也可以采用自定义别名方式来开发。\n在sqlmapperconfig.xml中定义别名 \u0026lt;typealiases\u0026gt; \u0026lt;!-- 单个别名定义 --\u0026gt; \u0026lt;typealias alias=\u0026#34;user\u0026#34; type=\u0026#34;cn.offcn.entity.user\u0026#34;/\u0026gt; \u0026lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --\u0026gt; \u0026lt;package name=\u0026#34;cn.offcn.entity\u0026#34;/\u0026gt; \u0026lt;package name=\u0026#34; 其它包 \u0026#34;/\u0026gt; \u0026lt;/typealiases\u0026gt; 在usermapper.xml中使用别名 \u0026lt;select id=\u0026#34;getusers\u0026#34; resulttype=\u0026#34;user\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;getuserbyid\u0026#34; parametertype=\u0026#34;int\u0026#34; resultmap=\u0026#34;userresultmap\u0026#34;\u0026gt; select * from user where userid=#{id} \u0026lt;/select\u0026gt; \u0026lt;resultmap id=\u0026#34;userresultmap\u0026#34; type=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; property=\u0026#34;userid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;gender\u0026#34; property=\u0026#34;gender\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;age\u0026#34; property=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result column=\u0026#34;birthday\u0026#34; property=\u0026#34;userbirthday\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultmap\u0026gt; mappers映射器标签详解 mappers映射器用于指定映射文件的位置。\n\u0026lt;!--使用相对于类路径的资源--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;cn/offcn/dao/userdao.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;!--使用mapper接口类路径--\u0026gt; 如：\u0026lt;mapper class=\u0026#34;cn.offcn.dao.userdao\u0026#34;/\u0026gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 mybatis自动返回主键值 返回主键值技术的业务应用场景 对于自增主键在某些业务中保存一个对象后，需要使用到这个主键完成后续的业务逻辑，比如：要保存订单后，还要保存订单项信息，订单项相信需要用到订单主键。所以应用场合很多，下面我们来应用一下返回主键值操作。\n接口中编写adduser方法 /** * 保存user对象 * @param user */ public void saveuser(user user); 在sql的配置文件中添加接口方法对应的sql配置 \u0026lt;select id=\u0026#34;saveuser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; insert into user (name,gender,age,birthday) values(#{name},#{gender},#{age},#{birthday}) \u0026lt;/select\u0026gt; 在sql标签上添加返回自增长的主键值的配置 第一种方式: \u0026lt;insert id=\u0026#34;saveuser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34; usegeneratedkeys=\u0026#34;true\u0026#34; keyproperty=\u0026#34;id\u0026#34;\u0026gt; insert into user (name,gender,age,birthday) values(#{name},#{gender},#{age},#{birthday}) \u0026lt;/insert\u0026gt; usegeneratedkeys: 表示开启获取自增主键值。 keyproperty： 表示从表中取到主键值后赋给user类中的哪个属性。 第二种方式:使用selectkey标签和mysql内置函数 \u0026lt;insert id=\u0026#34;saveuser\u0026#34; parametertype=\u0026#34;cn.offcn.entity.user\u0026#34;\u0026gt; \u0026lt;selectkey keycolumn=\u0026#34;id\u0026#34; keyproperty=\u0026#34;id\u0026#34; resulttype=\u0026#34;int\u0026#34; order=\u0026#34;after\u0026#34;\u0026gt; select last_insert_id() \u0026lt;/selectkey\u0026gt; insert into user (name,gender,age,birthday) values(#{name},#{gender},#{age},#{birthday}) \u0026lt;/insert\u0026gt; keycolumn:指定取数据库中哪一列的值（通常指主键列）。 keyproperty： 表示取出主键值后赋值user对象的哪个属性。 resulttype： 表示对象的属性类型 order：表示完后sql语句之前还是之后把主键值赋给实体类对应属性。 测试 @test public void testsaveuser() throws exception{ //获取sqlsession对象 sqlsession session = mybatisutils.getsession(); //调用sqlsession 创建 userdao接口的代理对象 usermapper usermapper = session.getmapper(usermapper.class); //创建user对象 user user=new user(\u0026#34;刘备\u0026#34;,\u0026#34;男\u0026#34;,30,new date()); //保存user对象 usermapper.saveuser(user); //打印user的id属性值 system.out.println(user.getid()); //提交事务 session.commit(); //关闭连接 mybatisutils.close(session); } ","date":"2022-03-20","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220430230666/","summary":"Mybatis环境搭建 前期准备 创建数据库 create table user( id int not null auto_increment, name varchar(30), gender varchar(6), age int, birthday date, primary key(id) ); 创建maven Java项目 打开Idear\u0026ndash;\u0026gt;选择File\u0026nda","title":"mybatis-1"},{"content":"(一)核心框架基础 内容介绍: 1. mybatis持久层技术 2. spring逻辑控制技术 3. springmvc web交互技术 4. ssm整合进行单体项目开发 (二)核心框架高级 内容介绍: 1. zookeeper 注册中心 2. dubbo 分布式技术 3. springboot spring框架整合 4. elasticsearch 全文检索 5. mybatis-plus mybatis封装工具 6. redis\u0026amp;nginx 非关系型数据库与负载均衡工具 核心内容: 重点说明解讲ssm整合后，对于分布式项目所要学习的框架技术。简单介绍每个框架的作用和应用场景。为后续学习提供指引。增强学员的学习兴趣和动力。 (三)分布式项目 基于springboot+mybatis+zookeeper+dubbo 的综合健康项目。\n什么是框架及优势 框架（framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。\n简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。\n我们是由于效率和易用性的考虑使用框架。框架能节省开发时间。框架强制使用公共的约定，因此它能有效地解决一些共有的问题，它能让决定更连贯，避免我们写一大堆自定义模块来实现这些性能，框架节省了我们不少的时间和精力，并且让扩展变得更容易。\n框架解决的问题 技术整合问题 框架要解决的最重要的一个问题是技术整合的问题，在 j2ee 的 框架中，有着各种各样的技术，不同的软件企业需要从 j2ee 中选择不同的技术，这就使得软件企业最终的应用依赖于这些技术，技术自身的复杂性和技术的风险性将会直接对应用造成冲击。而应用是软件企业的核心，是竞争力的关键所在，因此应该将应用自身的设计和具体的实现技术解耦。这样，软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响。框架一般处在低层应用平台（如 j2ee ）和高层业务逻辑之间的中间层。\n三层架构 框架的重要性在于它实现了部分功能，并且能够很好的将低层应用平台和高层业务逻辑进行了缓和。为了实现软件工程中的“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源。我们常见的mvc 软件设计思想就是很好的分层思想。\n框架的重要性在于它实现了部分功能，并且能够很好的将低层应用平台和高层业务逻辑进行了缓和。为了实现软件工程中的“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源。我们常见的mvc 软件设计思想就是很好的分层思想。\n三层架构就是为了符合“高内聚，低耦合”思想，把各个功能模块划分为表示层（ui）、业务逻辑层（bll）和数据访问层（dal）三层架构，各层之间采用接口相互访问，并通过对象模型的实体类（model）作为数据传递的载体，不同的对象模型的实体类一般对应于数据库的不同表，实体类的属性与数据库表的字段名一致。“高内聚，低耦合”,可以使开发人员分工更明确，将精力更专注于应用系统核心业务逻辑的分析、设计和开发，加快项目的进度，提高了开发效率，有利于项目的更新和维护工作。\n分层后的优势： 1.避免了表示层直接访问数据访问层，表示层只和业务逻辑层有联系，提高了数据安全性。 2.有利于系统的分散开发，每一个层可以由不同的人员来开发，只要遵循接口标准，利用相同的对象模型实体类就可以了，这样就可以 大大提高系统的开发速度。 3.方便系统的移植，如果要把一个 c/s 的系统变成 b/s 系统，只要修改三层架构的表示层就可以了，业务逻辑层和数据访问层几乎不用修改就可以轻松的把系统移植到网络上。 4.项目结构更清楚，分工更明确，有利于后期的维护和升级。 持久层技术解决方案 jdbc技术是jdk的原生api，提供对数据进行持久化底层技术，是java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。\n下面列出jdbc技术中常用对象及含义：\ndrivermanager：负责加载各种不同驱动程序（driver），并根据不同的请求，向调用者返回相应的数据库连接。 driver：驱动程序，会将自身加载到drivermanager中去，并处理相应的请求并返回相应的数据库连接。 connection：数据库连接，负责与进行数据库间通讯，sql执行以及事务处理都是在某个特定connection环境中进行的。可以产生用以执行sql的statement。 statement：用以执行sql查询和更新（针对静态sql语句和单次执行）。 preparedstatement：用以执行包含动态参数的sql查询和更新（在服务器端编译，允许重复执行以提高效率）。 commons dbutils是apache组织提供的一个对jdbc进行简单封装的开源工具类库，使用它能够简化jdbc应用程序的开 发，同时也不会影响程序的性能，同时内置事务自动提交。\n主要方法：\ndbutils类：启动类。 resultsethandler接口：转换类型接口。 maplisthandler类：实现类，把记录转化成list。 beanlisthandler类：实现类，把记录转化成list，使记录为javabean类型的对象。 query runner类：执行sql语句的类。 queryrunner进行查询的操作时handlers类型列表： arrayhandler ：将resultset中第一行的数据转化成对象数组。 arraylisthandler将resultset中所有的数据转化成list，list中存放的是object[]。 beanhandler ：将resultset中第一行的数据转化成类对象。 beanlisthandler ：将resultset中所有的数据转化成list，list中存放的是类对象。 columnlisthandler ：将resultset中某一列的数据存成list，list中存放的是object对象。 keyedhandler ：将resultset中存成映射，key为某一列对应为map。map中存放的是数据。 maphandler ：将resultset中第一行的数据存成map映射。 maplisthandler ：将resultset中所有的数据存成list。list中存放的是map。 scalarhandler ：将resultset中一条记录的其中的某一列的数据存成object。 jdbc做为持久层技术存在的问题\n数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。 sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。 使用preparedstatement向占位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 对结果集解析存在硬编码(查询列名)，sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对（javabean）解析比较方便。 代码冗余太大，sql与java程序耦合太紧密，不利于sql维护。 常见框架 持久化框架\n持久化框架mybatis mybatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache software foundation 迁移到了googlecode，并且改名为mybatis 。2013年11月迁移到github。 ibatis一词来源于“internet”和“abatis”的组合，是一个基于java的持久层框架。ibatis提供的持久层框架包括sql maps和 data access objects（daos）。 持久化框架hibernate hibernate是一个开放源代码的对象关系映射框架，它对jdbc进行了非常轻量级的对象封装，它将pojo与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成sql语句，自动执行，使得java程序员可以随心所欲的使用对象编程思维来操纵数库。hibernate可以应用在任何使用jdbc的场合，既可以在java的客户端程序使用，也可以在servlet/jsp的web应用中使用，最具革命意义的是，hibernate可以在应用ejb的javaee架构中取代cmp，完成数据持久化的重任。但是，这个框架因为各种原因目前在国内的流行 程度下降太多，现在公司开发也越来越少使用。目前使用 spring data 来实现数据持久化也是一种趋势。 web层mvc框架 spring mvc属于springframework的后续产品，已经融合在spring web flow里面。spring 框架提供了构建 web 应用程序的全功能mvc模块。使用 spring 可插入的 mvc 架构，从而在使用spring进行web开发时，可以选择使用spring的springmvc框架或集成其他mvc开发框架，如struts1(现在一般不用)，struts 2(一般老项目使用)等等。 技术整合框架 spring是java ee编程领域的一个轻量级开源框架，该框架由一个叫rod johnson的程序员在 2002 年最早提出并随后创建，是为了解决企业级编程开发中的复杂性，实现敏捷开发的应用型框架 。spring是一个开源容器框架，它集成各类型的工具，通过核心的bean factory实现了底层的类的实例化和生命周期的管理。在整个框架中，各类型的功能被抽象成一个个的 bean，这样就可以实现各种功能的管理，包括动态加载和切面编程。 mybatis概述 mybatis是一个优秀的基于 java 的持久层框架，它内部封装了jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。\nmybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql 的动态参数进行映射生成最终执行的sql语句，最后由 mybatis 框架执行sql并将结果映射为 java 对象并返回。\n采用orm思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。\nmybatis的特点:\n(1) 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用通过文档和源代码，可以比较完全的掌握它的设计思路和实现。\n(2) 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。\n(3) 解除sql与程序代码的耦合：通过提供dao层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。\n(4)提供映射标签，支持对象与数据库的orm字段关系映射\n(5) 提供对象关系映射标签，支持对象关系组建维护\n(6) 提供xml标签，支持编写动态sql。\n(7) 支持数据缓存和注解开发。\nmybatis的官方网址： https://www.mybatis.org/\n","date":"2022-03-20","permalink":"https://lovemjh.vercel.app/posts/java-frame/20220430230955/","summary":"(一)核心框架基础 内容介绍: 1. Mybatis持久层技术 2. Spring逻辑控制技术 3. SpringMVC Web交互技术 4. SSM整合进行单体项目开发 (二)核心框架高级 内容介绍: 1. zookeeper 注","title":"框架概述"},{"content":"一、maven 1. 理解 本意：专家 内行。是一款自动化构建工具，专注服务于java平台的项目构建和依赖管理 构建： 指我们将一些源码、配置文件、图片视频音频等 作为\u0026#34;源材料\u0026#34;，\u0026#34;生成\u0026#34;出一个可以运行 可以访问的项目的过程。 构建的环节： 1. 清理：删除以前的编译，为重新编译做准备 2. 编译：将java源码编译成字节码 3. 测试：针对性的测试，保证正确性 4. 报告：以标准的格式来记录测试结果 5. 打包：将项目压缩成可以部署的文件，如：java项目 jar web项目 war 6. 安装：将打好的包安装到maven仓库中 以便于其他应用依赖使用 7. 部署：将打包后的文件 部署到远程仓库或者服务器中运行 2. maven的作用 - 引入第三方jar：利用maven引入jar的坐标，根据坐标自动引入jar和依赖jar - 处理jar之间的依赖关系 - 处理jar之间的冲突 - 项目的分模块开发 - 实现分布式部署 3. maven的使用 1. 下载 安装 https://maven.apache.org/download.cgi 2. 解压：目录不要过深、不要中文路径 3. 检查 java_home 环境变量 4. 配置环境变量 ① maven_home 路径为maven安装路径 ② 在path变量中引入 %maven_home%\\bin 5. 检查 在doc中 mvn -v 配置maven本地仓库： 1. 在本地创建文件夹作为本地仓库（目录不要过深、不要中文路径） 2. 在maven配置文件中指定本地仓库地址 \u0026lt;localrepository\u0026gt;d:\\javatools3\\repmaven\u0026lt;/localrepository\u0026gt; 3. 在maven配置文件中指远程仓库地址 \u0026lt;server\u0026gt; \u0026lt;id\u0026gt;huaweicloud\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;anonymous\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;devcloud\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;huaweicloud\u0026lt;/id\u0026gt; \u0026lt;mirrorof\u0026gt;*\u0026lt;/mirrorof\u0026gt; \u0026lt;url\u0026gt;https://mirrors.huaweicloud.com/repository/maven/\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; 4. 配置jdk版本 \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-1.8\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activebydefault\u0026gt;true\u0026lt;/activebydefault\u0026gt; \u0026lt;jdk\u0026gt;1.8\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerversion\u0026gt;1.8\u0026lt;/maven.compiler.compilerversion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; 4. idea整合maven 5. 创建maven项目 #####5.1 创建java项目 5.2 创建web应用 在java项目的基础上 安装jbljavatoweb 插件 转换一下即可 ####6. maven的核心概念\n6.1 pom project object model:项目对象模型 ，将整个项目封装成对象便于操作和管理。maven项目的核心配置文件 6.2 目录结构 约定 \u0026gt; 配置 \u0026gt; 编码。能使用配置文件解决问题 不编码，能约定的不使用配置文件 项目名 src main java resources test java pom.xml 6.3 坐标 定位资源的位置 groupid 公司域名倒写+项目名 artifactid 当前的模块名 version 版本号 如： \u0026lt;groupid\u0026gt;com.ujiuye.maven\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mv_pro1\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; 6.4 仓库 ① 本地仓库：为当前本机上的maven工程服务 ② 远程仓库：本地没有 直接去远程仓库下载 1. 私服 当前的局域网下的一个范围的仓库 2. 中央仓库：架设在internet中的 为全世界的maven工程服务的 3. 中央仓库镜像：架设在各大洲，减轻中央仓库的压力，更快响应用户的请求 7. maven构建(生命周期) lif：生命周期 clean：清理 validate：校验 compile：编译 test：测试 package：打包 verify install：安装 site deploy：部署 plugins：插件 8. 依赖管理 #####8.1 依赖的传递性\n1. 间接传递 项目a 依赖 项目b 项目b依赖junit4.12，项目a也可以直接使用junit4.12 2. 直接传递 项目b直接在pom中引入junit4.12的依赖 8.2 依赖的传递范围 ① compile 编译 1. main目录下的java代码可以访问该范围的依赖 2. test目录下的java代码可以访问该范围的依赖 3. 部署到服务器中，运行时放入到web-inf/lib目录下 ② test 1. main目录下的java代码不可以访问该范围的依赖 2. test目录下的java代码可以访问该范围的依赖 3. 部署到服务器中，运行时不会放入到web-inf/lib目录下 如：junit ③ provided 1. main目录下的java代码可以访问该范围的依赖 2. test目录下的java代码可以访问该范围的依赖 3. 部署到服务器中，运行时不会放入到web-inf/lib目录下 其他：runtime import system等 8.3 依赖排除 依赖的原则： 路径最短者优先原则 先声明者优先原则 依赖排除： \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;com.ujiuye.maven\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;mv_pro1\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;!--依赖排除--\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 8.4 版本统一管理 1. 声明变量指定版本具体值 \u0026lt;properties\u0026gt; \u0026lt;spring.version\u0026gt;4.1.1.release\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; 2. 使用直接使用变量名 \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-core\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-context\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-jdbc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-orm\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-web\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;org.springframework\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;spring-webmvc\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 9. 多模块开发 9.1 继承关系 父工程中管理依赖 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;groupid\u0026gt;com.ujiuye.maven\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;parent\u0026lt;/artifactid\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;son1\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;son2\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;dependencymanagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencymanagement\u0026gt; \u0026lt;/project\u0026gt; 子工程中 继承父工程管理的依赖 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/pom/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/xmlschema-instance\u0026#34; xsi:schemalocation=\u0026#34;http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactid\u0026gt;parent\u0026lt;/artifactid\u0026gt; \u0026lt;groupid\u0026gt;com.ujiuye.maven\u0026lt;/groupid\u0026gt; \u0026lt;version\u0026gt;1.0-snapshot\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;modelversion\u0026gt;4.0.0\u0026lt;/modelversion\u0026gt; \u0026lt;artifactid\u0026gt;son1\u0026lt;/artifactid\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupid\u0026gt;junit\u0026lt;/groupid\u0026gt; \u0026lt;artifactid\u0026gt;junit\u0026lt;/artifactid\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 9.2 聚合 通过父工程将多个子工程模块 聚合在一起 统一使用统一管理 \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;son1\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;son2\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 二、酷站 如果不知道坐标 可以在该网站搜索 https://mvnrepository.com/ https://search.maven.org/ 如果有jar文件 但是没有坐标 此时可以将jar文件安装到本地仓库 mvn install:install-file -dfile=\u0026#34;jar地址\u0026#34; -dgroupid=组id -dartifactid=项目名 -dversion=版本号 -dpackaging打包方式 ","date":"2021-12-20","permalink":"https://lovemjh.vercel.app/posts/tool/20220430230448/","summary":"一、Maven 1. 理解 本意：专家 内行。是一款自动化构建工具，专注服务于Java平台的项目构建和依赖管理 构建： 指我们将一些源码、配置文件、图片视频音频等 作为\u0026#34","title":"maven"},{"content":"一、git简介 1. 理解 开源的分布式版本控制系统，可以有效 高速的处理应用由小到大项目版本管理。 2. 版本控制系统 版本控制系统 跟踪整个项目的开发过程 从开始到结束，核心任务就是查阅应用操作的历史记录 以及 多用户协同开发大型的应用 3. 版本控制系统分类 ① 集中式版本控制系统 svn 版本仓库存放在中央服务器，team每个人从中央服务器下载代码，每个人操作之后 再提交到中央仓库 ② 分布式版本控制系统 git 没有中央仓库，team每个人电脑都是一个完整的仓库，借助于第三托管平台，实现多人合并项目，推送到对应的托管平台即可 4. git的特点 ① 速度快、操作简单 ② 对非线性开发模式的强力支持(允许成千上万的分支协同开发) ③ 完全的分布式 ④ 高效管理大规模的应用 clone克隆，从远程仓库克隆一份到本地仓库。第一次操作 pull拉取， 从远程仓库拉取项目到本地 ，自动合并 最后放入到工作区 push推送，代码完成后，需要团队共享代码，将本地仓库代码推送到远程仓库 checkout:将本地仓库的代码检出到工作区 add: 在提交本地仓库之前 要先将代码添加到暂存区 便于记录 commit: 将提交到本地仓库 便于推送远程仓库 本地仓库: 在本地主机上的一个代码库，可以独立存在，也可以与远程仓库进行关联 工作区:对任何文件的修订(增删改)，都先放在工作区，工作区不与任何仓库分支进行关联 暂存区:把修订的文件，从工作区经过add(添加)后与某一个仓库分支进行关联，只要进 入缓存区的文件才能commit(提交)到本地仓库。 远程仓库 : 在局域网或互联网上的一个主机，存放代码库的主机或平台，比如github、 gitee.com(码云) 二、下载安装 1. 地址：https://git-scm.com/ 2. 傻瓜式安装 三、使用 1. 配置 使用之前做全局配置 设置账户和邮箱 git config --global user.name \u0026#39;用户名\u0026#39; git config --global user.email \u0026#39;邮箱\u0026#39; 2. 操作 2.1 本地仓库操作 - 初始化仓库 在目录下 执行命令 git init - 在该仓库中操作之后，提交到暂存区 git add 文件名/. - 提交到本地仓库 git commit -m \u0026#39;提交信息\u0026#39; - 查看有哪些提交 信息 git log # 当前提交的之前版本 - 版本回退 git reset --hard \u0026#39;版本id\u0026#39; - 回到未来的提交 git reflog # 查看所有版本 git reset --hard \u0026#39;未来提交版本id\u0026#39; - 删除文件(只能删除已提交到仓库的文件 未提交的不能删除) git rm 文件名 2.2 分支操作 - 查看当前仓库的分支 git branch git branch -v # 分支的更多信息 git branch -av # 本地和远程的分支 - 创建分支 git branch 分支名 git branch -d 分支名 # 创建并切换 - 切换分支 git checkout 分支名 - 合并分支(将其他分支合并到master) 先切换到master git checkout master 再执行合并 git merge 子分支名 注意： 如果多分支操作同一个文件，分支合并的过程中会产生合并冲突问题 解决： 先打开文件修改里面不应该出现的内容 再添加到暂存区 然后提交即可 2.3 远程仓库操作 为了实现协同开发 需要将本地仓库共享给团队其他人 ，需要借助远程仓库(第三方托管平台) -- github (https://www.github.com) -- 码云 (https://www.gitee.com) https方式： - 创建远程仓库 码云上创建 - 克隆远程仓库 https：git clone https地址 - 推送到远程仓库 1. 操作完成之后需要将操作的内容提交到本地仓库 2. 才可以推送到远程仓库 git push ssh方式： - 配置ssh 1. 生成密钥和公钥：ssh-keygen -t rsa 2. 将生成的密钥配置到码云 - 克隆远程仓库的项目 git clone ssh地址 - 上传到远程仓库 1. 先添加本地仓库 2. 执行 git push 其他命令： 1. 查看当前本地仓库 关联的远程仓库 git remote -v 注意：origin 是指远程仓库的默认服务名 2. 推送远程仓库 git push origin master 3. 解除远程仓库关联 git remote rm origin 4. 添加远程仓库 git remote add origin ssh地址 5. 拉取远程仓库中新内容 并合并到本地仓库 git pull origin master 四、idea中git操作 1. idea整合git 2. 项目leader - 创建项目 指定为本地仓库 - 推送到远程仓库 3. 开发者 - 克隆远程的仓库项目 - 操作之后提交到本地仓库 4. idea中git的分支 - 查看分支 - 新建分支 - 切换分支 - 合并分支 如果两分支操作同一个文体 产生合并冲突 解决 5. idea中git的历史提交 - 查看历史提交 - 回退到历史提交 ","date":"2021-12-17","permalink":"https://lovemjh.vercel.app/posts/tool/20220430230003/","summary":"一、Git简介 1. 理解 开源的分布式版本控制系统，可以有效 高速的处理应用由小到大项目版本管理。 2. 版本控制系统 版本控制系统 跟踪整个项目的开发过程 从开始到结束，核心任务","title":"版本控制之git"},{"content":"一、elementui 1. 理解 element，一套为开发者、设计师和产品经理准备的基于 vue 2.0 的桌面端组件库。 是一个ui框架，封装了html css vue 饿了么前端团队，基于vue封装并开源的框架，提供了各种样式的组件库 2. 作用 快速开发页面 3. 使用 · 下载引入依赖库 \u0026lt;!-- 1. 先引入vue.js --\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 2. 引入elementui组件库 --\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 3. 引入elementui 样式库 --\u0026gt; \u0026lt;link type=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34;\u0026gt; · 布局页面 布局到vue渲染的页面中 注意： 1. 引入库顺序 不要改变 2. elementui组件库 放入到 vue的渲染的视图中 3. 参考官方文档 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;!-- 1. 先引入vue.js --\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 2. 引入elementui组件库 --\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 3. 引入elementui 样式库 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;template\u0026gt; \u0026lt;el-table :data=\u0026#34;tabledata\u0026#34; stripe style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { tabledata: [ { date: \u0026#34;2016-05-02\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-04\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1517 弄\u0026#34;, }, { date: \u0026#34;2016-05-01\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1519 弄\u0026#34;, }, { date: \u0026#34;2016-05-03\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1516 弄\u0026#34;, }, ], }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4. 常见组件 (1) 导航菜单 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-menu :default-active=\u0026#34;activeindex2\u0026#34; class=\u0026#34;el-menu-demo\u0026#34; mode=\u0026#34;horizontal\u0026#34; @select=\u0026#34;handleselect\u0026#34; background-color=\u0026#34;#c3c3c3\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34; \u0026gt; \u0026lt;el-menu-item index=\u0026#34;1\u0026#34;\u0026gt;处理中心\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-submenu index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;我的工作台\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-submenu index=\u0026#34;2-4\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;选项4\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-4-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-4-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2-4-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-menu-item index=\u0026#34;3\u0026#34; disabled\u0026gt;消息中心\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;4\u0026#34; \u0026gt;\u0026lt;a href=\u0026#34;https://www.ele.me\u0026#34; target=\u0026#34;_blank\u0026#34; \u0026gt;订单管理\u0026lt;/a \u0026gt;\u0026lt;/el-menu-item \u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;el-col :span=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;h5\u0026gt;自定义颜色\u0026lt;/h5\u0026gt; \u0026lt;el-menu default-active=\u0026#34;2\u0026#34; class=\u0026#34;el-menu-vertical-demo\u0026#34; @open=\u0026#34;handleopen\u0026#34; @close=\u0026#34;handleclose\u0026#34; background-color=\u0026#34;#545c64\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34; \u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-location\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;导航一\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;分组一\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-menu-item-group title=\u0026#34;分组2\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-submenu index=\u0026#34;1-4\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;选项4\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-4-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-menu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;导航二\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;3\u0026#34; disabled\u0026gt; \u0026lt;i class=\u0026#34;el-icon-document\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;导航三\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-setting\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;导航四\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { activeindex: \u0026#34;1\u0026#34;, activeindex2: \u0026#34;1\u0026#34;, }, methods: { handleselect(key, keypath) { console.log(key, keypath); }, handleopen(key, keypath) { console.log(key, keypath); }, handleclose(key, keypath) { console.log(key, keypath); }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (2) 按钮 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; \u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button\u0026gt;默认按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;主要按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34;\u0026gt;成功按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34;\u0026gt;信息按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34;\u0026gt;警告按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34;\u0026gt;危险按钮\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button plain\u0026gt;朴素按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; plain\u0026gt;主要按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34; plain\u0026gt;成功按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; plain\u0026gt;信息按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34; plain\u0026gt;警告按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; plain\u0026gt;危险按钮\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button round\u0026gt;圆角按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; round disabled\u0026gt;主要按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34; round\u0026gt;成功按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; round\u0026gt;信息按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34; round\u0026gt;警告按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; round\u0026gt;危险按钮\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button icon=\u0026#34;el-icon-search\u0026#34; circle\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; icon=\u0026#34;el-icon-edit\u0026#34; circle\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34; icon=\u0026#34;el-icon-check\u0026#34; circle\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; icon=\u0026#34;el-icon-message\u0026#34; circle\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34; icon=\u0026#34;el-icon-star-off\u0026#34; circle\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; icon=\u0026#34;el-icon-delete\u0026#34; circle\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; icon=\u0026#34;el-icon-camera-solid\u0026#34; circle\u0026gt;\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; :loading=\u0026#34;true\u0026#34;\u0026gt;加载中\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { }, methods: { } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (3) 消息提示 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;template\u0026gt; \u0026lt;el-button :plain=\u0026#34;true\u0026#34; @click=\u0026#34;open\u0026#34;\u0026gt;打开消息提示\u0026lt;/el-button\u0026gt; \u0026lt;el-button :plain=\u0026#34;true\u0026#34; @click=\u0026#34;openvn\u0026#34;\u0026gt;vnode\u0026lt;/el-button\u0026gt; \u0026lt;template\u0026gt; \u0026lt;el-button :plain=\u0026#34;true\u0026#34; @click=\u0026#34;open2\u0026#34;\u0026gt;成功\u0026lt;/el-button\u0026gt; \u0026lt;el-button :plain=\u0026#34;true\u0026#34; @click=\u0026#34;open3\u0026#34;\u0026gt;警告\u0026lt;/el-button\u0026gt; \u0026lt;el-button :plain=\u0026#34;true\u0026#34; @click=\u0026#34;open1\u0026#34;\u0026gt;消息\u0026lt;/el-button\u0026gt; \u0026lt;el-button :plain=\u0026#34;true\u0026#34; @click=\u0026#34;open4\u0026#34;\u0026gt;错误\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: {}, methods: { open() { this.$message(\u0026#34;这是一条消息提示\u0026#34;); }, openvn() { const h = this.$createelement; this.$message({ message: h(\u0026#34;p\u0026#34;, null, [ h(\u0026#34;span\u0026#34;, null, \u0026#34;内容可以是 \u0026#34;), h(\u0026#34;i\u0026#34;, { style: \u0026#34;color: teal\u0026#34; }, \u0026#34;vnode\u0026#34;), ]), }); }, open1() { this.$message(\u0026#34;这是一条消息提示\u0026#34;); }, open2() { this.$message({ showclose: true, center: true, message: \u0026#34;恭喜你，这是一条成功消息\u0026#34;, type: \u0026#34;success\u0026#34;, }); }, open3() { this.$message({ message: \u0026#34;警告哦，这是一条警告消息\u0026#34;, type: \u0026#34;warning\u0026#34;, }); }, open4() { this.$message.error(\u0026#34;错了哦，这是一条错误消息\u0026#34;); }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (4) 对话框 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;dialogvisible = true\u0026#34; \u0026gt;点击打开 dialog\u0026lt;/el-button \u0026gt; \u0026lt;el-dialog title=\u0026#34;提示\u0026#34; :visible.sync=\u0026#34;dialogvisible\u0026#34; width=\u0026#34;30%\u0026#34; :before-close=\u0026#34;handleclose\u0026#34; \u0026gt; \u0026lt;span\u0026gt;这是一段信息\u0026lt;/span\u0026gt; \u0026lt;span slot=\u0026#34;footer\u0026#34; class=\u0026#34;dialog-footer\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;dialogvisible = false\u0026#34;\u0026gt;取 消\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;dialogvisible = false\u0026#34; \u0026gt;确 定\u0026lt;/el-button \u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;!-- table --\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;dialogtablevisible = true\u0026#34; \u0026gt;打开嵌套表格的 dialog\u0026lt;/el-button \u0026gt; \u0026lt;el-dialog title=\u0026#34;收货地址\u0026#34; :visible.sync=\u0026#34;dialogtablevisible\u0026#34;\u0026gt; \u0026lt;el-table :data=\u0026#34;griddata\u0026#34;\u0026gt; \u0026lt;el-table-column property=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;150\u0026#34; \u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column property=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;200\u0026#34; \u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column property=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;!-- form --\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;dialogformvisible = true\u0026#34; \u0026gt;打开嵌套表单的 dialog\u0026lt;/el-button \u0026gt; \u0026lt;el-dialog title=\u0026#34;收货地址\u0026#34; :visible.sync=\u0026#34;dialogformvisible\u0026#34;\u0026gt; \u0026lt;el-form :model=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动名称\u0026#34; :label-width=\u0026#34;formlabelwidth\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;form.name\u0026#34; autocomplete=\u0026#34;off\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动区域\u0026#34; :label-width=\u0026#34;formlabelwidth\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;form.region\u0026#34; placeholder=\u0026#34;请选择活动区域\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;区域一\u0026#34; value=\u0026#34;shanghai\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;区域二\u0026#34; value=\u0026#34;beijing\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;div slot=\u0026#34;footer\u0026#34; class=\u0026#34;dialog-footer\u0026#34;\u0026gt; \u0026lt;el-button @click=\u0026#34;dialogformvisible = false\u0026#34;\u0026gt;取 消\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;dialogformvisible = false\u0026#34; \u0026gt;确 定\u0026lt;/el-button \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { dialogvisible: false, griddata: [ { date: \u0026#34;2016-05-02\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-04\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-01\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-03\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, ], dialogtablevisible: false, dialogformvisible: false, form: { name: \u0026#34;\u0026#34;, region: \u0026#34;\u0026#34;, date1: \u0026#34;\u0026#34;, date2: \u0026#34;\u0026#34;, delivery: false, type: [], resource: \u0026#34;\u0026#34;, desc: \u0026#34;\u0026#34;, }, formlabelwidth: \u0026#34;120px\u0026#34;, }, methods: { handleclose(done) { this.$confirm(\u0026#34;确认关闭？\u0026#34;) .then((_) =\u0026gt; { done(); }) .catch((_) =\u0026gt; {}); }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (5) 标签页 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-tabs v-model=\u0026#34;activename\u0026#34; @tab-click=\u0026#34;handleclick\u0026#34; type=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;el-tab-pane label=\u0026#34;用户管理\u0026#34; name=\u0026#34;first\u0026#34;\u0026gt;用户管理\u0026lt;/el-tab-pane\u0026gt; \u0026lt;el-tab-pane label=\u0026#34;配置管理\u0026#34; name=\u0026#34;second\u0026#34;\u0026gt;配置管理\u0026lt;/el-tab-pane\u0026gt; \u0026lt;el-tab-pane label=\u0026#34;角色管理\u0026#34; name=\u0026#34;third\u0026#34;\u0026gt;角色管理\u0026lt;/el-tab-pane\u0026gt; \u0026lt;el-tab-pane label=\u0026#34;定时任务补偿\u0026#34; name=\u0026#34;fourth\u0026#34; \u0026gt;定时任务补偿\u0026lt;/el-tab-pane \u0026gt; \u0026lt;/el-tabs\u0026gt; \u0026lt;el-tabs v-model=\u0026#34;activename\u0026#34; @tab-click=\u0026#34;handleclick\u0026#34; type=\u0026#34;border-card\u0026#34;\u0026gt; \u0026lt;el-tab-pane label=\u0026#34;用户管理\u0026#34; name=\u0026#34;first\u0026#34;\u0026gt;用户管理\u0026lt;/el-tab-pane\u0026gt; \u0026lt;el-tab-pane label=\u0026#34;配置管理\u0026#34; name=\u0026#34;second\u0026#34;\u0026gt;配置管理\u0026lt;/el-tab-pane\u0026gt; \u0026lt;el-tab-pane label=\u0026#34;角色管理\u0026#34; name=\u0026#34;third\u0026#34;\u0026gt;角色管理\u0026lt;/el-tab-pane\u0026gt; \u0026lt;el-tab-pane label=\u0026#34;定时任务补偿\u0026#34; name=\u0026#34;fourth\u0026#34; \u0026gt;定时任务补偿\u0026lt;/el-tab-pane \u0026gt; \u0026lt;/el-tabs\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-tabs v-model=\u0026#34;editabletabsvalue\u0026#34; type=\u0026#34;card\u0026#34; editable @edit=\u0026#34;handletabsedit\u0026#34; \u0026gt; \u0026lt;el-tab-pane :key=\u0026#34;item.name\u0026#34; v-for=\u0026#34;(item, index) in editabletabs\u0026#34; :label=\u0026#34;item.title\u0026#34; :name=\u0026#34;item.name\u0026#34; \u0026gt; {{item.content}} \u0026lt;/el-tab-pane\u0026gt; \u0026lt;/el-tabs\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { activename: \u0026#34;second\u0026#34;, editabletabsvalue: \u0026#34;2\u0026#34;, editabletabs: [ { title: \u0026#34;tab 1\u0026#34;, name: \u0026#34;1\u0026#34;, content: \u0026#34;tab 1 content\u0026#34;, }, { title: \u0026#34;tab 2\u0026#34;, name: \u0026#34;2\u0026#34;, content: \u0026#34;tab 2 content\u0026#34;, }, ], tabindex: 2, }, methods: { handleclick(tab, event) { console.log(tab, event); }, handletabsedit(targetname, action) { if (action === \u0026#34;add\u0026#34;) { let newtabname = ++this.tabindex + \u0026#34;\u0026#34;; this.editabletabs.push({ title: \u0026#34;new tab\u0026#34;, name: newtabname, content: \u0026#34;new tab content\u0026#34;, }); this.editabletabsvalue = newtabname; } if (action === \u0026#34;remove\u0026#34;) { let tabs = this.editabletabs; let activename = this.editabletabsvalue; if (activename === targetname) { tabs.foreach((tab, index) =\u0026gt; { if (tab.name === targetname) { let nexttab = tabs[index + 1] || tabs[index - 1]; if (nexttab) { activename = nexttab.name; } } }); } this.editabletabsvalue = activename; this.editabletabs = tabs.filter((tab) =\u0026gt; tab.name !== targetname); } }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (6) 表格 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-table :data=\u0026#34;tabledata\u0026#34; style=\u0026#34;width: 60%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-table :data=\u0026#34;tabledata\u0026#34; stripe style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-table :data=\u0026#34;tabledata\u0026#34; border style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { tabledata: [ { date: \u0026#34;2016-05-02\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-04\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1517 弄\u0026#34;, }, { date: \u0026#34;2016-05-01\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1519 弄\u0026#34;, }, { date: \u0026#34;2016-05-03\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1516 弄\u0026#34;, }, ], }, methods: {}, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (7) 分页 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;block\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;demonstration\u0026#34;\u0026gt;页数较少时的效果\u0026lt;/span\u0026gt; \u0026lt;el-pagination layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;50\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;block\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;demonstration\u0026#34;\u0026gt;大于 7 页时的效果\u0026lt;/span\u0026gt; \u0026lt;el-pagination layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-pagination :page-size=\u0026#34;20\u0026#34; :pager-count=\u0026#34;11\u0026#34; layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;1000\u0026#34; \u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-pagination background layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-pagination small layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;50\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;div class=\u0026#34;block\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;demonstration\u0026#34;\u0026gt;完整功能\u0026lt;/span\u0026gt; \u0026lt;el-pagination background @size-change=\u0026#34;handlesizechange\u0026#34; @current-change=\u0026#34;handlecurrentchange\u0026#34; :current-page=\u0026#34;currentpage4\u0026#34; :page-sizes=\u0026#34;[100, 200, 300, 400]\u0026#34; :page-size=\u0026#34;100\u0026#34; layout=\u0026#34;total, sizes, prev, pager, next, jumper\u0026#34; :total=\u0026#34;400\u0026#34; \u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-switch v-model=\u0026#34;value\u0026#34;\u0026gt; \u0026lt;/el-switch\u0026gt; \u0026lt;el-pagination :hide-on-single-page=\u0026#34;value\u0026#34; :total=\u0026#34;5\u0026#34; layout=\u0026#34;prev, pager, next\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { currentpage1: 5, currentpage2: 5, currentpage3: 5, currentpage4: 4, value: false }, methods: { handlesizechange(val) { console.log(`每页 ${val} 条`); }, handlecurrentchange(val) { console.log(`当前页: ${val}`); }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (8) 表单 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-form ref=\u0026#34;form\u0026#34; :model=\u0026#34;form\u0026#34; label-width=\u0026#34;80px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动名称\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;form.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动区域\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;form.region\u0026#34; placeholder=\u0026#34;请选择活动区域\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;区域一\u0026#34; value=\u0026#34;shanghai\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;区域二\u0026#34; value=\u0026#34;beijing\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动时间\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;11\u0026#34;\u0026gt; \u0026lt;el-date-picker type=\u0026#34;date\u0026#34; placeholder=\u0026#34;选择日期\u0026#34; v-model=\u0026#34;form.date1\u0026#34; style=\u0026#34;width: 100%\u0026#34; \u0026gt;\u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col class=\u0026#34;line\u0026#34; :span=\u0026#34;2\u0026#34;\u0026gt;-\u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;11\u0026#34;\u0026gt; \u0026lt;el-time-picker placeholder=\u0026#34;选择时间\u0026#34; v-model=\u0026#34;form.date2\u0026#34; style=\u0026#34;width: 100%\u0026#34; \u0026gt;\u0026lt;/el-time-picker\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;即时配送\u0026#34;\u0026gt; \u0026lt;el-switch v-model=\u0026#34;form.delivery\u0026#34;\u0026gt;\u0026lt;/el-switch\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动性质\u0026#34;\u0026gt; \u0026lt;el-checkbox-group v-model=\u0026#34;form.type\u0026#34;\u0026gt; \u0026lt;el-checkbox label=\u0026#34;美食/餐厅线上活动\u0026#34; name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/el-checkbox\u0026gt; \u0026lt;el-checkbox label=\u0026#34;地推活动\u0026#34; name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/el-checkbox\u0026gt; \u0026lt;el-checkbox label=\u0026#34;线下主题活动\u0026#34; name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/el-checkbox\u0026gt; \u0026lt;el-checkbox label=\u0026#34;单纯品牌曝光\u0026#34; name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/el-checkbox\u0026gt; \u0026lt;/el-checkbox-group\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;特殊资源\u0026#34;\u0026gt; \u0026lt;el-radio-group v-model=\u0026#34;form.resource\u0026#34;\u0026gt; \u0026lt;el-radio label=\u0026#34;线上品牌商赞助\u0026#34;\u0026gt;\u0026lt;/el-radio\u0026gt; \u0026lt;el-radio label=\u0026#34;线下场地免费\u0026#34;\u0026gt;\u0026lt;/el-radio\u0026gt; \u0026lt;/el-radio-group\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动形式\u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;form.desc\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onsubmit\u0026#34;\u0026gt;立即创建\u0026lt;/el-button\u0026gt; \u0026lt;el-button\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;forminline\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;审批人\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;forminline.user\u0026#34; placeholder=\u0026#34;审批人\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动区域\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;forminline.region\u0026#34; placeholder=\u0026#34;活动区域\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;区域一\u0026#34; value=\u0026#34;shanghai\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;区域二\u0026#34; value=\u0026#34;beijing\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onsubmit\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;el-form :model=\u0026#34;ruleform\u0026#34; :rules=\u0026#34;rules\u0026#34; ref=\u0026#34;ruleform\u0026#34; label-width=\u0026#34;100px\u0026#34; class=\u0026#34;demo-ruleform\u0026#34; \u0026gt; \u0026lt;el-form-item label=\u0026#34;活动名称\u0026#34; prop=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;ruleform.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动区域\u0026#34; prop=\u0026#34;region\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;ruleform.region\u0026#34; placeholder=\u0026#34;请选择活动区域\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;区域一\u0026#34; value=\u0026#34;shanghai\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;区域二\u0026#34; value=\u0026#34;beijing\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动时间\u0026#34; required\u0026gt; \u0026lt;el-col :span=\u0026#34;11\u0026#34;\u0026gt; \u0026lt;el-form-item prop=\u0026#34;date1\u0026#34;\u0026gt; \u0026lt;el-date-picker type=\u0026#34;date\u0026#34; placeholder=\u0026#34;选择日期\u0026#34; v-model=\u0026#34;ruleform.date1\u0026#34; style=\u0026#34;width: 100%\u0026#34; \u0026gt;\u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col class=\u0026#34;line\u0026#34; :span=\u0026#34;2\u0026#34;\u0026gt;-\u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;11\u0026#34;\u0026gt; \u0026lt;el-form-item prop=\u0026#34;date2\u0026#34;\u0026gt; \u0026lt;el-time-picker placeholder=\u0026#34;选择时间\u0026#34; v-model=\u0026#34;ruleform.date2\u0026#34; style=\u0026#34;width: 100%\u0026#34; \u0026gt;\u0026lt;/el-time-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;即时配送\u0026#34; prop=\u0026#34;delivery\u0026#34;\u0026gt; \u0026lt;el-switch v-model=\u0026#34;ruleform.delivery\u0026#34;\u0026gt;\u0026lt;/el-switch\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动性质\u0026#34; prop=\u0026#34;type\u0026#34;\u0026gt; \u0026lt;el-checkbox-group v-model=\u0026#34;ruleform.type\u0026#34;\u0026gt; \u0026lt;el-checkbox label=\u0026#34;美食/餐厅线上活动\u0026#34; name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/el-checkbox\u0026gt; \u0026lt;el-checkbox label=\u0026#34;地推活动\u0026#34; name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/el-checkbox\u0026gt; \u0026lt;el-checkbox label=\u0026#34;线下主题活动\u0026#34; name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/el-checkbox\u0026gt; \u0026lt;el-checkbox label=\u0026#34;单纯品牌曝光\u0026#34; name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;/el-checkbox\u0026gt; \u0026lt;/el-checkbox-group\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;特殊资源\u0026#34; prop=\u0026#34;resource\u0026#34;\u0026gt; \u0026lt;el-radio-group v-model=\u0026#34;ruleform.resource\u0026#34;\u0026gt; \u0026lt;el-radio label=\u0026#34;线上品牌商赞助\u0026#34;\u0026gt;\u0026lt;/el-radio\u0026gt; \u0026lt;el-radio label=\u0026#34;线下场地免费\u0026#34;\u0026gt;\u0026lt;/el-radio\u0026gt; \u0026lt;/el-radio-group\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动形式\u0026#34; prop=\u0026#34;desc\u0026#34;\u0026gt; \u0026lt;el-input type=\u0026#34;textarea\u0026#34; v-model=\u0026#34;ruleform.desc\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;submitform(\u0026#39;ruleform\u0026#39;)\u0026#34; \u0026gt;立即创建\u0026lt;/el-button \u0026gt; \u0026lt;el-button @click=\u0026#34;resetform(\u0026#39;ruleform\u0026#39;)\u0026#34;\u0026gt;重置\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { form: { name: \u0026#34;\u0026#34;, region: \u0026#34;\u0026#34;, date1: \u0026#34;\u0026#34;, date2: \u0026#34;\u0026#34;, delivery: false, type: [], resource: \u0026#34;\u0026#34;, desc: \u0026#34;\u0026#34;, }, forminline: { user: \u0026#34;\u0026#34;, region: \u0026#34;\u0026#34;, }, ruleform: { name: \u0026#34;\u0026#34;, region: \u0026#34;\u0026#34;, date1: \u0026#34;\u0026#34;, date2: \u0026#34;\u0026#34;, delivery: false, type: [], resource: \u0026#34;\u0026#34;, desc: \u0026#34;\u0026#34;, }, rules: { name: [ { required: true, message: \u0026#34;请输入活动名称\u0026#34;, trigger: \u0026#34;blur\u0026#34; }, { min: 3, max: 5, message: \u0026#34;长度在 3 到 5 个字符\u0026#34;, trigger: \u0026#34;blur\u0026#34;, }, ], region: [ { required: true, message: \u0026#34;请选择活动区域\u0026#34;, trigger: \u0026#34;change\u0026#34; }, ], date1: [ { type: \u0026#34;date\u0026#34;, required: true, message: \u0026#34;请选择日期\u0026#34;, trigger: \u0026#34;change\u0026#34;, }, ], date2: [ { type: \u0026#34;date\u0026#34;, required: true, message: \u0026#34;请选择时间\u0026#34;, trigger: \u0026#34;change\u0026#34;, }, ], type: [ { type: \u0026#34;array\u0026#34;, required: true, message: \u0026#34;请至少选择一个活动性质\u0026#34;, trigger: \u0026#34;change\u0026#34;, }, ], resource: [ { required: true, message: \u0026#34;请选择活动资源\u0026#34;, trigger: \u0026#34;change\u0026#34; }, ], desc: [ { required: true, message: \u0026#34;请填写活动形式\u0026#34;, trigger: \u0026#34;blur\u0026#34; }, ], }, }, methods: { onsubmit() { console.log(\u0026#34;submit!\u0026#34;); }, submitform(formname) { this.$refs[formname].validate((valid) =\u0026gt; { if (valid) { alert(\u0026#34;submit!\u0026#34;); } else { console.log(\u0026#34;error submit!!\u0026#34;); return false; } }); }, resetform(formname) { this.$refs[formname].resetfields(); }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (9) container 用于布局的容器组件，方便快速搭建页面的基本结构 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; .el-header, .el-footer { background-color: #b3c0d1; color: #333; text-align: center; line-height: 60px; } .el-aside { background-color: #d3dce6; color: #333; text-align: center; line-height: 710px; } .el-main { background-color: #e9eef3; color: #333; text-align: center; line-height: 510px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt;header\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt;aside\u0026lt;/el-aside\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-main\u0026gt;main\u0026lt;/el-main\u0026gt; \u0026lt;el-footer\u0026gt;footer\u0026lt;/el-footer\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { }, methods: { }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5. 案例：后台管理页面 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; .el-header, .el-footer { background-color: #b3c0d1; color: #333; text-align: center; line-height: 40px; } .el-header { background-image: url(img/topleft.jpg); background-repeat: no-repeat; background-size: 100%; text-align: left; } .el-aside { background-color: #c3c3c3; color: #333; text-align: center; line-height: 710px; } .el-main { background-color: #e9eef3; color: #333; text-align: center; line-height: 510px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt; \u0026lt;h2\u0026gt;欢迎来到我网站\u0026lt;/h2\u0026gt; \u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;el-menu default-active=\u0026#34;2\u0026#34; class=\u0026#34;el-menu-vertical-demo\u0026#34; @open=\u0026#34;handleopen\u0026#34; @close=\u0026#34;handleclose\u0026#34; background-color=\u0026#34;#c3c3c3\u0026#34; text-color=\u0026#34;#fff\u0026#34; active-text-color=\u0026#34;#ffd04b\u0026#34; \u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-location\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span\u0026gt;\u0026lt;a href=\u0026#34;11-stu.html\u0026#34; target=\u0026#34;right\u0026#34;\u0026gt;学生管理\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- \u0026lt;el-menu-item-group\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;分组一\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-menu-item-group title=\u0026#34;分组2\u0026#34;\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-3\u0026#34;\u0026gt;选项3\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;el-submenu index=\u0026#34;1-4\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;选项4\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-4-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; --\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;el-menu-item index=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-menu\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;教师管理\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;3\u0026#34; disabled\u0026gt; \u0026lt;i class=\u0026#34;el-icon-document\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;班级管理\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;el-icon-setting\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;span slot=\u0026#34;title\u0026#34;\u0026gt;选课管理\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;iframe name=\u0026#34;right\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; frameborder=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;el-footer\u0026gt;footer\u0026lt;/el-footer\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: {}, methods: { handleopen(key, keypath) { console.log(key, keypath); }, handleclose(key, keypath) { console.log(key, keypath); }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;el/element-ui-2.13.0/lib/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;el/element-ui-2.13.0/lib/theme-chalk/index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;el-table ref=\u0026#34;multipletable\u0026#34; :data=\u0026#34;tabledata\u0026#34; tooltip-effect=\u0026#34;dark\u0026#34; style=\u0026#34;width: 100%\u0026#34; @selection-change=\u0026#34;handleselectionchange\u0026#34; \u0026gt; \u0026lt;el-table-column type=\u0026#34;selection\u0026#34; width=\u0026#34;55\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;日期\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt;{{ scope.row.date }}\u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34; show-overflow-tooltip\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;el-pagination background @size-change=\u0026#34;handlesizechange\u0026#34; @current-change=\u0026#34;handlecurrentchange\u0026#34; :current-page=\u0026#34;currentpage4\u0026#34; :page-sizes=\u0026#34;[100, 200, 300, 400]\u0026#34; :page-size=\u0026#34;100\u0026#34; layout=\u0026#34;total, sizes, prev, pager, next, jumper\u0026#34; :total=\u0026#34;400\u0026#34; \u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { tabledata: [ { date: \u0026#34;2016-05-03\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-02\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-04\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-01\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-08\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-06\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, { date: \u0026#34;2016-05-07\u0026#34;, name: \u0026#34;王小虎\u0026#34;, address: \u0026#34;上海市普陀区金沙江路 1518 弄\u0026#34;, }, ], multipleselection: [], currentpage4: 4, }, methods: { handleselectionchange(val) { this.multipleselection = val; }, handlesizechange(val) { console.log(`每页 ${val} 条`); }, handlecurrentchange(val) { console.log(`当前页: ${val}`); }, }, }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2021-12-16","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430225784/","summary":"一、ElementUI 1. 理解 Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。 是一个UI框架，封装了HTML CSS Vue 饿了么前端团队，基于V","title":"elementui"},{"content":"一、es6 1. 理解 ecmascript 6.0 是javascript新的语法，给js补充了一些新语法。vue基于es6的新语法。 2. 新特性 ① 声明变量 语法： let 变量名 = 初始值; 特点： 1. let声明的变量提供了局部作用域 2. let声明变量的名字 只能声明一次 3. let声明变量必须给初始值 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; // 1. 声明变量 var 声明的变量没有局部作用域 var i = 10 // 2. es6 let声明的变量提供了局部作用域 let j = 10 console.log(j) console.log(\u0026#34;----------------------\u0026#34;) { var n = 11 let m = 12 } console.log(n) // console.log(m) // uncaught referenceerror: m is not defined console.log(\u0026#34;---------------\u0026#34;) // let声明变量的名字 只能声明一次 var i = 19 // let j = 20 console.log(i) // console.log(j) // uncaught syntaxerror: identifier \u0026#39;j\u0026#39; has already been declared console.log(\u0026#34;---------------------\u0026#34;) console.log(xx); // undefined var xx = \u0026#34;app\u0026#34;; // let声明变量必须给初始值 console.log(yy) let yy = \u0026#34;apps\u0026#34; // uncaught referenceerror: cannot access \u0026#39;yy\u0026#39; before initialization \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ② 常量的声明 格式： const 常量名 = 初始值 特点： 1. 常量一经定义 不能改变值 否则报错 2. 常量必须给初始值 否则报错 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; // es6 声明常量 const pi = 3.1415926 // pi = 3.14 // uncaught typeerror: assignment to constant variable. console.log(pi) const p // uncaught syntaxerror: missing initializer in const declaration console.log(p) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ③ 解构赋值 1. 理解 解构赋值对赋值运算符的扩展，主要对数组和对象中的变量匹配赋值。更加简单易读，语义更加清晰 // 传统方式 var i=1, j=2, a=3 console.log(i, j, a) // es6 let[b, c, d] = [2, 3, 4] console.log(b, c, d) // 对象 var user = {name: \u0026#34;huahua\u0026#34;, age: 18} // 传统 var username = user.name var age1 = user.age console.log(username, age1) // es6 let{name, age} = user console.log(name, age) ④ 模板字符串 1. 理解 模板字符串相当于加强版的字符串，使用`(反引号)，可以获取普通字符、变量和表达式的值 var num = 10 // 传统 var name = \u0026#34;翠花\u0026#34; var str = \u0026#34;hi, \u0026#34;+name+\u0026#34;。 你好\u0026#34; var ss = \u0026#34;hi, \u0026#34;+name+\u0026#34;。\u0026#34;+say()+(num+1) console.log(ss) // es6 var str1 = `hi, ${name}。你好啊` var sss = `hi, ${name}。${say()} ${num+1}` console.log(sss) function say(){ return \u0026#34;么么哒\u0026#34; } ⑤ 对象声明简化 // 传统 对象声明 var name = \u0026#34;xx\u0026#34; var age = 18 var p = {name: name, age: age} console.log(p) // es6 let pp = {name, age} console.log(pp) ⑥ 声明函数简化 // 传统 var user1 = { username: \u0026#34;aa\u0026#34;, age: 19, say: function(){ console.log(\u0026#34;.......\u0026#34;) } } user1.say() // es6 var user2 = { username: \u0026#34;aa\u0026#34;, age: 19, say(){ console.log(\u0026#34;...es6....\u0026#34;) } } user2.say() ⑦ 函数默认值参数 //es6 默认值参数 function sayhi(name, age=18){ console.log(name+\u0026#34;::\u0026#34;+age) } sayhi(\u0026#34;xx\u0026#34;, 22) sayhi(\u0026#34;xx\u0026#34;) sayhi(\u0026#34;xx\u0026#34;, null) ⑧ 函数的不定参数 // es6 函数不定参数 function eat(...v){ console.log(v.length) } eat(1, \u0026#34;哈哈\u0026#34;, null, 3.14) ⑨ 箭头函数 箭头函数就是函数简洁的一种写法 特点： 1. 函数中无参或者多参数 ()不能省略 2. 函数体中如果只有 return 或者 只有一句话 {}可以省略 否则不可以 // 传统方式 var func1 = function (a){ console.log(a) } var func3 = function(b){ return b } // es6 类似lambda表达式 var func2 = a =\u0026gt; console.log(a) func2(10) var func4 = b =\u0026gt; b console.log(func4(11)) 二、vue 1. 理解 vue 渐进式框架 vue只关注视图层，将dom封装起来，提供简单的api 实现视图和数据的绑定，最大程度上释放了dom操作，vue是javascript的一个优秀框架 2. 作用 m-v-vm模式 m model 模型 数据模型 v view 视图 将数据页面渲染的结果 vm view-model 视图和模型的双向绑定 3. 使用 ① 下载 vue.js文件 ② 引入页面中 \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ③ 编码 1. 创建vue对象 2. 配置vue的选项 如：el data methods ... el: // element, vue中模型数据要渲染的页面 data： // 要渲染页面中的数据 后台获取 methods：// vue中需要使用的函数 3. 定义组件 去渲染数据 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 渲染 \u0026lt;/div\u0026gt; 4. 使用插值表达式 渲染data中数据 字符串数据 {{data的属性名}} 4. vue的指令 指令是带 v-前缀 的特殊的属性，如：v-html v-show v-for v-if，vue框架扩展的语法 取代dom操作 渲染vue中data的数据 4.1 v-html和v-text 类型 innerhtml 和 innertext \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p v-html=\u0026#34;h\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p v-text=\u0026#34;t\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let app = new vue({ el: \u0026#34;#app\u0026#34;, data: { h: \u0026#34;\u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;嘿嘿\u0026lt;/font\u0026gt;\u0026#34;, t: \u0026#34;哈哈\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.2 v-if 和 v-show v-if 值为true显示该组件 为false移出该组件 和 v-else v-show 值为true 显示组件 为false 设置display属性为none 不能 v-else使用 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2 v-if=\u0026#34;b\u0026#34;\u0026gt;欢迎: xx\u0026lt;/h2\u0026gt; \u0026lt;h2 v-else=\u0026#34;\u0026#34;\u0026gt;请登录\u0026lt;/h2\u0026gt; \u0026lt;h2 v-show=\u0026#34;b\u0026#34;\u0026gt;哈哈\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { b: false } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.3 v-on 作用：利用v-on绑定dom事件 当事件触发时执行v-on的js代码 语法： v-on:事件名 = \u0026#34;\u0026#34; 或 @事件名 = \u0026#34;\u0026#34; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button v-on:click=\u0026#34;num++\u0026#34;\u0026gt;点击{{num}}\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;func1()\u0026#34;\u0026gt;点击{{num}}\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;func2(num)\u0026#34;\u0026gt;点我干啥\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { num: 0 }, methods: { func1(){ console.log(\u0026#34;点击触发了：\u0026#34;+this.num) this.num ++ }, func2(n){ console.log(\u0026#34;func2调用了, \u0026#34;+n) } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.4 v-for 作用：页面渲染列表是遍历 格式： 1. (item, index) in 数组或集合 item 集合或数组中每一个元素 index 集合或数组的索引 2. (value, key, index) in 对象 value 对象中对应的属性值值 key 对象的属性名 index 对象的属性对应的索引 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;500\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;索引\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;学号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 1. 遍历集合 --\u0026gt; \u0026lt;tr v-for=\u0026#34;(item, index) in stulist\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.sid}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.username}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{item.sex}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;500\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;!-- 2. 对象的遍历 --\u0026gt; \u0026lt;tr v-for=\u0026#34;(v, key, index) in stu\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index}}--{{key}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; v-bind:name=\u0026#34;key\u0026#34; v-model=\u0026#34;stu[key]\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { stulist: [ {sid: 101, username: \u0026#34;小坤坤\u0026#34;, sex: \u0026#34;男\u0026#34;}, {sid: 102, username: \u0026#34;小冲冲\u0026#34;, sex: \u0026#34;未知\u0026#34;}, {sid: 103, username: \u0026#34;小一一\u0026#34;, sex: \u0026#34;男\u0026#34;}, {sid: 104, username: \u0026#34;小航航\u0026#34;, sex: \u0026#34;女\u0026#34;}, {sid: 105, username: \u0026#34;小龙龙\u0026#34;, sex: \u0026#34;男\u0026#34;} ], stu: {sid: 106, username: \u0026#34;小涛涛\u0026#34;, sex: \u0026#34;女\u0026#34;} } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.5 v-bind 作用：绑定标签的属性值 格式：v-bind:属性名=\u0026#34;\u0026#34; 或 :属性名=\u0026#34;\u0026#34; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;img v-bind:src=\u0026#34;src\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;src\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; :value=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v= new vue({ el: \u0026#34;#app\u0026#34;, data: { src: \u0026#34;img/mv.png\u0026#34;, username: \u0026#34;小美女\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.6 v-model 作用：表单数据的双向绑定 特点：双向绑定 1. vue中数据发生变化 会更新到页面 2. 页面数据变化也会更新vue中的数据 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;xx\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;xx\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { xx: \u0026#34;小明明\u0026#34; } }) \u0026lt;/script\u0026gt; 5. vue的选项 el: // element, vue中模型数据要渲染的页面 data： // 要渲染页面中的数据 后台获取 methods：// vue中需要使用的函数 computed: // 计算属性 watch: // 监控一个值发生变化 做出相应的处理 计算属性： \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{birthday}}\u0026lt;/p\u0026gt; 没有使用计算属性：\u0026lt;p\u0026gt;{{new date(birthday).getfullyear()+\u0026#39;年\u0026#39;+(new date(birthday).getmonth()+1)+\u0026#39;月\u0026#39;+new date(birthday).getdate()+\u0026#39;日\u0026#39;}}\u0026lt;/p\u0026gt; 计算属性：\u0026lt;p\u0026gt;{{getbirthday}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { xx: \u0026#34;小明明\u0026#34;, birthday: 1610669793429 }, computed: { getbirthday(){ return new date(this.birthday).getfullyear()+\u0026#39;年\u0026#39;+(new date(this.birthday).getmonth()+1)+\u0026#39;月\u0026#39;+new date(this.birthday).getdate()+\u0026#39;日\u0026#39; } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 监听： \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let v = new vue({ el: \u0026#34;#app\u0026#34;, data: { name: \u0026#34;小坤坤\u0026#34; }, watch: { name(newval, oldval){ console.log(newval, oldval) } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ####6. axios\nvue发送网络请求的一种方式，类似ajax 跨域问题： 由于浏览器提供安全性，同源策略(相同的协议、相同域名、相同的端口号)，如果其中一个不同产生跨域问题。 解决跨域问题： 配置一个跨域过滤器 package com.ujiuye.web.filter; import javax.servlet.*; import javax.servlet.annotation.webfilter; import javax.servlet.http.httpservletrequest; import javax.servlet.http.httpservletresponse; import java.io.ioexception; /** * 解决请求跨域问题 */ @webfilter(filtername = \u0026#34;filter01\u0026#34;, urlpatterns = \u0026#34;/*\u0026#34;) public class filter01 implements filter { public void destroy() { } public void dofilter(servletrequest req, servletresponse resp, filterchain chain) throws servletexception, ioexception { httpservletresponse response = (httpservletresponse) resp; httpservletrequest request = (httpservletrequest) req; // 不使用*，自动适配跨域域名，避免携带cookie时失效 string origin = request.getheader(\u0026#34;origin\u0026#34;); response.setheader(\u0026#34;access-control-allow-origin\u0026#34;, origin); // 自适应所有自定义头 string headers = request.getheader(\u0026#34;access-control-request-headers\u0026#34;); response.setheader(\u0026#34;access-control-allow-headers\u0026#34;, headers); response.setheader(\u0026#34;access-control-expose-headers\u0026#34;, headers); // 允许跨域的请求方法类型 response.setheader(\u0026#34;access-control-allow-methods\u0026#34;, \u0026#34;*\u0026#34;); // 预检命令（options）缓存时间，单位：秒 response.setheader(\u0026#34;access-control-max-age\u0026#34;, \u0026#34;3600\u0026#34;); // 明确许可客户端发送cookie，不允许删除字段即可 response.setheader(\u0026#34;access-control-allow-credentials\u0026#34;, \u0026#34;true\u0026#34;); chain.dofilter(request, response); } public void init(filterconfig config) throws servletexception { } } 方式1： // 发送axios请求 let p = new urlsearchparams() p.append(\u0026#34;username\u0026#34;, \u0026#34;xx\u0026#34;) p.append(\u0026#34;age\u0026#34;, 18) axios({ method: \u0026#34;post\u0026#34;, // 请求方式 url: \u0026#34;http://localhost:8080/javaweb_day18_axios_war_exploded/axiostest\u0026#34;, // 请求路径 data: p, responsetype: \u0026#34;text\u0026#34; }).then(resp =\u0026gt; { // 请求成功 获取返回结果 resp console.log(resp.data) }).catch(error =\u0026gt; { // 请求失败 打印错误信息 console.log(error) }) 注意： 1. 页面和后台部署的不是同一台服务器 发送ajax请求会产生跨域问题 2. axios发送请求携带参数时 可以封装到urlsearchparams/formdata 中发送 方式2： axios.get() axios.post() /* axios.get(\u0026#34;http://localhost:8080/javaweb_day18_axios_war_exploded/axiostest?username=root\u0026amp;age=20\u0026#34;).then(resp =\u0026gt; { console.log(resp) }).catch(error =\u0026gt; { console.log(error) }) */ axios.post(\u0026#34;http://localhost:8080/javaweb_day18_axios_war_exploded/axiostest\u0026#34;, p).then(resp =\u0026gt; { console.log(resp) }).catch(error =\u0026gt; { console.log(error) }) ####7. 生命周期\n钩子函数：vue的生命周期的过程中 自动触发的函数。如果开发想要在某个时机执行一些操作，可以指定该时机下的钩子函数 beforecreate vue未初始化之前执行 created vue属性初始化之后执行 加载页面之前获取数据一般在此时机 beforemount dom操作之前执行 mounted dom加载之后执行 beforeupdate 修改dom之前执行 updated 修改dom之后执行 beforedestroy vue销毁之前 destroyed vue销毁之后执行 ","date":"2021-12-15","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430215026/","summary":"一、ES6 1. 理解 ECMAScript 6.0 是JavaScript新的语法，给JS补充了一些新语法。Vue基于ES6的新语法。 2. 新特性 ① 声明变量 语法： let 变量名 = 初始值; 特点： 1. let声","title":"vue"},{"content":"此博客站点使用了github作为主站，又使用了gitee作为镜像站。但是gitee免费账户是不支持提交后自动部署的，所以有大佬开发了在github上使用的动作：gitee-pages-action（点击查看）。只要在某个仓库配置好这个动作就能在往这个仓库提交任何内容时自动让gitee部署gitee里面指定仓库的内容。\n我们按照这个仓库的文档往hexo站点的source目录添加.github\\workflows\\sync.yml这个文件，并在这个文件里面配置要使用的gitee站点仓库和用户名。\nname: sync on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: build gitee pages uses: yanglbme/gitee-pages-action@main with: gitee-username: 改成你的gitee用户名 gitee-password: ${{ secrets.gitee_password }} gitee-repo: 改成你的gitee仓库（用户名斜杠仓库名） branch: master 但是一个比较严重的问题是鄙人要让github这边部署站点的仓库更新时触发这个动作，鄙人用的是hexo，如果鄙人在source目录配置了.github目录时使用hexo的generate命令是不会向github提交这个动作的配置的。国内也没有一个比较好的解决方案，只好去查hexo的文档。\n经过查阅hexo文档发现，hexo默认会忽略隐藏文件和文件夹（包括名称以下划线和 .开头的文件和文件夹，hexo的_posts和_data等目录除外）。因此需要在后台仓库的_config.yml文件添加这样的配置才能把.github的目录也给带进来。可能已经预留了include属性，建议先搜索这个属性，然后直接往这里面添加。\ninclude: - \u0026#34;.github/**/*\u0026#34; 但是这样即使配置了添加这些文件，他默认也会把这个源文件也给渲染，所以我们还需要设置忽略这个文件的渲染。继续在_config.yml文件查找skip_render属性，添加这个文件名。\nskip_render: - \u0026#34;.github/**/*\u0026#34; 还有一处也需要修改，往远程仓库部署时要设置不能跳过隐藏的文件，因为git bash是按linux设计的，默认会将.开头的文件和文件夹视为隐藏文件。所以要继续在_config.yml文件查找deploy属性，设置里面ignore_hidden为false。\ndeploy: type: git ignore_hidden: false repo: gitee: git@gitee.com:你的gitee仓库.git,要使用的分支名 github: git@github.com:你的github仓库.git,要使用的分支名 注意github的部署仓库后台的settings里面也要按照最上面那个仓库说明中那样配置secrets（gitee_rsa_private_key和gitee_password的两个密钥。其中：gitee_rsa_private_key存放id_rsa私钥；gitee_password存放gitee帐号的密码），这一步不要忘记了。\n这样设置之后就可以在github完成部署仓库提交之后通过配置的动作自动使gitee也部署站点。\n","date":"2021-12-11","permalink":"https://lovemjh.vercel.app/posts/blog/20220430231595/","summary":"此博客站点使用了Github作为主站，又使用了Gitee作为镜像站。但是Gitee免费账户是不支持提交后自动部署的，所以有大佬开发了在Github上使用的动作：","title":"hexo gitee pages 自动部署站点"},{"content":"typora-git同步 介绍 通过git实现typora笔记的同步。\n主题推荐 1.安装typora主题插件\n自带的插件不好看，推荐安装主题《vue》\n下载主题压缩包\nhttp://theme.typora.io/theme/vue/\n2.文件 – 偏好设置 – 外观 – 打开主题文件夹\n3.将解压后的内容整个放进去，重启typora\n4.点击主题，即可看到新加入的主题vue，选中即可\n配置typora 本地新建存放笔记的文件夹，设置打开typora时自动打开此文件夹\n设置图片的存放模式，这样图片就会被自动分类，从图床中解脱出来\n查看git配置文件 git config --list - 初始化仓库 在目录下 执行命令 git init - 在该仓库中操作之后，提交到暂存区 git add 文件名/. - 提交到本地仓库 git commit -m \u0026#39;提交信息\u0026#39; - 查看有哪些提交 信息 git log # 当前提交的之前版本 - 版本回退 git reset --hard \u0026#39;版本id\u0026#39; - 回到未来的提交 git reflog # 查看所有版本 git reset --hard \u0026#39;未来提交版本id\u0026#39; - 删除文件(只能删除已提交到仓库的文件 未提交的不能删除) git rm 文件名 git仓库与本地笔记本连接 新建仓库 在gitee中新建一个仓库用来存储文档\n文件夹与项目关联 git 全局设置: git config --global user.name \u0026#34;用户名\u0026#34; git config --global user.email \u0026#34;邮箱\u0026#34; 创建本地 git 仓库，并与git仓库关联: #本地之前还没有文件夹，新建一个并与git项目关联 mkdir 文件夹 cd 文件夹 #我们之前已经建立了文件夹，所以直接从这里开始执行 git init touch readme.md git add readme.md git commit -m \u0026#34;first commit\u0026#34; git remote add origin https://gitee.com/xxxx/文件夹.git git push -u origin master 如果本身是git本地仓库，通过下面的来建立关联，一般很少用 #本地已有文件夹，通过命令与git项目建立关联 cd existing_git_repo git remote add origin https://gitee.com/xxxxx/文件夹.git git push -u origin master 通过脚本推送拉取文件 pull脚本 #!/bin/bash # 上面中的 #! 是一种约定标记, 它可以告诉系统这个脚本需要什么样的解释器来执行; echo \u0026#34;gitautopull starting...\u0026#34; git pull origin master push脚本 #!/bin/bash # 上面中的 #! 是一种约定标记, 它可以告诉系统这个脚本需要什么样的解释器来执行; echo \u0026#34;gitautopush starting...\u0026#34; time=$(date \u0026#34;+%y-%m-%d %h:%m:%s\u0026#34;) git add . read -t 30 -p \u0026#34;请输入提交注释:\u0026#34; msg if [ ! \u0026#34;$msg\u0026#34; ] ;then echo \u0026#34;[commit message] 默认提交, 提交人: $(whoami), 提交时间: ${time}\u0026#34; git commit -m \u0026#34;默认提交, 提交人: $(whoami), 提交时间: ${time}\u0026#34; else echo \u0026#34;[commit message] $msg, 提交人: $(whoami), 提交时间: ${time}\u0026#34; git commit -m \u0026#34;$msg, 提交人: $(whoami), 提交时间: ${time}\u0026#34; fi git push origin master echo \u0026#34;gitautopush ending...\u0026#34; ","date":"2021-12-11","permalink":"https://lovemjh.vercel.app/posts/blog/20220430231411/","summary":"Typora-Git同步 介绍 通过Git实现Typora笔记的同步。 主题推荐 1.安装Typora主题插件 自带的插件不好看，推荐安装主题《Vue》 下载主题压缩包 http://theme.typora.io/theme/Vue/ 2","title":"typora-git同步"},{"content":"ajax 一 ajax 1. 理解 ajax = asynchronous javascript and xml（异步的 javascript 和 xml）。 ajax 不是新的编程语言，而是一种使用现有标准的新方法。 ajax 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 2. 作用 异步请求服务器 不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容提高效率。 同步：发送一次请求，如果响应才能发送下次请求，如果没有响应，一直等待其他的请求发送不了 异步：发送一次请求，不需要等待 可以发送下一次请求 3. 使用 ① 创建核心对象 ② 设置请求配置信息(请求方式、请求地址等) ③ 设置监听(响应成功的情况下) ④ 局部更新页面(dom操作) // 3.1 创建核心对象 var xmlhttp; if (window.xmlhttprequest) { // ie7+, firefox, chrome, opera, safari 浏览器执行代码 xmlhttp=new xmlhttprequest(); } else { // ie6, ie5 浏览器执行代码 xmlhttp=new activexobject(\u0026#34;microsoft.xmlhttp\u0026#34;); } // 3.2 设置请求信息 xmlhttp.open(\u0026#34;get\u0026#34;, \u0026#34;checkname?username=\u0026#34;+username, true); xmlhttp.send(); // 3.3 设置监听 成功 xmlhttp.onreadystatechange = function() { if (xmlhttp.readystate==4 \u0026amp;\u0026amp; xmlhttp.status==200) { // 3.4 局部更新页面 dom操作 document.getelementbyid(\u0026#34;sp\u0026#34;).innerhtml = xmlhttp.responsetext; } } 4. jquery的ajax 方式1：$.ajax() $.ajax({ url: \u0026#34;checkname\u0026#34;, // 请求地址 data: {\u0026#34;username\u0026#34;:username }, // 请求携带参数 type: \u0026#34;post\u0026#34;, // 请求方式 async: \u0026#34;true\u0026#34;, // 是否异步 datatype: \u0026#34;text\u0026#34;, // 获取数据的类型 success: function(rel){ // 请求成功响应就绪 // dom操作更新页面数据 $(\u0026#34;#sp\u0026#34;).html(rel); } }) 方式2：$.get()/$.post() /* $.get(\u0026#34;checkname?username=\u0026#34;+username, function(rel){ // dom操作更新页面 $(\u0026#34;#sp\u0026#34;).html(rel); }, \u0026#34;text\u0026#34;)*/ $.post(\u0026#34;checkname\u0026#34;,{\u0026#34;username\u0026#34;:username}, function(rel){ // dom操作更新页面 $(\u0026#34;#sp\u0026#34;).html(rel); }, \u0026#34;text\u0026#34;) 5. 返回值类型 xml 以前使用 解析麻烦 json替代了 html html标签和内容 返回页面数据 script js脚本 json 处理大量数据使用的数据类型 text 文本 少量数据使用该类型 二、xml 1. 理解 xml 指可扩展标记语言（extensible markup language）。 xml 被设计用来传输和存储数据。现在一般做配置文件 xml 很重要，也很容易学习。 2. 作用： 设计用来传输和存储数据，现在一般做配置文件 如：web.xml 3. 约束：由于xml数据标签没有定义 为了指定标准 提供了约束方式 简单约束 : dtd（文档类型定义）的作用是定义 xml 文档的合法构建模块。 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;!doctype note[ \u0026lt;!element note (p+, to? ,xx*)\u0026gt; \u0026lt;!element p (#pcdata)\u0026gt; \u0026lt;!element to (#pcdata)\u0026gt; \u0026lt;!element xx (#pcdata)\u0026gt; ]\u0026gt; \u0026lt;note\u0026gt; \u0026lt;p\u0026gt;safas\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;ccc\u0026lt;/p\u0026gt; \u0026lt;to\u0026gt;asfsd\u0026lt;/to\u0026gt; \u0026lt;xx\u0026gt;100\u0026lt;/xx\u0026gt; \u0026lt;xx\u0026gt;sdff\u0026lt;/xx\u0026gt; \u0026lt;/note\u0026gt; 复杂约束：schema xml schema 是基于 xml 的 dtd 替代者。 xml schema 可描述 xml 文档的结构。 xml schema 语言也可作为 xsd（xml schema definition）来引用。 三、json 1. 理解 json: javascript object notation(javascript 对象表示法) json 是存储和交换文本信息的语法，类似 xml。 json 比 xml 更小、更快，更易解析。 2. 作用 网路传输数据的格式 3. json数据 特点：键值对的形式 [{\u0026#34;id\u0026#34;:1001, \u0026#34;name\u0026#34;: \u0026#34;小航航\u0026#34;, \u0026#34;qiangirl\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;翠花\u0026#34;}, {\u0026#34;name\u0026#34;:\u0026#34;柳岩\u0026#34;}]}, {\u0026#34;id\u0026#34;:1002, \u0026#34;name\u0026#34;:\u0026#34;小宫宫\u0026#34;, \u0026#34;qiangirl\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;小翠\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;小苍苍\u0026#34;}]}, {\u0026#34;id\u0026#34;:1003, \u0026#34;name\u0026#34;:\u0026#34;小明明\u0026#34;, \u0026#34;qiangirl\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;小云云\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;小远远\u0026#34;}]}] 四、搜索补全 baidu.jsp中 \u0026lt;%-- created by intellij idea. user: junguang date: 2021/12/14 time: 15:09 to change this template use file | settings | file templates. --%\u0026gt; \u0026lt;%@ page contenttype=\u0026#34;text/html;charset=utf-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;百度搜索\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; *{ padding: 0px; margin: 0px; } #dd input{ width: 500px; height: 40px; border-top-left-radius: 10px; border-bottom-left-radius: 10px; border-color: #c3c3c3; padding-left: 20px; border-right: none; margin-top: 0px; margin-left: 450px; float: left; } #dd a{ text-decoration: none; display: inline-block; width: 80px; height: 40px; background-color: blue; color: white; line-height: 40px; border-bottom-right-radius: 10px; border-top-right-radius: 10px; float: left; } #show{ width: 500px; border: 1px solid #c3c3c3; float: left; margin-left: 450px; border-radius: 10px; display: none; } #show div{ text-align: left; padding-left: 20px; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;js/jquery-3.5.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function(){ // 1. input绑定 键盘抬起事件 $(\u0026#34;#dd input\u0026#34;).keyup(function(){ // 清除show中的内容 $(\u0026#34;#show\u0026#34;).empty(); $(\u0026#34;#show\u0026#34;).css(\u0026#34;display\u0026#34;,\u0026#34;none\u0026#34;); // 2. 获取搜索框内容 var v = $(this).val().trim(); if(v==null || \u0026#34;\u0026#34;==v){ return; } // 3. 发送ajax请求 关联数据 $.post(\u0026#34;baidu\u0026#34;, {\u0026#34;search\u0026#34;:v}, function(rel){ // dom根据局部页面 show div中 for(var i=0; i\u0026lt; rel.length; i++){ console.log(rel[i].username); // 将获取的数据 装入show $(\u0026#34;#show\u0026#34;).css(\u0026#34;display\u0026#34;,\u0026#34;block\u0026#34;); $(\u0026#34;#show\u0026#34;).append(\u0026#34;\u0026lt;div\u0026gt;\u0026#34;+rel[i].username+\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;); } }, \u0026#34;json\u0026#34;) }); }) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt; \u0026lt;img src=\u0026#34;img/baidu.png\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;95\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;dd\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;search\u0026#34; /\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;show\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; baiduservlet package com.ujiuye.web.servlet; import com.fasterxml.jackson.databind.objectmapper; import com.ujiuye.bean.user; import com.ujiuye.service.userservice; import com.ujiuye.service.impl.userserviceimpl; import javax.servlet.servletexception; import javax.servlet.annotation.webservlet; import javax.servlet.http.httpservlet; import javax.servlet.http.httpservletrequest; import javax.servlet.http.httpservletresponse; import java.io.ioexception; import java.util.list; @webservlet(name = \u0026#34;baiduservlet\u0026#34;, urlpatterns = \u0026#34;/baidu\u0026#34;) public class baiduservlet extends httpservlet { protected void dopost(httpservletrequest request, httpservletresponse response) throws servletexception, ioexception { doget(request, response); } protected void doget(httpservletrequest request, httpservletresponse response) throws servletexception, ioexception { // 1. 获取请求参数 string search = request.getparameter(\u0026#34;search\u0026#34;); // 2. 处理业务 根据搜索关联数据 userservice service = new userserviceimpl(); list\u0026lt;user\u0026gt; list = service.findbysearch(search); // 转换json格式数据 （gson 功能比较全 fastjson 性能高） jackson // 2.1 获取核心对象 objectmapper mapper = new objectmapper(); string json = mapper.writevalueasstring(list); // 3. 响应 response.getwriter().print(json); } } ","date":"2021-12-05","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430214936/","summary":"AJAX 一 ajax 1. 理解 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换","title":"ajax"},{"content":"filter 1. 理解 filter过滤器，过滤器是执行过滤任务的对象，这些任务是针对对某一资源（servlet 或静态内容）的请求或来自某一资源的响应执行的，抑或同时针对这两者执行。 过滤的结果： 1. 拦截 2. 放行 2. 作用 过滤访问servlet或者其他资源之前的 初始化操作的对象，比如：自动登录 3. 使用 方式1： ① 自定义类 实现过滤器接口 ② 实现未实现方法 ③ 指定过滤的资源 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;myfilter1\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.ujiuye.web.filter.myfilter1\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;myfilter1\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/servlet1\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 方式2：注解的方式 (推荐) 4. 特点 · 一个资源可以配置多个filter · 一个filter可以过滤多个资源 · 过滤器默认不过滤转发 5. 使用场景 ① 字符编码过滤器② 自动登录 listener 1. 理解 listener监听器。监听servlet中的共享域对象的创建 销毁 属性的设置 获取 改变的对象 2. 作用 对数据的相关监听 3. 分类 ① 域对象的创建和销毁的监听器 servletcontextlistener 统计消耗的流量 httpsessionlistener 统计在线人数 servletrequestlistener 统计访问量 ② 域对象中属性操作的监听 servletcontextattributelistener httpsessionattributelistener servletrequestattributelistener ③ httpsession对象处理的监听 httpsessionbindinglistener session中绑定对象的监听器 httpsessionactivactionlistener 对象随着session钝化和活化的监听器 4. 使用 ① 自定义类实现监听器接口② 实现未实现方法③ 声明监听器 web.xml \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;com.ujiuye.web.listener.mylistener1\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; 四、总结 ","date":"2021-12-05","permalink":"https://lovemjh.vercel.app/posts/javaee/20220430215387/","summary":"Filter 1. 理解 Filter过滤器，过滤器是执行过滤任务的对象，这些任务是针对对某一资源（servlet 或静态内容）的请求或来自某一资源的响应执行的，抑或同时针对这两者","title":"filter"},{"content":"http协议\nhttp://localhost:8080/javaweb_day11_web/ 协议：规定客户端 与 服务器传递数据的格式 http协议的内容 请求 请求行 ：包含url信息 和 协议信息 请求头 ： 包含用户发送的数据描述信息和浏览器相关的描述信息，不需要手动，是由浏览器处理的 请求正文： 请求体中携带的数据 如：用户登录注册输入的信息 响应 响应行 ：协议信息版本号 响应头 ：服务器告诉浏览器的一些信息 响应正文：服务器响应给浏览器的源码 4. servlet 理解： servlet 是运行在 web 服务器中的小型 java 程序。servlet 通常通过 http（超文本传输协议）接收和响应来自 web 客户端的请求。 ① servlet是一个java接口 ② 需要运行在服务器中 ③ 可以处理来自客户端的请求和响应 作用： 处理来自客户端的请求和响应 使用： ① 自定义类实现servlet接口 ② 实现servlet中未实现方法 5 ③ 配置servlet的访问路径 在web.xml文件中配置 \u0026lt;!--声明servlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;myservlet1\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.ujiuye.servlet.myservlet1\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--配置访问路径--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;myservlet1\u0026lt;/servlet-name\u0026gt; \u0026lt;!--http://localhost:8080/javaweb_day11_web/xx--\u0026gt; \u0026lt;url-pattern\u0026gt;/xx\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 使用注意事项 1. servlet是由谁实例化的？ 由tomcat服务器(servlet容器)实例化的 2. servlet实例化几次？只初始化一次 3. servlet什么时候初始化的？第一次请求 4. 一个servlet可以设置多少个访问路径？可以设置多个访问路径 5. 一个路径可以访问多个servlet吗？一个路径只能映射一个servlet 6. 路径多元化 /xx 一层 /xx/xxx/xxxx 多层 /* 除去已经配置过的路径的其他任意路径 *.png 后缀的形式 浏览器请求servlet的过程 1. 当浏览器url中输入http://localhost:8080/javaweb_day11_web/xx 2. 根据/xx 匹配web.xml中的\u0026lt;servlet-mapping\u0026gt;中的\u0026lt;url-pattern\u0026gt; 3. 没有匹配到 报404未找到 如果匹配到 4. 再根据匹配到的\u0026lt;servlet-mapping\u0026gt;中的\u0026lt;servlet-name\u0026gt;,根据这个\u0026lt;servlet-name\u0026gt; 进步匹配 \u0026lt;servlet\u0026gt;中的\u0026lt;servlet-name\u0026gt; 5. 没有匹配到 报404未找到 如果匹配到 6. 根据当前的\u0026lt;servlet-name\u0026gt;找对应的\u0026lt;servlet-class\u0026gt; 7. 反射机制加载当前类 servlet的生命周期方法 init 初始化方法 默认当第一次请求servlet时执行该方法 对servlet做初始化操作。 service 处理客户端请求和响应 实现浏览器和servlet交互 destory 销毁方法 服务器关闭 移出应用 tomcat销毁当前servlet servlet的进化史 1. genericservlet抽象类 实现了servlet接口，并且实现了除service之外的其他方法 2. httpservlet 继承了genericservlet 实现service方法 根据http协议的请求方式执行不同的方法doxx,然后定义自己的service方法。开发者使用只需要重写对应请求方式的doxx 或者重写service方法注解的方式使用httpservlet ","date":"2021-12-05","permalink":"https://lovemjh.vercel.app/posts/javaee/20220430215286/","summary":"HTTP协议 http://localhost:8080/JavaWeb_day11_web/ 协议：规定客户端 与 服务器传递数据的格式 HTTP协议的内容 请求 请求行 ：包含url信息 和 协议信息 请求头 ： 包含用户发送的数据描述信息和浏览器相关的描述信","title":"http协议"},{"content":"请求与响应 一、请求 1. 理解 servletrequest接口 ----\u0026gt; httpservletrequest子接口 ----\u0026gt;httpservletrequestwrapper 实现类 ① 客户端请求将请求信息封装该对象中 ② 该对象是由servlet容器创建的，开发者只需要使用 ③ 在核心方法中直接使用 定义将客户端请求信息提供给某个 servlet 的对象。servlet 容器创建 servletrequest 对象，并将该对象作为参数传递给该 servlet 的 service 方法。 2. 作用 作用：获取请求信息： 请求行 请求头 请求正文 3. 使用 1. 获取请求行信息 string scheme = request.getscheme(); system.out.println(\u0026#34;协议：\u0026#34;+scheme); string servername = request.getservername(); system.out.println(\u0026#34;主机名：\u0026#34;+servername); int serverport = request.getserverport(); system.out.println(\u0026#34;端口号：\u0026#34;+serverport); string contextpath = request.getcontextpath(); system.out.println(\u0026#34;项目名：\u0026#34;+contextpath); string method = request.getmethod(); system.out.println(\u0026#34;请求方式：\u0026#34;+method); stringbuffer requesturl = request.getrequesturl(); system.out.println(\u0026#34;请求url：\u0026#34;+requesturl); 2. 获取请求头信息 string accept = request.getheader(\u0026#34;accept\u0026#34;); system.out.println(\u0026#34;accept：\u0026#34;+accept); system.out.println(\u0026#34;------------------------------------------\u0026#34;); enumeration\u0026lt;string\u0026gt; headernames = request.getheadernames(); while(headernames.hasmoreelements()){ string name = headernames.nextelement(); string value = request.getheader(name); system.out.println(name+\u0026#34;：\u0026#34;+value); } 3. 获取请求正文(重点) · 获取url拼接参数 //① 根据一个name获取一个value string value = request.getparameter(\u0026#34;name\u0026#34;); · 获取表单数据 // ② 获取一个name对应多个value string[] values = request.getparametervalues(\u0026#34;name\u0026#34;); // ③ 获取表单中所有的name enumeration\u0026lt;string\u0026gt; names = request.getparameternames(); // ④ 获取全部的name和 value map\u0026lt;string, string[]\u0026gt; map = request.getparametermap(); 4. beanutils实现map映射实体类对象 ① 下载导包 commons-beanutils-1.8.3.jar commons-logging-1.1.1.jar ② 使用 beanutils.populate(要映射对象, map数据); 要求：表单的name值 和 实体类的属性名 一致 5. 请求中文乱码 request.setcharacterencoding(\u0026#34;utf-8\u0026#34;); 6. 案例：注册案例 7. 转发 理解： 客户端请求资源servleta时，servleta资源不足或者没有，请求其他的资源(页面、servlet),再响应给客户端。请求其他的资源的过程叫做转发 使用： // 1. 获取转发器 requestdispatcher rd = request.getrequestdispatcher(\u0026#34;要转发资源的路径\u0026#34;); // 2. 请求转发 rd.forward(request, response); // 完全转发 rd.include(request, response); // 部分转发 使用场景：跳转页面 如：注册成功跳转登录页 二、响应 1. 理解 定义辅助 servlet 将响应发送到客户端的对象。servlet 容器创建 servletresponse 对象，并将它作为参数传递给 servlet 的 service 方法。 ① 是servlet中处理响应的对象 ② 是servlet容器 创建的 ③ 作为核心方法的参数 开发者只需要在核心方法中使用 servletresponse接口 ----\u0026gt; httpservletresponse子接口 ----\u0026gt; httpservletresponsewrapper 实现了 2. 作用 servlet中处理响应客户端的对象。可以响应文本，也可以响应字节 3. 使用 ① 文本 响应文本： printwriter writer = response.getwriter(); writer.print(\u0026#34;i am server, 这是文本信息\u0026#34;); 中文乱码问题解决： response.setcontenttype(\u0026#34;text/html; charset=utf-8\u0026#34;); ② 字节 响应字节： servletoutputstream sos = response.getoutputstream(); 文件下载案例： 文件从服务器 ----\u0026gt; 客户端 ----\u0026gt; 下载到本地磁盘 // 1. 获取请求信息 string filename = request.getparameter(\u0026#34;filename\u0026#34;); // 2. 实现下载：读入到内存 然后写出到客户端 再由客户端下载到本地 // 3. 读入内存 // 3.1 获取web目录下资源的真实路径 string realpath = request.getservletcontext().getrealpath(\u0026#34;img/\u0026#34; + filename); // system.out.println(realpath); fileinputstream fis = new fileinputstream(realpath); // 告诉浏览器 该文件需要下载 response.setheader(\u0026#34;content-disposition\u0026#34;, \u0026#34;attchment;filename=\u0026#34;+filename); // 4. 写出到客户端 servletoutputstream sos = response.getoutputstream(); // 5. 边读边写 byte[] buff = new byte[2*1024]; int len = 0; while((len=fis.read(buff))!=-1){ sos.flush(); sos.write(buff, 0, len); } // 6. 关闭 sos.close(); fis.close(); 4. 重定向 理解：\t客户端请求servleta资源，servleta没有资源servleta响应客户端携带302状态码和重定向的url地址。客户端立刻对重定向的地址发送请求。这个过程称为重定向 实现： response.sendredirect(\u0026#34;重定向地址\u0026#34;); 使用场景：跳转页面 如：登录成功跳转首页 三、转发和重定向区别 转发特点： 1. 转发是由请求发起的 2. 发生在服务器内部 3. 转发过程中请求地址不变 4. 转发只能转发内部资源 5. 转发可以转发web-inf中的资源 6. 表单提交完成之后转发不可以刷新当前页面 重定向特点： 1. 重定向是由响应发起的 2. 发生在客户端与服务器之间 3. 重定向过程请求地址发生变化 4. 重定向既可以重定向内部资源 也可以重定向外部资源 5. 重定向不可以重定向web-inf下的资源 6. 表单提交完成之后重定向可以刷新当前页面 四、作业 实现登录和注册功能 共享域 1. 理解 在servlet可以实现数据共享的对象。 2. 分类 ① servletcontext 范围最大 可以在项目的任何地方实现数据的共享 ② session 范围 一次会话中 实现数据的共享 ③ request 范围 一次请求中 实现数据的共享 3. 作用 实现servlet与servlet之间 或者 servlet与页面之间 数据的共享 4. 使用 保存数据到共享域： setattribute(string name, object value); 取共享域数据： getattribute(string name); 删除共享域数据 removeattribute(string name) cookie 和 session 一、会话 1.理解 客户端发送请求到服务器，连接成功会话开始，只有连接不断开整个过程就属于一次会话。从连接成功开始 到 服务器或者客户端断开结束。在此期间的任何请求 任何资源都属于该次会话。 2. 作用 由于http协议，无状态的特点。每次请求都是一次新的会话，有时候需要重复验证。所以用户体验太差，要解决这种问题 使用会话技术。 3. 会话技术 cookie 客户端会话 session 服务器端会话 二、cookie 1. 理解 创建一个 cookie，cookie 是 servlet 发送到 web 浏览器的少量信息，这些信息由浏览器保存，然后发送回服务器。cookie 的值可以唯一地标识客户端，因此 cookie 常用于会话管理。 1. 需要在servlet中创建 2. 保存到浏览器 3. 唯一标识客户端 保存少量数据 2. 使用 1. 创建cookie cookie cookie = new cookie(string name, string value); 2. 响应客户端 response.addcookie(cookie); 3. 获取cookie cookie[] cookies = request.getcookies(); if(cookies!=null){ for (cookie cookie : cookies) { string name = cookie.getname(); string value = cookie.getvalue(); system.out.println(name+\u0026#34;==\u0026#34;+value); } }else{ system.out.println(\u0026#34;没有cookie.....\u0026#34;); } 4. 过期时间 和浏览器无关 cookie.setmaxage(); // 单位：m +秒数 -默认浏览器会话结束 0立即销毁 5. 有效路径：只在当前的有效路径下 生效 默认当前创建cookie的servlet访问路径的上一层 cookie.setpath(路径); 3. 场景 1. 记录上次访问时间 2. 登录时的记住账号功能(作业) 3. 浏览记录 4. 特点 1. cookie保存到客户端 安全性低 2. cookie保存数据只能是字符串 不能有特殊符号 空格 分号 逗号 不能以$开头等 3. cookie保存数据大小最多4kb 4. 一个服务器可以创建多个cookie 5. cookie可以设置有效时间 从调用addcookie方法开始 到期之后销毁了 6. cookie的名字、路径、有效时间 决定了是不是同一个cookie 三、session 1. 理解 httpsession 提供一种方式，跨多个页面请求或对 web 站点的多次访问标识用户并存储有关该用户的信息。 servlet 容器使用此接口创建 http 客户端和 http 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。一个会话通常对应于一个用户，该用户可能多次访问一个站点。服务器能够以多种方式维护会话，比如使用 cookie 或重写 url。 ① session是由servlet容器创建 ② 维护客户端和服务器的会话 2. 使用 1. 创建cookie cookie cookie = new cookie(string name, string value); 2. 响应客户端 response.addcookie(cookie); 3. 获取cookie cookie[] cookies = request.getcookies(); if(cookies!=null){ for (cookie cookie : cookies) { string name = cookie.getname(); string value = cookie.getvalue(); system.out.println(name+\u0026#34;==\u0026#34;+value); } }else{ system.out.println(\u0026#34;没有cookie.....\u0026#34;); } 4. 过期时间 和浏览器无关 cookie.setmaxage(); // 单位：m +秒数 -默认浏览器会话结束 0立即销毁 5. 有效路径：只在当前的有效路径下 生效 默认当前创建cookie的servlet访问路径的上一层 cookie.setpath(路径); 3. 场景 1. 用户登录成功保存用户信息 2. 购物车 4. 特点 1. session将数据保存到服务器 相对安全 2. session可以保存任意数据 3. session保存数据的大小 没有限制 4. 一个服务器对应一个session对象 每个用户分别分配不同的id 5. session可以设置有效时间 这个时间是指两次相邻访问的时间间隔 6. session是通过jsessionid确定是否是同一次会话 隐藏特点： session数据的钝化（序列化到本地磁盘）和活化（从本地磁盘序列化到内存） 5. 总结 1. 保存数据量比较小 安全性低 数据易变 使用cookie维护会话 2. 保存的数据量较大 安全性高 数据不易变 使用session维护会话 cookie数据保存到了客户端 减轻了服务器的压力，session默认需要借助cookie使用 即使没有cookie session也可以维护会话 比如：重写url地址 ","date":"2021-12-05","permalink":"https://lovemjh.vercel.app/posts/javaee/20220430215283/","summary":"请求与响应 一、请求 1. 理解 ServletRequest接口 ----\u0026gt; HttpServletRequest子接口 ----\u0026gt;HttpServletRequestWrapper 实现类 ① 客户端请求将请求信息封装该对象中 ② 该对象是由Ser","title":"servlet"},{"content":"1. 理解 java databases connectivity 是一种独立于数据库系统、通用sql数据库存取和操作的一组接口（一组api） 2. 作用 1. jdbc提供了一组api 开发者只需要针对一组api开发即可，为开发者屏蔽了一些问题 2. jdbc为连接不同的数据库提供了统一的路径 3. 根据不同的数据库厂商提供不同的驱动 提高了维护性 3. 使用 包：java.sql.* javax.sql.* 一个类(drivermanager) 三个接口(connection、statement、resultset) 使用步骤： 1. 加载驱动 class.forname(\u0026#34;com.mysql.jdbc.driver\u0026#34;) 2. 获取连接 connection conn = drivermanager.getconnection(\u0026#34;jdbc:mysql://localhost:3306/库名\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;密码\u0026#34;) 3. 创建命令对象 statement st = conn.createstatement(); 4. 编写sql string sql = \u0026#34;\u0026#34;; 5. 执行命令 返回结果 resultset rs = st.executequery(sql); // 执行查询 int row = st.executeupdate(sql); // 执行增删改 6. 处理结果 7. 关闭资源 rs.close(); st.close(); conn.close(); jdbc优化 1. 优化1：sql注入 1. sql注入问题： sql中出现了特殊的字符 导致sql语句发生变化 引发结果不正确 2. 解决： 使用preparedstatement预编译命令接口 替代 statement接口 3. 原理： ·对sql语句先编译 检查传递的内容 如果出现了特殊字符 给转义 ·sql语句中使用? 作为占位符 只对?的内容 检查转义 4. preparedstatement是statement的子接口 · 避免sql中拼接变量 引发问题 · 复用sql语句 2. 优化2：连接对象 1. 连接池的必要性 · 连接资源没有得到复用，导致连接资源创建很多次 占用系统资源 · 连接资源创建和关闭都需要时间 导致程序效率降低 · 过多的连接请求导致 数据库系统宕机 · 连接资源不关闭 造成内存泄漏 2. 连接池的好处 · 提高连接资源的复用性 · 提高系统的执行效率 连接资源统一由连接池管理 · 合理的分配 连接资源 · 减少数据库宕机的可能性 3. 开源的连接池 · dbcp连接池 · c3p0连接池 · druid连接池 4. 连接池的使用 c3p0使用： 1. 下载导包 c3p0-0.9.5.2.bin.zip 2. 引入jar c3p0-0.9.5.2.jar mchange-commons-java-0.2.11.jar 3. 编写代码 方式1:代码配置 方式2：配置文件方式 (推荐使用) ① 在src下创建 c3p0.properties ② 在c3p0.properties 配置数据源 ③ 创建连接池对象 // 1. 创建连接池对象 combopooleddatasource cpds = new combopooleddatasource(); // 2. 使用 connection = cpds.getconnection(); druid使用 1. 下载导包 druid-1.1.10.zip 2. 引入 jar druid-1.1.10.jar 3. 编码 ① 在src下创建 druid.properties ② 在druid.properties 配置数据源 ③ 使用 // 1. 读取配置文件 properties properties = new properties(); inputstream is = thread.currentthread().getcontextclassloader() .getresourceasstream(\u0026#34;druid.properties\u0026#34;); properties.load(is); //2. 创建连接池对象 datasource datasource = druiddatasourcefactory.createdatasource(properties); // 3. 使用 connection = datasource.getconnection(); 3. 优化3：封装连接池工具类 封装连接池工具类 连接池只被创建一次 1. 将连接池的创建 封装到静态代码块中 2. 获取连接池对象的方法 静态方法 4. 优化4：连接对象线程安全 jdk1.2 threadlocal类 原理： 将有可能引发线程安全的对象，绑定在threadlocal中。将该对象复制一份作为本地线程的局部变量，该对象只能当前线程使用。因此源对象不会发生任何变化，所以解决了线程安全问题。 使用： ① 将线程安全问题的对象绑定到threadlocal private static threadlocal\u0026lt;connection\u0026gt; tl = new threadlocal\u0026lt;\u0026gt;(); ② 获取绑定的连接对象 connection conn = tl.get(); ③ 绑定连接对象到 tl.set(conn); ④ 解绑 tl.remove() package com.ujiuye.utils; import com.alibaba.druid.pool.druiddatasourcefactory; import javax.sql.datasource; import java.io.ioexception; import java.io.inputstream; import java.sql.connection; import java.sql.sqlexception; import java.util.properties; /* * 封装连接池工具类 连接池只被创建一次 * 1. 将连接池的创建 封装到静态代码块中 * 2. 获取连接池对象的方法 静态方法 * 3. 释放连接对象 静态方法 * * * * */ public class jdbcutils { // 1. 解决线程安全问题 实例化threadlocal private static threadlocal\u0026lt;connection\u0026gt; tl = new threadlocal\u0026lt;\u0026gt;(); static datasource datasource; static { try { // 1. 读取配置文件 properties properties = new properties(); inputstream is = thread.currentthread().getcontextclassloader() .getresourceasstream(\u0026#34;druid.properties\u0026#34;); properties.load(is); // 2. 创建连接池对象 datasource = druiddatasourcefactory.createdatasource(properties); } catch (exception e) { e.printstacktrace(); } } // 获取连接 public static connection getconnection() throws sqlexception { // 1. 先从threadlocal中获取连接对象 connection connection = tl.get(); // 2. 判断是否 已经绑定 if(connection==null){ // 3. 从池子中获取连接 connection = datasource.getconnection(); // 4. 将该连接绑定到threadlocal上 tl.set(connection); } return connection; } // 1. 封装释放的方法 public static void release(){ // 1. 获取绑定上的连接 connection connection = tl.get(); if(connection!=null){ // 2. 解绑 tl.remove(); // 3. 放回池子 try { connection.close(); } catch (sqlexception e) { e.printstacktrace(); } } } } 5. 优化5：dbutils工具类 理解：\tdbutils工具类 是 apacha提供的将操作数据库的步骤 和 返回结果为了封装 使用： 1. 下载导包 commons-dbutils-1.7-bin.zip 2. 导入jar commons-dbutils-1.7.jar 3. 使用 ① 创建核心对象 queryrunner qr = new queryrunner(); ② 调用方法 // 执行增删改 int row = qr.update(conn, sql, sql中参数); // 执行查询 // beanhandler 映射一个对象 // beanlisthandler 映射多个对象 返回list // scalehandler 返回聚合结果 qr.query(conn,sql, resultsethandler,object...obj) 6. 优化6：封装通用dao 想法：\t每一个表都有dbutils 增删改查的功能，通过面向对象的继承思想。将增删改查的封装到父类中，只需要创建子类继承父类 子类具有了增删改查的功能。 封装： package com.ujiuye.dao; import com.ujiuye.utils.jdbcutils; import org.apache.commons.dbutils.queryrunner; import org.apache.commons.dbutils.handlers.beanhandler; import org.apache.commons.dbutils.handlers.beanlisthandler; import org.apache.commons.dbutils.handlers.scalarhandler; import java.sql.sqlexception; import java.util.list; /** * 封装增删改查的通用类 * 1. 封装增删改功能 * 2. 单查功能 * 3. 多查功能 * 4. 查个数功能 */ public class basicdao\u0026lt;t\u0026gt; { queryrunner qr; { qr = new queryrunner(); } // 1. 增删改 public int update(string sql, object...params){ try { return qr.update(jdbcutils.getconnection(), sql, params); } catch (sqlexception e) { throw new runtimeexception(e); } finally { jdbcutils.release(); } } // 2. 单查 public t querysingle(string sql, class\u0026lt;t\u0026gt; clazz, object...params){ try { return qr.query(jdbcutils.getconnection(), sql, new beanhandler\u0026lt;\u0026gt;(clazz), params); } catch (sqlexception e) { throw new runtimeexception(e); } finally { jdbcutils.release(); } } // 3. 多查 public list\u0026lt;t\u0026gt; querymore(string sql, class\u0026lt;t\u0026gt; clazz, object...params){ try { return qr.query(jdbcutils.getconnection(), sql, new beanlisthandler\u0026lt;\u0026gt;(clazz), params); } catch (sqlexception e) { throw new runtimeexception(e); } finally { jdbcutils.release(); } } // 4. 查个数 public object scale(string sql, object...params){ try { return qr.query(jdbcutils.getconnection(), sql, new scalarhandler\u0026lt;\u0026gt;(), params); } catch (sqlexception e) { throw new runtimeexception(e); } finally { jdbcutils.release(); } } } 总结 jdbc最终使用步骤： 1. 导入第三方jar mysql-connector-java-5.1.44-bin.jar druid-1.1.10.jar commons-dbutils-1.7.jar 2. 导入数据源 配置文件 引入src目录 druid.properties 3. 导入连接池工具类jdbcutils 4. 导入通用dao 5. 创建类继承dao 一、补充 ####1. junit单元测试\n* 测试：白盒测试(代码测试) 黑盒测试(功能性测试) * junit单元测试用法 * 1. 自定类 * 2. 定义测试方法 (可以多个) * public修饰 无返回值 无参 @test注解 * 3. 常见注解 * * @beforeclass 测试方法执行之前执行 只执行一次 * @before 每个测试方法执行之前 都会执行一次 @test 标注当前方法为测试方法 @after 每个测试方法执行之后 都会执行该方法 @afterclass 测试方法执行完毕之后执行 只执行一次 2. 事务 1. 开启事务 conn.setautocommit(false); 2. 成功 提交事务 conn.commit(); 3. 失败 回滚事务 conn.rollback() 3. 批处理 1. 添加批处理 ps.addbatch(); 2. 执行批处理 ps.executebatch(); 3. 清除批处理 ps.clearbatch ","date":"2021-12-02","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430214396/","summary":"1. 理解 Java Databases Connectivity 是一种独立于数据库系统、通用SQL数据库存取和操作的一组接口（一组API） 2. 作用 1. JDBC提供了一组API 开发者只需要针对一组API开发即可，为开发","title":"jdbc"},{"content":"一、mysql高级 1. 视图 理解\t简化查询的过程，其结果是提供数据查询的安全性的虚拟表，视图中保存的仅仅是一条select语句，保存的是视图的定义，并没有保存真正的数据。所以视图称为虚拟表。 作用 1. 确保数据的安全性，防止未经允许访问到敏感数据 2. 封装了查询的过程，简化sql语句 3. 视图屏蔽了真实的表结果 使用 2. 存储过程 理解\t是一种存储复杂的程序，便于外部调用的对象。类似于java中的方法。存储过程完成特定功能的sql语句集，用户可以通过调用传参执行存储过程 作用 1. 提高sql语句的封装和重用 2. 存储过程是安全的 使用 3. 触发器 理解 是一个特殊的存储过程，不需要手动调用，而是被自动调用的存储过程 作用 1. 监听数据表表中数据变化的 2. 当数据发生某种变化触发触发器执行 3. 协助应用对数据操作的完整性 触发触发器时机 before insert after insert before delete after delete before update after update 使用 4. 存储引擎 理解： 存储库 表和数据的相关结构 分类 myisam 表名.frm：存储表结构(列名、类型等) 表名.myi：存储表的索引信息 表名.myd：存储表中数据 特点： 1. 做插入 查询效率高 2. 不支持事务 外键 3. 支持全文索引 表级锁 innodb 表名.frm：存储表结构(列名、类型等) ibdate1：共享表空间 存储所有数据和索引信息 特点： 1. 支持事务 外键 2. 不支持全文索引 3. 支持行级锁，在高并发的情况下效率高 5. 索引 理解 是一种特殊的文件，包含对数据的引用指针。通俗的理解 索引类似于一本书的目录。目的加快数据库的查询效率。 分类 主键索引 ： 唯一不能为null 一个表一个 加快了查询 唯一索引 ： 唯一但是可以为null 一个表可以多个 加快了查询 外键索引 ： 关联表 普通索引 ： 加快查询 组合索引 ： 多条件查询 加快查询 需要创建索引 1. 主键索引 每一个表创建 2. 频繁的作为条件的字段 创建索引 提高查询效率 3. 作为排序条件的字段 创建索引 提高排序效率 4. 作为分组字段 统计字段 创建索引 5. 与其他表有关系的字段 指定外键索引 最好不创建索引 1. 表的数据比较少 2. 经常增删改的表或者字段 3. where条件中不用的字段 6. 锁机制 理解： 锁计算机协调多个进程或线程并发访问同一个资源的一种处理机制。数据也是多用户共享的资源，保证数据的一致性 有效性。 锁的分类： 1. 多数据操作类型分为：读锁 和 写锁 读锁(共享锁)：针对同一份数据 多个读操作可以同时进行而且不会相互影响 写锁(排它锁)：当前写操作没有完成，阻断其他的写操作 select ..... for update 2. 范围分类 表锁 对表加锁 行锁 对行数据加锁 3. 用法： 悲观锁 乐观锁 间隙锁 select .... where id \u0026gt;= 100 for update 死锁 二、总结 sql语句 ddl、dml(重点)、dql(重点)、dcl、事务(重点) 高级(了解)： 视图、存储过程、触发器、存储引擎、索引、锁机制 ","date":"2021-12-01","permalink":"https://lovemjh.vercel.app/posts/001/20220430223848/","summary":"一、MySQL高级 1. 视图 理解 简化查询的过程，其结果是提供数据查询的安全性的虚拟表，视图中保存的仅仅是一条select语句，保存的是视图的定义，并没有保存真正的数","title":"mysql高级"},{"content":"sql命令 分类 ddl 数据定义语言 数据库的创建和删除、数据表的创建、删除和修改 关键字：create / drop / alter dml 数据操作语言 数据库表中数据的增删改 dql 数据查询语言 数据表中数据的查询 dcl 数据控制语言 创建用户分配权限 事务 ddl 1. ddl 数据定义语言数据库的创建和删除、数据表的创建、删除和修改 · 库操作 1. 查看所有库：show databases 2. 创建数据库：create database if not exists 库名; 3. 删除数据库：drop database if exists 库名; 4. 查看数据库命令：show create database 库名; · 表操作 1. 创建表： create table if not exists 表名( 列名1 类型 【约束】, 列名2 类型 【约束】, ...... ) 2. 查看表结构：desc 表名; 3. 删除表：drop table if exists 表名; 4. 表修改 ① 修改表名：alter table 原表名 rename 新表名 ② 修改列表：alter table 表名 change 【column】 原列名 新列名 类型 【约束】; ③ 修改列的类型：alter table 表名 modify 【column】 列名 新类型 【约束】； ④ 添加列：alter table 表名 add 【column】列名 类型 【约束】; ⑤ 删除列：alter table 表名 drop 【column】列名; 5. 约束操作 ① 主键删除 alter table 表名 drop primary key; # 表级删除 alter table 表名 modify column 字段名 类型 ; # 列级删除 ② 主键添加 alter table 表名 add primary key(列名);# 表级添加 alter table 表名 modify column 字段名 类型 primary key # 列级添加 ③ 非空删除 alter table 表名 modify column 列名 类型 null; ④ 非空添加 alter table 表名 modify column 列名 类型 not null; ⑤ 默认删除 alter table 表名 modify column 列名 类型; ⑥ 默认添加 alter table 表名 modify column 列名 类型 default \u0026#39;\u0026#39;; ⑦ 唯一删除 alter table 表名 drop index 列名; ⑧ 唯一添加 alter table 表名 add unique(列名); # 表级添加 alter table 表名 modify column 列名 类型 unique; # 列级添加 ⑨ 外键添加 alter table 从表名 add constraint 外键名 foreign key(从表字段) references 主表(主表主键); ⑩ 外键删除 alter table stu drop foreign key 外键名; alter table stu drop index 外键名; mysql常见类型： 整型：tinyint/smallint/int/bigint 浮点型：double(n, m)/float(n, m)/decimal(n, m) n 代表：整数和小数总位数 m 代表：小数的位数 字符型： char(n)\t定长字符串 n可以不写 默认1 性能高 varchar(n) 变长字符串 n必须写 最大长度 性能低 日期类型： date 年月日 datetime 年月日 时分秒 8个字节 1900 ~ 9999 time 时分秒 timestamp 年月日 时分秒 4个字节 1970 ~ 2038 mysql约束 约束是限制 表中数据的 一种要求 约束： 1. 默认约束 default \u0026#39;内容\u0026#39; 2. 非空约束 not null 3. 主键约束 primary key 唯一 不能为null 一个表有且仅有一个主键 4. 唯一约束 unique 唯一 可以为null null可以多个 5. 外键约束 建立两表之间的关系，一个表的某一列 来源于另一个表的主键值 dml 1. 增(插入) 语法： insert into 表名(列名1, 列名2,...) values(值1, 值2,....) insert into 表名(列名1, 列名2,...) values(值1, 值2,....),(值1, 值2,....),(值1, 值2,....).... 注意事项： 1. 列名和值要一一对应 2. 插入值的类型 匹配列名的类型 3. 整型 浮点型值可以不加引号，字符类型和日期类型 必须加引号 4. 不区分单双引号 5. 如果约束有默认约束和可以为空的列 值可以不写 对应列也不写 6. 如果表中所有列都给数据 列名可以省略不写 2. 删 语法： delete from 表名 where 条件 全部删除 truncate table 表名; 【delete和truncate区别】 ① delete可以加where truncate 不可以 ② delete删除可以回滚 truncate 不可以 ③ delete 删除自增字段时 下次添加自增效果仍然以删除之前自增 truncate 删除自增字段再次添加重新开始 ④ delete 一条一条数据删除 truncate 删除整个表 然后再创建新表 truncate效率高 3. 修改 语法： update 表名 set 列名1=新值, 列名2=新值,... where 条件 注意： 1. where 条件要加 否则修改所有数据 dql 数据查询语言，查询数据库表中的数据。查询的结果为虚拟表\n基础查询 语法：select 查询列表 from 表名; 特点： 1. 查询列表可以是 常量、变量、函数、表达式、字段名或者组合 2. 查询数据来源于表 加 from 否则不加 3. 查询列表为虚拟表的列名 条件查询 语法： select 查询列表 from 表名 where 条件; 特点： 1. 条件形式 有多种： 条件表达式：\u0026gt; \u0026lt; \u0026gt;= \u0026lt;= !=或者\u0026lt;\u0026gt; = 逻辑表达式：and(\u0026amp;\u0026amp;) or(||) not(!) 模糊表达式：like / between...and... / not null 排序查询 语法： select 查询列表 from 表名 where 条件 order by 排序列表 asc|desc; 特点： 1. order by 必须写在where后 2. 排序列表：单字段名、表达式、函数、别名、多字段名或者组合 3. asc 升序(默认) desc降序 常见函数 1. 单行函数：传递一个参数返回一个结果 字符函数： length(); 获取字符长度 upper(); 转大写 lower(); 转小写 lpad(); 左填充 rpad(); 右填充 substr(); 截取字符串 trim(); 去除两侧空格 concat(); 拼接字符串 数值函数： ceil(); 向上取整 floor(); 向下取整 abs(); 绝对值 round(); 四舍五入 rand(); 随机数 0-1 mod(); 取余 truncate(); 截取数值 日期函数： now(); 获取当前的日期+时间 curdate(); 获取当前的日期 curtime(); 获取当前的时间 year()/ month()/day() date_format(); 格式化日期 流程控制 1. if() 2. 等价于 if(){}else if(){}else if(){}....else{} case when 条件1 then 值1 when 条件2 then 值2 ..... else end 2. 多行函数：传递一组参数返回一个结果 sum(); 求和 avg(); 平均值 max(); 最大值 min(); 最小值 count(); 个数 特点： 1. 分组函数中可以传递列名、表达式 2. 多行函数自动忽略null值 3. 多行函数支持类型 sum avg 只支持数值类型 max min count支持任意类型 分组查询 语法： select 查询列表 ----- ④ from 表名\t------ ① where 分组之前条件 ------ ② group by 分组字段 ------ ③ having 分组后条件 ------ ⑤ order by 排序列表 asc|desc; ----- ⑥ 特点: 1. 分组查询查询列表中只能查询到分组函数和分组字段 2. 分组查询执行顺序 后执行可以使用前执行的别名 分页查询 语法： select 查询列表 from 表名 where 分组前条件 group by 分组字段 having 分组后条件 order by 排序列表 asc|desc limit 偏移量, 个数 特点： 1. 偏移量 跳过前面的个数 2. 个数 一页要查询的个数 连接查询 又叫多表查询，查询的内容来自于多个表，此时需要将多个表连接起来查询\n表之间的关系 ① 一对一的关系 如：妻子和丈夫 将从表中的主键与主表中的主键建立外键关系\n② 一对多和多对一 如：员工和部门 或者 学生和班级\n③ 多对多 如：学生和科目 需要使用中间表，两表与中间表建立外键关系\n连接查询 内连接查询 1. 隐式内连接(sql92) 语法： select 查询列表 from 表1 别名1, 表2 别名2,... where 连接条件 and 分组前条件 group by 分组字段 having 分组后条件 order by 排序列表 asc|desc limit 偏移量, 个数 特点： 1. 连接条件一定要加 否则出现笛卡尔乘积现象 n*m 2. 通过where添加连接条件 3. from后的表名顺序可以随意调整 不影响结果 4. 根据连接条件分类 ① 等值内连接 ② 非等值内连接 ③ 自连接 5. n表连接 连接条件至少n-1个 2. 显示内连接(sql99) 语法： select 查询列表 from 表1 别名1 inner join 表2 别名2 on 连接条件 .... where 分组前条件 group by 分组字段 having 分组后条件 order by 排序列表 asc|desc limit 偏移量, 个数 特点： 1. 连接条件需要添加 2. on后加连接条件 3. 表的顺序可以随意调换 不影响结果 4. 根据连接条件分类 ① 等值内连接 ② 非等值内连接 ③ 自连接 5. n表连接 连接条件至少n-1个 外连接查询(sql99) 语法: select 查询列表 from 表1 别名1 left|right outer join 表2 别名2 on 连接条件.... where 分组前条件 group by 分组字段 having 分组后条件 order by 排序列表 asc|desc limit 偏移量, 个数 特点： 1. 分为左外连接 和 右外连接 2. left outer 左外连接指 左表为主表(所有数据查询) 右表为副表(有对应主表的数据查询) 查询结果 = 主表中所有数据、副表中有对应关系的数据 以及与主表中没有对应关系的显示为null 3. right outer 右外连接指 右表为主表(所有数据查询) 左表为副表(有对应主表的数据查询) 查询结果 = 主表中所有数据、副表中有对应关系的数据 以及与主表中没有对应关系的显示为null 4. 表之间的顺序不能随意调换，否则会影响结果 子查询 一个查询语句中嵌套了另一个完整的查询语句，被嵌套的语句称为子查询或内查询，外面的语句称为主查询或外查询 语法： select (子查询) from (子查询) where (子查询) 特点： 1. 子查询写在小括号中 2. 子查询优先主查询执行 主查询用到子查询的结果 3. 子查询的结果 ① 单行子查询 子查询的结果只有一个 搭配符号：= \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= \u0026lt;\u0026gt; ② 多行子查询 子查询结果有多个 搭配符号：in / all / any 原则： 能用单表 不使用多表 能用多表不用子查询 dcl dcl 数据控制语言 创建不同的用户指定不同的权限\n事务 理解 完成某个功能的整个过程，称为一个事务。mysql数据默认一个命令是一个事务\n作用 多个语句同生共死：只要所有语句都成功了 才成功 只要有一个语句失败了 恢复到执行之前的状态\n使用：\n4. 事务的特性 ① 原子性 事务是不可分割的 ② 一致性 数据的一致性 ③ 持久性 事务完成之后数据是持久化存储的 ④ 隔离性 事务与事务之间的隔离 隔离级别：低 ---\u0026gt; 高 1. 读未提交 read uncommitted 引发问题：脏读 解决：提高隔离级别 2. 读已提交 read committed 引发问题：不可重复读 解决：提升隔离级别 3. 可重复读 repeatable read 引发问题：幻读 4. 串行化 ","date":"2021-11-30","permalink":"https://lovemjh.vercel.app/posts/001/20220430223589/","summary":"SQL命令 分类 DDL 数据定义语言 数据库的创建和删除、数据表的创建、删除和修改 关键字：create / drop / alter DML 数据操作语言 数据库表中数据的增删改 DQL 数据查询语言 数据表中数","title":"sql命令01"},{"content":"\n一、理解 可以持久化保存数据库的软件，便于操作。\n二、作用 保存数据的技术：变量、对象、数组、集合 保存在内存 io 数据的操作不友好 数据库： 1. 数据库保存数据 有组织 有结构 2. 可以实现数据的持久化保存 3. 便于对数据操作(增删改查) 4. 提供了操作数据库的sql语句(命令) 三、数据库分类 关系型数据库 非关系型数据库 四、mysql 1. 下载安装 下载地址：https://dev.mysql.com/downloads/ 安装：参考\u0026lt;\u0026lt;mysql安装过程\u0026gt;\u0026gt; 卸载： ① 卸载应用 ② 删除残留文件：安装的目录下 d:\\programdata\\mysql d:\\program files\\mysql ③ 检查注册表 ④ 关机 开启重新安装 测试： 1. 关闭mysql服务：net stop mysql服务名 2. 开启mysql服务：net start mysql服务名 3. 连接：mysql 【-hip地址】 -u用户名 -p密码 数据库结构 1. 一个dbms数据库系统中保存 多个 数据库 2. 一个数据库 中保存 多张表 3. 一张表中 可以保存 多条数据 表头（列名或者字段名）+ 每一条数据 ","date":"2021-11-29","permalink":"https://lovemjh.vercel.app/posts/001/20220430223384/","summary":"一、理解 可以持久化保存数据库的软件，便于操作。 二、作用 保存数据的技术：变量、对象、数组、集合 保存在内存 IO 数据的操作不友好 数据库： 1. 数据库保存数据 有组织 有结构 2. 可","title":"mysql数据库"},{"content":"一、jquery ####1. 理解\n1. 写更少的代码 做更多的事情 2. jquery是js的函数库 3. 优化了html文档操作、事件处理 2. 使用 ① 下载代码库 jquery-3.5.1.min.js 压缩版本 jquery-3.5.1.js 未压缩 ② 引入页面中 \u0026lt;!-- 1. 引入jquer库 --\u0026gt; \u0026lt;script src=\u0026#34;js/jquery-3.5.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3. 语法 1. 核心函数 $() · $(function(){}) 等价于 window.onload = function(){} 区别： jquery中$(function(){}) 可以使用多次 js中的window.onload = function(){} 只能使用1次 · $(选择器) 获取标签元素 2. jquery对象： 是一组js对象 可以相互转换 // 1. jquery对象 转换成 js对象 ps.get(0).style.color = \u0026#34;pink\u0026#34;; ps[1].style.color = \u0026#34;yellow\u0026#34;; // 2. js 对象 转换成jquery $(h2).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); 4. 选择器 分类： 1. 基本选择器\t2. 层级选择器 3. 属性选择器 4. 表单选择器 #####基本选择器\n$(\u0026#34;#id值\u0026#34;) $(\u0026#34;.class值\u0026#34;) $(\u0026#34;标签名\u0026#34;) $(\u0026#34;*\u0026#34;) $(\u0026#34;#id,.class,标签\u0026#34;) 层级选择器 属性选择器 #####表单选择器 5.dom操作函数 1. 文档操作 内部插入 外部插入 包裹 替换 删除 2. 属性操作 3. 样式操作 css 6. 事件 js\tjquery xx.onclick = function(){} ====\u0026gt;\txxx.click(function(){}) xx.onchange = function(){} ====\u0026gt; xxx.change(function(){}) ...... 7. 遍历 二、jquery插件 https://www.jq22.com/ 表单校验插件 1. 下载 2. 导入 \u0026lt;!-- 1. 导入jquery库 --\u0026gt; \u0026lt;script src=\u0026#34;js/jquery-3.5.1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 2. 导入validate库 --\u0026gt; \u0026lt;script src=\u0026#34;js/jquery.validate.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 3. 中文库 --\u0026gt; \u0026lt;script src=\u0026#34;js/messages_zh.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3. 编码 ","date":"2021-11-26","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430215029/","summary":"一、jQuery ####1. 理解 1. 写更少的代码 做更多的事情 2. jQuery是js的函数库 3. 优化了HTML文档操作、事件处理 2. 使用 ① 下载代码库 jquery-3.5.1.min.js 压缩版本 jquery-3.5.1.js 未压缩 ② 引入页面中 \u0026lt;!--","title":"jquery"},{"content":"一、javascript 1. 理解 javascript，简称js 一种函数式优先轻量级、解释性(即时编译性)的高级编程语言。 开发web页面的脚本语言而出名，也支持面向对象、命令式和声明式的风格 2. 作用 html页面中标签 添加动态效果，增强了用户的体验 3. 使用 使用方式1：在html中的script标签中引入js代码 \u0026lt;!-- 方式1：内部使用 --\u0026gt; \u0026lt;script\u0026gt; // 写js代码 function tan(){ // 弹框 alert(\u0026#34;点我干啥！\u0026#34;) } \u0026lt;/script\u0026gt; 注意：script标签可以写在页面的任何位置 使用方式2：外部使用 在外部定义.js文件 通过\u0026lt;script\u0026gt;引入到该页面中 \u0026lt;!-- 方式2：外部使用 推荐使用 --\u0026gt; \u0026lt;script src=\u0026#34;js/xx.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 二、js的组成 ecmascript：整个js的语法标准，统一了基本语法、对象、函数等的定义 dom：document object model 文档对象模型 可以实现对页面中的标签的操作 bom：browser object model 浏览器对象模型 与浏览器交互 三、ecmascript 1. 变量 语法：var 变量名 = 初始值; 注意：js中变量可以不给初始值 2. 数据类型 （5种） // 2. 数据类型 // 2.1 number 数值类型 包含整数和小数 // typeof 获取变量的类型 console.log(typeof(a)); // number类型 var b = 3.14; console.log(typeof(b)); // number类型 // 2.2 string 字符类型 var str = \u0026#34;hello\u0026#34;; var str1 = \u0026#39;a\u0026#39;; console.log(typeof(str)); console.log(typeof(str1)); // 2.3 boolean 布尔型 true/false var b = true; console.log(typeof(b)) // 2.4 undefined 未定义类型 var x; console.log(x); // 2.5 object 类型 null {} new var n = null; console.log(typeof(n)) var person = { \u0026#34;name\u0026#34;: \u0026#34;xx\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;sayhello\u0026#34;: function(){ alert(\u0026#34;aaaa\u0026#34;); } } person.sayhello(); console.log(typeof(person)); console.log(\u0026#34;========================\u0026#34;) var obj = new object(); console.log(typeof(obj)); 3. 运算符 · 赋值运算符： = += -= *= /= %= · 算术运算符： + - * / % ++ -- · 比较运算符： \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= == != === · 逻辑运算符： \u0026amp;\u0026amp; || ! · 位运算符： \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026lt;\u0026lt;\u0026lt; \u0026gt;\u0026gt;\u0026gt; ^ · 三目运算符： 表达式?值1:值2 4. 流程控制与java用法一致 if(){} if(){}else{} if(){}else if(){}else if(){}......else{} switch(){case:} while(){} do{}while() for(){} 5. 函数的定义 等价于 java中的方法 function对象 // 1. 无参无返回值函数 // 1.1 定义 function func1(){ // alert(\u0026#34;无参无返回值函数\u0026#34;); } // 1.2 调用 func1(); // 2 有参无返回值的函数 function func2(xx){ // alert(\u0026#34;有参无返回值函数：\u0026#34;+xx); } func2(\u0026#34;haha\u0026#34;); // 3. 无参有返回值 function func3(){ return \u0026#34;嘿嘿\u0026#34;; } var info = func3(); console.log(info); // 4. 有参有返回值 function func4(name, age, sex){ return name+\u0026#34;:\u0026#34;+age+\u0026#34;:\u0026#34;+sex; } var result = func4(\u0026#34;小王吧\u0026#34;, 18, \u0026#34;未知\u0026#34;); console.log(result) // 5. 匿名函数 var xx = function(){ alert(\u0026#34;我是匿名函数\u0026#34;); } // 调用匿名函数 xx(); 四、常见的事件 \u0026lt;!-- 1. 点击事件 --\u0026gt; \u0026lt;button onclick=\u0026#34;func1()\u0026#34;\u0026gt;点击按钮\u0026lt;/button\u0026gt; \u0026lt;!-- 2. 双击事件 --\u0026gt; \u0026lt;button ondblclick=\u0026#34;func2()\u0026#34;\u0026gt;双击按钮\u0026lt;/button\u0026gt; \u0026lt;!-- 3. 内容改变事件 --\u0026gt; \u0026lt;input onchange=\u0026#34;func3()\u0026#34; type=\u0026#34;text\u0026#34; \u0026gt; \u0026lt;!-- 4. 焦点的获取和失去事件 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onfocus=\u0026#34;getfunc4()\u0026#34; onblur=\u0026#34;losefunc4()\u0026#34;/\u0026gt; \u0026lt;!-- 5. 鼠标的悬停和失去事件 --\u0026gt; \u0026lt;div id=\u0026#34;d1\u0026#34; style=\u0026#34;width: 100px; height: 100px; border: 1px solid blue;\u0026#34; onmouseover=\u0026#34;func5()\u0026#34; onmouseout=\u0026#34;func6()\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 6. 键盘的按下和抬起事件 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; onkeydown=\u0026#34;func7()\u0026#34; onkeyup=\u0026#34;func8()\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; // 1. 点击事件 function func1(){ // 2. 弹警告框 alert(\u0026#34;点击事件触发....\u0026#34;) } // 2. 双击事件 function func2(){ alert(\u0026#34;双击事件触发.....\u0026#34;) } // 3. 内容改变事件 function func3(){ console.log(\u0026#34;内容变化了\u0026#34;); } // 4. 焦点的获取和失去事件 function getfunc4(){ console.log(\u0026#34;获取了焦点...\u0026#34;) } function losefunc4(){ console.log(\u0026#34;失去了焦点...\u0026#34;) } // 5. 鼠标悬停和失去事件 function func5(){ // 1. 通过id获取标签对象 var d1 = document.getelementbyid(\u0026#34;d1\u0026#34;); // 2. 改变背景颜色 d1.style.backgroundcolor = \u0026#34;red\u0026#34;; } function func6(){ // 1. 获取标签对象 var d1 = document.getelementbyid(\u0026#34;d1\u0026#34;); // 2. 改变背景颜色 d1.style.backgroundcolor = \u0026#34;white\u0026#34;; } // 6. 键盘按下和抬起事件 function func7(){ console.log(\u0026#34;键盘按下事件触发了.......\u0026#34;) } function func8(){ console.log(\u0026#34;键盘抬起事件触发了.......\u0026#34;) } \u0026lt;/script\u0026gt; 五、常见的弹框 1. 弹警告框 alert(信息) 2. 弹提示框 confirm(提示信息) 确定返回true 取消 返回false 3. 弹输入框 prompt(提示信息) 返回输入框的值 六、定时器 1. 一次性定时器 创建定时器：var id = settimeout(执行的任务, 到期时间); 清除定时器：cleartimeout(id); 七、js获取标签元素 1. 根据id值获取 var b = document.getelementbyid(\u0026#34;id值\u0026#34;); 2. 根据class值获取: 返回 divs:[object htmlcollection] var eles = document.getelementsbyclassname(\u0026#34;class值\u0026#34;); 3. 根据标签名获取 divs:[object htmlcollection] var eles = document.getelementsbytagname(\u0026#34;标签名\u0026#34;); 4. 根据标签的name 属性获取 返回：divs:[object nodelist] var eles = document.getelementsbyname(\u0026#34;name值\u0026#34;); 八、js常见对象 1. 数组array 1. 创建数组 var arr = new array(5); var arr = new array(); var arr = [1,2,3,4,5] 2. js数组的特点 长度是可变的 数组的数据类型可以任意类型 数组的数据可以是双列数组 3. 数组的操作(增删改查) 添加数据 ① arr[index] = value ② arr.push(value) 删除数据 delete arr[index] 修改 arr[index] = 新值 查(遍历) for(var index in arr){ console.log(arr[index]); } 4. 数组中常见函数 join() 将数组中的数据通过某字符拼接成字符串 push() 数组添加数据 2. 字符串对象 1. 创建字符串 var str = \u0026#34;\u0026#34;; var str = new string(\u0026#34;\u0026#34;); 2. 常见函数 str.length; 回去字符串长度 str.startswith(); 判断字符串是否以某个字符开头 str.endswith(); 判断字符串是否以某个字符结尾 截取字符串 str.substring(起始坐标,结束坐标); 包含起始 不包含结束 str.substr(起始坐标, 截取个数); 包含起始 拆分字符串 str.split(); 返回数组 3. 日期对象 // 1. 获取日期 // thu nov 25 2021 11:24:26 gmt+0800 (中国标准时间) var d = new date(); console.log(d); // 2. 日期api var year = d.getfullyear(); // 获取年份 console.log(year); var month = d.getmonth()+1; // 获取月份 console.log(month); var day = d.getday(); // 获取当周的第几天 console.log(day); var dd = d.getdate(); // 获取当月的第几天 console.log(dd); var hours = d.gethours(); // 时间 console.log(hours); var minutes = d.getminutes(); // 分钟 console.log(minutes); var second = d.getseconds(); // 秒数 console.log(second); var date = year + \u0026#34;-\u0026#34; + month + \u0026#34;-\u0026#34; + dd + \u0026#34; \u0026#34; + hours + \u0026#34;:\u0026#34; + minutes + \u0026#34;:\u0026#34; + second; document.write(\u0026#34;当前日期和时间：\u0026#34;+date); 4. 定时器 循环定时器 创建定时器：var x = setinterval(执行任务, 间隔时间); 清除定时器：clearinterval(x) 九、dom document object model 文档对象模型 页面中的标签元素都可以通过document操作（增删改查） 查(获取) ① 通过标签的id属性获取标签元素, 返回：标签元素 var e = document.getelementbyid(\u0026#34;id值\u0026#34;); ② 通过标签名 获取标签元素 返回：htmlcollection var eles = document.getelementsbytagname(\u0026#34;标签名\u0026#34;); ③ 通过class值获取标签元素 返回：htmlcollection var eles = document.getelementsbyclassname(\u0026#34;class值\u0026#34;); ④ 通过name值获取标签元素 返回：nodelist var eles = document.getelementsbyname(\u0026#34;name值\u0026#34;); 注意： 整个页面加载完毕之后执行 window.onload = function(){ // 获取标签元素 } 2. 增 ① 创建标签元素 var e = document.createelement(\u0026#34;标签名\u0026#34;); ② 指定存放位置 document.body.appendchild(e) document.body.insertbefore(e, 参照元素) 3. 删 ① 自己删除自己 元素标签.remove(); ② 父亲删除儿子 父标签.removechild(子标签); 4. 改 ① 创建修改后的标签a ② 获取要修改的标签b ③ 修改 b.parentnode.replacechild(a, b) 5. 内容的操作 ① 双边标签 获取内容： 标签元素.innerhtml 标签元素.innertext 设置内容： 标签元素.innerhtml = 值 标签元素.innertext = 值 ② 输入框标签 获取内容： 标签元素.value 设置内容： 标签元素.value = 值 6. 属性操作 1. 设置属性 标签元素.setattribute(\u0026#34;属性名\u0026#34;,\u0026#34;属性值\u0026#34;); 2. 获取属性 标签元素.getattribute(\u0026#34;属性名\u0026#34;); 3. 删除属性 标签元素.removeattribute(\u0026#34;属性名\u0026#34;); 7. 样式操作 ① 标签元素.style.样式名 = 值; ② 标签元素.setattribute(\u0026#34;class\u0026#34;,\u0026#34;xx\u0026#34;) 十、bom browser object model 浏览器对象模型 浏览器初始化页面时 初始化一个全局变量 描述当前窗口的属性和状态，这个全局对象称为浏览器对象模型 1. window 【window.】settimeout() 【window.】setinterval() 【window.】alert() window.document.getelementxx 2. 常见函数 \u0026lt;button onclick=\u0026#34;forward1()\u0026#34;\u0026gt;点击前进\u0026lt;/button\u0026gt; \u0026lt;button onclick=\u0026#34;back1()\u0026#34;\u0026gt;点击后退\u0026lt;/button\u0026gt; \u0026lt;button onclick=\u0026#34;reload1()\u0026#34;\u0026gt;点击刷新\u0026lt;/button\u0026gt; \u0026lt;button onclick=\u0026#34;jump()\u0026#34;\u0026gt;点击跳转\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function forward1(){ window.history.forward(); // 前进 } function back1(){ window.history.back(); // 后退 } function reload1(){ window.location.reload() // 刷新 } function jump(){ window.location.href = \u0026#34;http://www.baidu.com\u0026#34; // 实现跳转 } \u0026lt;/script\u0026gt; \u0026lt;a href=\u0026#34;12-dom之样式操作.html\u0026#34;\u0026gt;跳转到12-dom之样式操作\u0026lt;/a\u0026gt; ","date":"2021-11-24","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430214800/","summary":"一、JavaScript 1. 理解 JavaScript，简称JS 一种函数式优先轻量级、解释性(即时编译性)的高级编程语言。 开发Web页面的脚本语言而出名，也支持面向","title":"javascript"},{"content":"1. 理解 cascading style sheets 层叠样式表，使用一些样式来修饰html标签的效果 2. 使用 几乎每一个标签都有的属性：id class name style 使用方式1：行内样式 根据的标签的style属性引入css样式 \u0026lt;!-- 方式1：行内样式使用 几乎每一个标签都有的属性：id class name style（引入css样式） --\u0026gt; \u0026lt;div style=\u0026#34;color: pink; font-size: 20px;\u0026#34;\u0026gt; 这是一个美女，但是没有化妆 \u0026lt;/div\u0026gt; 使用方式2：内联样式 根据head中的 子标签style 引入css样式 提高css的复用性 \u0026lt;style\u0026gt; span, b{ color: red; font-size: 25px; } \u0026lt;/style\u0026gt; 使用方式3：外联样式 在外部编写.css文件 在head中使用link标签引入该页面 \u0026lt;!-- 方式3：引入外部样式 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./css/xx.css\u0026#34;\u0026gt; 总结： 优先级：就近原则 3. 选择器 1. 理解：css中为了便于定位具体的某个标签 2. 选择器种类： 基本选择器：标签选择器、id选择器、类选择器 ·标签选择器：通过标签的名字定位到标签 /* 1. 标签选择器: 定位页面中所有该名字的标签 */ div{ color: red; } ·id选择器：通过标签的id属性值定位该标签 /* 2. id选择器：id值是唯一的 定位更加准确 */ #d2{ color: blue; } · 类选择器 /* 3. 类选择器：多个标签可以有相同的class的值 一个标签可以有多个 */ .d1{ color: pink; } .d3{ font-size: 25px; } 其他选择器 · 组合选择器 /* 4. 组合选择器: 多个选择器组合使用 逗号隔开 */ .d1,.sp1{ color: pink; } · 层级选择器 /* 5. 层级选择器：一层一层找 */ p b span{ color: green; } · 伪类选择器 /* 6. 伪类选择器：根据标签的状态定位 */ /* a链接未点击的状态 */ a:link{ color: red; } /* a链接访问后的状态 */ a:visited{ color: #c3c3c3; } /* a链接鼠标悬停的状态 */ a:hover{ color: green; } /* a链接正在点击的状态 */ a:active{ color: yellow; } ·属性选择器 /* 7. 属性选择器：根据标签的属性值 定位该标签 */ input[name=username]{ background-color: blue; } · *选择器 /* 8. *选择器 匹配页面中所有的标签 */ *{ margin: 0px; } 优先级： 越精确优先级越高 id选择器 \u0026gt; 其他的选择器 \u0026gt; *选择器 4. 常见的样式 语法： 样式名: 样式值; · 以键值对的形式书写 · 键和值之间冒号隔开 · 每一个样式使用分号结束 · 一个标签可以有多个样式 ① 字体样式 color: rgba(255, 0, 0, .2); /* 字体颜色:可以是单词 十六进制形式 和 rgba形式 */ font-size: 20px; /* 字体大小 */ font-weight: bolder; /* 字体粗细：加粗 */ font-family: \u0026#39;宋体\u0026#39;; /* 字体类型 */ font-style: italic; /* 字体风格：倾斜 */ ② 文本样式 font-size: 30px; text-align: center; /* 对齐方式 */ text-decoration: none; /* 文本装饰 */ /* 文本阴影 参数1：阴影颜色 参数2：水平方向的偏移量 参数3：垂直方向的偏移量 参数4：模糊度 */ text-shadow: pink 5px 6px 3px; line-height: 200px; /* 行高：文本所占位置的高度 可以实现垂直方向的居中 */ ③ 尺寸样式 width height ④ 背景样式 background-color: green; /* 背景的颜色 */ /* background-image: url(./img/lgx.png); */ /* 背景图片 */ background-repeat: no-repeat; /* 是否平铺 */ background-position: left bottom; /* 背景图片的位置 */ /* 背景图片是否随着标签滚动 fixed不随着滚动 scroll 随着滚动 */ background-attachment: fixed; /* 背景的渐变色参数1：方向 参数2:颜色的变化 */ background: linear-gradient(to bottom, green, white) ⑤ 定位 /* 定位 relative 相对定位 相对于当前标签原先的位置 absolute 绝对定位 相对于页面的左上为抽点 fixed 固定定位 位置不变 */ position: absolute; ⑥ 边框样式 参数1：边框的宽度 参数2：边框的类型 参数3：边框的颜色 border: 1px solid blue; /* border-top: 1px dashed red; border-bottom: 1px dotted pink; border-left: 8px groove #c3c3c3; border-right: 8px ridge green; */ /* border: 10px ridge #c3c3c3; */ border-radius: 10px; /* 边框角的弧度 */ ⑦ 盒子模型 理解：布局页面的思想 注意： 盒子的位置大小 = height + border边框 + margin 外边距 + padding 内边距 ⑧ float 和 display float 使标签浮动 作用：块级标签的水平方向的对象 顶部对齐 后果： 1. 块标签 转换成 行内块(可以设置宽度和高度 不独占一行) 2. 浮动之后 空间坍塌 影响后面的标签的正常布局 总结：因此只用使用了浮动 完毕之后要记得清楚浮动 使用： float: left|right 清除浮动： 添加一个同级别的空标签 设置 样式 clear:both display 作用：① 可以实现块标签、行标签和行内块标签的相互转换 ② 可以实现标签的显示和隐藏 使用： display: inline-block; // 转换行内块标签 display: inline; // 转换行标签 display: block; // 转换块标签 display: none; // 隐藏标签 ","date":"2021-11-23","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430214665/","summary":"1. 理解 Cascading Style Sheets 层叠样式表，使用一些样式来修饰html标签的效果 2. 使用 几乎每一个标签都有的属性：id class name style 使用方式1：行内样式 根据的标签的style属性引入CSS样","title":"css"},{"content":"html 页面技术 1. 理解 hyper text markup language超文本标记语言 超出文本范畴可以通过特有的标签实现的一种语言 不用编译 直接由浏览器解析。 2. 作用 使用户通过浏览器可以展示 图文并茂的效果 3. 使用 1. 编辑器: vscode 2. 测试工具：浏览器 chrome 火狐 ie edge ...... 3. 编写代码 · 需要使用标签实现效果 · 文件后缀 .html · 标签的语法：\u0026lt;标签名\u0026gt; 标签名英文字母组成 建议小写 · 通常标签有开始 有结束：\u0026lt;marquee\u0026gt;\u0026lt;/marquee\u0026gt; 双边标签 · 单边标签：\u0026lt;br /\u0026gt; · 标签中可以写属性：\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;\u0026lt;/font\u0026gt; · 页面的结构 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4. 标签 1. 语法： · 双边标签：\u0026lt;marquee\u0026gt;\u0026lt;/marquee\u0026gt; 单边标签：\u0026lt;meta /\u0026gt; · 标签中可以写属性：\u0026lt;body color=\u0026#34;blue\u0026#34;\u0026gt; · 标签名都是预定义好的 不可以随便定义 · 属性也是定义好的 · 双边标签中可以写内容 单边标签中不能写内容 · 标签之间可以嵌套 正确：\u0026lt;body\u0026gt;\u0026lt;font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/body\u0026gt; 错误：\u0026lt;body\u0026gt;\u0026lt;font\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/font\u0026gt; 5. 常见标签 · 文本标签 1. 标题标签：h1 - h6 依次递减 2. 文本加粗标签：b 、 strong 3. 文本斜体标签：i 、 em 、cite 4. 上标 下标： sup sub 5. 滚动字体：marquee 6. 字体 ： font · 带格式的标签 1. 段落标签：p 2. 列表： 无序：ul\u0026gt;li 有序：ol\u0026gt;li 3. 换行标签: br 4. 分割线：hr · 多媒体标签* 1. 图片加载 \u0026lt;img src=\u0026#34;路径\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;300\u0026#34; title=\u0026#34;雄鹰\u0026#34;\u0026gt; 2. 音频加载 \u0026lt;!-- 音频加载 --\u0026gt; \u0026lt;audio src=\u0026#34;./img/小苹果.mp3\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; 3. 视频加载 \u0026lt;!-- 视频加载 --\u0026gt; \u0026lt;video src=\u0026#34;./img/搞笑视频.mp4\u0026#34; controls width=\u0026#34;200\u0026#34; height=\u0026#34;300\u0026#34; autoplay\u0026gt;\u0026lt;/video\u0026gt; · 超链接标签* a 超链接标签 \u0026lt;!-- a 链接 href: 跳转目标 target: 打开目标窗口的方式 --\u0026gt; \u0026lt;a href=\u0026#34;http://www.baidu.com\u0026#34;\u0026gt;点击去百度\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;01-hello.html\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;去hello\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#xx\u0026#34;\u0026gt;去第十段\u0026lt;/a\u0026gt; · 表格标签* \u0026lt;!-- 表格标签 table 属性：border 边框 cellspacing 单元格之间的距离 width 宽 height高 align对齐 1. 表格标题caption 2. 行 tr 属性：align 文本内容对齐方式 3. 表头 th 默认加粗 居中 4. 列 td 属性：colspan 合并左右单元格 rowspan 合并上下单元格 --\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;600\u0026#34; height=\u0026#34;500\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;caption\u0026gt;学生信息表\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;学号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;爱好\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;1001\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;坤坤儿\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;未知\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;球\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;1002\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;云云儿\u0026lt;/td\u0026gt; \u0026lt;td colspan=\u0026#34;2\u0026#34;\u0026gt;未知\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;1003\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;凯凯儿\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;男\u0026lt;/td\u0026gt; \u0026lt;td rowspan=\u0026#34;2\u0026#34;\u0026gt;男\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;1004\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;帅帅儿\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;女\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; · 表单标签** \u0026lt;!-- form表单：可以直接通过页面输入内容提交到后台服务器的标签 action: 提交地址 method: 提交方式 get默认 将数据拼接在url地址后面提交 不安全 2kb post通常使用 相对安全 通过请求头的形式提交数据 input 输入框 type 输入内容的类型 text 文本 password 密文 radio 单选框 checkbox 多选框 submit 带提交功能的按钮 button 不带提交功能的按钮 name 提交数据的key value 初始值 placeholder 文本提示信息 disabled 不可用 checked 默认选中 select 下拉框 name option 每一个元素 textarea 文本域 button 带提交功能的按钮 --\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; 类\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;型：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;type\u0026#34; value=\u0026#34;成人\u0026#34; disabled/\u0026gt;\u0026lt;br \u0026gt; 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; placeholder=\u0026#34;请输入用户名\u0026#34;/\u0026gt;\u0026lt;br /\u0026gt; 密\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;pwd\u0026#34; placeholder=\u0026#34;密码\u0026#34;/\u0026gt;\u0026lt;br \u0026gt; 性\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;别：\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;nan\u0026#34; checked\u0026gt; 男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;nv\u0026#34;\u0026gt; 女\u0026lt;br \u0026gt; 爱\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;好：\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;lq\u0026#34; checked\u0026gt; 篮球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;zq\u0026#34;\u0026gt; 足球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;pq\u0026#34;\u0026gt; 排球 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;yjq\u0026#34;\u0026gt; 瑜伽球 \u0026lt;br \u0026gt; 籍\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;贯：\u0026lt;select name=\u0026#34;pro\u0026#34;\u0026gt; \u0026lt;option\u0026gt;浙江省\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;河北省\u0026lt;/option\u0026gt; \u0026lt;option\u0026gt;河南省\u0026lt;/option\u0026gt; \u0026lt;option selected\u0026gt;安徽省\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br \u0026gt; 个性签名：\u0026lt;textarea rows=\u0026#34;10\u0026#34; cols=\u0026#34;100\u0026#34; name=\u0026#34;xx\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt;\u0026lt;br \u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;注册\u0026#34; /\u0026gt; \u0026lt;button\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;按钮\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 补充 1. 内联架构标签 ① iframe可以实现一个页面中嵌套另一个页面 \u0026lt;h2\u0026gt;这是当前页面\u0026lt;/h2\u0026gt; \u0026lt;iframe src=\u0026#34;./表单标签.html\u0026#34; width=\u0026#34;600\u0026#34; height=\u0026#34;600\u0026#34; name=\u0026#34;xx\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;a href=\u0026#34;表格.html\u0026#34; target=\u0026#34;xx\u0026#34;\u0026gt;点击加载百度页面\u0026lt;/a\u0026gt; ② frameset 可以实现将一个页面拆分 多个页面 \u0026lt;frameset rows=\u0026#34;100, *\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;http://www.baidu.com\u0026#34; noresize frameborder=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;frameset cols=\u0026#34;10%, *\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;http://www.jd.com\u0026#34; noresize frameborder=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;frame src=\u0026#34;http://www.jq22.com\u0026#34; noresize frameborder=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;/frameset\u0026gt; \u0026lt;/frameset\u0026gt; 2. 字符实体 3. 无意义标签 常见的无意义标签：div span div 块级标签：独占一行 可以设置宽和高 span 行级标签：不独占一行 不可以设置宽和高 html5 提供了一些无意义的标签：header footer article... 4. 总结 能看明白 常见的标签：多媒体标签、超链接标签、表单标签、表格标签、无意义标签 参考文献： https://w3school.com.cn https://www.runoob.com/ ","date":"2021-11-22","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430214595/","summary":"HTML 页面技术 1. 理解 Hyper Text Markup Language超文本标记语言 超出文本范畴可以通过特有的标签实现的一种语言 不用编译 直接由浏览器解析。 2. 作用 使用户通过浏览器可以展示 图文并茂","title":"html"},{"content":"docker安装 安装docker 安装过docker的可以跳过这一步，没有安装的使用以下脚本命令直接安装docker。\n//安装依赖 yum -y install yum-utils device-mapper-persistent-data lvm2 //配置仓库镜像 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo //安装docker yum -y install docker-ce 安装docker好后记得启动docker，和设置开机启动 使用一下命令\n##启动docker： sudo systemctl start docker ##开机启动docker： sudo systemctl enable docker 配置国内镜像仓库 前言： docker在默认安装之后，通过命令docker pull 拉取镜像时，默认访问docker hub上的镜像，在国内网络环境下，下载时间较久或者拉取失败，所以要配置国内镜像仓库。\n教程： 第一步.新建或编辑daemon.json\nvi /etc/docker/daemon.json 第二部.编辑daemon.json文件填入一下内容 记得退出保存\n{ \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;http://hub-mirror.c.163.com\u0026#34;] } 第三步.第三步：重启docker\nsystemctl restart docker.service 第四步.执行docker info查看是否修改成功\ndocker info 成功如下图\n其他的加速地址如下： ##网易 http://hub-mirror.c.163.com ##docker中国区官方镜像 https://registry.docker-cn.com ##中国科技大学 https://docker.mirrors.ustc.edu.cn ##阿里云容器 服务 https://cr.console.aliyun.com/\n青龙面板安装 拉取青龙镜像 docker pull whyour/qinglong:latest 部署镜像 ##建议改一下青龙端口以防被爆破 将-p 5700：5700改成-p 5800：5700 青龙面板地址就变成你的ip+5800 前提改的端口没有被占用，如果你不需要改直接复制以下命令执行\ndocker run -dit \\ -v $pwd/ql/config:/ql/config \\ -v $pwd/ql/log:/ql/log \\ -v $pwd/ql/db:/ql/db \\ -v $pwd/ql/jbot:/ql/jbot \\ -v $pwd/ql/raw:/ql/raw \\ -v $pwd/ql/repo:/ql/repo \\ -v $pwd/ql/scripts:/ql/scripts \\ -p 5700:5700 \\ --name qinglong \\ --hostname qinglong \\ --restart always \\ whyour/qinglong:latest 打开防火墙 去你的服务商开启防火墙 开放端口5700\n以下部分主机商开通端口教程\n腾讯云: https://www.bt.cn/bbs/thread-1229-1-1.html\n阿里云：https://www.bt.cn/bbs/thread-2897-1-1.html\n华为云：https://www.bt.cn/bbs/thread-3923-1-1.html\n登录青龙面板 面板地址：http://你服务器ip:5700 默认账号：admin 默认密码：adminadmin 注意：当您使用以上密码首次登录后，面板会显示已初始化密码。请在ssh终端内输入以下指令查看新密码（输出的结果就是实际的密码了{“username”:“admin ##这里是你的管理员账号”,“password”:” 123456 ##这里的就是你新管理密码”），代码如下：\ndocker exec -it qinglong cat /ql/config/auth.json 完成登录 青龙面板更新命令：一步一步执行 cd qinglong ##进入青龙目录 qinglong改你的目录 docker-compose down docker pull whyour/qinglong:latest docker-compose up -d 依赖安装 1.出现下列错误：(缺依赖)\nerror: cannot find module ‘xx’\n执行命令：docker exec -it ql(ql你的容器名称) pnpm install xx（xx填缺少依赖的文件名）\n2.一般出现这种错误：(缺文件)\nerror: cannot find module ‘./xx’\n执行命令：那就很有是拉库命令不完整，请检查或复制完整的拉库命令,看看群置顶↑😜\n3.一般出现这种错误：(缺py依赖)\nmodulenotfounderror: no module named ‘xxx’,并且是.py结尾的脚本\n执行命令：docker exec -it ql(ql你的容器名称) pip3 install xxx\n4.遇到这种问题：(脚本问题)\ntypeerror: cannot read property ‘xxxx’ of undefined\n操作是：原因可能是脚本问题，或者接口问题，又或者是黑号，又或者是京东问题，又或者是ip黑了，等等。总之遇到这种情况，有人说重装能解决，或者换ip再试试，自\nssh安装依赖：\ndocker exec -it qinglong bash -c \u0026#34;apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev \u0026amp;\u0026amp; cd scripts \u0026amp;\u0026amp; npm install canvas --build-from-source\u0026#34; 宠物汪汪依赖\ndocker exec -it qinglong bash -c \u0026#34;cd scripts \u0026amp;\u0026amp; npm i -s png-js\u0026#34; 签到及宠汪汪兑换必装依赖文件 cd ql/scripts \u0026amp;\u0026amp; wget https://cdn.jsdelivr.net/gh/mzljjkj/mzkj@master/20210819/66ed73000262d5876ea6464d5b6280a5/66ed73000262d5876ea6464d5b6280a5.zip \u0026amp;\u0026amp; unzip 66ed73000262d5876ea6464d5b6280a5.zip 安装tough-cookie cd /root/ql/scripts \u0026amp;\u0026amp; npm install png-js crypto-js download got http-server request tough-cookie tunnel ws 安装crypto-js npm install crypto-js 全部依赖库：\ndocker exec -it qinglong bash -c \u0026#34;npm install -g typescript\u0026#34; docker exec -it qinglong bash -c \u0026#34;npm install axios date-fns\u0026#34; docker exec -it qinglong bash -c \u0026#34;npm install crypto -g\u0026#34; docker exec -it qinglong bash -c \u0026#34;npm install jsdom\u0026#34; docker exec -it qinglong bash -c \u0026#34;npm install png-js\u0026#34; docker exec -it qinglong bash -c \u0026#34;npm install -g npm\u0026#34; docker exec -it qinglong bash -c \u0026#34;pnpm i png-js\u0026#34; docker exec -it qinglong bash -c \u0026#34;pip3 install requests\u0026#34; docker exec -it qinglong bash -c \u0026#34;apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev \u0026amp;\u0026amp; cd scripts \u0026amp;\u0026amp; npm install canvas --build-from-source\u0026#34; docker exec -it qinglong bash -c \u0026#34;apk add python3 zlib-dev gcc jpeg-dev python3-dev musl-dev freetype-dev\u0026#34; docker exec -it qinglong bash -c \u0026#34;cd /ql/scripts/ \u0026amp;\u0026amp; apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev \u0026amp;\u0026amp; npm i \u0026amp;\u0026amp; npm i -s ts-node typescript @types/node date-fns axios png-js canvas --build-from-source\u0026#34; 安装配置文件及依赖 不废话，每个教程都会出现的依赖，一行一行执行完就行，不用理会报错什么的。\n正常用户都是node.js\nios软件用户请使用 https://raw.githubusercontent.com/nobyda/script/master/jd-dailybonus/jd_dailybonus.js\n下载 cd /usr/local \u0026amp;\u0026amp; wget https://nodejs.org/dist/v14.17.5/node-v14.17.5-linux-x64.tar.xz 解压 xz -dk node-v14.17.5-linux-x64.tar.xz \u0026amp;\u0026amp; tar -xvf node-v14.17.5-linux-x64.tar 复制下面放到profile文件（看前面步骤） export node_home=/usr/local/node-v14.17.5-linux-x64 export path=$path:$node_home/bin export node_path=$node_home/lib/node_modules 生效 source /etc/profile 必装依赖（别偷懒）\n一、安装got cd xdd-plus \u0026amp;\u0026amp; npm install got 二、安装tough-cookie cd /root/ql/scripts \u0026amp;\u0026amp; npm install png-js crypto-js download got http-server request tough-cookie tunnel ws 三、安装crypto-js npm install crypto-js 四、图形验证依赖 宠汪汪 图形签到等需求 docker exec -it qinglong bash -c \u0026#34;cd scripts \u0026amp;\u0026amp; npm i -s png-js\u0026#34; 五、部分脚本依赖 docker exec -it qinglong bash -c \u0026#34;apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev \u0026amp;\u0026amp; cd scripts \u0026amp;\u0026amp; npm install canvas --build-from-source\u0026#34; 六、签到及宠汪汪兑换必装依赖文件 cd ql/scripts \u0026amp;\u0026amp; wget https://cdn.jsdelivr.net/gh/mzljjkj/mzkj@master/20210819/66ed73000262d5876ea6464d5b6280a5/66ed73000262d5876ea6464d5b6280a5.zip \u0026amp;\u0026amp; unzip 66ed73000262d5876ea6464d5b6280a5.zip 七、全部依赖 docker exec -it qinglong bash -c \u0026#34;npm install -g typescript\u0026#34; docker exec -it qinglong bash -c \u0026#34;npm install axios date-fns\u0026#34; docker exec -it qinglong bash -c \u0026#34;npm install png-js\u0026#34; docker exec -it qinglong bash -c \u0026#34;npm install -g npm\u0026#34; docker exec -it qinglong bash -c \u0026#34;pnpm i png-js\u0026#34; docker exec -it qinglong bash -c \u0026#34;pip3 install requests\u0026#34; docker exec -it qinglong bash -c \u0026#34;apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev \u0026amp;\u0026amp; cd scripts \u0026amp;\u0026amp; npm install canvas --build-from-source\u0026#34; docker exec -it qinglong bash -c \u0026#34;apk add python3 zlib-dev gcc jpeg-dev python3-dev musl-dev freetype-dev\u0026#34; docker exec -it qinglong bash -c \u0026#34;cd /ql/scripts/ \u0026amp;\u0026amp; apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev \u0026amp;\u0026amp; npm i \u0026amp;\u0026amp; npm i -s ts-node typescript @types/node date-fns axios png-js canvas --build-from-source\u0026#34; 上述资源大部分来自互联网，大家参考使用。致敬各位作者。\n青龙nvjdc前端使用与安装教程 第一步.安装unzip yum install wget unzip -y 第二步.创建一个目录放配置以及chromium 1.创建目录和进入nolanjdc\nmkdir nolanjdc \u0026amp;\u0026amp; cd nolanjdc 2.下载config.json 配置文件 并且修改自己的配置\n#国外机 wget -o config.json https://github.com/shiunke/nvjdc/blob/main/config.json #国内机 wget -o config.json https://ghproxy.com/https://github.com/shiunke/nvjdc/blob/main/config.json 3.创建chromium文件夹并进入\nmkdir -p .local-chromium/linux-884014 \u0026amp;\u0026amp; cd .local-chromium/linux-884014 4.chromium目录下载chromium\nwget https://mirrors.huaweicloud.com/chromium-browser-snapshots/linux_x64/884014/chrome-linux.zip \u0026amp;\u0026amp; unzip chrome-linux.zip 5.删除下载chrome的压缩包\nrm -f chrome-linux.zip 6.回到 nolanjdc目录\ncd \u0026amp;\u0026amp; cd nolanjdc 第三步.拉取nvjdc镜像并创建容器 1.镜像拉取\ndocker pull nolanhzy/nvjdc:1.0 2.创建容器\ndocker run --name nolanjdc -p 5800:80 -d -v \u0026#34;$(pwd)\u0026#34;/config.json:/app/config/config.json:ro \\-v \u0026#34;$(pwd)\u0026#34;/.local-chromium:/app/.local-chromium \\-it --privileged=true nolanhzy/nvjdc:1.0 第四步.查看日志 看是否安装成功 出现 netjdc started 表示成功 docker logs -f nolanjdc 第五步.配置文件填入自己的青龙id和密钥 第六步.配置完所有重启容器 注意：配置或改了配置文件完一定要重启容器要不然报错或者改了没有生效\n##重启nolanjdc指令：docker restart nolanjdc 第七步.访问前端 链接是：你的ip加你的端口 如127.0.0.1:5703（如果按照本教程来的默认5703如果自己改过按照你改的来）\n0.3版多容器配置： { ///最大支持几个网页 \u0026#34;maxtab\u0026#34;: \u0026#34;4\u0026#34;, //网站标题 \u0026#34;title\u0026#34;: \u0026#34;nolanjdcloud\u0026#34;, //网站公告 \u0026#34;announcement\u0026#34;: \u0026#34;本项目脚本收集于互联网，为了您的财产安全，请关闭京东免密支付。\u0026#34;, ///多青龙配置 \u0026#34;config\u0026#34;: [ { //容器1 //序号必须从1开始 \u0026#34;qlkey\u0026#34;: 1, //服务器名称 \u0026#34;qlname\u0026#34;: \u0026#34;阿里云\u0026#34;, //青龙url \u0026#34;qlurl\u0026#34;: \u0026#34;http://ip或者端口:5700\u0026#34;, //青龙2,9 openapi client id \u0026#34;ql_clientid\u0026#34;: \u0026#34;\u0026#34;, //青龙2,9 openapi client secret \u0026#34;ql_secret\u0026#34;: \u0026#34;\u0026#34;, //青龙面包最大ck容量 \u0026#34;ql_capacity\u0026#34;: 45, //消息推送二维码 \u0026#34;qrurl\u0026#34;:\u0026#34;\u0026#34; },{ //容器2 //序号必须从1开始 \u0026#34;qlkey\u0026#34;: 1, //服务器名称 \u0026#34;qlname\u0026#34;: \u0026#34;阿里云\u0026#34;, //青龙url \u0026#34;qlurl\u0026#34;: \u0026#34;http://ip或者端口:5700\u0026#34;, //青龙2,9 openapi client id \u0026#34;ql_clientid\u0026#34;: \u0026#34;\u0026#34;, //青龙2,9 openapi client secret \u0026#34;ql_secret\u0026#34;: \u0026#34;\u0026#34;, //青龙面包最大ck容量 \u0026#34;ql_capacity\u0026#34;: 45, //消息推送二维码 \u0026#34;qrurl\u0026#34;:\u0026#34;\u0026#34; },{ //容器3 //序号必须从1开始 \u0026#34;qlkey\u0026#34;: 1, //服务器名称 \u0026#34;qlname\u0026#34;: \u0026#34;阿里云\u0026#34;, //青龙url \u0026#34;qlurl\u0026#34;: \u0026#34;http://ip或者端口:5700\u0026#34;, //青龙2,9 openapi client id \u0026#34;ql_clientid\u0026#34;: \u0026#34;\u0026#34;, //青龙2,9 openapi client secret \u0026#34;ql_secret\u0026#34;: \u0026#34;\u0026#34;, //青龙面包最大ck容量 \u0026#34;ql_capacity\u0026#34;: 45, //消息推送二维码 \u0026#34;qrurl\u0026#34;:\u0026#34;\u0026#34; } ] } 更新教程：\n1.. 删除容器 镜像\n##删除nolanjdc容器 docker rm -f nolanjdc ##删除nolanhzy/nvjdc:0.3镜像 //注意：0.3 为版本号 按需更改 docker rmi -f nolanhzy/nvjdc:0.3 2..进入以前下载过浏览器 和json配置的文件夹中 如原来在 root 下 nolanjdc 文件夹中 下载的配置与浏览器\n2..进入以前下载过浏览器 和json配置的文件夹中 如原来在 root 下 nolanjdc 文件夹中 下载的配置与浏览器 3.然后重新执行 拉取新版本镜像 拉取配置文件 和创建容器指令 指令看上面教程\n青龙面板2.9傻妞机器人编译安装教程 一键安装：s=sillygirl;a=arm64;if [[ $(uname -a | grep \u0026#34;x86_64\u0026#34;) != \u0026#34;\u0026#34; ]];then a=amd64;fi ;if [ ! -d $s ];then mkdir $s;fi ;cd $s;wget https://mirror.ghproxy.com/https://github.com/cdle/${s}/releases/download/main/${s}_linux_$a -o $s \u0026amp;\u0026amp; chmod 777 $s;pkill -9 $s;$(pwd)/$s 国内用户先执行：set sillygirl download_prefix https://ghproxy.com/ 芝士自愿开启：set jd_cookie enable_jd_cookie true 一键安装版更新方法: 删除root/sillygirl/sillygirl文件，重新跑上面命令。 第一步. 这里以linux amd64为例，去官网下载安装go语言安装包(这里已经准备好下载指令 直接第二步开始）： 第二步. 输入下方指令 下载go1.16.7.linux-amd64.tar.gz包 cd /usr/local \u0026amp;\u0026amp; wget https://golang.google.cn/dl/go1.16.7.linux-amd64.tar.gz -o go1.16.7.linux-amd64.tar.gz 第三步. 解压 tar -xvzf go1.16.7.linux-amd64.tar.gz 输入以下命令 tar -xvzf go1.16.7.linux-amd64.tar.gz 第四步. 设置环境变量 输入指令：vi /etc/profile ,将下方框内文本复制到最后一行 export go111module=on export goproxy=https://goproxy.cn export goroot=/usr/local/go export gopath=/usr/local/go/path export path=$path:$goroot/bin:$gopath/bin 保存文件后 输入指令： source /etc/profile 如果要查看go安装好没有 输入指令：go env 输出如下图代表go安装好了 安装git：（如果安装过就不用安装） 下面3个命令挨个跑完就好了\nwget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -ivh epel-release-latest-7.noarch.rpm yum install -y git 安装gcc 2个命令一个一个跑完 (安装过的跳过） yum -y install gcc yum -y install gcc-c++ 第五步. 拉库编译和安装傻妞(一步一步执行) ##返回到root目录 cd ~ ##拉傻妞库 此时你的qinglong目录下会新增文件夹-sillygirl git clone https://ghproxy.com/https://github.com/cdle/sillygirl ##安装傻妞对青龙的扩展 cd sillygirl/develop \u0026amp;\u0026amp; git clone https://ghproxy.com/https://github.com/ufuckee/jd_cookie ##回到sillygirl目录 cd .. ##在sillygirl目录下新建文件 dev.go ##在dev.go内填写以下内容 （注意 qq 和 tg 插件 要放在后面） package main import ( //青龙2.9机器人 _\u0026#34;github.com/cdle/sillygirl/develop/qinglong\u0026#34; //京东账号 _ \u0026#34;github.com/cdle/sillygirl/develop/jd_cookie\u0026#34; //腾讯qq _\u0026#34;github.com/cdle/sillygirl/im/qq\u0026#34; //te legram _\u0026#34;github.com/cdle/sillygirl/im/tg\u0026#34; //微信公众号 _\u0026#34;github.com/cdle/sillygirl/im/wxmp\u0026#34; //微信号 _\u0026#34;github.com/cdle/sillygirl/im/wx\u0026#34; ) ##在sillygirl 目录下运行 go build 稍微等一下，让它跑一会儿 go build ##给权限 chmod 777 sillygirl 然后在sillygirl文件夹里面运行一下指令 ##初始化并生成配置文件 等弹出二维码机器人qq扫码绑定机器人 ./sillygirl 扫码绑定后按住ctrl再按c退出，然后输入下面的静默挂机挂机指令 nohup ./sillygirl 1\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; #amd64 接下来去qq 第一步.接下来打开手机登录你的机器人qq 给自己发 （机器人给机器人发送 填你需要管理机器人的qq号 ）\n例如：set qq masters 123456789 第二部. 现在你登录你管理机器人的qq号慢慢发下面指令\n傻妞注销/更换qq命令 (注意执行需要去服务器重新运行机器人指令) delete qq session.token 傻妞机器人名 set sillygirl name 傻妞 傻妞http服务端口 set sillygirl port 8080 傻妞消息撤回等待时间，单位秒 set sillygirl duration 5 傻妞自动升级是否通知 set sillygirl update_notify false 是否开启傻妞自动更新 set sillygirl auto_update true 傻妞内置赞赏码 set sillygirl appreciate https://gitee.com/aiancandle/sillygirl/raw/main/appreciate.jpg 是否启动http服务 set sillygirl enable_http_server false 设置青龙openapi的client_id参数 set qinglong client_id ? 设置青龙openapi的client_secret参数 set qinglong client_secret ? 青龙是否开启自动隐藏重复任务功能 set qinglong autocronhideduplicate true 设置青龙面板地址 set qinglong host http://127.0.0.1:5700 设置qq登录账号 set qq uin 10000 设置qq登录密码 set qq password 123456789 设置qq临时消息默认群号 set qq tempmessagegroupcode ? 指定要监听的qq群 set qq ongroups g1\u0026amp;g2\u0026amp;g3... 设置自动同意好友请求 set qq auto_friend true 设置是否对监听自身消息 set qq onself true 设置qq管理员 set qq masters q1\u0026amp;q2\u0026amp;q3... 设置接受通知的qq账号 set qq notifier q1\u0026amp;q2\u0026amp;q3... 设置qq设备信息(自动生成) set qq device.json ? 设置qq登录令牌(自动生成) set qq session.token ? 设置telegram机器人token set tg token ? 设置telegram机器人代理 set tg http_proxy ? 设置telegram机器人管理员 set tg masters t1\u0026amp;t2\u0026amp;t3... 设置接受通知的telegram账号 set tg notifier t1\u0026amp;t2\u0026amp;t3... 设置微信公众平台app_id set wxmp app_id ? 设置微信公众平台app_secret set wxmp app_secret ? 设置微信公众平台token set wxmp token ? 设置微信公众平台encoding_aes_key set wxmp encoding_aes_key ? 设置微信公众平台管理员 set wxmp masters w1\u0026amp;w2\u0026amp;w3... 傻妞内置微信插件，依赖于可爱猫和http-sdk 傻妞远程处理接口 /wx/receive 设置插件调用地址，确保傻妞可以访问可爱猫端口 #set wx api_url ? 设置图片转发模式，否则可能会出现此图片来自xx未经允许不得使用的提示 #set wx relay_mode true 设置指定转发地址，格式为 https://域名/relay?url=%s，不知道不用填 #set wx relaier ? 设置傻妞是否动态网络地址，适用于傻妞家庭宽带而可爱猫在云服务器的情况下 set wx sillygirl_dynamic_ip true 设置可爱猫是否动态网络地址，适用于可爱猫家庭宽带而傻妞在云服务器的情况下 #set wx keaimao_dynamic_ip true 设置可爱猫端口 #set wx keaimao_port ? 新增配置文件并编译傻妞 新增sets.conf配置文件。\ncd /etc/sillygirl touch sets.conf 按键盘字母i进入编辑模式，输入下面的参数，并对应配置，然后按键盘esc退出编辑模式，输入命令:wq保存并退出。这里主要设置下青龙面板的地址和之前创建应用的参数，以及阿东面板的地址和坑位数。\n# 傻妞机器人名 set sillygirl name 傻妞 #傻妞http服务是否开启，默认false，开启改为true set sillygirl enable_http_server true # 傻妞http服务端口 set sillygirl port 8080 # 傻妞消息撤回等待时间，单位秒 set sillygirl duration 5 # 傻妞自动升级是否通知 set sillygirl update_notify true #是否开启傻妞自动更新 set sillygirl auto_update true # 傻妞内置赞赏码 #set sillygirl appreciate 你的二维码 # 设置青龙openapi的client_id参数 set qinglong client_id u0ea-0ta47ug # 设置青龙openapi的client_secret参数 set qinglong client_secret 1wrzipao_hm77zidkdz3w87i # 青龙是否开启自动隐藏重复任务功能 set qinglong autocronhideduplicate true # 设置青龙面板地址 set qinglong host http://180.76.133.222:5700 # 设置qq登录账号 #set qq uin 10000 #这里建议注释，直接后台弹出二维码登陆 # 设置qq登录密码 #set qq password 123456789 #这里建议注释，直接后台弹出二维码登陆 # 设置监听群聊号码，默认监听所有 set qq groupcode 417497383 # 设置是否自动同意好友请求 set qq auto_friend true # 是否对自己发出的消息进行回复 set qq onself true # 设置qq管理员 set qq masters 2409741052 # 设置接受通知的qq账号，默认管理员接受 set qq notifier 2409741052 # 设置qq设备信息(自动生成) #set qq device.json ? #这里建议注释，直接后台弹出二维码登陆 # 设置qq登录令牌(自动生成) #set qq session.token ? #这里建议注释，直接后台弹出二维码登陆 # 设置telegram机器人token #set tg token ? # 设置telegram机器人代理 #set tg url ? # 设置telegram机器人管理员 #set tg masters 2409741052 # 设置接受通知的telegram账号，默认管理员接受 #set tg notifier 2409741052 # 设置微信公众平台app_id #set wxmp app_id wx954624d55c5f59f3 # 设置微信公众平台app_secret #set wxmp app_secret 924274dc192eb2482aca8b00f048dc31 # 设置微信公众平台token #set wxmp token ? # 设置微信公众平台encoding_aes_key #set wxmp encoding_aes_key ? # 设置微信公众平台管理员 #set wxmp masters w1\u0026amp;w2\u0026amp;w3... #设置阿东登陆地址 #set jd_cookie address http://180.76.133.222:5703 #设置阿东登陆坑位数 #set jd_cookie login_num 3 #若兰配置 set jd_cookie nolan_addr http://180.76.133.222:5800 #芝士自愿开启： set jd_cookie enable_jd_cookie true 需要主意的是，记得配置的地方，删除set前面的”#“，不然不生效。\n4. 编译傻妞并运行\ncd /etc/sillygirl \u0026amp;\u0026amp; go build chmod 777 sillygirl ./sillygirl 对接芝士命令 ^jd\\s+asset\\s+(.+)$ ^查询 (\\s+)$ # 资产推送$ 资产推送 #会根据绑定的qq一对一推送 # 资产推送定时 九点例子： set jd_cookie asset_push 0 9 * * * ，包括失效提醒。 # 查询资产 查询or查询 [序号] #命令\u0026#34;查询\u0026#34;绑定账号资产命令；命令\u0026#34;查询 1\u0026#34;，查询指定账号资产，注意空格，顺序为青龙的ck排序，支持匹配绑定的社交账号 # 获取绑定的社交账号 jd imof [ck或pt_pin] 。 # 查询今日豆子变化 ^jd\\s+today\\s+bean[(](\\s+)[)]$ # 查询昨日豆子变化 ^jd\\s+yestoday\\s+bean[(](\\s+)[)]$ # 查询豆子变化 ^jd\\s+bean[(](\\s+)[)]$ # wskey转换 更新狗东账号 #转换 wskey 到 cookie ^jd\\s+eueu\\s+(.+)$ ^jd\\s+find\\s+(.+)$ ^jd\\s+exchange\\s+(\\s+)\\s+(.+)$ ^jd\\s+enable\\s+(.+)$ ^jd\\s+disable\\s+(.+)$ ^jd\\s+remark\\s+(\\s+)\\s+(.+)$ # jd账号绑定qq号码 set pinqq pt_pin qq号码，?：set pinqq jd_xxxxxx 123456 # 取消jd账号绑定qq号码 delete pinqq pt_pin，?：delete pinqq jd_xxxxxx # 解绑im账号 对应的所有京东账号： jd unbind im，?：jd unbind 10000 # jd账号绑定tg账号（可由） set pintg pt_pin tgid（找getmyid获取） # 取消jd账号绑定tg账号 delete pintg pt_pin # 设置wskey自动转cooke定时： set jdwsck update 56 * * * * # 解绑京东账号 jd unbind 可以解绑名下所有京东账号 #给绑定该京东账号的社交账号发送消息 jd send pt_pin msg ,pt_pin填all则发给所有。 # ck提交 pt_key=([^;=\\s]+);\\s*pt_pin=([^;=\\s]+) 例：直接发抓到的ck，格式参考命令 # wskey提交 pin=([^;=\\s]+);\\s*wskey=([^;=\\s]+) 例：直接发抓到的ck，格式参考命令 # 限制查询频率 set jd_cookie query_wait_time [限制秒数] 例:set jd_cookie query_wait_time 60 # 设置阿东登录地址 set jd_cookie adong_addr 阿东ip:端口 # 设置阿东qq机器人账号 set jd_cookie selfqid 机器人qq账号 # 登录狗东账号 登录或登陆 # 退出狗东登录 q或退出登陆 # 删除阿东地址 delete jd_cookie adong_addr 例：delete jd_cookie adong_addr 127.0.0.1:5701 # 给绑定该京东账号的社交账号发送消息 jd send pt_pin msg #pt_pin填all则发给所有。 # 解锁内测功能 申请内测 #打赏作者进内测群，请打出“申请内测”。需要set tg masters [myuid]。没有用tg的，请在/etc/sillygirl/sets.conf加上一行命令。 重启傻妞教程 ps -a|grep sillygirl ##显示进程号 kill -9 xxxxxx ##杀掉进程 cd sillygirl \u0026amp;\u0026amp; ./sillygirl ##运行机器人 然后按ctrl＋ c在输入一下静默挂机命令\nnohup ./sillygirl 1\u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; #amd64 注意无法正常启动傻妞请手动更新启动并挂机输入一下命令\ncd sillygirl \u0026amp;\u0026amp; git pull \u0026amp;\u0026amp; go build \u0026amp;\u0026amp; ./sillygirl -d 相关问题 1.qq扫码请使用需要做机器人的qq去扫码 2.如果需要更换机器人，输入下方指令： sillygirl注销qq命令：delete qq session.token，重新运行扫码扫描即可。\n2.提示链接不上青龙？ 上方命令，机器人qq对自己发，设置好青龙的应用id以及密匙，应用创建：青龙面板-系统设置-应用设置-添加应用-名称随意-权限全选-就可以看到id以及密匙。 然后重启傻妞即可对接青龙。\n3.目前傻妞不需要配置config.yaml，一切以上方命令为准。\nnolanjdc对接傻妞教程 要求： 最新版傻妞 最新版nolanjdc 即可对接傻妞 第一步.需要你安装了nolanjdc 安装了nolanjdc不是最新版 更新nolanjdc看下面教程（即安装了nolanjdc，又是最新版的看第3）\n##删除nolanjdc容器 docker rm -f nolanjdc ##删除nolanhzy/nvjdc:0.3镜像 //注意：0.3 为版本号 按需更改你是什么版本就改什么版本 docker rmi -f nolanhzy/nvjdc:0.3 ##进入nolanjdc文件夹 cd /root/nolanjdc ##拉取最新版镜像 docker pull nolanhzy/nvjdc:1.0 ##然后创建新版镜像容器\ndocker run --name nolanjdc -p 5800:80 -d -v \u0026#34;$(pwd)\u0026#34;/config.json:/app/config/config.json:ro \\-v \u0026#34;$(pwd)\u0026#34;/.local-chromium:/app/.local-chromium \\-it --privileged=true nolanhzy/nvjdc:1.0 3.安装了nolanjdc又是最新版的 请修改配置文件如下图（注意：请把配置改成下图 一模一样 要不然报错）\n然后重启nolanjdc容器\ndocker restart nolanjdc 第二步.傻妞机器人的安装更新 2.安装了的 不是最新版傻妞机器人的请更新机器人（安装了傻妞又是最新版的看第3）\n##显示傻妞进程号 ps -a|grep sillygirl ##杀掉傻妞进程 xxxxxx处写你查出来的进程号 kill -9 xxxxxx ##更新机器人指令 a=arm64;if [[ $(uname -a | grep \u0026#34;x86_64\u0026#34;) != \u0026#34;\u0026#34; ]];then a=amd64;fi ;s=sillygirl;cd;if [ ! -d $s ];then mkdir $s;fi ;cd $s;wget https://mirror.ghproxy.com/https://github.com/cdle/${s}/releases/download/main/${s}_linux_$a -o $s \u0026amp;\u0026amp; chmod 777 $s \u0026amp;\u0026amp;pkill -9 $s ; $(pwd)/$s 3.已经是最新傻妞的 用管理员qq给机器人发送命令\nset jd_cookie nolan_addr http://你的jdc ip:你的jdc端口号 必须加 http:// set qinglong client_id 青龙应用id set qinglong client_secret 青龙应用secret(密钥) set qinglong host http://青龙ip:端口号 拉库 接下来青龙面板的定时任务里添加定时任务（拉库，建议可以同时拉faker和青蛙的，默认你们都是国内服务器）\nfaker库 名称faker 命令\nql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git \u0026#34;jd_|jx_|gua_|jddj_|getjdcookie\u0026#34; \u0026#34;activity|backup\u0026#34; \u0026#34;^jd[^_]|user|zoofaker_necklace.js|jdjrvalidator_pure|sign_graphics_validate\u0026#34; 定时规则0/10 1 * * * *\n青蛙库 名称青蛙 命令\nql repo https://github.com/smiek2121/scripts.git \u0026#34;jd_|gua_\u0026#34; \u0026#34;\u0026#34; \u0026#34;^movementfaker|^jdjrvalidator|^zoofaker|^sign\u0026#34; 定时规则0/20 1 * * * *\n如何拉库： ql repo \u0026lt;repourl\u0026gt; \u0026lt;path\u0026gt; \u0026lt;blacklist\u0026gt; \u0026lt;dependence\u0026gt; \u0026lt;branch\u0026gt; 对应意思 “库地址” “拉哪些” “不拉哪些” “依赖文件” “分支”\n拉取单个脚本 ql raw \u0026lt;fileurl\u0026gt; 使用方法： 一、添加库：进入面板-右上角“定时任务”-分别填入相关信息。提供个人设置，给大家参考。其中人物名、任务定时可自定义。\n二、运行库任务添加脚本：分别点击每个库的运行按钮，稍等一下，让它飞一会儿。然后刷新页面，就能看到库的脚本了。\n截止2021年9月21日目前还在维护的仓库 ccwav大佬的资产通知增强版和ck检测（推荐使用） 不包含sendnotify: ql repo https://github.com/ccwav/qlscript.git \u0026#34;jd_\u0026#34; \u0026#34;sendnotify.js\u0026#34; \u0026#34;ql.js\u0026#34; 包含sendnotify: ql repo https://github.com/ccwav/qlscript.git \u0026#34;jd_\u0026#34; \u0026#34;\u0026#34; \u0026#34;ql.js|sendnotify.js\u0026#34; wskey转换来源于zy143l大佬（不上传，推荐） 完美网络用户：ql repo https://github.com/zy143l/wskey.git \u0026#34;wskey\u0026#34; 国内网络用户：ql repo https://ghproxy.com/github.com/zy143l/wskey.git \u0026#34;wskey\u0026#34; zero205大佬更新拉库命令（更新频繁，内置作者助力） ql repo https://github.com/zero205/jd_tencent_scf.git \u0026#34;jd_|jx_|getjdcookie\u0026#34; \u0026#34;backup|icon\u0026#34; \u0026#34;^jd[^_]|user|sendnotify|sign_graphics_validate|jdjr\u0026#34;\u0026#34;main\u0026#34; yuannian1112拉取仓库命令： 国内鸡 ql repo https://hub.fastgit.org/yuannian1112/jd_scripts.git \u0026#34;jd_|jx_|getjdcookie\u0026#34; \u0026#34;activity|backup\u0026#34; \u0026#34;^jd[^_]|user|utils\u0026#34; 国外鸡 ql repo https://github.com/yuannian1112/jd_scripts.git \u0026#34;jd_|jx_|getjdcookie\u0026#34; \u0026#34;activity|backup\u0026#34; \u0026#34;^jd[^_]|user|utils\u0026#34; v4修改默认库为 https://hub.fastgit.org/yuannian1112/jd_scripts.git 分支修改为main ## star261 更新燃动 ql repo https://github.com/star261/jd.git \u0026#34;scripts|jd\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;main\u0026#34; ## chinnkarahoi 无维护，原版 ql repo https://github.com/chinnkarahoi/jd_scripts.git \u0026#34;jd_|jx_|getjdcookie\u0026#34; \u0026#34;activity|backup|coupon\u0026#34; \u0026#34;^jd[^_]|user\u0026#34; ## jdhelloworld 基本天天有更新,但是采用ts脚本让初学者不友好 ql repo https://github.com/jdhelloworld/jd_scripts.git \u0026#34;jd_|jx_|getcookie\u0026#34; \u0026#34;activity|backup|coupon|enen|update\u0026#34; \u0026#34;^jd[^_]|user|tools\u0026#34; ##柠檬panghu 已经跑路 ql repo https://github.com/panghu999/jd_scripts.git \u0026#34;jd_|jx_|getjdcookie\u0026#34; \u0026#34;activity|backup|jd_delcoupon|format_\u0026#34; \u0026#34;^jd[^_]|user\u0026#34; ## he1pu 有更新 ql repo https://github.com/he1pu/jdhelp.git \u0026#34;jd_|jx_|getjdcookie\u0026#34; \u0026#34;activity|backup|jd_delcoupon\u0026#34; \u0026#34;^jd[^_]|user\u0026#34; ## shufflewzc 集合目前能用的脚本有更新 ql repo https://github.com/shufflewzc/faker2.git \u0026#34;jd_|jx_|jddj_|getjdcookie\u0026#34; \u0026#34;activity|backup\u0026#34; \u0026#34;^jd[^_]|user|zoofaker_necklace|jdjrvalidator_pure|sign_graphics_validate\u0026#34; ##annyoo2021 lxk最终版及搬运整理 集合目前能用的脚本 推荐 ql repo https://github.com/annyoo2021/scripts.git \u0026#34;jd_|jx_|long_|getjdcookie\u0026#34; \u0026#34;activity|backup\u0026#34; \u0026#34;^jd[^_]|user|zoofaker_necklace|jdjrvalidator_pure|jdjrvalidator\u0026#34; \u0026#34;main\u0026#34; smiek2221仓库 https://github.com/smiek2221/scripts tsukasa007仓库 https://github.com/tsukasa007/my_script/tree/master 同步上游各个大佬的仓库 相当于合集 https://github.com/dovfork 京东青龙内部互助code.sh安装使用教程 前言： 使用code.sh 实现内部ck互助 可以实现1.优先助力越前面的ck 2.均力助力等\n脚本文件： code.sh\ntask_before.sh\n安装教程： 第一步.把 code.sh、task_before.sh 复制到青龙容器的 /ql/config/ 路径。\n第二步.将 code.sh 设定定时任务。\n名称：格式化更新互助码\n命令：task /ql/config/code.sh\n定时规则：10 * * * *\n注意注：①表示每整点10分时运行。 ②自动静默安装或修复常用依赖功能可能带来脚本运行时间长，主机性能消耗较大的副作用，如果不需要该功能，请自行修改 code.sh 内容：fixdependtype=”1″ 改成 fixdependtype=””\n第三步.运行脚本 完成安装 京东羊毛非标准端口cdn加速隐藏ip和端口 前言： 这里以京东羊毛kingfeng前端为例5000端口 其他端口理论可以自己去试试\n要求：\n✔搭建好了青龙面板\n✔搭建了kingfeng前端\n✔有一个备案域名\ncdn加速的好处：\n✔可以隐藏你的服务器源ip 以防别人直接攻击\n✔ 域名访问 列如不用cdn 你就是这样访问前端1.1.1.1:5700你用了cdn后就可以这样 xxx.baidu.xxx问\n注意：我也是小白 不懂原理 我只是负责分享我自己成功的案列 大神勿喷 大家可以自己去试试下面教程 有大神懂其中原理的我洗耳恭听。\n教程： 如果没有配置好青龙面板请看下面链接\n点击查看青龙安装教程\n如果没配置好kingfeng请看下面链接\n点击查看kingfeng前端安装教程\n上面都完成了再做一下要步骤\n第一步.我百度了一下好多cdn都不支持非标准端口加速基本上都是80 443端口 我们今天用的是七牛的免费cdn 这里我不提供链接自己百度 注册好 \u0026gt; 登录控制台 \u0026gt; 然后点添加域名 看图片 第二步.来到图4页面 看清楚我选的配置 这里特别说明一哈\n源ip： 填你的服务器ip\n端口：填你的 开放kingfeng端口\n测试源站那里 ：测试资源名 你是安教程搭建的kingfeng前端 你就填 #/ 如果你加速其他你就自己找资源名 或者发出来。\n第三步.上面都配置完了后 你点确定哟 然后去你的域名服务商哪里解析cname记录 主机值： 你刚才在cdn添加二级域名前缀是什么你就填什么\n解析类型：cname\n记录值 ：你在七牛cdn配置完 他会给你的\n然后就完成了过几分钟去打开你的网站【可以不用加端口访问了】看看是不是可以正常访问 不能访问端口防火墙开没得 成功了的话 再去ping一哈看是不是隐藏了你的ip 用的服务商提供节点[咦][咦]\n这是我成功的案列我我没弄清楚什么原理 分享给大家 如果不行勿喷。\n演示站：http://jd.unke.ren\n青龙面板跑京喜欢乐砍价脚本和教程 前言： 脚本只会砍第一个ck需要砍的商品\n活动入口：https://st.jingxi.com/sns/202103/20/jxhlk/list.html\n第一步.拉取脚本 ql raw https://github.com/shiunke/scripts/blob/unke/jxhlk.py\n第二步.去京喜选择你要砍的东西 活动入口：https://st.jingxi.com/sns/202103/20/jxhlk/list.html\n第三步.运行脚本 青龙面板 京东前端kingfng安装教程 说明： kingfeng 仅支持 qinglong 2.9+ kingfeng支持的架构：\nkingfeng: docker一键部署 支持wsck ptkey 用户添加/更新cookies 检测是否过期 添加备注 用户添加cookies 自动执行wskey转换任务 推送卡片 自定义公告 支持html语法 管理员在线登录修改配置 多节点支持 安装教程： 第一步.如果你的青龙面板不是qinglong 2.9+的 请在在ssh执行以下命令 如果是2.9+的忽略这一步 docker exec -it qinglong bash ##进入容器 注意qinglong位置改成你的容器名字\nql update ##将更新青龙到最新\nql check ##检查青龙状态是否正确\n第二步.复制粘贴到ssh执行下列命令 如出现无法拉取 请自行设置docker国内源 docker pull ranqi03/kingfeng:latest\n完成以上命令继续输入一下命令 docker run -dit \\ -v $pwd/kingfeng/:/app/config/ \\ -p 5000:80 \\ --name kingfeng \\ --hostname kingfeng \\ ranqi03/kingfeng:latest 第三步.配置docker映射目录：下的config.yaml 默认地址： /用户名/kingfeng/config.yaml 这里教程使用finalshell软件编辑 比较方便如下图 其他方法百度一哈 配置完记得保存 单节点设置 servers: -ql_name:上海节点 ##设置你的节点名字 列入上海节点 ql_url:http://172.13.1.33:5700/ ##使用容器ip+青龙默认部署端口为5700 例如我容器ip是172.13.1.33 那我ql_url地方就填http://172.13.1.33:5700/ ql_client_id:xxxxxxx ##这个需要在青龙面板 系统管理》应用设置》添加应用》名称kingfeng 权限给：环节变量 定时任务 任务日志 然后确定 将client id复制到这里 ql_client_secret:xxxxxx ##这个需要在青龙面板 系统管理》应用设置》添加应用》名称kingfeng 权限给：环节变量 定时任务 任务日志 然后确定 将client secret复制到这里 maxcount: 100\n##你要设置的多少名额 这里是可以添加100个名额 secretkey: xxxxx\n##这里是你登录kingfeng后台的管理密钥 ##管理员登录 选择任意节点 输入配置文件的密钥 登录即可 wskeytaskfullname: wskey转换\n#wskey转换任务名 notice: 你好,这里可以自定义公告\n#用户自定义公告内容 支持html语法 username: kingfeng #管理员名称 pushimageurl: https://img2.baidu.com/it/u=1007188585,453085648\u0026fm=26\u0026fmt=auto\u0026gp=0.jpg\n#推送图片 改成你的推送图片链接即可\n多节点设置 servers: -ql_name:上海节点 ##设置你的节点名字 列如上海节点 ql_url:http://172.13.1.33:5700/ ##使用容器ip+青龙默认部署端口为5700 例如我容器ip是172.13.1.33 那我ql_url地方就填http://172.13.1.33:5700/ ql_client_id:xxxxxxx ##这个需要在青龙面板 系统管理》应用设置》添加应用》名称可以随便填 权限给：环节变量 定时任务 任务日志 然后确定 将client id复制到这里 ql_client_secret:xxxxxx ##这个需要在青龙面板 系统管理》应用设置》添加应用》名称可以随便填 权限给：环节变量 定时任务 任务日志 然后确定 将client secret复制到这里 maxcount: 100\n##你要设置的多少名额 这里是可以添加100个名额 -ql_name:广东节点 ##设置你的节点名字 列如广东节点 ql_url:http://172.13.1.33:5700/ ##使用容器ip+青龙默认部署端口为5700 例如我容器ip是172.13.1.33 那我ql_url地方就填http://172.13.1.33:5700/ ql_client_id:xxxxxxx ##这个需要在青龙面板 系统管理》应用设置》添加应用》名称可以随便填 权限给：环节变量 定时任务 任务日志 然后确定 将client id复制到这里 ql_client_secret:xxxxxx ##这个需要在青龙面板 系统管理》应用设置》添加应用》名称可以随便填 权限给：环节变量 定时任务 任务日志 然后确定 将client secret复制到这里 maxcount: 100\n##你要设置的多少名额 这里是可以添加100个名额 secretkey: xxxxx\n##这里是你登录kingfeng后台的管理密钥 ##管理员登录 选择任意节点 输入配置文件的密钥 登录即可 wskeytaskfullname: wskey转换\n#wskey转换任务名 notice: 你好,这里可以自定义公告\n#用户自定义公告内容 支持html语法 username: kingfeng #管理员名称 pushimageurl: https://img2.baidu.com/it/u=1007188585,453085648\u0026fm=26\u0026fmt=auto\u0026gp=0.jpg\n#推送图片 改成你的推送图片链接即可\n第四步.就可以访问kingfeng前端了 访问链接：你的ip+端口5000 列如：http://172.13.1.33:5000/ （注意：如果你改过端口那访问链接就是 ip+你改的端口 按照上面教程的话就是5000端口 更新教程： 指令：docker kill kingfeng \u0026amp;\u0026amp; docker rmi kingfeng\n指令：docker pull ranqi03/kingfeng:latest\n指令： docker run -dit \\ -v $pwd/kingfeng/:/app/config/ \\ -p 5000:80 \\ \u0026ndash;name kingfeng \\ \u0026ndash;hostname kingfeng \\ ranqi03/kingfeng:latest\n注意：建议更新前先备份config.yaml\n常见问题 q：配置填写正确但是节点加载不出来 a：请检查服务器cpu是否爆高,如未爆高请在青龙容器内执行ql update以及ql check\nq：是否支持内网端口？\na：支持公网ip 域名 以及容器ip 推荐容器ip(安全性略高,速度稍微快)。\nq：为什么访问主页出现错误空提示？\na：一般为端口映射错误/失败，请自行检查配置文件。\nq：是否支持n1 arm架构？\na：不支持。\n真正的内部互助喵咪库 喵咪库 ql repo https://github.com/cdle/carry.git \u0026ldquo;jd_\u0026rdquo; \u0026quot;\u0026quot; \u0026ldquo;jdcookie.js|sendnotify.js|share_code.js|user_agents.js\u0026rdquo;\nql cron run 喵咪库\nql cron logs 喵咪库\nql cron run cdle\n","date":"2021-11-15","permalink":"https://lovemjh.vercel.app/posts/blog/20220430231513/","summary":"docker安装 安装docker 安装过Docker的可以跳过这一步，没有安装的使用以下脚本命令直接安装Docker。 //安装依赖 yum -y install yum-utils device-mapper-persistent-data lvm2 //配置仓库镜像 yum-config-manager --add-repo","title":"青龙脚本部署"},{"content":"新特性 特点 (***)1.lambda表达式\n(***)2.streamapi\n3.对于时间类的增强。\n4.optional 用于处理空指针异常。\n(**)5.接口中静态方法和默认方法\n6.函数式接口。\n7.hashmap底层： 哈希表+链表 ，但是1.8jdk 修改了 哈希表+ 链表/红黑树 ，阈值 大于 8 转树，小于6 链表\n8.元空间 metaspace 元空间使用的是物理内存。方法区是一个逻辑概念，在1.7以前包含1.7，由永久代实现，1.8jdk由元 空间实现。 静态成员与字符串常量池在1.7jdk之后在堆中。但是逻辑上属于方法区。\n接口中的默认方法 1.接口中默认方法引入的原因： ① 便于类的维护② 向下兼容。\n2.关键字：\ndefault\n3.细节：\n① 接口本身不能创建对象，如果要创建对象，只能通过子类来实现，默认方法也是通过子类来进行\n调用，但是如果子类觉得该方法不适用，可以重写。\n② 类优先原则：当接口与类中有同名方法时，如果接口中的是默认方法，那么，类优先，该子类调\n用该方法时，使用的是类中的实现。\n③ 当多个接口中，有同名默认方法时，如果这些接口，都由一个子类实现，该子类必须实现该默认\n方法。\n④ 接口中的默认方法在子类中如果需要调用，调用格式：\n接口.super.方法名称(参数列表)\n代码 package com.demo; /** 1.接口中的默认方法：① 向下兼容 ② 便于类的维护。 2.细节问题： ① 接口中的默认方法，子类或子接口都继承该方法。可以根据需要进行重写。 ② 当子类实现的接口与继承的类有同名默认方法时，类优先原则。 ③ 当子类实现的多个接口中，有同名默认方法时，子类必须重写父接口的方法。 ④ 如果子类重写了父接口的默认方法，还需要使用该父接口中的默认方法。 格式： 父接口的名称.super.方法名称() */ public class 接口中的默认方法 { public static void main(string[] args) { zit2 t = new zit2(); t.fun1(); } } interface t2{ public void fun(); //接口中默认方法。 public default void fun1(){ system.out.println(\u0026#34;1111\u0026#34;); }; } interface t3{ //接口中默认方法。 public default void fun1(){ system.out.println(\u0026#34;33333\u0026#34;); }; } class m{ public void fun1(){ system.out.println(\u0026#34;2222\u0026#34;); } } class zit2 /*extends m */implements t2,t3{ @override public void fun() { } @override public void fun1() { t2.super.fun1(); } } class zit21 implements t2{ @override public void fun() { } } 接口的静态方法 1.接口中的静态方法：向类进行靠近\n2.关键字：\nstatic\n3.调用格式：\n接口的名称.方法名称()\n4.接口中的静态方法不能被子类继承，只能通过接口的名称的形式，进行调用\n代码 package com.demo; /** 1.接口中的静态方法：向类进行靠近 2.关键字： static 3.调用格式： 接口的名称.方法名称() 4.接口中的静态方法不能被子类继承，只能通过接口的名称的形式，进行调用。 */ public class 接口的静态方法 { public static void main(string[] args) { t5.fun(); zit5 t= new zit5(); } } interface t5{ public static void fun(){ system.out.println(111); } } class zit5 implements t5{ } 私有方法 1.9 接口私有方法。\nlambda表达式 1.概述\n1.语法 ：\n格式：\n(数据类型 参数名称,数据类型 参数名称) -\u0026gt; {\n方法体;\nreturn 返回值;\n}\n注意：\n① 其中数据类型 参数名称，由于1.7jdk类型推断的出现，数据类型可以省略。没有参数的\n情况下，()也不能省略\n② -\u0026gt; 叫箭头符号 也叫lambda运算符\n③ {}里面就是方法体的实现。\n2.用途：\nlambda表达式是匿名内部类的简化书写。该匿名内部类必须是一个接口，该接口中有且只有一\n个抽象方法。\n不能是一个类。\n3.函数式接口：\n接口，该接口中有且只有一个抽象方法\n4.@functionalinterface 该注解可以校验是否为函数式接口。\npackage com.demo; /** 1.语法 ： 格式： (数据类型 参数名称,数据类型 参数名称) -\u0026gt; { 方法体; } 注意： ① 其中数据类型 参数名称，由于1.7jdk类型推断的出现，数据类型可以省略。没有参数的 情况下，()也不能省略 ② -\u0026gt; 叫箭头符号 也叫lambda运算符 ③ {}里面就是方法体的实现。 2.用途： lambda表达式是匿名内部类的简化书写。该匿名内部类必须是一个接口，该接口中有且只有一 个抽象方法。 不能是一个类。 3.函数式接口： 接口，该接口中有且只有一个抽象方法 4.@functionalinterface 该注解可以校验是否为函数式接口。 */ public class lambda表达式 { public static void main(string[] args) { /* new t(){ @override public void fun() { } };*/ new t(){ @override public void fun() { } }; // 简化 t t= ()-\u0026gt;{ system.out.println(\u0026#34;aaaa\u0026#34;); }; t t1= ()-\u0026gt;{ system.out.println(\u0026#34;bbbb\u0026#34;); }; t.fun(); t1.fun(); //类 /* new f(){ @override public void sf() { super.sf(); } };*/ // f f = ()-\u0026gt;{}; } } @functionalinterface interface t{ public void fun(); // public void fun1(); } /* class f{ public void sf(){} }*/ lambda表达式的格式 1.如果{}的方法体中语句只有一句，可以省略大括号不写。\n2.对于lambda表达式来说，()中的数据类型可以省略。并且参数名称可以是任意的标识符。\n3.如果lambda表达式中，小括号里面的参数只有一个，lambda表达式的小括号也可以省略。\n4.如果lambda表达式中，方法体有返回值，并且只有返回值一句，{}和return都可以省略。\npackage com.demo; /** 1.如果{}的方法体中语句只有一句，可以省略大括号不写。 2.对于lambda表达式来说，()中的数据类型可以省略。并且参数名称可以是任意的标识符。 3.如果lambda表达式中，小括号里面的参数只有一个，lambda表达式的小括号也可以省略。 4.如果lambda表达式中，方法体有返回值，并且只有返回值一句，{}和return都可以省略。 */ public class lambda表达式的书写格式 { public static void main(string[] args) { /*m m = ()-\u0026gt;{ system.out.println(\u0026#34;aaaa\u0026#34;); };*/ // 简化 /* m m= ()-\u0026gt; system.out.println(\u0026#34;aaaa\u0026#34;); m.fun();*/ /* m1 m1 = (b)-\u0026gt;{ system.out.println(\u0026#34;bbbb\u0026#34;); };*/ //简化 /* m1 m1=b-\u0026gt; system.out.println(b); m1.mf(12);*/ /* m2 m2 = (a,b)-\u0026gt;{ system.out.println(a+b); };*/ /*m3 m3= a -\u0026gt;{ return a; };*/ //简化 m3 m3 = a-\u0026gt; a; int i = m3.mf3(12); system.out.println(i); } } interface m{ public void fun(); } interface m1{ public void mf(int a); } interface m2{ public void mf2(string a,int b); } interface m3{ public int mf3(int a); } 方法引用 1.概述 1.方法引用：\n① 对象::方法名称\n② 类名::方法名称\n注意：\n1》 ::双冒号运算符，也叫方法引用运算符\n2》方法引用是对lambda的进一步简化，当lambda表达式的方法体是由已有方法实现，可以通\n过调用方法的格式进行简化。\npackage com.demo; /** 1.方法引用： ① 对象::方法名称 ② 类名::方法名称 注意： 1》 ::双冒号运算符，也叫方法引用运算符 2》方法引用是对lambda的进一步简化，当lambda表达式的方法体是由已有方法实现，可以通 过调用方法的格式进行简化。 */ public class 方法引用 { public static void main(string[] args) { // tm t = a -\u0026gt;integer.valueof(a); //简化 /*tm t = integer::valueof; system.out.println(t.fun(\u0026#34;123\u0026#34;));*/ /* tm1 t1 = a -\u0026gt; system.out.println(a); t1 = system.out::println;*/ fm f = new fm(); // tm1 t2 = a -\u0026gt;f.n(a); //简化 tm1 t2 = f::n; fm1 fm = new fm1(); // tm2 t3 = (a,b)-\u0026gt; fm.kk1(a,b); tm2 t3 = fm1::kk1; t3.add(1,2); } } interface tm{ public int fun(string a); } interface tm1{ public void k(string a); } class fm{ public void n(string a){ system.out.println(a); } } interface tm2{ public void add(int a,int b); } class fm1{ public static void kk1(int a,int b){ system.out.println(a+b); } } 四大函数式接口 1.概述 1.四大函数式接口：\n1\u0026gt;consumer 消费型接口\nconsumer\u0026lt;t\u0026gt;:accept(t t)\n常用方法：\nandthen(consumer) 先执行对象的accept，再执行参数的accept。\n2\u0026gt;supplier 供给型接口\nsupplier\u0026lt;t\u0026gt; t get()\npackage com.demo; import java.util.function.consumer; import java.util.function.supplier; /** 1.四大函数式接口： 1\u0026gt;consumer 消费型接口 consumer\u0026lt;t\u0026gt;:accept(t t) 常用方法： andthen(consumer) 先执行对象的accept，再执行参数的accept。 2\u0026gt;supplier 供给型接口 supplier\u0026lt;t\u0026gt; t get() function 函数型接口 predicate 断言型接口 */ public class 四大内置函数式接口 { public static void main(string[] args) { consumer\u0026lt;string\u0026gt; con = a-\u0026gt; system.out.println(\u0026#34;aaaa\u0026#34;); // consumer\u0026lt;string\u0026gt; con = system.out::println; // con.accept(\u0026#34;abc\u0026#34;); /*consumer\u0026lt;string\u0026gt; con1 = a-\u0026gt;{ system.out.println(\u0026#34;bbbb\u0026#34;); }; consumer\u0026lt;string\u0026gt; con2 = con.andthen(con1); con2.accept(\u0026#34;mm\u0026#34;);*/ // 2\u0026gt;supplier 供给型接口 // supplier\u0026lt;t\u0026gt; t get() supplier\u0026lt;integer\u0026gt; sl = ()-\u0026gt;5; integer it = sl.get(); system.out.println(it); } } 断言型接口 1.predicate 断言型接口\npredicate\u0026lt;t\u0026gt; boolean test(t t) 断言 测试：\n2.常用方法：\n① and \u0026amp;\u0026amp; 与\n② or ||或\n③ negate() !非\npackage com.demo; import java.util.function.predicate; /** 1.predicate 断言型接口 predicate\u0026lt;t\u0026gt; boolean test(t t) 断言 测试： 2.常用方法： ① and \u0026amp;\u0026amp; 与 ② or ||或 ③ negate() !非 */ public class 四大内置函数式接口1 { public static void main(string[] args) { predicate\u0026lt;integer\u0026gt; p = t -\u0026gt; t\u0026gt;5; // system.out.println(p.test(10)); predicate\u0026lt;integer\u0026gt; p1 = t -\u0026gt; t\u0026lt;20; //要求t\u0026gt;5 并且t\u0026lt;20 predicate\u0026lt;integer\u0026gt; p2 = p.and(p1); // system.out.println(p2.test(22)); //要求t\u0026gt;5或t\u0026lt;20 predicate\u0026lt;integer\u0026gt; p3 = p.or(p1); //t\u0026lt;=5 predicate\u0026lt;integer\u0026gt; p4 = p.negate(); system.out.println(p4.test(-13)); } } 4.函数型接口\npackage com.demo; import java.util.function.function; /** 1.function 函数型接口: function\u0026lt;t,r\u0026gt; r apply(t t) 2.常用方法： \u0026lt;v\u0026gt; function\u0026lt;t,v\u0026gt; andthen(function\u0026lt;? super r,? extends v\u0026gt; after) */ public class 四大内置函数式接口之函数型接口 { public static void main(string[] args) { function\u0026lt;string,integer\u0026gt; fc = t-\u0026gt;{ system.out.println(1111); return integer.valueof(t); }; // integer value = fc.apply(\u0026#34;123\u0026#34;); // system.out.println(value); // function\u0026lt;string ,string\u0026gt; fc1 = t-\u0026gt;t.concat(\u0026#34;abc\u0026#34;); // system.out.println(fc1.apply(\u0026#34;bcd\u0026#34;)); function\u0026lt;integer,string\u0026gt; fc3= t-\u0026gt;{ system.out.println(222); return t.tostring(); }; function\u0026lt;string,string\u0026gt; fc2 = fc.andthen(fc3); //先执行对象的apply方法然后再执行参数的apply方法。 system.out.println(fc2.apply(\u0026#34;123\u0026#34;));; } } streamapi 1.概念 streamapi:对集合这样的数据的查找 过滤 筛选 等操作的补充，流本身不是数据源，不能存储数据\n的。\n2.stream对象的获取 collection\n① parallelstream() 获取的并行流\n② stream() 获取串行流\nstream\n① of(t\u0026hellip; values) 获取串行流\n3.stream工作原理 ① 获取stream流对象\n② 中间操作(惰性求值：没有终止操作，不执行)\n③ 终止操作\n4.常用方法\npackage com.demo; import java.util.optional; import java.util.stream.stream; /** 1.中间操作： ① concat(stream\u0026lt;? extends t\u0026gt; a, stream\u0026lt;? extends t\u0026gt; b) 合并流 ② distinct() 去重复 注意： 对于自定义类，要注意重写equals方法。才能去重复 ③ filter(predicate\u0026lt;? super t\u0026gt; predicate) 过滤 ④ limit(long maxsize) 截取参数为最大值 ⑤ map(function\u0026lt;? super t,? extends r\u0026gt; mapper) 映射 注意： 映射是根据返回值来映射新的流元素。 ⑥ skip(long n) 跳过 n从1开始 2.终止操作： ① count() 统计个数，返回值为long类型 ② foreach(consumer\u0026lt;? super t\u0026gt; action) 对流中所有元素执行该操作 ③ max(comparator\u0026lt;? super t\u0026gt; comparator) /min(comparator\u0026lt;? super t\u0026gt; comparator) 求最大/小值 */ public class streamapi常用方法 { public static void main(string[] args) { /*stream\u0026lt;integer\u0026gt; it = stream.of(1, 2, 3, 4, 5); stream\u0026lt;integer\u0026gt; it1 = stream.of(6,7,8,9,10); stream\u0026lt;integer\u0026gt; concat = stream.concat(it, it1); concat.filter(t-\u0026gt;t\u0026gt;5).foreach(system.out::println);*/ // ① count() 统计个数，返回值为long类型 /*long count = stream.of(1, 2, 3, 4, 5, 6, 7).count(); system.out.println(count);*/ // ② distinct() 去重复 // stream.of(1, 2, 3, 4, 5, 6, 7,6,3).distinct().foreach(system.out::println); //对于自定义类，要注意重写equals方法。才能去重复 // stream.of(new person(\u0026#34;张三\u0026#34;,19),new person(\u0026#34;张 三\u0026#34;,19)).distinct().foreach(system.out::println); // ④ limit(long maxsize) 截取参数为最大值 // stream.of(1,2,3,4,5,6,7).limit(8).foreach(system.out::println); // ⑤ map(function\u0026lt;? super t,? extends r\u0026gt; mapper) 映射 // stream.of(1,2,3,4,5,6,7).map(t-\u0026gt;t+3).foreach(system.out::println); //涨工资 /*stream.of(new person(\u0026#34;张三\u0026#34;,19),new person(\u0026#34;张三1\u0026#34;,20),new person(\u0026#34;张三 2\u0026#34;,21)).map( t-\u0026gt;new person(t.name,t.age+3)).foreach(system.out::println);*/ // ③ max(comparator\u0026lt;? super t\u0026gt; comparator) /min(comparator\u0026lt;? super t\u0026gt; comparator) 求最大/小值 // optional\u0026lt;integer\u0026gt; max = stream.of(1, 2, 3, 4, 5, 6, 7, -10, 20, -19).max((x, y) -\u0026gt; x - y); // //get() 获取该类对象的封装的值 // system.out.println(max.get()); //optional 用于空指针的处理，防止空指针异常 // string msg = null; // optional\u0026lt;string\u0026gt; value = optional.of(msg); // optional\u0026lt;string\u0026gt; value2 = optional.ofnullable(msg); } } class person{ string name; int age; public person() { } public person(string name, int age) { this.name = name; this.age = age; } @override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; person person = (person) o; if (age != person.age) return false; return name != null ? name.equals(person.name) : person.name == null; } @override public int hashcode() { int result = name != null ? name.hashcode() : 0; result = 31 * result + age; return result; } @override public string tostring() { return \u0026#34;person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 2.常用方法\npackage com.demo; import java.util.list; import java.util.stream.collectors; import java.util.stream.stream; /** 1.sorted() 按自然顺序排序 中间操作 2.sorted(comparator\u0026lt;? super t\u0026gt; comparator) 根据第三方比较器进行排序 (***) 3.collect(collector\u0026lt;? super t,a,r\u0026gt; collector)stream流转集合 注意： 通过collectors获取collector子类对象。 1》 toxxx tolist toset tomap */ public class streamapi常用方法一 { public static void main(string[] args) { // 1.sorted() 按自然顺序排序 中间操作 // stream.of(1,-15,20,32,47,-50).sorted().foreach(system.out::println); // stream.of(\u0026#34;-1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;111\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;123\u0026#34;).sorted((x,y)-\u0026gt;integer.valueof(x)- integer.valueof(y)).foreach(system.out::println); // 3.collect(collector\u0026lt;? super t,a,r\u0026gt; collector)stream流转集合 list\u0026lt;integer\u0026gt; list = stream.of(1, 2, 3, 4, 5, 6, 7).collect(collectors.tolist()); } } 注解 1.概述 注释：对代码的解释说明。\n注解：annotation。\n注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取， 并 执行相应的处理\n注解的作用 ① 文档提取：javadoc api @author @since\n② 编译检测：@functionalinterface @override\n③ 代码依赖：@service @controller 主要是代替配置文件。\n3.自定义注解 [权限修饰符] @interface 注解的名称{\n数据类型[] 属性名称() default 默认值;\n数据类型[] 属性名称() default 默认值;\n}\n注意：数据类型，可以是string 基本数据类型 class类型，这些类型可以是数组形式 ，其余不行。\n如果自定义注解中 ，属性的名称为value，在调用时，可以省略value的名称。\npackage com.demo; import java.util.scanner; /** 1.自定义注解格式： [权限修饰符] @interface 注解的格式{ 数据类型[] 属性名称() default 默认值; } 注意： 其中 属性名称前的数据类型： 可以是基本数据类型，也可以是字符串，还可以class类型 */ public class 自定义注解 { public static void main(string[] args) { scanner sc = new scanner(system.in); string s1= sc.nextline(); } } @myannation(value =\u0026#34;kk\u0026#34;,cs={int.class,string.class}) class m{ @myannation(cs={string.class,double.class},value = \u0026#34;ff\u0026#34;) public void fun(){ } } @interface myannation{ string value() default \u0026#34;mm\u0026#34;; //数组 class[] cs(); } 4.元注解 package com.demo; import java.lang.annotation.*; /** 1.元注解： 注解的注解。 2.作用：用来修饰限定注解的注解。 3.常见元注解： 1》@target 表示可以修饰的成员 elementtype： type field method 2》@retention 表示注解的生命周期(***)。 retentionpolicy： source 编译期存在 class 在class文件中存在 runtime 运行期存在。 3》@documented: 注解写入文档 4》@inherited : 子类继承父类的注解（子类没有任何注解修饰） */ public class 元注解 { public static void main(string[] args) { class clazz = n.class; //注意：一个自定义注解，如果想在运行期能够获取，必须使用生命周期为runtime。 annotation value = clazz.getannotation(my1.class); system.out.println(value); class clazz1 = zin.class; annotation value2 = clazz1.getannotation(my1.class); system.out.println(value2); n n = new n(); n.fun(); //抑制编译器警告 @suppresswarnings(\u0026#34;unused\u0026#34;) int a = 5; } } @my1 class n{ @my1 @deprecated //已过时 public void fun(){ } } @inherited @retention(retentionpolicy.runtime) @target({elementtype.method,elementtype.type}) @interface my1{ string value() default \u0026#34;kk\u0026#34;; } class zin extends n{ } 常见注解 @deprecated:用于标志过时的类、方法和成员变量 @override:用于修饰重写的方法 @suppresswarnings:用户忽略警告 @functionalinterface：函数式接口检测 ","date":"2021-11-11","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430214272/","summary":"新特性 特点 (***)1.Lambda表达式 (***)2.StreamAPI 3.对于时间类的增强。 4.Optional 用于处理空指针异常。 (**)5.接口中静态方法和默认方法 6.函数式接口。 7.HashMap底","title":"1.8新特性"},{"content":"反射 概念 java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。\n这种动态获取程序信息以及动态调用对象的功能称为java语言的反射机制\nclass class 类的实例表示正在运行的 java 应用程序中的类和接口\npackage com.demo; /** 1.获取class类的对象 ① forname(string classname) 注意： 参数必须是类的完全限定名。 ② .class ③ getclass() */ public class 反射概述 { public static void main(string[] args) throws classnotfoundexception { person p = new person(); // p.show(); class clazz = p.getclass(); system.out.println(clazz); class clazz1 = person.class; system.out.println(clazz1); //person 简名 class clazz2 = class.forname(\u0026#34;com.demo.person\u0026#34;); system.out.println(clazz2); } } class person{ string name; int age; public void show(){} } class类对象的获取 ① forname(string classname)\n② .class\n③ getclass()\n类的加载 1.类加载过程：按需加载，并且只加载一次。\n如果需要用到该类，在方法区中查找是否有该类存在，如果存在，直接使用，如果不存在，将硬盘\n上.class通过类加载器加载进内存。 将.class文件转换成class类的对象。该对象只有一个，该对象\n代表的是类。\n准备： 静态成员开辟空间。\n类的连接 ： 验证 准备 解析 2.类加载机制： 双亲委派机制 父类加载\n加载到方法区中的类需要保证唯一性，采用双亲委派，父类加载的机制。 1.启动/引导类加载器 2.扩展类加载器 3.应用程序/系统程序类加载器 反射创建对象 概述 1.jvm中通过class对象来创建该对象代表的类的对象\n2.常用方法:\n① newinstance() 调用空参的构造方法创建对象 ② getconstructors() 获取所有的构造方法 ③ getconstructor(class\u0026lt;?\u0026gt;... parametertypes) 3.constructor:表示构造方法类\n① newinstance(object... initargs) 创建对象 代码 package com.demo; import java.lang.reflect.constructor; import java.lang.reflect.invocationtargetexception; /** 1.jvm中通过class对象来创建该对象代表的类的对象 2.常用方法: ① newinstance() 调用空参的构造方法创建对象 ② getconstructors() 获取所有的构造方法 ③ getconstructor(class\u0026lt;?\u0026gt;... parametertypes) 3.constructor:表示构造方法类 ① newinstance(object... initargs) 创建对象 */ public class class类对象的常用方法 { public static void main(string[] args) throws classnotfoundexception, illegalaccessexception, instantiationexception, nosuchmethodexception, invocationtargetexception { // a a = new a(); /* class clazz = class.forname(\u0026#34;com.demo.a\u0026#34;); a a = (a) clazz.newinstance(); a.show(); class clazz1 = b.class; b b = (b) clazz1.newinstance(); system.out.println(b);*/ // ② getconstructors() 获取所有的构造方法 class clazz2 = a.class; /* constructor[] cs = clazz2.getconstructors(); for (constructor c : cs) { system.out.println(c); }*/ constructor cn = clazz2.getconstructor(string.class, int.class); // a a1 = new a(\u0026#34;张三\u0026#34;,19); a o = (a) cn.newinstance(\u0026#34;张三\u0026#34;, 19); // system.out.println(cn); o.show(); } } class a{ string name; int age; public void show(){ system.out.println(name +\u0026#34;:\u0026#34;+age); } public a() { } public a(string name, int age) { this.name = name; this.age = age; } } class b {} package com.demo; import java.lang.reflect.constructor; import java.lang.reflect.invocationtargetexception; /** 1.getconstructors()细节问题： 注意：凡是只有getxxx的形式，都只能获取public修饰的。如果需要获取 其它的权限的时候，使用getdeclaredxxx() 2.关于private访问权限的取消： setaccessible(boolean flag) 如果参数为true 表示取消java的语法访问检测，称为打开权限。 */ public class class类创建对象 { public static void main(string[] args) throws nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception { class clazz = person.class; /*constructor[] cs = clazz.getdeclaredconstructors(); for (constructor c : cs) { system.out.println(c); }*/ constructor c = clazz.getdeclaredconstructor(string.class, int.class); //打开权限 c.setaccessible(true); person p = (person) c.newinstance(\u0026#34;张三\u0026#34;, 19); p.show(); } } class person{ string name; int age; public void show(){ system.out.println(name +\u0026#34;:\u0026#34;+ age); } public person() { } private person(string name, int age) { this.name = name; this.age = age; } } 反射构造方法的细节问题 概述 1.getconstructors()细节问题：\n注意：凡是只有getxxx的形式，都只能获取public修饰的。如果需要获取\n其它的权限的时候，使用getdeclaredxxx()，该形式只能用于本类声明，但是getxxx的形式，如果\n父类是public也可以获取。\n2.关于private访问权限的取消：\nsetaccessible(boolean flag) 如果参数为true 表示取消java的语法访问检测，称为打开权限。\n代码 package com.demo; import java.lang.reflect.constructor; import java.lang.reflect.invocationtargetexception; /** 1.getconstructors()细节问题： 注意：凡是只有getxxx的形式，都只能获取public修饰的。如果需要获取 其它的权限的时候，使用getdeclaredxxx() 2.关于private访问权限的取消： setaccessible(boolean flag) 如果参数为true 表示取消java的语法访问检测，称为打开权限。 */ public class class类创建对象 { public static void main(string[] args) throws nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception { class clazz = person.class; /*constructor[] cs = clazz.getdeclaredconstructors(); for (constructor c : cs) { system.out.println(c); }*/ constructor c = clazz.getdeclaredconstructor(string.class, int.class); //打开权限 c.setaccessible(true); person p = (person) c.newinstance(\u0026#34;张三\u0026#34;, 19); p.show(); } } class person{ string name; int age; public void show(){ system.out.println(name +\u0026#34;:\u0026#34;+ age); } public person() { } private person(string name, int age) { this.name = name; this.age = age; } } 反射获取属性(字段field) 概述 1.获取字段：\n① getfield(string name) 指定的修饰符为public字段 ② getfields() 修饰符为public所有字段 ③ getdeclaredfield(string name) 指定的声明的字段 ④ getdeclaredfields() 指定的声明所有的字段 2.设置/获取字段值 setter getter\n① set(object obj, object value) /get(object obj) 代码 package com.demo; import java.lang.reflect.field; /** 1.获取字段： ① getfield(string name) 指定的修饰符为public字段 ② getfields() 修饰符为public所有字段 ③ getdeclaredfield(string name) 指定的声明的字段 ④ getdeclaredfields() 指定的声明所有的字段 2.设置/获取字段值 setter getter ① set(object obj, object value) /get(object obj) */ public class 字段 { public static void main(string[] args) throws nosuchfieldexception, illegalaccessexception, instantiationexception { class clazz = student.class; field age = clazz.getfield(\u0026#34;age\u0026#34;); /*system.out.println(age); class clazz1 = middlestudent.class; field age1 = clazz1.getfield(\u0026#34;age\u0026#34;); system.out.println(age1);*/ student st = (student) clazz.newinstance(); /*age.set(st, 20); system.out.println(age.get(st));*/ field name = clazz.getdeclaredfield(\u0026#34;name\u0026#34;); //打开权限 name.setaccessible(true); name.set(st, \u0026#34;张三\u0026#34;); st.show(); } } class student{ private string name; public int age; public void show(){ system.out.println(name +\u0026#34;:\u0026#34;+ age); } public student() { } private student(string name, int age) { this.name = name; this.age = age; } } class middlestudent extends student{} 反射之方法 概念 1.获取方法：\n① getmethod(string name, class\u0026lt;?\u0026gt;... parametertypes) ② getmethods() ③ getdeclaredmethod(string name, class\u0026lt;?\u0026gt;... parametertypes) ④ getdeclaredmethods() 2.调用方法：\ninvoke(object obj, object... args) ① 第一个参数表示对象，如果是静态方法可以置为null ② 第二个参数表示方法的实参，如果没有参数也可以置为null或不写。 ③ 该方法的返回值为方法调用的返回值。 void 返回值为null 代码 package com.demo; import java.lang.reflect.invocationtargetexception; import java.lang.reflect.method; /** 1.获取方法： ① getmethod(string name, class\u0026lt;?\u0026gt;... parametertypes) ② getmethods() ③ getdeclaredmethod(string name, class\u0026lt;?\u0026gt;... parametertypes) ④ getdeclaredmethods() 2.调用方法： invoke(object obj, object... args) ① 第一个参数表示对象，如果是静态方法可以置为null ② 第二个参数表示方法的实参，如果没有参数也可以置为null或不写。 ③ 该方法的返回值为方法调用的返回值。 void 返回值为null */ public class 方法 { public static void main(string[] args) throws illegalaccessexception, instantiationexception, nosuchmethodexception, invocationtargetexception { //先找到class class clazz = worker.class; //创建worker类的对象 worker wr = (worker) clazz.newinstance(); //获取show方法 由于该方法没有参数，可以使用null或直接省略不写。 /*method show = clazz.getmethod(\u0026#34;show\u0026#34;); object value = show.invoke(wr); system.out.println(value);*/ /*method working = clazz.getmethod(\u0026#34;working\u0026#34;, string.class); object value1 = working.invoke(wr, \u0026#34;建筑\u0026#34;); system.out.println(value1);*/ method add = clazz.getmethod(\u0026#34;add\u0026#34;, int.class, int.class); int value2 = (int) add.invoke(wr, 15, 23); system.out.println(value2); method fun = clazz.getmethod(\u0026#34;fun\u0026#34; ); object value3 = fun.invoke(null); } } class worker{ string name; int age; public void show(){ system.out.println(name +\u0026#34;:\u0026#34;+ age); } public void working(string action){ system.out.println(\u0026#34;工人从事\u0026#34;+action+\u0026#34;行业\u0026#34;); } public int add(int a,int b){ return a+b; } public static void fun(){ system.out.println(\u0026#34;aaaaa\u0026#34;); } } 反射总结 概述 概念 class 获取方式三种 字段 set/get 构造方法 newinstance 方法 invoke\n反射的其它方法 package com.demo; /** 1.getinterfaces() 获取父接口 2.getname() 返回类/接口的完全限定名。 3.getsuperclass()获取父类 4.getclassloader() 获取类加载器 */ public class 反射的其它方法 { public static void main(string[] args) { class clazz = zia.class; /*class[] in = clazz.getinterfaces(); for (class aclass : in) { system.out.println(aclass.getname()); }*/ /*class sc = clazz.getsuperclass(); system.out.println(sc);*/ classloader cl = clazz.getclassloader(); system.out.println(cl.getparent().getparent()); } } class a { } interface t{} class zia extends a implements t{} 暴力反射 package com.exec; import java.lang.reflect.invocationtargetexception; import java.lang.reflect.method; import java.util.arraylist; public class 暴力反射 { public static void main(string[] args) throws nosuchmethodexception, invocationtargetexception, illegalaccessexception { arraylist\u0026lt;integer\u0026gt; list = new arraylist\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); class clazz = list.getclass(); method add = clazz.getmethod(\u0026#34;add\u0026#34;, object.class); add.invoke(list, \u0026#34;abc\u0026#34;); system.out.println(list); } } 来电显示 package com.exec; import java.io.file; import java.io.filenotfoundexception; import java.io.filereader; import java.io.ioexception; import java.util.properties; /** 1.手机的来电显示： 2.配置文件。xml */ public class 来电显示 { public static void main(string[] args) throws ioexception, classnotfoundexception, illegalaccessexception, instantiationexception { properties prp = new properties(); prp.load(new filereader(new file(\u0026#34;day27b\\\\p.properties\u0026#34;))); class clazz = class.forname(prp.getproperty(\u0026#34;classname\u0026#34;)); phonei pi = (phonei) clazz.newinstance(); pi.display(); } } class phonei{ public void display(){ system.out.println(\u0026#34;显示号码\u0026#34;); } } class phoneii extends phonei{ @override public void display() { super.display(); system.out.println(\u0026#34;大头贴\u0026#34;); } } class phoneiii extends phoneii{ @override public void display() { super.display(); system.out.println(\u0026#34;归属地。。。\u0026#34;); } } class phoneiiii extends phoneiii{} ","date":"2021-11-09","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430222140/","summary":"反射 概念 Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和","title":"反射"},{"content":"网络编程 网络编程概述 网络 计算机网络：计算机网络系统就是利用通信设备和线路将地理位置不同、功能独立的多个计算机系统互\n联起来，以功能完善的网络软件实现网络中资源共享和信息传递的系统\n网络三要素 1.ip地址：标识计算机，是计算机在互联网上的唯一标识地址。\n2.端口号：标识计算机上的软件的。不同的软件有不同的端口号，端口号 2个字节，0~65535 一般建\n议使用8000之后。\nmysql 3306 tomcat 8080\n3.通信协议：双方应该遵循的规则。\nhttp：超文本传输协议\nftp: 文件传输协议\ntcp/ip:传输控制协议/网际协议\nudp:用户数据包协议\n网络的分层架构 ip地址 ip地址（internet protocol address）是指互联网协议地址，又译为网际协议地址。标识计算机在互联网上的唯一地址。\n格式：\nipv4:点分十进制，32位，由4个部分组成。例如： 192.168.0.1\nipv6：冒分十六进行，128位，例如：x:x:x 一个ipv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::” ip地址的分类： abc de特殊地址 (***)组播地址 d类ip地址在历史上被叫做多播地址(multicast address)，即组播地址 224.0.0.0\n到239.255.255.255\n()广播地址 255.255.255.255 ()\n本地回环地址 127.0.0.1 域名 localhost\njava提供的ip地址 inetaddress\n1.常用方法：\n① getbyname(string host) 根据参数获取inetadress对象\n② gethostname() 获取ip地址中域名的字符串形式\n③ gethostaddress() 获取ip地址的字符串形式\n④ getallbyname(string host)获取ip地址的数组\n⑤ getlocalhost() 返回本机的ip地址\n⑥ tostring() 将ip地址转换为字符串。\n代码 package com.demo; import java.net.inetaddress; import java.net.unknownhostexception; /** 1.常用方法： ① getbyname(string host) 根据参数获取inetadress对象 ② gethostname() 获取ip地址中域名的字符串形式 ③ gethostaddress() 获取ip地址的字符串形式 ④ getallbyname(string host)获取ip地址的数组 ⑤ getlocalhost() 返回本机的ip地址 ⑥ tostring() 将ip地址转换为字符串。 */ public class ip地址 { public static void main(string[] args) throws unknownhostexception { /*inetaddress ip = inetaddress.getbyname(\u0026#34;www.baidu.com\u0026#34;); system.out.println(ip.gethostname()); system.out.println(ip.gethostaddress());*/ // ④ getallbyname(string host)获取ip地址的数组 /* inetaddress[] ips = inetaddress.getallbyname(\u0026#34;www.baidu.com\u0026#34;); for (inetaddress ip : ips) { system.out.println(ip); }*/ // ⑤ getlocalhost() 返回本机的ip地址 inetaddress ip1 = inetaddress.getlocalhost(); system.out.println(ip1); inetaddress ip2 = inetaddress.getbyname(\u0026#34;localhost\u0026#34;); system.out.println(ip2); } } udp 概念 udp：传输层协议。用户数据包协议（udp，user datagram protocol）。\n无连接的传输协议。\n特点：\n无连接、不可靠、快速传输。数据报包进行传输，包最大不会超过64k\n使用场景：\n实时直播，视频，网游。\njava中提供的udp协议的类 datagramsocket：发送端/接收端：此类表示用来发送和接收数据报包的套接字\ndatagrampacket：表示数据报包。实现无连接包投递服务 发送端 发送端步骤\n1.发送端：\n① 发送端端点对象：\ndatagramsocket()\n② 打包数据\ndatagrampacket(byte[] buf, int length, inetaddress address, int port)\n③ 发送\nsend(datagrampacket p)\n④ 关闭资源\nclose()\n代码 package com.udpdemo; import java.io.ioexception; import java.net.*; /** 1.发送端： ① 发送端端点对象： datagramsocket() ② 打包数据 datagrampacket(byte[] buf, int length, inetaddress address, int port) ③ 发送 send(datagrampacket p) ④ 关闭资源 close() */ public class 发送端 { public static void main(string[] args) throws ioexception { datagramsocket ds = new datagramsocket(); byte[] bt = \u0026#34;你好\u0026#34;.getbytes(); datagrampacket dp = new datagrampacket(bt,bt.length, inetaddress.getbyname(\u0026#34;localhost\u0026#34;),9000); ds.send(dp); //接收 byte[] bt1= new byte[1024]; datagrampacket dp1 = new datagrampacket(bt1,bt1.length); ds.receive(dp1); system.out.println(\u0026#34;发送端接收到的数据\u0026#34;+new string(dp1.getdata(),0,dp1.getlength())); ds.close(); } } 接收端 ① 接收端端点对象：datagramsocket(int port)\n② 接收数据报包，先创建空数据报包 然后接收数据。\ndatagrampacket(byte[] buf, int length)\n③ 接收：\nreceive(datagrampacket p)\n④ 关闭资源\nclose()\n3.datagrampacket常用方法：\n① getlength() 获取数据报包中读取的数据的字节长度。\n② getaddress() 接收端获取的发送端的ip地址\n③ getport() 接收端获取的发送端的端口号\n代码 package com.udpdemo; import java.io.ioexception; import java.net.datagrampacket; import java.net.datagramsocket; import java.net.socketexception; /** 2.接收端： ① 接收端端点对象：datagramsocket(int port) ② 接收数据报包，先创建空数据报包 然后接收数据。 datagrampacket(byte[] buf, int length) ③ 接收： receive(datagrampacket p) ④ 关闭资源 close() 3.datagrampacket常用方法： ① getlength() 获取数据报包中读取的数据的字节长度。 ② getaddress() 接收端获取的发送端的ip地址 ③ getport() 接收端获取的发送端的端口号 */ public class 接收端 { public static void main(string[] args) throws ioexception { datagramsocket ds = new datagramsocket(9000); byte[] bt = new byte[1024]; //数据报包的创建 空白 datagrampacket dp = new datagrampacket(bt,bt.length); //接收 ds.receive(dp); system.out.println(new string(bt,0,dp.getlength())); //发送 byte[] bt1 = \u0026#34;发送端你好\u0026#34;.getbytes(); //打数据报包 datagrampacket dp1 = new datagrampacket(bt1, bt1.length,dp.getaddress(),dp.getport()); //接收端向发送端发送数据。 ds.send(dp1); ds.close(); } } 简易聊天室 发送端代码 package com.demo; import java.io.ioexception; import java.net.*; import java.util.scanner; public class 发送端 { public static void main(string[] args) throws ioexception { datagramsocket ds = new datagramsocket(); scanner sc = new scanner(system.in); while (true) { system.out.println(\u0026#34;请输入您要发送到接收端的数据:\u0026#34;); string msg = sc.nextline(); byte[] bt = msg.getbytes(); //打数据报包 datagrampacket dp = new datagrampacket(bt, bt.length, inetaddress.getlocalhost(),9000); //发送 ds.send(dp); //结束 if (msg.equals(\u0026#34;exit\u0026#34;)){ break; } //接收 byte[] bt1 = new byte[1024]; //空的数据报包进行接收 datagrampacket dp1 = new datagrampacket(bt1, bt1.length); //接收 ds.receive(dp1); system.out.println(\u0026#34;从接收端接收的信息为：\u0026#34;+new string(bt1,0,dp1.getlength())); } //关闭资源 ds.close(); } } 接收端代码 package com.demo; import java.io.ioexception; import java.net.datagrampacket; import java.net.datagramsocket; import java.util.scanner; public class 接收端 { public static void main(string[] args) throws ioexception { datagramsocket ds = new datagramsocket(9000); scanner sc = new scanner(system.in); while (true) { //接收 byte[] bt = new byte[1024]; datagrampacket dp = new datagrampacket(bt,bt.length); ds.receive(dp); string rec = new string(bt, 0, dp.getlength()); system.out.println(\u0026#34;从发送端来的数据为：\u0026#34;+rec); //结束 if (rec.equals(\u0026#34;exit\u0026#34;)){ break; } //发送 system.out.println(\u0026#34;请输入向发送端发送的数据:\u0026#34;); string msg = sc.nextline(); byte[] bt1 = msg.getbytes(); datagrampacket dp1 = new datagrampacket(bt1,bt1.length,dp.getaddress(),dp.getport()); ds.send(dp1); } //关闭资源 ds.close(); } } 广播地址 概述 广播地址： 255.255.255.255 所有\n代码 package com.demo1; import java.io.ioexception; import java.net.datagrampacket; import java.net.datagramsocket; import java.net.inetaddress; /** 1.广播地址： 255.255.255.255 所有。 */ public class 广播地址 { public static void main(string[] args) throws ioexception { datagramsocket ds = new datagramsocket(); byte[] bt = \u0026#34;大家注意听课了。。。。\u0026#34;.getbytes(); datagrampacket dp = new datagrampacket(bt, bt.length, inetaddress.getbyname(\u0026#34;255.255.255.255\u0026#34;),9005 ); ds.send(dp); ds.close(); } } 组播地址 概述 1.组播地址 d类ip地址在历史上被叫做多播地址(multicast address)，即组播地址\n224.0.0.0到239.255.255.255\n2.组播 java提供的类： multicastsocket\n3.注意：\n组播必须加入组播组 ，才能接受组播信息。\njoingroup(inetaddress mcastaddr)\n发送端代码 package com.demo1; import java.io.ioexception; import java.net.datagrampacket; import java.net.inetaddress; import java.net.multicastsocket; /** 1.组播地址 d类ip地址在历史上被叫做多播地址(multicast address)，即组播地址 224.0.0.0到239.255.255.255 2.组播 java提供的类： multicastsocket 3.注意： 组播必须加入组播组 ，才能接受组播信息。 joingroup(inetaddress mcastaddr) */ public class 组播地址发送端 { public static void main(string[] args) throws ioexception { multicastsocket ms = new multicastsocket(); byte[] bt = \u0026#34;大家注意听课了。。。\u0026#34;.getbytes(); datagrampacket dp = new datagrampacket(bt, bt.length, inetaddress.getbyname(\u0026#34;224.0.0.6\u0026#34;),9000); ms.send(dp); ms.close(); } } 接收端代码 package com.demo1; import java.io.ioexception; import java.net.datagrampacket; import java.net.inetaddress; import java.net.multicastsocket; public class 组播地址接收端 { public static void main(string[] args) throws ioexception { multicastsocket ms = new multicastsocket(9000); byte[] bt = new byte[1024]; datagrampacket dp = new datagrampacket(bt, bt.length); //加入组播 ms.joingroup(inetaddress.getbyname(\u0026#34;224.0.0.6\u0026#34;)); ms.receive(dp); system.out.println(\u0026#34;从组播地址接收到的数据为：\u0026#34;+new string(bt,0,dp.getlength())); ms.close(); } } tcp协议 概述 tcp：传输控制协议（tcp，transmission control protocol）是一种面向连接的、可靠的、基于\n字节流的传输层通信协议\n使用场景：\n文件传输 需要保证数据完整性 tcp协议客户端 1.步骤：\n① 创建客户端对象:\nsocket(inetaddress address, int port)\n② 发送/接收数据\ngetinputstream() 读取\ngetoutputstream()写入\n代码 package com.tcpdemo; import java.io.ioexception; import java.io.outputstream; import java.net.inetaddress; import java.net.socket; import java.net.unknownhostexception; /** 1.步骤： ① 创建客户端对象: socket(inetaddress address, int port) ② 发送/接收数据 getinputstream() 读取 getoutputstream()写入 */ public class 客户端 { public static void main(string[] args) throws ioexception { socket sc = new socket(inetaddress.getbyname(\u0026#34;localhost\u0026#34;),9000); //发送数据 outputstream os = sc.getoutputstream(); //写出 os.write(\u0026#34;服务器您好\u0026#34;.getbytes()); //关闭 os.close(); sc.close(); } } tcp协议服务器端 1.步骤：\n① 创建服务器端对象：\nserversocket(int port)\n② 等待连接：\naccept() 侦听并接受到此套接字的连接。返回值就是连接到该服务器的客户端对象。\n③ 读取客户端发送的信息\n通过accept方法返回的socket获取输入流。\n代码 package com.tcpdemo; import java.io.ioexception; import java.io.inputstream; import java.net.serversocket; import java.net.socket; /** 1.步骤： ① 创建服务器端对象： serversocket(int port) ② 等待连接： accept() 侦听并接受到此套接字的连接。返回值就是连接到该服务器的客户端对象。 ③ 读取客户端发送的信息 通过accept方法返回的socket获取输入流。 */ public class 服务器端 { public static void main(string[] args) throws ioexception { serversocket ss = new serversocket(9000); //等待并监听 该方法一旦执行成功，意味着三次握手已经结束。 socket sc = ss.accept(); //读取 inputstream in = sc.getinputstream(); int value = 0; byte[] bt = new byte[1024]; while ((value=in.read(bt))!=-1){ system.out.println(new string(bt,0,value)); } //关闭 in.close(); ss.close(); } } tcp协议细节问题 概述 如果使用的是循环读取，由于写入必须到达流的末尾或文件的末尾才能取到-1，\n导致循环一直无法停止跳出，代码就没办法继续执行了。需要通过以下方法进行置为流的末尾。\n① shutdowninput()\n② shutdownoutput()\n客户端代码 package com.tcpdemo1; import java.io.ioexception; import java.io.inputstream; import java.io.outputstream; import java.net.inetaddress; import java.net.socket; /** 1.步骤： ① 创建客户端对象: socket(inetaddress address, int port) ② 发送/接收数据 getinputstream() 读取 getoutputstream()写入 2.细节问题： 如果使用的是循环读取，由于写入必须到达流的末尾或文件的末尾才能取到-1， 导致循环一直无法停止跳出，代码就没办法继续执行了。需要通过以下方法进行置为流的末尾。 ① shutdowninput() ② shutdownoutput() */ public class 客户端 { public static void main(string[] args) throws ioexception { socket sc = new socket(inetaddress.getbyname(\u0026#34;localhost\u0026#34;),9000); //发送数据 outputstream os = sc.getoutputstream(); //写出 os.write(\u0026#34;服务器您好\u0026#34;.getbytes()); //置于流的末尾 sc.shutdownoutput(); //接收从服务器端发来的数据 inputstream in = sc.getinputstream(); int value = 0; byte[] bt = new byte[1024]; while ((value = in.read(bt))!=-1){ system.out.println(new string(bt,0,value)); } //关闭 os.close(); in.close(); sc.close(); } } 服务器端代码 package com.tcpdemo1; import java.io.ioexception; import java.io.inputstream; import java.io.outputstream; import java.net.serversocket; import java.net.socket; /** 1.步骤： ① 创建服务器端对象： serversocket(int port) ② 等待连接： accept() 侦听并接受到此套接字的连接。返回值就是连接到该服务器的客户端对象。 ③ 读取客户端发送的信息 通过accept方法返回的socket获取输入流。 */ public class 服务器端 { public static void main(string[] args) throws ioexception { serversocket ss = new serversocket(9000); //等待并监听 该方法一旦执行成功，意味着三次握手已经结束。 socket sc = ss.accept(); //读取 inputstream in = sc.getinputstream(); int value = 0; byte[] bt = new byte[1024]; while ((value=in.read(bt))!=-1){ system.out.println(new string(bt,0,value)); } system.out.println(\u0026#34;=================\u0026#34;); //服务器端向客户端发送数据 outputstream out = sc.getoutputstream(); out.write(\u0026#34;客户端您好\u0026#34;.getbytes()); //关闭 in.close(); out.close(); ss.close(); } } 文件上传 原理 从客户端的硬盘上读取文件到客户端的java程序，然后通过java程序写入到服务器端的java程序，通过服务器端的java程序，写入到服务器的硬盘上。 客户端代码 package com.uploaddemo; import java.io.file; import java.io.fileinputstream; import java.io.ioexception; import java.io.outputstream; import java.net.inetaddress; import java.net.socket; /** 1.创建客户端对象 2. 读取硬盘上的文件，向服务器端写入 3.关闭资源 */ public class 客户端 { public static void main(string[] args)throws ioexception { socket s = new socket(inetaddress.getbyname(\u0026#34;localhost\u0026#34;),9000); //文件输入流 fileinputstream fis = new fileinputstream(new file(\u0026#34;c:\\\\users\\\\administrator\\\\desktop\\\\成功的阶梯.jpg\u0026#34;)); //向服务器写入 outputstream os = s.getoutputstream(); //读取硬盘上的文件，向服务器端写入 int value =0; byte[] bt = new byte[1024]; while ((value = fis.read(bt))!=-1){ os.write(bt,0,value); } //关闭资源 os.close(); fis.close(); s.close(); } } 服务器端代码 package com.uploaddemo; import java.io.file; import java.io.fileoutputstream; import java.io.inputstream; import java.net.serversocket; import java.net.socket; /** 1.创建服务器端的对象 2.等待客户端的连接 3.接收从客户端来的文件，并且写入到服务器端的硬盘。 4.关闭资源 */ public class 服务器端 { public static void main(string[] args) throws exception { serversocket ss = new serversocket(9000); socket s = ss.accept(); // socket的输入流 inputstream in = s.getinputstream(); //文件输出流 fileoutputstream fos = new fileoutputstream(new file(\u0026#34;day26b\\\\upload\\\\1.jpg\u0026#34;)); // 3.接收从客户端来的文件，并且写入到服务器端的硬盘。 int value = 0; byte[] bt = new byte[1024]; while ((value = in.read(bt))!=-1){ fos.write(bt,0, value); } // 关闭资源 fos.close(); in.close(); ss.close(); } } 文件上传的重名问题 概述 文件上传时，由于文件名称是相同的，新的上传的文件会覆盖原有的。解决的办法：\n① window系统重命名的方式 ② uuid\n全球唯一标识。\nrandomuuid() 获取uuid 多线程下的文件上传 客户端代码 package uploaddemo1; import java.io.file; import java.io.fileinputstream; import java.io.ioexception; import java.io.outputstream; import java.net.inetaddress; import java.net.socket; /** 1.创建客户端对象 2. 读取硬盘上的文件，向服务器端写入 3.关闭资源 */ public class 客户端 { public static void main(string[] args)throws ioexception { socket s = new socket(inetaddress.getbyname(\u0026#34;localhost\u0026#34;),9000); //文件输入流 fileinputstream fis = new fileinputstream(new file(\u0026#34;c:\\\\users\\\\administrator\\\\desktop\\\\成功的阶梯.jpg\u0026#34;)); //向服务器写入 outputstream os = s.getoutputstream(); //读取硬盘上的文件，向服务器端写入 int value =0; byte[] bt = new byte[1024]; while ((value = fis.read(bt))!=-1){ os.write(bt,0,value); } //关闭资源 os.close(); fis.close(); s.close(); } } 服务器端代码 package uploaddemo1; import java.io.file; import java.io.fileoutputstream; import java.io.inputstream; import java.net.serversocket; import java.net.socket; import java.util.uuid; /** 1.创建服务器端的对象 2.等待客户端的连接 3.接收从客户端来的文件，并且写入到服务器端的硬盘。 4.关闭资源 */ public class 服务器端 { public static void main(string[] args) throws exception { serversocket ss = new serversocket(9000); boolean flag = true; while (flag) { socket s = ss.accept(); new thread(new runnable() { @override public void run() { try(inputstream in = s.getinputstream(); fileoutputstream fos = new fileoutputstream(new file(\u0026#34;day27a\\\\upload\\\\\u0026#34;+ uuid.randomuuid()+\u0026#34;.jpg\u0026#34;)); ){ // 3.接收从客户端来的文件，并且写入到服务器端的硬盘。 int value = 0; byte[] bt = new byte[1024]; while ((value = in.read(bt))!=-1){ fos.write(bt,0, value); thread.sleep(2000); } }catch (exception e){ e.printstacktrace(); } } }).start(); } ss.close(); } } ","date":"2021-11-07","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430214426/","summary":"网络编程 网络编程概述 网络 计算机网络：计算机网络系统就是利用通信设备和线路将地理位置不同、功能独立的多个计算机系统互 联起来，以功能完善的网络软件实现网络中资源共享","title":"网络编程"},{"content":"多线程 概念 三个概念：\n① 程序：软件。数据与指令的集合。\n② 进程：正在执行的程序。\n③ 线程：进程中的多条执行路径。\n两个概念：\n① 并发：在某一个时间段内，都有执行。\n② 并行：在同一时刻，同时执行。 多线程的好处： 提高了程序的执行效率。\n线程也不能无限开启，必须要有度。\n创建线程的方式 ① 继承 thread\n② 实现 runnable\n③ 实现 callable\n线程创建方式一 继承：\nthread类：\njava提供的线程类，运行线程并发执行。\n一种方法是将类声明为 thread 的子类。该子类应重写 thread 类的 run 方法\n需要调用start方法开启线程\n代码 package com.demo; public class 线程创建方式一 { public static void main(string[] args) throws interruptedexception { athread at = new athread(); at.start(); for (int i = 0; i \u0026lt; 1000; i++) { system.out.println(\u0026#34;main+==\u0026#34;+i); } } } class athread extends thread{ @override public void run() { for (int i = 0; i \u0026lt;1000 ; i++) { system.out.println(\u0026#34;athread=================\u0026#34;+i); }; } } 线程执行的调度机制\n抢占式执行。cpu的时间片\n线程的执行结果是未知的。\n线程的执行原理 线程创建的方式二 实现runnable\n实现接口中的run方法。\n在创建对象时，需要通过start方法才能开启线程。\nthread(runnable target) 该构造可以把runnable接口对象转换成线程。进而调用start方法。\n注意：继承和实现两种形式在实际开发中，使用？\n继承的特点：单继承 多重继承\n实现的特点：多继承 多重继承 多实现。\n现实开发中，使用接口的实现的形式较多，该方式比继承更灵活。\n代码 package com.demo; /** 实现runnable 实现接口中的run方法。 在创建对象时，需要通过start方法才能开启线程。 thread(runnable target) 该构造可以把runnable接口对象转换成线程。进而调用start方法。 */ public class 线程创建方式二 { public static void main(string[] args) { arunnable ar = new arunnable(); // ar --\u0026gt;thread thread at = new thread(ar); at.start(); for (int i = 0; i \u0026lt; 1000; i++) { system.out.println(\u0026#34;main+==\u0026#34;+i); } } } class arunnable implements runnable{ @override public void run() { for (int i = 0; i \u0026lt;1000 ; i++) { system.out.println(\u0026#34;arunnable=================\u0026#34;+i); }; } } 线程创建的方式三 1.实现接口callable：\n需要线程返回线程的执行结果。\ncall()\n由于thread中没有直接接收callable的参数的构造方法，可以通过futuretask(callable\ncallable)\n进行线程对象的创建。\n2.futuretask常用方法：\nget() 获取线程的执行结果\n代码 package com.demo; import java.util.concurrent.callable; import java.util.concurrent.executionexception; import java.util.concurrent.futuretask; /** 1.实现接口callable： 需要线程返回线程的执行结果。 call() 由于thread中没有直接接收callable的参数的构造方法，可以通过futuretask(callable\u0026lt;v\u0026gt; callable) 进行线程对象的创建。 2.futuretask常用方法： get() 获取线程的执行结果 */ public class 线程创建方式三 { public static void main(string[] args) throws executionexception, interruptedexception { acallable ab = new acallable(); //转线程对象 futuretask\u0026lt;string\u0026gt; task = new futuretask\u0026lt;\u0026gt;(ab); thread at = new thread(task); at.start(); system.out.println(task.get()+\u0026#34;=======================================\u0026#34;); for (int i = 0; i \u0026lt; 200; i++) { system.out.println(\u0026#34;main+==\u0026#34;+i); } } } class acallable implements callable\u0026lt;string\u0026gt;{ @override public string call() throws exception { for (int i = 0; i \u0026lt;100; i++) { system.out.println(\u0026#34;======================acallable\u0026#34;+i); } return \u0026#34;这是一个线程的执行结果\u0026#34;; } } 总结 线程创建：\n① 继承thread类\n② 实现runnable接口\n③ 实现callable接口\n线程执行的调度机制 抢占式执行。cpu的时间片\n线程的执行结果是未知的。\n线程的执行原理 线程的常见方法 thread 线程 是程序中的执行线程。java 虚拟机允许应用程序并发地运行多个执行线程。\n线程常见方法 1.常见方法：\n① currentthread() 返回当前线程对象:不是线程体系的类，还想调用线程的方法时。\nmain方法 ：main线程 主线程\n② getname() /setname(string name) 返回/设置当前线程名称\n默认线程的名称：\nthread-index :index从0开始\n③ getpriority()/setpriority(int newpriority)返回/设置线程的优先级。\n(***) 线程的优先级：高优先级的执行要高于低优先级的。\n1\u0026gt;max_priority 最高优先级 10\n2\u0026gt;min_priority 最小优先级 1\n3\u0026gt;norm_priority 默认优先级 5\n代码 package com.demo; /** 1.常见方法： ① currentthread() 返回当前线程对象:不是线程体系的类，还想调用线程的方法时。 main方法 ：main线程 主线程 ② getname() /setname(string name) 返回/设置当前线程名称 默认线程的名称： thread-index :index从0开始 ③ getpriority()/setpriority(int newpriority)返回/设置线程的优先级。 (***) 线程的优先级：高优先级的执行要高于低优先级的。 1\u0026gt;max_priority 最高优先级 10 2\u0026gt;min_priority 最小优先级 1 3\u0026gt;norm_priority 默认优先级 5 */ public class 线程常见方法 { public static void main(string[] args) { /* athread at = new athread(); at.start(); athread at1 = new athread(); at1.start();*/ system.out.println(thread.currentthread().getname()); system.out.println(thread.currentthread().getpriority()); } } class athread extends thread{ @override public void run() { system.out.println(getname()); } } 线程常见方法一 1.interrupt()中断线程。标记线程是否是中断。\n2.interrupted() 判断线程是否中断。\n代码 package com.demo; /** 1.interrupt()中断线程。标记线程是否是中断。 2.interrupted() 判断线程是否中断。 */ public class 线程常见方法一 { public static void main(string[] args) { bthread bt = new bthread(); bt.start(); } } class bthread extends thread{ @override public void run() { for (int i = 0; i \u0026lt; 100; i++) { if(i == 5){ interrupt(); } system.out.println(i+\u0026#34;===============\u0026#34;+interrupted()); } } } 线程常见方法二 1.守护线程：setdaemon(boolean on)/isdaemon() 设置/判断是否为守护线程\n注意： 参数为true表示是一个守护线程。\n在线程开启之前设置为守护线程。\n2.线程分类：\n① 用户线程\n② 守护线程： 为用户线程提供便捷服务的线程。用户线程一旦结束，守护线程也会随之结\n束。\n代码 package com.demo; /** 1.守护线程：setdaemon(boolean on)/isdaemon() 设置/判断是否为守护线程 注意： 参数为true表示是一个守护线程。 在线程开启之前设置为守护线程。 2.线程分类： ① 用户线程 ② 守护线程： 为用户线程提供便捷服务的线程。用户线程一旦结束，守护线程也会随之结束。 */ public class 线程常见方法三 { public static void main(string[] args) { cthread ct = new cthread(); //线程开启之前 设置 ct.setdaemon(true); ct.start(); for (int i = 0; i \u0026lt;10 ; i++) { system.out.println(\u0026#34;=============main\u0026#34;+i); } } } class cthread extends thread{ @override public void run() { for (int i = 0; i \u0026lt; 1000; i++) { system.out.println(\u0026#34;====+cthread+==\u0026#34;+i); } } } 线程常见方法三 1.join()/join(ms) 等待线程的终止\n注意： 线程开启之后调用。\n相当于方法调用，调用run方法。\n代码 package com.demo; /** 1.join()/join(ms) 等待线程的终止 注意： 线程开启之后调用。 相当于方法调用，调用run方法。 */ public class 线程常见方式四 { public static void main(string[] args) throws interruptedexception { dthread dt = new dthread(); dt.start(); dt.join(); for (int i = 0; i \u0026lt; 100; i++) { system.out.println(\u0026#34;main+======================================\u0026#34;+i); } } } class dthread extends thread{ @override public void run() { for (int i = 0; i \u0026lt; 100; i++) { system.out.println(\u0026#34;dthread +======\u0026#34;+ i); } } } 线程常见方法四 （***） 1.sleep(long millis) 休眠\n（*）2.yield() 线程的让步，暂停当前线程的执行，转而执行其他线程\npackage com.demo; import java.text.simpledateformat; import java.util.date; /** （***） 1.sleep(long millis) 休眠 （*）2.yield() 线程的让步，暂停当前线程的执行，转而执行其他线程。 */ public class 线程常见方法五 { public static void main(string[] args) throws interruptedexception { /*for (int i = 0; i \u0026lt; 100; i++) { system.out.println(i); thread.sleep(100); }*/ //打印时间 /* simpledateformat sf = new simpledateformat(\u0026#34;yyyy/mm/dd hh:mm:ss\u0026#34;); while (true){ date date = new date(); system.out.println(sf.format(date)); thread.sleep(1000); }*/ // system.out.println(thread.currentthread().tostring()); // yield() mthread m = new mthread(); m.start(); for (int i = 0; i \u0026lt; 10000; i++) { system.out.println(\u0026#34;main+============================\u0026#34;+i); } } } class mthread extends thread{ @override public void run() { for (int i = 0; i \u0026lt; 10000; i++) { if(i%2 == 0){ yield(); } system.out.println(\u0026#34;====\u0026#34;+i); } } } 多线程的安全问题 概述 （***）多线程的安全问题：当多个线程，共同操作多个共享数据时，由于多个线程的同时操作，导致\n程序运行的结果与预期的结果不一致，该现象称为多线程的安全问题。\n解决 方式：\n① 同步\n② 线程的通信： wait() notify() notifyall()\n同步 也称为加锁\n关键字：synchronized\n① 分类：\n同步方法：\n[权限修饰符] synchronized 返回值类型 方法名称(参数列表){}\n同步代码块\nsynchronized(锁对象){\n}\n锁对象：可以是任意对象。\n常见的锁对象：\n① 对象锁： 对象\n② this锁： this\n③ 静态锁: 静态成员\n④ 类锁: 类名/数据类型 .class\n代码 package com.demo; /** 1.多线程的安全问题： 账户取款操作。 */ public class 多线程的安全问题 { public static void main(string[] args) { bankaccount ba = new bankaccount(); thread t = new thread(ba); thread t1 = new thread(ba); t.setname(\u0026#34;张三\u0026#34;); t1.setname(\u0026#34;李思\u0026#34;); t.start(); t1.start(); } } class bankaccount implements runnable{ double balance = 1000;//余额 object o = new object(); static double d = new double(12.3); @override public /*synchronized*/ void run() { //同步代码块 任意对象：锁对象:要求对所有的线程对象有效 ，共享。 // synchronized (o) {//对象锁 // synchronized (this) {//this锁 // synchronized (d) {//静态锁：静态成员 synchronized (bankaccount.class) {//类锁 if(balance\u0026gt;0){ try { thread.sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } balance -=1000; system.out.println(thread.currentthread().getname()+\u0026#34;取款后，金额为:\u0026#34;+ balance); }else{ system.out.println(thread.currentthread().getname()+\u0026#34;余额不足\u0026#34;); } } } } 继承关系下的同步方式 多线程的安全问题 1.解决多线程的安全问题：同步\n2.同步注意事项：\n又叫加锁：\n1》同步方法\n2》同步代码块\n3.同步的前提：\n① 必须存在多线程的安全问题\n② 同步时，锁必须是唯一的，共享的，所有线程共享同一把锁。\n4.同步方法：\n静态方法 ：相当于 同步代码块中的类锁\n[权限修饰符] static synchronized 返回值类型 方法名称(参数列表){}\n非静态方法： 相当于 同步代码块中的this\n[权限修饰符] synchronized 返回值类型 方法名称(参数列表){}\n注意：\n一般不建议 synchronized 加载run方法上。\n5.同步代码块：\n锁对象：\n① this锁\n② 任意对象\n③ 类锁: .class\n④ 静态锁：静态对象\n代码 package com.demo; /** 1.多线程？ 安全问题？： ① 多个线程 ② 共享数据 ③ 共同访问共享数据 2.同步 又叫加锁： ① 保证有多线程的安全问题 ② 保证锁唯一，所有线程对象共享同一把锁。 */ public class 多线程的安全问题继承方式 { public static void main(string[] args) { bankaccount ba = new bankaccount(); bankaccount ba1 = new bankaccount(); ba.setname(\u0026#34;张三\u0026#34;); ba1.setname(\u0026#34;李思\u0026#34;); ba.start(); ba1.start(); } } class bankaccount extends thread{ static double balance = 1000; static object o = new object(); @override public /*synchronized */void run() { // synchronized (bankaccount.class) { synchronized (o) { if (balance\u0026gt;0){ try { thread.sleep(10); } catch (interruptedexception e) { e.printstacktrace(); } balance -= 1000; system.out.println(getname() + \u0026#34;取款后，余额为:\u0026#34;+balance); }else{ system.out.println(getname()+\u0026#34;余额不足\u0026#34;); } } /*fun(); system.out.println(\u0026#34;==============\u0026#34;);*/ } /*public static synchronized void fun(){ if (balance\u0026gt;0){ try { thread.sleep(10); } catch (interruptedexception e) { e.printstacktrace(); } balance -= 1000; system.out.println(getname() + \u0026#34;取款后，余额为:\u0026#34;+balance); }else{ system.out.println(getname()+\u0026#34;余额不足\u0026#34;); } }*/ } lock锁 概念 lock接口。\n比使用 synchronized 方法和语句可获得的更广泛的锁定操作\n创建对象：\n使用的是子类reentrantlock。\n常用方法 ① lock ：获取锁\n② unlock：释放锁\n代码 package com.demo; import java.util.concurrent.locks.lock; import java.util.concurrent.locks.reentrantlock; public class lock锁 { public static void main(string[] args) { ba ba = new ba(); thread t = new thread(ba); thread t1 = new thread(ba); t.start(); t1.start(); } } class ba implements runnable{ lock lock = new reentrantlock(); double balance = 1000; @override public void run() { //加锁 lock.lock(); if (balance\u0026gt;0){ try { thread.sleep(10); } catch (interruptedexception e) { e.printstacktrace(); } balance -= 1000; system.out.println(thread.currentthread().getname()+\u0026#34;取款后，余额为:\u0026#34;+balance); }else{ system.out.println(thread.currentthread().getname()+\u0026#34;余额不足！！！\u0026#34;); } //释放锁 lock.unlock(); system.out.println(\u0026#34;==============\u0026#34;); } } 死锁 概念 deadlock 死锁：\n(***) 解决了多线程安全问题的同步线程，如果访问的是互斥的共享资源(互斥：多个共享资源，访问\n顺序相反。)，由于互斥访问，造成的资源锁死现象，称为死锁。\n死锁现象 哲学家餐桌问题：\n代码 package com.demo; public class 死锁 { public static void main(string[] args) { athread at = new athread(); athread at1 = new athread(); at.flag = true; at.start(); at1.start(); } } class athread extends thread{ static object o = new object(); static object o1 = new object(); boolean flag ; @override public void run() { if (flag){ synchronized (o){ system.out.println(\u0026#34;执行了o......1\u0026#34;); try { sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } synchronized (o1){ system.out.println(\u0026#34;执行了o1....1\u0026#34;); } } }else{ synchronized (o1){ system.out.println(\u0026#34;执行了o1......2\u0026#34;); try { sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } synchronized (o){ system.out.println(\u0026#34;执行了o....2\u0026#34;); } } } } } 查看死锁的工具 jstack 查看jvm的内存的运行状况。\n格式：\njstack pid号\n生产者和消费者模式 解决线程安全问题的方式 线程的通信：\n可以实现多个线程之间的交互。 线程生命周期/线程的状态 线程的生命周期 新建状态：创建对象\n就绪状态：start方法被调用。\n运行状态：抢到了cpu时间片\n消亡状态： 执行完毕\n阻塞状态：在运行过程中，遇到的 wait、join、sleep等。\n单例设计模式（饿汉式/懒汉式） 设计模式 java中有常见23种设计模式： 模板设计模式\n单例：一个类中就只有一个对象。\n实例化：创建对象\n单例设计模式（饿汉式） 步骤：\n① 私有构造方法\n② 在该类中声明一个属性，该属性的数据类型就是该类，修饰符用 private static修饰。\n③ 提供一个public static的get方法，对外提供该对象。\n代码 package com.demo; public class 单例设计模式 { public static void main(string[] args) { /* a a = new a(); a a1 = new a(); a a2 = new a(); a a3 = new a(); singleton s = new singleton();*/ singleton s = singleton.getinstance(); singleton s1 = singleton.getinstance(); system.out.println(s == s1); } } class a{} //饿汉式 class singleton{ private singleton(){} private static singleton instance =new singleton(); public static singleton getinstance (){ return instance; } public static void fun(){} } 懒汉式 1.由于饿汉式无论是否使用单例对象，都会创建该对象，为了进行改进，引入了懒汉式。\n2.在实际开发中，使用饿汉式比懒汉式更多，\n尽管饿汉式可能造成资源的浪费，但是懒汉式有线程安全问题的。\n所以，考虑线程安全问题的前提下，使用饿汉式居多。如果要使用懒汉式，必须要进行线程安全问题的解决。加同步。\n代码 package com.demo; /** 1.由于饿汉式无论是否使用单例对象，都会创建该对象，为了进行改进，引入了懒汉式。 2.在实际开发中，使用饿汉式比懒汉式更多， 尽管饿汉式可能造成资源的浪费，但是懒汉式有线程安全问题的。 所以，考虑线程安全问题的前提下，使用饿汉式居多。如果要使用懒汉式，必须要进行线程安全问题的解决。加同步。 */ public class 单例设计模式 { public static void main(string[] args) { singleton s = singleton.getinstance(); singleton s1 = singleton.getinstance(); system.out.println(s == s1); } } //懒汉式 class singleton{ private singleton(){} private static singleton instance ; public static singleton getinstance(){ if (instance == null) { synchronized (singleton.class) { if (instance == null){ instance = new singleton(); } } } return instance; } } 枚举 概念 1.枚举：有穷序列集。一一列举\n2.案例：\n性别： 数据类型 int 0 1 12\n细节 1.1.5jdk引入了枚举\n2.关键字 ：enum 枚举类关键字 用法同class\n3.枚举类第一行必须是该类对象的名称，多个之间用逗号隔开。\n4.枚举类：本质： 类。\n① 构造方法：有 并且是私有的。\n② 属性：\n③ 方法\n④ 抽象方法\n代码 package com.demo; /** 1.1.5jdk引入了枚举 2.关键字 ：enum 枚举类关键字 用法同class 3.枚举类第一行必须是该类对象的名称，多个之间用逗号隔开。 4.枚举类：本质： 类。 ① 构造方法：有 并且是私有的。 ② 属性： ③ 方法 ④ 抽象方法 */ public class 枚举 { public static void main(string[] args) { student st = new student(); st.sex = sex.male; st.sex = sex.female; //面向对象 对象.方法/属性 sex.male.fun(); //红灯的行为 traffic.red.action(); //绿灯的行为 traffic.green.action(); } } class student{ //性别 sex sex ; } /* class sex { //只有两个对象 private sex(){} private static sex in = new sex(); private static sex in1 = new sex(); }*/ enum sex{ male,female;//表示该类的对象，必须放在枚举类的第一行，直接写枚举类对象的名称，由于是static final一般全部大写。 int a;//属性 public void fun(){ system.out.println(\u0026#34;这是sex中的方法。。。\u0026#34;); } } //enum enum traffic{ red{ @override public void action() { system.out.println(\u0026#34;红灯停\u0026#34;); } } ,yellow { @override public void action() { system.out.println(\u0026#34;黄灯等待\u0026#34;); } },green{ @override public void action() { system.out.println(\u0026#34;绿灯行\u0026#34;); } }; public abstract void action(); } //四季 enum season{ spring(\u0026#34;春季\u0026#34;),summer(\u0026#34;夏季\u0026#34;), autumn(\u0026#34;秋季\u0026#34;),winter(\u0026#34;冬季\u0026#34;); private string desc; //构造方法注入 private season(string desc){ this.desc = desc; } // private season(){} } 线程的生命周期 java中thread类提供了6个状态\n概念 thread.state\nnew\n至今尚未启动的线程处于这种状态。\nrunnable\n正在 java 虚拟机中执行的线程处于这种状态。\nblocked\n受阻塞并等待某个监视器锁的线程处于这种状态。\nwaiting\n无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。\ntimed_waiting\n等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。\nterminated\n已退出的线程处于这种状态。\n线程池 概念 线程池：是用来管理线程的\u0026quot;池子\u0026quot;.频繁的创建和销毁的线程，会增大内存的消耗，为了降低内存的消耗，使用线程池来管理和循环利用线程。\njava中提供的线程池 executor 管理线程的接口\n子接口：\nexecutorservice\n常用方法：\n① submit(runnable task) 提交线程\n② shutdown() 执行之前提交的任务，并且关闭线程池\nexecutors：线程池的工厂类。\n常用方法：\n① newcachedthreadpool() 创建一个可根据需要创建新线程的线程池,池中的线程不够，就创\n建。会导致线程过多，造成内存泄漏。\n② newfixedthreadpool(int nthreads) 创建一个可重用固定线程数的线程池,线程池中线\n程是固定的，如果任务数大于线程数，等待。如果线程任务执行长，等待时间就会过长。\n代码\npackage com.demo; import java.util.concurrent.*; /** threadpoolexecutor(int corepoolsize, int maximumpoolsize, long keepalivetime, timeunit unit, blockingqueue\u0026lt;runnable\u0026gt; workqueue, threadfactory threadfactory, rejectedexecutionhandler handler) 参数： corepoolsize - 池中所保存的线程数，包括空闲线程。 maximumpoolsize - 池中允许的最大线程数。 keepalivetime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。 unit - keepalivetime 参数的时间单位。 workqueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 runnable 任 务。 arrayblockingqueue:由数组支持的有界任务队列。 arrayblockingqueue(int capacity) threadfactory - 执行程序创建新线程时使用的工厂。 executors.defaultthreadfactory() handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。 在默认的 threadpoolexecutor.abortpolicy 中，处理程序遭到拒绝将抛出运行时 rejectedexecutionexception。 在 threadpoolexecutor.callerrunspolicy 中，线程调用运行该任务的 execute 本 身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 在 threadpoolexecutor.discardpolicy 中，新的不能执行的任务将被删除。 在 threadpoolexecutor.discardoldestpolicy 中，如果执行程序尚未关闭，则位于 工作队列头部的任务将被删除， 然后重试执行程序（如果再次失败，则重复此过程）。 */ public class threadpoolexecutor线程池 { public static void main(string[] args) { threadpoolexecutor tp = new threadpoolexecutor(3, 5, 1, timeunit.seconds, new arrayblockingqueue\u0026lt;\u0026gt;(1), executors.defaultthreadfactory(), new threadpoolexecutor.discardoldestpolicy()); for (int i = 0; i \u0026lt; 7; i++) { int finali = i;//1.8jdk之后，在内部类中使用时，加final或省略都是加的。 tp.submit(new runnable() { @override public void run() { try { thread.sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } system.out.println(thread.currentthread().getname()+\u0026#34;======\u0026gt;\u0026#34;+ finali); } }); } } } threadpoolexecutor 1.引入 threadpoolexecutor：可以解决线程的管理问题，由于newcachedthreadpool()在使用时，可能会\n造成线程的过多，\nnewfixedthreadpool(int nthreads)创建的线程池，可能会造成等待时间过长，为了平衡这两种现\n象，引入了\nthreadpoolexecutor。\n2.创建对象\nthreadpoolexecutor(int corepoolsize, int maximumpoolsize,\nlong keepalivetime, timeunit unit, blockingqueue workqueue,\nthreadfactory threadfactory, rejectedexecutionhandler handler)\n参数：\ncorepoolsize - 池中所保存的线程数，包括空闲线程。\nmaximumpoolsize - 池中允许的最大线程数。\nkeepalivetime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。\nunit - keepalivetime 参数的时间单位。\nworkqueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 runnable 任\n务。\narrayblockingqueue:由数组支持的有界任务队列。 arrayblockingqueue(int\ncapacity)\nthreadfactory - 执行程序创建新线程时使用的工厂。 executors.defaultthreadfactory()\nhandler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。\n在默认的 threadpoolexecutor.abortpolicy 中，处理程序遭到拒绝将抛出运行时\nrejectedexecutionexception。\n在 threadpoolexecutor.callerrunspolicy 中，线程调用运行该任务的 execute 本 身。此策\n略提供简单的反馈控制机制，能够减缓新任务的提交速度。\n在 threadpoolexecutor.discardpolicy 中，新的不能执行的任务将被删除。\n在 threadpoolexecutor.discardoldestpolicy 中，如果执行程序尚未关闭，则位于 工作队列\n头部的任务将被删除，\n然后重试执行程序（如果再次失败，则重复此过程）。\npackage com.demo; import java.util.concurrent.*; /** threadpoolexecutor(int corepoolsize, int maximumpoolsize, long keepalivetime, timeunit unit, blockingqueue\u0026lt;runnable\u0026gt; workqueue, threadfactory threadfactory, rejectedexecutionhandler handler) 参数： corepoolsize - 池中所保存的线程数，包括空闲线程。 maximumpoolsize - 池中允许的最大线程数。 keepalivetime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。 unit - keepalivetime 参数的时间单位。 workqueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 runnable 任 务。 arrayblockingqueue:由数组支持的有界任务队列。 arrayblockingqueue(int capacity) threadfactory - 执行程序创建新线程时使用的工厂。 executors.defaultthreadfactory() handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。 在默认的 threadpoolexecutor.abortpolicy 中，处理程序遭到拒绝将抛出运行时 rejectedexecutionexception。 在 threadpoolexecutor.callerrunspolicy 中，线程调用运行该任务的 execute 本 身。此策 略提供简单的反馈控制机制，能够减缓新任务的提交速度。 在 threadpoolexecutor.discardpolicy 中，新的不能执行的任务将被删除。 在 threadpoolexecutor.discardoldestpolicy 中，如果执行程序尚未关闭，则位于 工作队列 头部的任务将被删除， 然后重试执行程序（如果再次失败，则重复此过程）。 */ public class threadpoolexecutor线程池 { public static void main(string[] args) { threadpoolexecutor tp = new threadpoolexecutor(3, 5, 1, timeunit.seconds, new arrayblockingqueue\u0026lt;\u0026gt;(1), executors.defaultthreadfactory(), new threadpoolexecutor.discardoldestpolicy()); for (int i = 0; i \u0026lt; 7; i++) { int finali = i;//1.8jdk之后，在内部类中使用时，加final或省略都是加的。 tp.submit(new runnable() { @override public void run() { try { thread.sleep(100); } catch (interruptedexception e) { e.printstacktrace(); } system.out.println(thread.currentthread().getname()+\u0026#34;======\u0026gt;\u0026#34;+ finali); } }); } } } ","date":"2021-11-04","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430214372/","summary":"多线程 概念 三个概念： ① 程序：软件。数据与指令的集合。 ② 进程：正在执行的程序。 ③ 线程：进程中的多条执行路径。 两个概念： ① 并发：在某一个时间段内，都有执行。 ② 并行：","title":"多线程"},{"content":"io流 文件 概述 file：\n​\t文件和目录路径名的抽象表示形式。\n​\t既可以表示文件也可以表示文件夹。\n​\t抽象路径：创建文件对象时，硬盘上不一定存在。\n构造方法 1.构造方法：\n​\t① file(string pathname)\n​\t② file(file parent, string child)\n​\t③ file(string parent, string child)\n常用方法 1.常用方法：\n​\t① exists() 判断文件或目录是否存在在硬盘上。\n​\t② getabsolutefile() /getabsolutepath() 绝对路径\n2.绝对路径和相对路径：\n​\t① 绝对路径：从盘符开始的路径。\n​\t② 相对路径： 相对于某个路径的路径。\n​\t对javase的项目：针对idea工具，前面啥也不带 表示当前项目底下。\n代码 package com.demo; import java.io.file; /** 1.构造方法： ① file(string pathname) ② file(file parent, string child) ③ file(string parent, string child) 2.常用方法： ① exists() 判断文件或目录是否存在在硬盘上。 ② getabsolutefile() /getabsolutepath() 绝对路径 3.绝对路径和相对路径： ① 绝对路径：从盘符开始的路径。 ② 相对路径： 相对于某个路径的路径。 对javase的项目：针对idea工具，前面啥也不带 表示当前项目底下。 */ public class file类 { public static void main(string[] args) { file f = new file(\u0026#34;d:\\\\1\\\\2.txt\u0026#34;); // system.out.println(f.exists()); // ② file(file parent, string child) file f1 = new file(\u0026#34;d:\\\\1\u0026#34;); file f2 = new file(f1,\u0026#34;2.txt\u0026#34;); file f3 = new file(\u0026#34;d:\\\\1\u0026#34;,\u0026#34;2.txt\u0026#34;); /* system.out.println(f2.getabsolutepath()); system.out.println(f3.getabsolutepath());*/ file f4 = new file(\u0026#34;1.txt\u0026#34;); system.out.println(f4.getabsolutefile()); file f5 = new file(\u0026#34;day21a\\\\1.txt\u0026#34;); system.out.println(f5.getabsolutefile()); } } 常用方法一 1.常用方法：\n​\t① createnewfile() 创建文件没有才创建。\n​\t② delete() /deleteonexit() 删除 /退出jvm时删除\n​\t注意：\n​\tdelete删除方法不走回收站。\n​\tdelete删除文件或空目录。\n​\t(**)③ isdirectory() 判断是否为目录\n​\t(**)④ isfile() 判断是否为文件\n注意：\n​\t目录或文本必须存在才能返回true，否则不存在或者不是都返回false。\n​\t⑤ length() 文件的长度 容量 只对文件有效，对于目录来说，值不确定的。\n代码 package com.demo; import java.io.file; import java.io.ioexception; import java.text.simpledateformat; import java.util.date; import java.util.logging.simpleformatter; /** 1.常用方法： ① createnewfile() 创建文件没有才创建。 ② delete() /deleteonexit() 删除 /退出jvm时删除 注意： delete删除方法不走回收站。 delete删除文件或空目录。 (**)③ isdirectory() 判断是否为目录 (**)④ isfile() 判断是否为文件 注意： 目录或文本必须存在才能返回true，否则不存在或者不是都返回false。 ⑤ length() 文件的长度 容量 只对文件有效，对于目录来说，值不确定的。 */ public class file类常用方法 { public static void main(string[] args) throws ioexception { file file = new file(\u0026#34;d:\\\\1\\\\3.txt\u0026#34;); // ① createnewfile() 创建文件没有才创建。 /*boolean flag = file.createnewfile(); system.out.println(flag);*/ // ② delete() /deleteonexit() 删除 /退出jvm时删除ut // boolean flag1 = file.delete(); // system.out.println(flag1); // file file2 = new file(\u0026#34;d:\\\\1\u0026#34;); // boolean flag2 = file2.delete(); // system.out.println(flag2); // getparent()/getparentfile() 获取父目录 // system.out.println(file.getparent()); /*(**)③ isdirectory() 判断是否为目录 (**)④ isfile() 判断是否为文件*/ file file2 = new file(\u0026#34;d:\\\\1\\\\5.txt\u0026#34;); // system.out.println(file2.isfile()); // lastmodified()最后一次修改时间 // system.out.println(file2.lastmodified()); // date date = new date(file2.lastmodified()); // system.out.println(new simpledateformat(\u0026#34;yyyy/mm/dd e hh:mm:ss\u0026#34;).format(date)); // ⑤ length() 文件的长度 system.out.println(file2.length()); } } 文件遍历的方法 1.list()/listfiles()/listfiles(filefilter filter) 遍历目录\n​\t注意：\n​\t① 当前目录下的所有直接子目录或子文件。\n​\t② 不包括目录本身。\n​\t③ 如果对象本身是文件，此时，该方法返回值为null需要进行判断是否为null再进行遍历\n代码 package com.demo; import java.io.file; /** 1.list()/listfiles()/listfiles(filefilter filter) 遍历目录 注意： ① 当前目录下的所有直接子目录或子文件。 ② 不包括目录本身。 ③ 如果对象本身是文件，此时，该方法返回值为null需要进行判断是否为null再进行遍历 */ public class 文件遍历的方法 { public static void main(string[] args) { file file = new file(\u0026#34;d:\\\\1\\\\3.txt\u0026#34;); file[] fs = file.listfiles(); //需要进行判断 否则可能报空指针异常。 if(fs!= null){ for (file f : fs) { system.out.println(f); } } } } 文件过滤器 1.filefilter文件过滤器\n​\tboolean accept(file pathname) 如果返回值为true，可以通过，否则不能通过\n代码 package com.demo; import java.io.file; import java.io.filefilter; import java.util.arrays; /** 1.filefilter文件过滤器 boolean accept(file pathname) 如果返回值为true，可以通过，否则不能通过 */ public class 文件过滤器 { public static void main(string[] args) { file file = new file(\u0026#34;d:\\\\1\u0026#34;); file[] cs = file.listfiles(new filefilter() { @override public boolean accept(file pathname) { return pathname.getname().endswith(\u0026#34;.txt\u0026#34;); } }); system.out.println(arrays.tostring(cs)); } } 文件常用方法二 1.mkdir()/mkdirs() 创建目录 ,mkdir只支持父目录存在的情况下创建，而加s表示父目录可以不在。\n2.renameto(file dest) 重命名\n​\t在同一个目录下，相当于重命名，但是在不同的目录下，相当于剪切和重命名。\n代码 package com.demo; import java.io.file; /** 1.mkdir()/mkdirs() 创建目录 ,mkdir只支持父目录存在的情况下创建，而加s表示父目录可以不在。 2.renameto(file dest) 重命名 在同一个目录下，相当于重命名，但是在不同的目录下，相当于剪切和重命名。 */ public class file类常用方法一 { public static void main(string[] args) { /* file file = new file(\u0026#34;d:\\\\1\\\\2\\\\3\u0026#34;); file.mkdirs();*/ file file1 = new file(\u0026#34;d:\\\\1\\\\2\\\\5.txt\u0026#34;); file file2 = new file(\u0026#34;d:\\\\1\\\\2\\\\7.txt\u0026#34;); file file3 = new file(\u0026#34;d:\\\\1\\\\2\\\\3\\\\9.txt\u0026#34;); // file1.renameto(file2); file2.renameto(file3); } } 递归 概述 1.递归：\n​\t自己调用自己。\n2.分类：\n​\t① 直接递归： 在该方法中直接调用方法自身 . a-\u0026gt;a\n​\t② 间接递归: 该方法调用了其它方法，在其它方法中，又调用该方法。\n​\ta\u0026ndash;\u0026gt;b\u0026ndash;\u0026gt;c\u0026ndash;\u0026gt;a\n3.递归注意事项：\n​\t递归必须有出口，否则会报stackoverflowerror栈溢出异常。\n​\t例如：求和 1-10\n​\tf(n)\n​\tf(1) 1\n​\tf(2) ==\u0026gt;f(1)+2\n​\tf(3)===\u0026gt; f(2)+3\n​\t==\u0026gt; f(n) ==\u0026gt; f(n-1)+n 代码 package com.demo; /** 1.递归： 自己调用自己。 2.分类： ① 直接递归： 在该方法中直接调用方法自身 . a-\u0026gt;a ② 间接递归: 该方法调用了其它方法，在其它方法中，又调用该方法。 a--\u0026gt;b--\u0026gt;c--\u0026gt;a 3.递归注意事项： 递归必须有出口，否则会报stackoverflowerror栈溢出异常。 例如：求和 1-10 f(n) f(1) 1 f(2) ==\u0026gt;f(1)+2 f(3)===\u0026gt; f(2)+3 ==\u0026gt; f(n) ==\u0026gt; f(n-1)+n */ public class 递归 { public static void main(string[] args) { system.out.println(getsum(5)); } public static int getsum(int n){ if(n==1){ return 1; } return getsum(n-1)+n; } } io流 概述 io流：计算机中数据的传输。\nio 输入input 输出output io流的分类： 1》方向：\n​\t输入流\n​\t输出流\n2》数据类型：\n​\t字节流\n​\t字符流\n四大基本流 字节输入流\n字节输出流\n字符输入流\n字符输出流\n字节输入流 概述 byte input\n抽象父类：inputstream\n子类： fileinputstream 文件字节输入流\n构造方法： fileinputstream(file file)\nfileinputstream(string name)\n常用方法 1》 read()从流中读取一个字节数据，返回值表示读取的字节，到达文件的末尾 返回值为-1\n2》 close() 关闭资源。\n代码 package com.demo; import java.io.file; import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.ioexception; /** 1.字节输入流： ① 构造方法： fileinputstream(file file) fileinputstream(string name) ② 常用方法： 1》 read()从流中读取一个字节数据，返回值表示读取的字节，到达文件的末尾 返回值为-1 2》 close() 关闭资源。 */ public class 字节输入流 { public static void main(string[] args) throws ioexception { fileinputstream fis = new fileinputstream(new file(\u0026#34;day22a\\\\1.txt\u0026#34;)); /* int value = fis.read(); system.out.println(value); value = fis.read(); system.out.println(value); value = fis.read(); system.out.println(value); value = fis.read(); system.out.println(value);*/ int value = 0;//表示要读取的字节的数值 while ((value = fis.read())!= -1){ system.out.print((char) value); } //关闭资源 fis.close(); } } read方法的使用 （***） 1.read() 读取一个字节，返回值为该字节数值，并且到达文件的末尾 返回值为-1.\n（***）2. read(byte[] b) 一次性读取最多b.length个数据，到达文件的末尾，返回值为-1\n注意：\n​\t一般b的大小，是以1024整数倍的形式存在，也可以是别的值。\n​\t对于b中存储的元素值，如果b的空间不够，会覆盖原有数据。\n​\tb称为缓冲区小数组，用来一次性从输入流中进行读取。\n3.read(byte[] b, int off, int len) 将 最多len个数据读取到b中，到达文件的末尾，返回值为-1\n4.字节数组转字符串的方法：\n​\tstring(byte[] bytes, int offset, int length) ​\t从offset位置开始，将length个字节进行转换\n代码 package com.demo; import java.io.file; import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.ioexception; import java.util.arrays; /** （***） 1.read() 读取一个字节，返回值为该字节数值，并且到达文件的末尾 返回值为-1. （***）2. read(byte[] b) 一次性读取最多b.length个数据，到达文件的末尾，返回值为-1 注意： 一般b的大小，是以1024整数倍的形式存在，也可以是别的值。 对于b中存储的元素值，如果b的空间不够，会覆盖原有数据。 b称为缓冲区小数组，用来一次性从输入流中进行读取。 3.read(byte[] b, int off, int len) 将 最多len个数据读取到b中，到达文件的末尾，返回值为-1 4.字节数组转字符串的方法： string(byte[] bytes, int offset, int length) 从offset位置开始，将length个字节进行转换。 */ public class read方法 { public static void main(string[] args) throws ioexception { fileinputstream fis = new fileinputstream(new file(\u0026#34;day22a\\\\2.txt\u0026#34;)); byte[] bt = new byte[1024];// 1个字节 8位 1024b = 1kb m g t p /*int value = fis.read(bt); system.out.println(value); system.out.println(arrays.tostring(bt)); //字节数组转字符串 system.out.println(new string(bt,0,value)); value = fis.read(bt); system.out.println(value); system.out.println(arrays.tostring(bt)); system.out.println(new string(bt,0,value));*/ /*int value = 0; while ((value = fis.read(bt))!=-1){ system.out.println(new string(bt,0,value)); }*/ // 3.read(byte[] b, int off, int len) 将 最多len个数据读取到b中，到达文件的末尾，返回值为-1 int value1 = fis.read(bt, 1, 3); system.out.println(value1); system.out.println(arrays.tostring(bt)); fis.close(); } } available方法 available() 剩余字节数,如果一次都没读取，就是该文件的长度，如果读取了，就是剩余没有读取的字节数。\n代码 package com.demo; import java.io.file; import java.io.fileinputstream; import java.io.filenotfoundexception; import java.io.ioexception; /** 1.available() 剩余字节数,如果一次都没读取，就是该文件的长度，如果读取了，就是剩余没有读取的字节数。 */ public class available方法 { public static void main(string[] args) throws ioexception { fileinputstream fis = new fileinputstream(new file(\u0026#34;day22a\\\\2.txt\u0026#34;)); system.out.println(fis.available()); fis.read(); system.out.println(fis.available()); fis.read(); system.out.println(fis.available()); } } 字节输出流 概述 outputstream ：表示输出字节流的所有类的超类\n子类：\nfileoutputstream\n细节 1.构造方法：\n​\t1》 fileoutputstream(file file)/fileoutputstream(file file, booleanappend)\n注意：\n​\t字节输出流的文件找不到异常，指无法创建时，才会报该异常，否则，会自动创建或覆盖原文件。\n​\t其中第二个参数表示是否在末尾插入，如果为true表示从末尾开始插入，如果不写false表示从文件开头插入。\n​\t2》fileoutputstream(string name) /fileoutputstream(string name, booleanappend)\n2.常用方法：\n​\t① write(int b) 将一个字节的内容写到文件中\n​\t② write(byte[] b) 将一个数组中的内容写到文件输出流中。\n​\t③ write(byte[] b, int off, int len) 将数组中的内容 从off位置开始，写len个。\n代码 package com.demo; import java.io.file; import java.io.filenotfoundexception; import java.io.fileoutputstream; import java.io.ioexception; /** 1.构造方法： 1》 fileoutputstream(file file)/fileoutputstream(file file, boolean append) 注意： 字节输出流的文件找不到异常，指无法创建时，才会报该异常，否则，会自动创建或覆盖原文件。 其中第二个参数表示是否在末尾插入，如果为true表示从末尾开始插入，如果不写或false表示从文件开头插入。 2》fileoutputstream(string name) /fileoutputstream(string name, boolean append) 2.常用方法： ① write(int b) 将一个字节的内容写到文件中 ② write(byte[] b) 将一个数组中的内容写到文件输出流中。 ③ write(byte[] b, int off, int len) 将数组中的内容 从off位置开始，写len个。 */ public class 字节输出流 { public static void main(string[] args) throws ioexception { fileoutputstream fos = new fileoutputstream(new file(\u0026#34;day22a\\\\6.txt\u0026#34;)/*,true*/); fos.write(97); byte[] bt = {97,98,99,100}; fos.write(bt); //输入字符串--\u0026gt;byte[] fos.write(\u0026#34;今天天气很好\u0026#34;.getbytes()); byte[] bt1 = {101,102,103,104,105}; fos.write(bt1,1,2); fos.close(); } } 文件复制 概念 一边进行输入一边进行输出的过程\n​\t输入：文件字节输入流\n​\t输出: 文件字节输出流\n字节流可以进行操作的文件：\n所有的文件，包括 文本文件 视频 声音 图片 ，但是对于文本文件这种，由于编码问题，建议字符流，减少乱码问题的产生。 代码 package com.demo; import java.io.*; /** 一边进行输入一边进行输出的过程 输入：文件字节输入流 输出: 文件字节输出流 字节流可以进行操作的文件： 所有的文件，包括 文本文件 视频 声音 图片 ，但是对于文本文件这种，由于编码问题，建议字符流，减少乱码问题的产生。 */ public class 文件复制操作 { public static void main(string[] args) throws ioexception { fileinputstream fis = new fileinputstream(new file(\u0026#34;day22b\\\\img\\\\1.jpg\u0026#34;)); fileoutputstream fos= new fileoutputstream(new file(\u0026#34;c:\\\\users\\\\administrator\\\\desktop\\\\5.jpg\u0026#34;)); int value = 0; byte[] bt = new byte[1024]; while ((value = fis.read(bt))!=-1){ fos.write(bt,0,value); } //关闭资源 fis.close(); fos.close(); } } 流的异常处理形式 1.6jdk的处理形式 try{ }catch(异常的数据类型 异常的名称){ }finally{\n}\n代码 package com.demo; import java.io.file; import java.io.fileinputstream; import java.io.fileoutputstream; import java.io.ioexception; /** try{ }catch(异常的数据类型 异常的名称){ }finally{ } */ public class jdk1_6异常处理形式 { public static void main(string[] args) { fileinputstream fis = null; fileoutputstream fos = null; try{ int i = 5/0; fis = new fileinputstream(new file(\u0026#34;day22b\\\\img\\\\1.jpg\u0026#34;)); fos= new fileoutputstream(new file(\u0026#34;c:\\\\users\\\\administrator\\\\desktop\\\\5.jpg\u0026#34;)); int value = 0; byte[] bt = new byte[1024]; while ((value = fis.read(bt))!=-1){ fos.write(bt,0,value); } }catch (ioexception e){ e.printstacktrace(); }finally { if (fis != null) { try { fis.close(); } catch (ioexception e) { e.printstacktrace(); } } try { if (fos!= null) { fos.close(); } } catch (ioexception e) { e.printstacktrace(); } } } } 1.7jdk流的异常处理 格式：\ntry(需要关闭的流){ }catch(异常的数据类型 异常的名称){ }\n注意：\n① finally 如果有其它操作，仍然可以使用finally但是如果只是关流，可以直接写在try()里面。会自动关流。\n② try后面的()必须放置实现了autocloseable接口的对象，才能够进行自动关流。\n代码 package com.demo; import java.io.file; import java.io.fileinputstream; import java.io.fileoutputstream; import java.io.ioexception; /** try{ }catch(异常的数据类型 异常的名称){ }finally{ } */ public class jdk1_6异常处理形式 { public static void main(string[] args) { fileinputstream fis = null; fileoutputstream fos = null; try{ int i = 5/0; fis = new fileinputstream(new file(\u0026#34;day22b\\\\img\\\\1.jpg\u0026#34;)); fos= new fileoutputstream(new file(\u0026#34;c:\\\\users\\\\administrator\\\\desktop\\\\5.jpg\u0026#34;)); int value = 0; byte[] bt = new byte[1024]; while ((value = fis.read(bt))!=-1){ fos.write(bt,0,value); } }catch (ioexception e){ e.printstacktrace(); }finally { if (fis != null) { try { fis.close(); } catch (ioexception e) { e.printstacktrace(); } } try { if (fos!= null) { fos.close(); } } catch (ioexception e) { e.printstacktrace(); } } } } 处理/功能流 概述 对基本流的一个功能的增强，称为处理流。\n带有缓冲区的字节流，高效读写的流 bufferedinputstream 带有缓冲区的字节输入流\nbufferedoutputstream 带有缓冲区的字节输出流\n默认缓冲区的大小 8192个字节\n构造方法 ① bufferedinputstream(inputstream in)\n② bufferedoutputstream(outputstream out)\n带有缓冲区的高效读写字节输出流 常用方法：\n① flush() 刷新缓冲区\n(***) 3.close方法与flush方法的区别：\n① flush 刷新缓冲区，不会关闭流，后续还可以使用输出流。\n② close方法 表示关闭资源，会关闭输出流。但是在关闭输出流之前，调用flush方法 刷新缓冲区。\n代码 package com.demo;import java.io.*;public class 带有缓冲区的高效读写的字节流 { public static void main(string[] args) throws ioexception { bufferedinputstream bis = new bufferedinputstream(new fileinputstream (new file(\u0026#34;day22b\\\\src\\\\com\\\\demo\\\\文件复制操作.java\u0026#34;))); int value = 0; byte[] bt = new byte[1024]; while ((value = bis.read(bt))!= -1){ system.out.println(new string(bt,0,value)); } bis.close(); }} package com.demo;import java.io.*;/** 1.构造方法： bufferedoutputstream(outputstream out) 2.常用方法： ① flush() 刷新缓冲区 (***) 3.close方法与flush方法的区别： ① flush 刷新缓冲区，不会关闭流，后续还可以使用输出流。 ② close方法 表示关闭资源，会关闭输出流。但是在关闭输出流之前，调用flush方法 刷新缓冲区。 */public class 带有缓冲区的高效读写的字节输出流 { public static void main(string[] args) throws ioexception { bufferedoutputstream br = new bufferedoutputstream(new fileoutputstream(new file(\u0026#34;day22b\\\\1.txt\u0026#34;))); br.write(98); br.write(97); br.write(99); br.flush(); }} 带有高效读写的文件复制 package com.demo; import java.io.*; public class 带有高效读写的文件复制 { public static void main(string[] args) { try( bufferedinputstream bis = new bufferedinputstream(new fileinputstream(new file(\u0026#34;day22b\\\\img\\\\1.jpg\u0026#34;))); bufferedoutputstream bos = new bufferedoutputstream(new fileoutputstream(new file(\u0026#34;c:\\\\users\\\\administrator\\\\desktop\\\\5.jpg\u0026#34;))); ){ int value = 0; byte[] bt = new byte[1024]; while ((value = bis.read(bt))!=-1){ bos.write(bt,0,value); } }catch (ioexception e){ e.printstacktrace(); } } } 字符流 概念 字符输入流： reader\n字符输出流： writer\n底层/实质：\n字节流 + 编码\nreader 字符输入流 1.filereader 文件字符输入流\n2.构造方法：\n​\tfilereader(file file) /filereader(string filename) 3.常用方法：\n​\tread() ​\tread(char[] c) ​\tclose()\n代码 package com.demo; import java.io.file; import java.io.filenotfoundexception; import java.io.filereader; import java.io.ioexception; public class 文件字符输入流 { public static void main(string[] args) throws ioexception { filereader fr = new filereader(new file(\u0026#34;day22b\\\\src\\\\com\\\\demo\\\\文件复制操作.java\u0026#34;)); // int value = fr.read(); // system.out.println((char) value); int value = 0; char[] c = new char[1024]; while ((value = fr.read(c)) != -1){ // system.out.print((char)value); system.out.println(new string(c,0,value)); } fr.close(); } } writer字符输出流 1.filewriter 文件字符输出流\n2.构造方法：\n​\tfilewriter(file file) /filewriter(file file, boolean append)\n​\tfilewriter(string filename) /filewriter(string filename, boolean append)\n3.常用方法：\n​\twrite(string str)\n​\twrite(char[] c,offset,len)\n​\tclose()\n​\tflush()\n代码 package com.demo; import java.io.file; import java.io.filewriter; import java.io.ioexception; public class 文件字符输出流 { public static void main(string[] args) throws ioexception { filewriter fw = new filewriter(new file(\u0026#34;day22b\\\\3.txt\u0026#34;)); fw.append(\u0026#39;a\u0026#39;); fw.write(\u0026#34;今天天气真好\u0026#34;); fw.write(new char[]{\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;}, 0, 3); fw.close(); } } 高效读写的字符流 概述 bufferedreader 带有缓冲区的字符输入流：字符、数组和行的高效读取\nbufferedwriter 带有缓冲区的字符输出流 ：提供单个字符、数组和字符串的高效写入\n构造方法 bufferedreader(reader in)\nbufferedwriter(writer out)\n常用方法： 1.string readline() 读取一行\n2.newline() 可以根据不同的平台实现换行\n代码 package com.demo; import java.io.*; /** 文件复制 */ public class 高效读写的字符流 { public static void main(string[] args) { try( bufferedreader br = new bufferedreader(new filereader(new file(\u0026#34;day23a\\\\src\\\\com\\\\homework\\\\topic1.java\u0026#34;))); bufferedwriter bw = new bufferedwriter(new filewriter(new file(\u0026#34;day23a\\\\t.java\u0026#34;))); ){ string msg = null; while ((msg = br.readline())!=null){ bw.write(msg); //换行 bw.newline(); } }catch (ioexception e){ e.printstacktrace(); } } } 转换流 概述 1.编码与解码：\n① 编码： 根据编码表将字符存储在计算机中。将认识的转换成计算机中存储的。\n② 编码表： 规定。编码与解码的依据。\n单字节： ascii iso-8859-1 不支持中文\n两个字节： gbk ：中国国内。\n多个字节：\nunicode ：utf-8 全世界统一编码。\n③ 解码：根据编码表将存储在计算机中的数据值，转换成相应的字符。\n④ 编码与解码时，要保证编码与解码使用相同的编码表，如果使用的不是同一个，会造成乱码\n问题。\n⑤ 解决乱码问题：\n编码与解码使用的编码表一致。\n2.转换流：\n① inputstreamreader： 实质：根据编码，将字节流转换成字符流。\n1》构造方法：\ninputstreamreader(inputstream in, charset cs)\n注意：\n如果只有一个参数，采用平台默认编码，如果有两个参数，第二个参数表示编码。\n② outputstreamwriter：\n1》构造方法：\noutputstreamwriter(outputstream out, charset cs)\n3.转换流的作用：\n① 可以将字节流转成字符流。\n② 可以对字符流进行编码的指定。\n代码 package com.demo; import java.io.*; import java.net.urldecoder; import java.net.urlencoder; /** 1.编码与解码： ① 编码： 根据编码表将字符存储在计算机中。将认识的转换成计算机中存储的。 ② 编码表： 规定。编码与解码的依据。 单字节： ascii iso-8859-1 不支持中文 两个字节： gbk ：中国国内。 多个字节： unicode ：utf-8 全世界统一编码。 ③ 解码：根据编码表将存储在计算机中的数据值，转换成相应的字符。 ④ 编码与解码时，要保证编码与解码使用相同的编码表，如果使用的不是同一个，会造成乱码问题。 ⑤ 解决乱码问题： 编码与解码使用的编码表一致。 2.转换流： ① inputstreamreader： 实质：根据编码，将字节流转换成字符流。 1》构造方法： inputstreamreader(inputstream in, charset cs) 注意： 如果只有一个参数，采用平台默认编码，如果有两个参数，第二个参数表示编码。 */ public class 转换流 { public static void main(string[] args) throws ioexception { // filereader fr = new filereader(new file(\u0026#34;day23a\\\\1.txt\u0026#34;)); /*inputstreamreader fr = new inputstreamreader(new fileinputstream(new file(\u0026#34;day23a\\\\1.txt\u0026#34;)),\u0026#34;gbk\u0026#34;); char[] c = new char[1024]; int value = fr.read(c); system.out.println(new string(c,0,value)); fr.close();*/ // filewriter fw = new filewriter(new file(\u0026#34;day23a\\\\1.txt\u0026#34;)); outputstreamwriter fw = new outputstreamwriter(new fileoutputstream(new file(\u0026#34;day23a\\\\1.txt\u0026#34;)),\u0026#34;gbk\u0026#34;); fw.write(\u0026#34;今天天气很好\u0026#34;); fw.close(); //urlencoder html编码实用工具类 /*string valueu = urlencoder.encode(\u0026#34;今天天气真好\u0026#34;, \u0026#34;utf-8\u0026#34;); string valueg = urlencoder.encode(\u0026#34;今天天气真好\u0026#34;, \u0026#34;gbk\u0026#34;); system.out.println(valueu); system.out.println(valueg); //urldecoder html解码实用工具类 string vu = urldecoder.decode(valueu, \u0026#34;utf-8\u0026#34;); string vu1 = urldecoder.decode(valueu, \u0026#34;gbk\u0026#34;); system.out.println(vu); system.out.println(vu1);*/ } } 其他流 概念 system.in \u0026ndash;\u0026gt; inputstream 字节输入流\nprintstream/printwriter 打印字节/符流 永远不会抛出 ioexception\nscanner 扫描器\n常用方法：返回字符串\nnext()\nnextline()\n对象流 概念 1.程序运算的结果\u0026ndash;》内存？\u0026ndash;》存储在硬盘 持久化 \u0026ndash;》存储在文件上 io流/ 数据库\n2.通过io流写入的内容都是字符串的形式。获取其中某些数据，比较麻烦。引入了对象流。\n3.objectoutputstream:对象输出流/序列化流\n4.构造方法：\n① objectoutputstream(outputstream out)\n5.常用方法：\n① writeobject(object obj) 写入一个对象\n6.注意：\n① notserializableexception 如果写入的类上没有实现 serializable接口会报该异常。\n② serializable：序列化接口，类通过实现 java.io.serializable 接口以启用其序列化功能\n注意：\n该接口没有任何方法，该接口主要是用来标识对象可以存储在计算机中。\n7.objectinputstream：对象输入流/反序列化流\n8.构造方法：\n① objectinputstream(inputstream in)\n9.常用方法：\n① object readobject() 读取一个对象，注意，返回值类型为object.\n代码 package com.demo; import java.io.*; /** 1.objectoutputstream:对象输出流/序列化流 2.构造方法： ① objectoutputstream(outputstream out) 3.常用方法： ① writeobject(object obj) 写入一个对象 4.注意： ① notserializableexception 如果写入的类上没有实现 serializable接口会报该异常。 ② serializable：序列化接口，类通过实现 java.io.serializable 接口以启用其序列化功能 注意： 该接口没有任何方法，该接口主要是用来标识对象可以存储在计算机中。 5.objectinputstream：对象输入流/反序列化流 6.构造方法： ① objectinputstream(inputstream in) 7.常用方法： ① object readobject() 读取一个对象，注意，返回值类型为object. */ public class 对象输出流 { public static void main(string[] args) throws ioexception, classnotfoundexception { //写入 /* objectoutputstream oos = new objectoutputstream(new fileoutputstream(new file(\u0026#34;day23b\\\\1.txt\u0026#34;))); oos.writeobject(new person(\u0026#34;zs\u0026#34;, 19)); oos.close();*/ //读取 objectinputstream ois = new objectinputstream(new fileinputstream(new file(\u0026#34;day23b\\\\1.txt\u0026#34;))); person value = (person) ois.readobject(); system.out.println(value); ois.close(); } } //serializable 标识对象可以存储在计算机中 class person implements serializable{ string name; int age; @override public string tostring() { return \u0026#34;person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } public person() { } public person(string name, int age) { this.name = name; this.age = age; } } 对象流读写多个对象 package com.demo; import java.io.*; /** 1.读写多个对象 2.eofexception :当输入意外到达文件或流的末尾时，会报该异常 */ public class 对象流读写多个对象 { public static void main(string[] args) throws ioexception, classnotfoundexception { /* objectoutputstream oos = new objectoutputstream(new fileoutputstream(new file(\u0026#34;day23b\\\\3.txt\u0026#34;))); oos.writeobject(new person(\u0026#34;张三\u0026#34;, 19)); oos.writeobject(new person(\u0026#34;李四\u0026#34;, 21)); oos.writeobject(new person(\u0026#34;王五\u0026#34;, 20)); oos.close();*/ objectinputstream ois = new objectinputstream(new fileinputstream(new file(\u0026#34;day23b\\\\3.txt\u0026#34;))); person value = (person) ois.readobject(); system.out.println(value); person value1 = (person) ois.readobject(); system.out.println(value1); person value2 = (person) ois.readobject(); system.out.println(value2); person value3 = (person) ois.readobject(); system.out.println(value3); } } 对象流存储集合 package com.demo; import java.io.*; import java.util.arraylist; import java.util.iterator; /** 1.存储集合 */ public class 对象流存储集合 { public static void main(string[] args) throws ioexception, classnotfoundexception { /*objectoutputstream oos = new objectoutputstream(new fileoutputstream(new file(\u0026#34;day23b\\\\5.txt\u0026#34;))); arraylist\u0026lt;person\u0026gt; list = new arraylist\u0026lt;\u0026gt;(); list.add(new person(\u0026#34;张三\u0026#34;, 19)); list.add(new person(\u0026#34;李四\u0026#34;, 19)); list.add(new person(\u0026#34;王五\u0026#34;, 19)); oos.writeobject(list); oos.close();*/ //读 objectinputstream ois = new objectinputstream(new fileinputstream(new file(\u0026#34;day23b\\\\5.txt\u0026#34;))); arraylist\u0026lt;person\u0026gt; list = (arraylist\u0026lt;person\u0026gt;) ois.readobject(); //遍历 /*iterator\u0026lt;person\u0026gt; it = list.iterator(); while (it.hasnext()){ system.out.println(it.next()); }*/ for (person person : list) { system.out.println(person); } ois.close(); } } scanner细节问题 package com.demo; import java.util.scanner; /** 1.scanner : ① next() 返回与分隔模式匹配的数据 ② nextline() 返回一行 注意： 在使用next、nextxxx 与 nextline连用时，需要重新创建一个scanner对象，保证数组中不存在数据。 */ public class scanner细节问题 { public static void main(string[] args) { scanner sc = new scanner(system.in); // string value = sc.next(); // system.out.println(value); string value1 = sc.next(); sc = new scanner(system.in); string value2 = sc.nextline(); system.out.println(value1); system.out.println(value2); } } 对象流的细节问题 概述 1.存的时候，对象流中存储的对象，必须是实现了序列化接口。如果，该对象的属性有没有实现序列化接口的，也必须实现。\n否则会报notserializableexception。\n2.瞬时对象 ：只存在内存中的对象。\n关键字：transient 表示该对象是瞬时对象。不会被持久化，不会被存储。\n代码 package com.demo; import java.io.*; /** 1.存的时候，对象流中存储的对象，必须是实现了序列化接口。如果，该对象的属性有没有实现序列化接口的，也必须实现。 否则会报notserializableexception。 2.瞬时对象 ：只存在内存中的对象。 关键字：transient 表示该对象是瞬时对象。不会被持久化，不会被存储。 */ public class 对象流的细节问题 { public static void main(string[] args) throws ioexception, classnotfoundexception { /*objectoutputstream oos = new objectoutputstream(new fileoutputstream(new file(\u0026#34;day23b\\\\7.txt\u0026#34;))); oos.writeobject(new b(15, new a())); oos.close();*/ objectinputstream ois = new objectinputstream(new fileinputstream(new file(\u0026#34;day23b\\\\7.txt\u0026#34;))); b value = (b) ois.readobject(); system.out.println(value); } } //作为需要持久化的对象的属性，也需要被序列化。 class a implements serializable{ int k; } class b implements serializable { int m; /* transient*/ a a;//瞬时对象 可以通过关键字 transient来表示，不会被持久化 @override public string tostring() { return \u0026#34;b{\u0026#34; + \u0026#34;m=\u0026#34; + m + \u0026#34;, a=\u0026#34; + a + \u0026#39;}\u0026#39;; } public b() { } public b(int m, a a) { this.m = m; this.a = a; } } 序列化版本号 概述 1.serialversionuid:序列化版本号:向下兼容。\nprivate static final long serialversionuid = 1l; 手动默认一般设置为1l\n2.invalidclassexception：失效的类异常，当使用对象流写入或读取的类的模板文件不一致时，会报该异常。 代码 package com.demo; import java.io.*; /** 1.步骤： ① 写--》writeobject() ② 读--》 readobject() 2.invalidclassexception :失效的类异常，该异常由对象流报出。 当写入的对象的类，在写入后被修改，读取时，会报该异常。 3.serialversionuid：序列化版本号。作用：向下兼容类。 ① 默认 private static final long serialversionuid = 1l */ public class 对象流序列化的细节问题1 { public static void main(string[] args) throws ioexception, classnotfoundexception { /*objectoutputstream oos = new objectoutputstream(new fileoutputstream(new file(\u0026#34;day23b\\\\9.txt\u0026#34;))); oos.writeobject(new student(\u0026#34;张三\u0026#34;, 19)); oos.close();*/ objectinputstream ois = new objectinputstream(new fileinputstream(new file(\u0026#34;day23b\\\\9.txt\u0026#34;))); student stu = (student) ois.readobject(); system.out.println(stu); ois.close(); } } class student implements serializable { private static final long serialversionuid = 4496801413692333247l; // private static final long serialversionuid = 1l; string name; int age; string stuno; @override public string tostring() { return \u0026#34;student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } public student() { } public student(string name, int age) { this.name = name; this.age = age; } public student(string name, int age, string stuno) { this.name = name; this.age = age; this.stuno = stuno; } } 属性集 概念 properties：\n表示了一个持久的属性集。 可保存在流中或从流中加载，\n属性列表中每个键及其对应值都是一个字符串。\n实质：\nmap集合的一个子类。继承自hashtable。\n构造方法 properties()\n常用方法 ① setproperty(string key, string value) 添加键值对\n② list(printstream/printwriter out)/store(outputstream/writer out, string\ncomments)\n（***）③ load(inputstream/reader instream) 加载属性集到流中\n（***） ④ getproperty(string key) 通过key获取值\n代码 package com.demo; import java.io.file; import java.io.filereader; import java.io.filewriter; import java.io.ioexception; import java.util.properties; /** 1. 属性集： 2.常用方法： ① setproperty(string key, string value) 添加键值对 ② list(printstream/printwriter out)/store(outputstream/writer out, string comments) （***）③ load(inputstream/reader instream) 加载属性集到流中 （***） ④ getproperty(string key) 通过key获取值 jdbc:java数据库连接 */ public class properties属性集 { public static void main(string[] args) throws ioexception { properties prp = new properties(); /*prp.setproperty(\u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;); prp.setproperty(\u0026#34;psw\u0026#34;, \u0026#34;123\u0026#34;); //prp.list(system.out); prp.store(new filewriter(new file(\u0026#34;day24a\\\\jdbc.properties\u0026#34;)), \u0026#34;this is java\u0026#34;);*/ prp.load(new filereader(new file(\u0026#34;day24a\\\\jdbc.properties\u0026#34;))); system.out.println(prp.getproperty(\u0026#34;name\u0026#34;)); system.out.println(prp.getproperty(\u0026#34;psw\u0026#34;)); } } ","date":"2021-11-01","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430214135/","summary":"IO流 文件 概述 File： ​ 文件和目录路径名的抽象表示形式。 ​ 既可以表示文件也可以表示文件夹。 ​ 抽象路径：创建文件对象时，硬盘上不一定存在。 构造方法 1.构造方法：","title":"i/o"},{"content":"泛型 概述 泛型：参数化类型\n泛型声明的格式 1.泛型类 2.泛型接口 3.泛型方法。\n1.泛型类：\n​\t格式：\n​\t[权限修饰符] class 类名\u0026lt;标识符,标识符\u0026gt;{} 代码 package com.demo; /** 1.泛型类： 格式： [权限修饰符] class 类名\u0026lt;标识符,标识符\u0026gt;{} */ public class 泛型\u0026lt;m\u0026gt; { public static void main(string[] args) { fun(5); 泛型\u0026lt;double\u0026gt; k = new 泛型\u0026lt;\u0026gt;(); 泛型\u0026lt;integer\u0026gt; k1 = new 泛型\u0026lt;\u0026gt;(); } public static void fun(int a){} /* public static void add(int a,int b){} public static void add(double a,double b){} public static void add(float a,int b){}*/ public void add(m a, m b){} } 泛型接口 格式 [权限修饰符] interface 接口名称\u0026lt;标识符,标识符\u0026gt;{ }\n代码 package com.demo; /** 1.格式： [权限修饰符] interface 接口名称\u0026lt;标识符,标识符\u0026gt;{ } */ public class 泛型 { public static void main(string[] args) { t\u0026lt;string\u0026gt; t = new t\u0026lt;string\u0026gt;() { @override public void fun(string s) { } }; t\u0026lt;integer\u0026gt; t1 = new t\u0026lt;integer\u0026gt;() { @override public void fun(integer integer) { } }; } } interface t\u0026lt;m\u0026gt;{ public void fun(m m); } 泛型方法 概述 接口或类上的泛型可以给类/接口的成员使用，方法也算是成员，所以接口或类上的泛型可以给方法使用。\n引入泛型方法的原因：(使用场景) ① 当类或接口上的泛型不够该方法使用时，可以将该方法声明成泛型方法。\n② 静态方法必须使用泛型方法。(静态方法随着类的加载而加载，当类出现时，未必有对象，泛型也可能没有被指定)\n泛型方法声明的格式 [权限修饰符][修饰符] \u0026lt;标识符,标识符\u0026gt;返回值类型 方法名称 (参数列表 泛型){}\n泛型方法的泛型的确定 随着方法的调用而确定\n代码 package com.demo; /** 1.泛型方法： */ public class 泛型方法 { public static void main(string[] args) { f\u0026lt;string\u0026gt; f = new f\u0026lt;\u0026gt;(); f.fun(\u0026#34;abc\u0026#34;, 12); f.fun(\u0026#34;abc\u0026#34;, \u0026#34;abc\u0026#34;); } } class f\u0026lt;n\u0026gt;{ public \u0026lt;k\u0026gt;void fun(n n,k k){ } public void fun1(n n){ } //返回值类型前面声明泛型。 泛型方法 public static \u0026lt;b\u0026gt;void sf(b b){} } 泛型的特点 可擦除技术：只存在编译期，在class文件中不存在。\n菱形技术：\u0026lt;\u0026gt; 1.7有类型推断，可以进行直接推断，在new后面的可以省略数据类型不写\n泛型的好处 可以将运行期的异常转换成编译期的异常，减少了类型转换异常的发生。\n避免了向下转型。\n泛型的继承时的注意问题 子类继承时 如果父类有泛型，在子类中没有指定任何泛型时，为object类型 如果子类中使用泛型时 当泛型的值不确定时，子类与父类都要有泛型\n当泛型的值确定时，父类后面指定泛型的具体类型\n代码 package com.demo; public class 泛型关于子类继承问题 { public static void main(string[] args) { zip\u0026lt;integer\u0026gt; zp = new zip\u0026lt;\u0026gt;(); zip\u0026lt;integer\u0026gt; zp1 = new zip(); zip\u0026lt;integer\u0026gt; zp2 = new zip\u0026lt;\u0026gt;(); zip\u0026lt;string\u0026gt; zp3= new zip\u0026lt;\u0026gt;(); zip1 zp4 = new zip1(); zp4.fun(\u0026#34;abc\u0026#34;); } } class p\u0026lt;t1\u0026gt;{ public void fun(t1 t1){} } //当泛型的值不确定时，子类与父类都要有泛型 class zip\u0026lt;t1\u0026gt; extends p\u0026lt;t1\u0026gt;{} //当泛型的值确定时，父类后面指定泛型的具体类型 class zip1 extends p\u0026lt;string\u0026gt;{} 泛型的通配符 概述 1.泛型的通配符：\n​\t? 代表可以接收任意数据类型。表示有泛型。\n​\t注意：具体类型的操作，就不能使用。\n2.泛型通配符的限定：\n​\t? extends t 上限限定\n​\t? super t 下限限定\n3.泛型的命名：\n原则上泛型起名是标识符，但是一般起名用字母代替，java中常见字母\ne t k v 用法上没区别，含义有区别\ne ：element 元素\nt ：type 类型\nk： key 键\nv： value 值\n代码 package com.demo; import java.util.arraylist; import java.util.iterator; /** 1.泛型的通配符： ? 代表可以接收任意数据类型。表示有泛型。 注意：具体类型的操作，就不能使用。 2.泛型通配符的限定： ? extends t 上限限定 ? super t 下限限定 3.泛型的命名： 原则上泛型起名是标识符，但是一般起名用字母代替，java中常见字母 e t k v 用法上没区别，含义有区别 e ：element 元素 t ：type 类型 k： key 键 v： value 值 */ public class 泛型的通配符 { public static void main(string[] args) { /*arraylist\u0026lt;integer\u0026gt; list = new arraylist(); fun(list); arraylist\u0026lt;string\u0026gt; list1 = new arraylist(); fun(list1);*/ arraylist\u0026lt;person\u0026gt; list2 = new arraylist\u0026lt;\u0026gt;(); fun1(list2); } public static void fun(arraylist\u0026lt;?\u0026gt; list){ iterator\u0026lt;?\u0026gt; it = list.iterator(); while (it.hasnext()){ object value = it.next(); } } public static void fun1(arraylist\u0026lt;? super student\u0026gt; list){} } class person{ } class student extends person{} class middlestudent extends student{} ","date":"2021-10-29","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430214286/","summary":"泛型 概述 泛型：参数化类型 泛型声明的格式 1.泛型类 2.泛型接口 3.泛型方法。 1.泛型类： ​ 格式： ​ [权限修饰符] class 类名\u0026lt;标识符,标识符\u0026gt;{} 代码 package com.demo; /**","title":"泛型"},{"content":"集合框架 1:集合：（1） collection(单列集合)list(有序,可重复)arraylist底层数据结构是数组,查询快,增删慢 线程不安全,效率高vector 底层数据结构是数组,查询快,增删慢 线程安全,效率低linkedlist 底层数据结构是链表,查询慢,增删快 线程不安全,效率高set(无序,唯一)hashset 底层数据结构是哈希表。 哈希表依赖两个方法：hashcode()和equals()\nlinkedhashset底层数据结构由链表和哈希表组成。 由链表保证元素有序。 由哈希表保证元素唯一。treeset 底层数据结构是红黑树。(是一种自平衡的二叉树) 如何保证元素唯一性呢? 根据比较的返回值是否是0来决定 如何保证元素的排序呢? 两种方式 自然排序(元素具备比较性) 让元素所属的类实现comparable接口 比较器排序(集合具备比较性) 让集合接收一个comparator的实现类对象\n（2）map(双列集合)a:map集合的数据结构仅仅针对键有效，与值无关。 b:存储的是键值对形式的元素，键唯一，值可重复。 hashmap 底层数据结构是哈希表。线程不安全，效率高 哈希表依赖两个方法：hashcode()和equals() 执行顺序： 首先判断hashcode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashcode()和equals()即可 linkedhashmap 底层数据结构由链表和哈希表组成。 由链表保证元素有序。 由哈希表保证元素唯一。hashtable 底层数据结构是哈希表。线程安全，效率低 哈希表依赖两个方法：hashcode()和equals() 执行顺序： 首先判断hashcode()值是否相同 是：继续执行equals(),看其返回值 是true:说明元素重复，不添加 是false:就直接添加到集合 否：就直接添加到集合 最终： 自动生成hashcode()和equals()即可treemap 底层数据结构是红黑树。(是一种自平衡的二叉树) 如何保证元素唯一性呢? 根据比较的返回值是否是0来决定 如何保证元素的排序呢? 两种方式 自然排序(元素具备比较性) 让元素所属的类实现comparable接口 比较器排序(集合具备比较性) 让集合接收一个comparator的实现类对象\n2:到底使用那种集合：是否是键值对象形式:是：map键是否需要排序:是：treemap否：hashmap 不知道，就使用hashmap。\n否：collection元素是否唯一:是：set元素是否需要排序:是：treeset否：hashset 不知道，就使用hashset否：list要安全吗:是：vector否：arraylist或者linkedlist增删多：linkedlist 查询多：arraylist 不知道，就使用arraylist不知道，就使用arraylist\ncollection接口 collection 层次结构 中的根接口，单列集合。存储的对象。\n目标： collection集合概述。\n什么是集合?\n集合是一个大小可变的容器。\n容器中的每个数据称为一个元素。数据==元素。\n集合的特点是：类型可以不确定，大小不固定。集合有很多种，不同的集合特点和使用场景不同。\n数组：类型和长度一旦定义出来就都固定了。\n集合有啥用？\n在开发中，很多时候元素的个数是不确定的。\n而且经常要进行元素的增删改查操作，集合都是非常合适的。\n开发中集合用的更多！！\njava 中集合的代表是： collection.\ncollection集合是java中集合的祖宗类。\n学习collection集合的功能，那么一切集合可以用这些功能！！ 集合的特点：\nset系列集合，添加的元素是无序，不重复，无索引的。\n\u0026mdash;\u0026mdash; hashset: 添加的元素是无序，不重复，无索引的。\n\u0026mdash;\u0026ndash; linkedhashset： 添加的元素是有序，不重复，无索引的。\n\u0026mdash;\u0026ndash; treeset：不重复，无索引，按照大小默认升序排序！！\nlist系列集合： 添加的元素是有序，可重复，有索引。\n\u0026mdash;\u0026mdash; arraylist： 添加的元素是有序，可重复，有索引。\n\u0026mdash;\u0026ndash; linekdlist: 添加的元素是有序，可重复，有索引。\n小结：\ncollection是集合的祖宗类，collection集合的功能时一切集合都可以直接使用的。\n数组与集合 1.数组可以存储任意数据类型，可以存储基本数据类型也可以存储引用数据类型。 只能存储同一种。\n并且在一开始的时候，长度就固定了。对于数组增删操作时，移动的位置会多。\n2.集合实质是对数组的一个补充，集合中可以存储任意数据类型的对象。但是不能存储基本数据类型\n的数值的，提供了方法，对数据的crud，进行便捷操作。\n3.无论是数组还是集合，都是用来存储数据的容器。\n集合创建对象 1.collection 集合体系：\n2.集合是一个接口。必须通过子类来创建对象。\n构造方法：\n① arraylist()\n3.集合常用方法：\n① add(e e) 添加\n② addall(collection\u0026lt; ? extends e\u0026gt; c) 将一个集合中的元素添加到另一个集合。\n③ clear() 清除\n④ contains(object o) 判断包含\n注意：\n判断结果取决于参数的equals方法。对于自定义类来说，要重写equals方法，达到按需求返回true的目的。\n代码 package com.demo; import java.util.arraylist; import java.util.collection; /** 1.collection 集合体系： 2.集合是一个接口。必须通过子类来创建对象。 构造方法： ① arraylist() 3.集合常用方法： ① add(e e) 添加 ② addall(collection\u0026lt;? extends e\u0026gt; c) 将一个集合中的元素添加到另一个集合。 ③ clear() 清除 ④ contains(object o) 判断包含 注意：判断结果取决于参数的equals方法。对于自定义类来说，要重写equals方法，达到按 需求返回true的目的。 */ public class collection集合 { public static void main(string[] args) { collection c = new arraylist(); c.add(true);//boolean c.add(123);// integer c.add(\u0026#34;abc\u0026#34;); c.add(new person(\u0026#34;张三\u0026#34;,19)); collection c1 = new arraylist(); // ② addall(collection\u0026lt;? extends e\u0026gt; c) 将一个集合中的元素添加到另一个集合。 // c1.addall(c); // ③ clear() 清除 // c.clear(); // ④ contains(object o) 判断包含 // system.out.println(c.contains(1234)); system.out.println(c.contains(new person(\u0026#34;张三\u0026#34;,19))); } } class person{ string name; int age; public person() { } @override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; person person = (person) o; if (age != person.age) return false; return name != null ? name.equals(person.name) : person.name == null; } @override public int hashcode() { int result = name != null ? name.hashcode() : 0; result = 31 * result + age; return result; } public person(string name, int age) { this.name = name; this.age = age; } @override public string tostring() { return \u0026#34;person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } collection 常用方法 1.remove(object o) 移除 单个元素,多个重复元素，每次只能删除一个\n2.size() 相当于length 表示集合中元素个数\n3.toarray() 集合转数组 ，返回值的数据类型 object\n代码 package com.demo; import java.util.arraylist; import java.util.collection; /** 1.remove(object o) 移除 单个元素,多个重复元素，每次只能删除一个 2.size() 相当于length 表示集合中元素个数 3.toarray() 集合转数组 ，返回值的数据类型 object */ public class 集合常用方法 { public static void main(string[] args) { collection c = new arraylist(); //isempty() 判断集合是否为空元素集合，如果是返回true // system.out.println(c.isempty()); c.add(1); c.add(2); c.add(3); c.add(4); c.add(2); /* system.out.println(c); for (int i = 0; i \u0026lt; c.size(); i++) { c.remove(2); }system.out.println(c);*/ object[] arr = c.toarray(); for (int i = 0; i \u0026lt; arr.length; i++) { system.out.println(arr[i]); } } } 迭代器 1.iterator ：迭代器\n① hasnext()：判断该位置是否还有集合元素\n② next() :返回该集合元素\n③ remove() ： 删除集合元素\n2.获取迭代器的方式：\n① iterator()\n3.nosuchelementexception 没有该元素异常 ，发生于集合中没有元素，但是通过next方法获取时。\n4.建议：\n迭代器额hasnext与next方法一配一使用。 代码 package com.demo; import java.util.arraylist; import java.util.collection; import java.util.iterator; /** 1.数据操作 ：crud 增删改查。 2.iterator ：迭代器 ① hasnext()：判断该位置是否还有集合元素 ② next() :返回该集合元素 ③ remove() ： 删除集合元素 3.获取迭代器的方式： ① iterator() 4.nosuchelementexception 没有该元素异常 ，发生于集合中没有元素，但是通过next方法获取 时。 */ public class 迭代器 { public static void main(string[] args) { collection c = new arraylist(); c.add(1); c.add(\u0026#34;abc\u0026#34;); c.add(true); c.add(\u0026#39;我\u0026#39;); //获取 集合中某个位置的元素 \u0026#34;abc\u0026#34; 遍历 iterator it = c.iterator(); while(it.hasnext()){ system.out.println(it.next()); } } } 并发修改异常 1.集合删除元素：\n① remove(obj) 集合的删除方法 删除单个元素\n② remove() 迭代器的删除\n\\2. 并发修改异常：concurrentmodificationexception\n原因：\n当使用集合进行类似于迭代器的遍历时，如果在遍历的过程中，对集合进行了增删操作，就会报该异常。\n必须使用迭代器自身的删除方法，才不会有问题。\n代码 package com.demo; import java.util.arraylist; import java.util.collection; import java.util.iterator; /** 1.集合删除元素： ① remove(obj) 集合的删除方法 删除单个元素 ② remove() 迭代器的删除 2. 并发修改异常：concurrentmodificationexception 原因：当使用集合进行类似于迭代器的遍历时，如果在遍历的过程中，对集合进行了增删操作，就会报该异常。 必须使用迭代器自身的删除方法，才不会有问题。 */ public class 集合元素删除的方式 { public static void main(string[] args) { collection c = new arraylist(); c.add(1); c.add(2); c.add(3); c.add(4); c.add(5); iterator it = c.iterator(); while (it.hasnext()){ object obj = it.next(); //删除值为3 的元素 if (obj.equals(3)){ it.remove(); // c.remove(3); //建议使用迭代器自身的删除方法而不是集合的删除方法 } } system.out.println(c); } } 集合的泛型 1.引入泛型：\n检测数据类型是否符合要求。\n2.格式：\n集合的数据类型\u0026lt;要存储的数据类型\u0026gt;\n3.集合泛型：\n① 将运行期的类型转换异常转变成编译期的异常，提高了程序的健壮性。\n② 避免了向下转型。\n4.泛型的特点：\n① 可擦除技术：泛型只存在编译期，class文件中不存在。\n② 菱形技术:1.6必须只能new后的集合对象的泛型的数据类型，但是1.7之后，有了类型推断，根据前面的泛型，可以推导后面的泛型，省略不写。\n代码 package com.demo; import java.util.arraylist; import java.util.collection; import java.util.iterator; /** 1.引入泛型： 检测数据类型是否符合要求。 2.格式： 集合的数据类型\u0026lt;要存储的数据类型\u0026gt; 3.集合泛型： ① 将运行期的类型转换异常转变成编译期的异常，提高了程序的健壮性。 ② 避免了向下转型。 4.泛型的特点： ① 可擦除技术：泛型只存在编译期，class文件中不存在。 ② 菱形技术:1.6必须只能new后的集合对象的泛型的数据类型，但是1.7之后，有了类型推断，根据前面的泛型，可以推导后面的泛型，省略不写。 */ public class 集合的泛型 { public static void main(string[] args) { collection\u0026lt;student\u0026gt; c = new arraylist\u0026lt;\u0026gt;();//菱形技术。省略不写泛型的数据类型。 c.add(new student(\u0026#34;张三\u0026#34;, 19)); c.add(new student(\u0026#34;李思\u0026#34;, 19)); // c.add(1); // c.add(\u0026#34;abc\u0026#34;); // c.add(true); //使用集合判断如果是学生对象，就调用study方法。 /*iterator it = c.iterator(); while (it.hasnext()){ object obj = it.next(); if ( obj instanceof student){ student st = (student) obj; st.study(); } }*/ //带有泛型的形式 iterator\u0026lt;student\u0026gt; it = c.iterator(); while (it.hasnext()){ student st = it.next(); system.out.println(st.name); } } } class student { string name; int age; @override public string tostring() { return \u0026#34;student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } public student() { } public student(string name, int age) { this.name = name; this.age = age; } public void study(){ system.out.println(\u0026#34;goodgoodstudy\u0026#34;); } } list集合 概述 1.有序的集合：\n有序：插入与存储顺序相同\n（***） 2.list集合特点：\n有序 可重复 可插入null\n3.list集合可以通过索引访问集合中的元素。\n4.常用方法：\n① add(int index, e element) 根据index 添加元素\n注意：\n第一个参数index有范围，从[0,size]范围为止。\n(***)② get(int index) 返回index位置的元素\n（***）③ listiterator()/listiterator(int index) 获取list集合特有的迭代器\n1》 hasprevious() 向上判断是否存在元素\n2》 previous() 获取元素值\n④ remove(int index) /remove(object o) 删除索引/对象元素\n注意：\n如果是数值，认为是index索引值，如果是想通过数值对象删除，必须通过new操作创建对象。\n⑤ set(int index, e element) 修改\n代码 package com.demo; import java.util.arraylist; import java.util.collection; import java.util.list; import java.util.listiterator; /** 1.有序的集合： 有序：插入与存储顺序相同 （***） 2.list集合特点： 有序 可重复 可插入null 3.list集合可以通过索引访问集合中的元素。 4.常用方法： ① add(int index, e element) 根据index 添加元素 注意： 第一个参数index有范围，从[0,size]范围为止。 (***)② get(int index) 返回index位置的元素 （***）③ listiterator()/listiterator(int index) 获取list集合特有的迭代器 1》 hasprevious() 向上判断是否存在元素 2》 previous() 获取元素值 ④ remove(int index) /remove(object o) 删除索引/对象元素 注意： 如果是数值，认为是index索引值，如果是想通过数值对象删除，必须通过new操作创建对象。 ⑤ set(int index, e element) 修改 */ public class list集合 { public static void main(string[] args) { list\u0026lt;integer\u0026gt; c = new arraylist\u0026lt;\u0026gt;(); c.add(1); c.add(5); c.add(2); c.add(7); system.out.println(c); // ① add(int index, e element) 根据index 添加元素 // c.add(5, 15); // (***)② get(int index) 返回index位置的元素 // system.out.println(c.get(2)); // ③ listiterator() 获取list集合特有的迭代器 /* listiterator\u0026lt;integer\u0026gt; it = c.listiterator(c.size()); *//*while(it.hasnext()){ system.out.println(it.next()); }*//* while(it.hasprevious()){ system.out.println(it.previous()); }*/ // ④ remove(int index) /remove(object o) 删除索引/对象元素 //删除数值为5的元素 // c.remove(new integer(5)); // ⑤ set(int index, e element) 修改 c.set(1, 17); system.out.println(c); } } arraylist集合 概述 (***)1.arraylist 底层：list 接口的大小可变数组的实现\n2.arraylist 特点： 有序 可重复 可存储null\n3.构造方法：\n① arraylist() 初始容量为10的数组\n② arraylist(collection\u0026lt; ? extends e\u0026gt; c)\n代码 package com.demo; import java.util.arraylist; /** (***)1.arraylist 底层：list 接口的大小可变数组的实现 2.arraylist 特点： 有序 可重复 可存储null 3.构造方法： ① arraylist() 初始容量为10的数组 ② arraylist(collection\u0026lt;? extends e\u0026gt; c) */ public class arraylist集合 { public static void main(string[] args) { arraylist\u0026lt;string\u0026gt; list = new arraylist\u0026lt;\u0026gt;(); system.out.println(list); list.add(\u0026#34;abc\u0026#34;); list.add(\u0026#34;def\u0026#34;); arraylist\u0026lt;string\u0026gt; list1 = new arraylist\u0026lt;\u0026gt;(list); system.out.println(list1); } } 集合的遍历方式 1.集合的遍历方式：\n① 迭代器： iterator : hasnext next 单列集合通过\n② list下特有的接口：只能list集合使用 listiterator\n③ for循环 :只适用于list集合\n④ 转数组 toarray()单列集合通过\n(***) ⑤ 增强for循环 底层原理：迭代\n格式：\nfor(变量的数据类型 变量的名称: 整体的名称){\n}\n代码 package com.demo; import java.util.arraylist; import java.util.iterator; import java.util.listiterator; /** 1.集合的遍历方式： ① 迭代器： iterator : hasnext next 单列集合通过 ② list下特有的接口：只能list集合使用 listiterator ③ for循环 :只适用于list集合 ④ 转数组 toarray()单列集合通过 (***) ⑤ 增强for循环 底层原理：迭代 格式： for(变量的数据类型 变量的名称: 整体的名称){ } */ public class 集合的遍历方式 { public static void main(string[] args) { arraylist\u0026lt;integer\u0026gt; list = new arraylist\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); // ① 迭代器： iterator : hasnext next /* iterator\u0026lt;integer\u0026gt; it = list.iterator(); while (it.hasnext()){ system.out.println(it.next()); }*/ // ② list下特有的接口：只能list集合使用 listiterator /*listiterator\u0026lt;integer\u0026gt; listit = list.listiterator(list.size()); while (listit.hasprevious()){ system.out.println(listit.previous()); }*/ // ③ for循环 只适用于list集合 /* for (int i = 0; i \u0026lt; list.size(); i++) { system.out.println(list.get(i)); }*/ // ④ 转数组 toarray()单列集合通过 /* object[] arr = list.toarray(); for (int i = 0; i \u0026lt; arr.length; i++) { system.out.println(arr[i]); } */ // ⑤ 增强for循环 /* for (integer it:list) { system.out.println(it); }*/ int[] arr2 = {1,2,3,4,5,6}; for(int i:arr2){ system.out.println(i); } } } linkedlist 结构 (***)\n1.arraylist与linkedlist的区别？\narraylist底层是大小可变的数组的实现，查询快 增删慢。线程不安全\nlinkedlist底层是双向链表的实现，增删快 ，查询慢。线程不安全。\n2.linkedlist可以当做堆栈、队列或双端队列。\n队列： 先进先出\n栈： 先进后出。\n原理 1.底层： 双向链表\n2.特点： 有序 可重复 可以插入null\n代码 package com.demo; import java.util.linkedlist; /** (***) 1.底层： 双向链表 2.特点： 有序 可重复 可以插入null */ public class linkedlist集合 { public static void main(string[] args) { linkedlist\u0026lt;integer\u0026gt; list = new linkedlist\u0026lt;\u0026gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); } } vector 用法用arraylist。该集合是线程安全的，如果需要使用线程安全的集合，可以采用vector。\n单列集合的体系结构和它们之间的区别 list：其中list的集合查询快，增删慢，原因是因为list的存储的结构是数组结构。\n**而list下的_linklist_**的集合查询慢，增删快。原因是 linklist的存储结构是链表。在其中有大量操作收尾元素的方法，不过使用其特有的方法时不能使用多态。\nset：在set中不能有重复元素。没有索引，不能使用普通for循环遍历。是一个无序的集合，储存元素和取出元素的顺序很有可能不一致。底层是一个哈希表结构，查询速度很快。\nset下的_hashset_：首先要明白哈希值。是系统模拟的地址，而不是真实的地址，不同对象的哈希值不一样，如果对求哈希值的方法进行重写，那么就能使哈希值相同。string下的所有哈希值是一样的。jdk1.8之后，底层是数组加链表/红黑，如果链表的长度超过8位就会转换为红黑树。\nhashset不能存储重复元素的原理： set集合在调用add方法的时候，add方法会调用元素的hashcode方法和equals方法。如果没有相同的哈希值，就放入集合，如果相同就调用equals方法。返回true就不会存储集合中。\n（equals默认比较两个对象地址值，自定义上的类型一定要重写hashcode方法和equals方法）\nset下的_linkedhashset_:linkedhashset继承了hashset，比hashset多了一条链表（记录元素的存储数据），保证元素有序。也不允许重复。\nset集合 概述 set集合特点： 不重复，只能存储一个null\nhashset 1.特点：无序 不重复，只能存储一个null\n2.构造方法： hashset() 初始容量是16\n3.底层： 哈希表 ()\n4.如何对自定义类的对象的存储进行去重复： 重写hashcode和equals。\n5.hashset存储原理： ① hashcode() ② equals\n① 将存储到集合中的元素，调用该元素的hashcode方法，算出哈希码值，然后根据哈希算法，换 算出在哈希表中的位置，如果该位置没有元素，直接插入。\n② 如果该位置有元素，这种现象称为哈希碰撞也叫哈希冲突。发生了这种情况，调用equals方法 进行判断，如果返回值为false，在该索引位置下以链表的形式插入。\n③ 如果发生了哈希冲突之后，调用equals方法判断结果为true。此时不插入。 6.hashset存储细节问题：\n​\t① 发生哈希冲突插入形式：\n​\t1》 1.7jdk以前 ，头插法\n​\t2》 1.8jdk之后 ，尾插法 2.哈希桶存储元素：\n​\t1.7之前 采用链表的形式。\n​\t1.8之后 采用链表 + 红黑树的形式\n​\t阈值是8 ，当链表长度超过8的时候，从链表转换成红黑树。\n​\t阈值小于5，红黑树转链表。\n3.加载因子：\n​\t当哈希桶容量*加载因子超过这个数值时，就扩容。\n注意：\n​\t扩容还是转树不是必然的，不是硬性超过阈值为8 就转。需要看扩容和转树哪个性能更好，哪个好转哪个。\n红黑树 红黑树（red black tree） 是一种自平衡二叉查找树\n二叉树：\n二叉查找树：\n特点：\n一棵空树，或者是具有下列性质的二叉树：\n（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n（3）左、右子树也分别为二叉排序树；\n（4）没有键值相等的结点。\n总结：\n左小右大，没有相等 treeset集合 概述 (***)treeset底层： 基于红黑树的treemap集合。\n(***)treeset的特点： 无序 不重复 可存储一个null 可排序\n1.注意：\n① 使用treeset()构造方法时,默认会使用元素的自然顺序比较器，如果存储在该集合中的类\n没有实现comparable该接口，\n会报classcastexception类型转换异常。\n② treeset集合在进行存储时，会自动调用comparato方法进行判断，根据 \u0026gt;0 \u0026lt;0 ==0的结\n果进行插入。\n如果等于0 不插入。\n2.treeset利用比较器进行比较的，如果自定义类去重，不需要重写hashcode和equals。 第三方比较器 概述 1.treeset(comparator\u0026lt; ? super e\u0026gt; comparator)\n2.comparator ：\n第三方比较器 ：\ncompare(t o1, t o2)\n相当于 compareto方法中的：this相当于o1 o 相当于o2.\n3.当存在第三方比较器时，根据就近原则，第三方比较器优先有效。\n代码 package com.demo; import java.util.comparator; import java.util.treeset; /** 1.treeset(comparator\u0026lt;? super e\u0026gt; comparator) 2.comparator ：第三方比较器 ： compare(t o1, t o2) 相当于 compareto方法中的：this相当于o1 o 相当于o2. 3.当存在第三方比较器时，根据就近原则，第三方比较器优先有效。 */ public class 第三方比较器 { public static void main(string[] args) { treeset\u0026lt;person\u0026gt; set = new treeset\u0026lt;\u0026gt;(new namecomparator()); set.add(new person(\u0026#34;zs\u0026#34;, 19)); set.add(new person(\u0026#34;ls\u0026#34;, 20)); system.out.println(set); } } class namecomparator implements comparator\u0026lt;person\u0026gt;{ @override public int compare(person o1, person o2) { return o1.name .compareto(o2.name); } } class person implements comparable\u0026lt;person\u0026gt;{ string name; int age ; @override public string tostring() { return \u0026#34;person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } public person() { } public person(string name, int age) { this.name = name; this.age = age; } @override public int compareto(person o) { return this.age -o.age; } } linkedhashset 概念 (***)底层: 哈希表和双向链表组成。\n(***)特点： 有序 不重复 可以存储一个null\n场景：\n购物车 商品历史浏览记录\nmap map 双列集合：\nmap\u0026lt;k,v\u0026gt;\n将键映射到值的对象。一个映射不能包含重复的键；键与值是一一对应的关系，键不能重复，但是值可\n以重复。\n1.map集合常用方法：\n① put(key,value) 将键值对添加到集合 add方法。\n注意：\n键如果重复，会覆盖原有的值，并且将原有的值返回。\n② containskey(object key) /containsvalue(object value) 包含\n注意：\n自定义类的对象需要重写hashcode和equals\n(***)③ get(object key) 通过key获取value\n④ collection values() 获取值的集合。\n2.map对象的创建 ：\n① hashmap() 创建初始容量为16，加载因子0.75\n代码 package com.demo; import java.util.collection; import java.util.hashmap; import java.util.map; /** 1.map集合常用方法： ① put(key,value) 将键值对添加到集合 add方法。 注意： 键如果重复，会覆盖原有的值，并且将原有的值返回。 ② containskey(object key) /containsvalue(object value) 包含 注意： 自定义类的对象需要重写hashcode和equals (***)③ get(object key) 通过key获取value ④ collection\u0026lt;v\u0026gt; values() 获取值的集合。 2.map对象的创建 ： ① hashmap() 创建初始容量为16，加载因子0.75 */ public class map集合的常用方法 { public static void main(string[] args) { map\u0026lt;string,integer\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;一\u0026#34;, 1); map.put(\u0026#34;二\u0026#34;, 2); map.put(\u0026#34;三\u0026#34;, 3); system.out.println(map); /*integer it = map.put(\u0026#34;三\u0026#34;, 5); system.out.println(it);*/ // ② containskey(object key) /containsvalue(object value) 包含 // system.out.println(map.containskey(\u0026#34;二\u0026#34;)); // (***)③ get(object key) 通过key获取value // system.out.println(map.get(\u0026#34;二\u0026#34;)); // ④ collection\u0026lt;v\u0026gt; values() 获取值的集合。 collection\u0026lt;integer\u0026gt; cl = map.values(); system.out.println(cl); } } map集合的遍历方式之一 map集合的遍历：\n① keyset()\n思路：\nmap集合没有迭代器，map集合需要先转set集合，然后迭代。\n代码 package com.demo; import java.util.hashmap; import java.util.iterator; import java.util.map; import java.util.set; /** map集合的遍历： ① keyset() 思路： map集合没有迭代器，map集合需要先转set集合，然后迭代。 */ public class map集合的遍历 { public static void main(string[] args) { map\u0026lt;string,integer\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;一\u0026#34;, 1); map.put(\u0026#34;二\u0026#34;, 2); map.put(\u0026#34;三\u0026#34;, 3); set\u0026lt;string\u0026gt; keys = map.keyset(); //遍历 iterator\u0026lt;string\u0026gt; it = keys.iterator(); while (it.hasnext()){ string key = it.next(); system.out.println(key +\u0026#34;==\u0026gt;\u0026#34; + map.get(key)); } } } map.entry map.entry\n映射项（键-值对）。\n1.map集合的遍历方式二：\nmap.entry map中的子接口。\n2.常用方法：\n① getkey()获取键\n② getvalue() 获取值\n3.map的常用方法：\nentryset() 获取map.entry的set集合\n代码 package com.demo; import java.util.hashmap; import java.util.iterator; import java.util.map; import java.util.set; //import java.util.map.entry; //直接写entry 可以在该位置导包 /** 1.map集合的遍历方式二： map.entry map中的子接口。 2.常用方法： ① getkey()获取键 ② getvalue() 获取值 3.map的常用方法： entryset() 获取map.entry的set集合。 */ public class map的遍历方式二 { public static void main(string[] args) { hashmap\u0026lt;string,integer\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;二\u0026#34;, 2); map.put(\u0026#34;三\u0026#34;, 3); map.put(\u0026#34;一\u0026#34;, 1); set\u0026lt;map.entry\u0026lt;string,integer\u0026gt;\u0026gt; entry = map.entryset(); //遍历 /*iterator\u0026lt;map.entry\u0026lt;string,integer\u0026gt;\u0026gt; it = entry.iterator(); while(it.hasnext()){ map.entry\u0026lt;string,integer\u0026gt; en = it.next(); system.out.println(en.getkey() + \u0026#34;=====\u0026#34;+ en.getvalue()); }*/ for (iterator\u0026lt;map.entry\u0026lt;string,integer\u0026gt;\u0026gt; it = entry.iterator(); it.hasnext();){ map.entry\u0026lt;string, integer\u0026gt; value = it.next(); system.out.println(value.getkey() + \u0026#34;===\u0026#34;+ value.getvalue()); } } } hashmap 概述 底层：\n基于哈希表的实现。\n特点：\n键值对的映射，一个键对应一个值，键是不重复的，键无序\nhashmap 细节问题：\n自定义类做键: 需要重写hashcode和equals方法。\n代码 package com.demo; import java.util.hashmap; import java.util.map; /** 1.hashmap 细节问题： 自定义类做键: 需要重写hashcode和equals方法。 */ public class hashmap细节问题 { public static void main(string[] args) { /*hashmap\u0026lt;string ,person\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); map.put(\u0026#34;张三\u0026#34;,new person(\u0026#34;张三\u0026#34;, 19)); map.put(\u0026#34;张三1\u0026#34;,new person(\u0026#34;张三1\u0026#34;, 19)); map.put(\u0026#34;张三2\u0026#34;,new person(\u0026#34;张三2\u0026#34;, 19)); map.put(\u0026#34;张三2\u0026#34;,new person(\u0026#34;张三2\u0026#34;, 20)); system.out.println(map);*/ hashmap\u0026lt;person,string\u0026gt; map = new hashmap\u0026lt;\u0026gt;(); map.put(new person(\u0026#34;zs\u0026#34;, 19), \u0026#34;zs\u0026#34;); map.put(new person(\u0026#34;zs1\u0026#34;, 19), \u0026#34;zs1\u0026#34;); map.put(new person(\u0026#34;zs2\u0026#34;, 19), \u0026#34;zs2\u0026#34;); map.put(new person(\u0026#34;zs3\u0026#34;, 19), \u0026#34;zs3\u0026#34;); map.put(new person(\u0026#34;zs3\u0026#34;, 19), \u0026#34;zs5\u0026#34;); system.out.println(map); } } class person{ string name; int age ; @override public string tostring() { return \u0026#34;person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } public person() { } public person(string name, int age) { this.name = name; this.age = age; } @override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; person person = (person) o; if (age != person.age) return false; return name != null ? name.equals(person.name) : person.name == null; } @override public int hashcode() { int result = name != null ? name.hashcode() : 0; result = 31 * result + age; return result; } } treemap 概述 底层：基于红黑树（red-black tree）的 navigablemap 实现\n特点：\n键值对的映射，一个键对应一个值，键是不重复的，键无序 键可排序\ntreemap 细节问题：\n自定义类做键: 需要在类或者构造方法中使用比较器。\n代码 package com.demo; import java.util.comparator; import java.util.treemap; /** */ public class treemap细节问题 { public static void main(string[] args) { /*treemap\u0026lt;string,student\u0026gt; map = new treemap\u0026lt;\u0026gt;(); map.put(\u0026#34;张三\u0026#34;, new student(\u0026#34;张三\u0026#34;, 19)); map.put(\u0026#34;张三\u0026#34;, new student(\u0026#34;张三1\u0026#34;, 19)); system.out.println(map);*/ treemap\u0026lt;student ,string\u0026gt; map = new treemap\u0026lt;\u0026gt;(new comparator\u0026lt;student\u0026gt;() { @override public int compare(student o1, student o2) { return o1.name.compareto(o2.name); } }); map.put(new student(\u0026#34;zs\u0026#34;, 19), \u0026#34;zs\u0026#34;); map.put(new student(\u0026#34;zs\u0026#34;, 19), \u0026#34;zs1\u0026#34;); system.out.println(map); } } class student { string name; int age; public student(string name, int age) { this.name = name; this.age = age; } public student() { } @override public string tostring() { return \u0026#34;student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } collections 概述 集合工具类\n可变参数 格式：\n数据类型\u0026hellip; 变量的名称\n调用可变参数的方法时，可以传递0-任意个参数，但是定义可变参数对应的方法时，要求可变参数定\n义在最后。\n实质： 数组\n常用方法 1.常用方法：\n① addall(collection\u0026lt;? super t\u0026gt; c, t\u0026hellip; elements) 添加元素到集合\n② fill(list\u0026lt;? super t\u0026gt; list, t obj) 替换\n③ max/min (collection\u0026lt;? extends t\u0026gt; coll, comparator\u0026lt;? super t\u0026gt; comp) 求最大小值\n④ sort(list list, comparator\u0026lt;? super t\u0026gt; c)\n排序默认没有第二个参数表示按元素的自然顺序进行排序，有按第三方比较器\n⑤ shuffle(list\u003c?\u003e list) 随机置换\n代码 package com.demo; import java.util.arraylist; import java.util.collections; import java.util.comparator; /** 1.常用方法： ① addall(collection\u0026lt;? super t\u0026gt; c, t... elements) 添加元素到集合 ② fill(list\u0026lt;? super t\u0026gt; list, t obj) 替换 ③ max/min (collection\u0026lt;? extends t\u0026gt; coll, comparator\u0026lt;? super t\u0026gt; comp) 求最大小值 ④ sort(list\u0026lt;t\u0026gt; list, comparator\u0026lt;? super t\u0026gt; c) 排序默认没有第二个参数表示按元素的自然顺序进行排序，有按第三方比较器 ⑤ shuffle(list\u0026lt;?\u0026gt; list) 随机置换 */ public class 集合工具类 { public static void main(string[] args) { // a a = new a(); // a.add(); arraylist\u0026lt;string\u0026gt; list = new arraylist\u0026lt;\u0026gt;(); // collections.addall(list,\u0026#34;abc\u0026#34;,\u0026#34;bcd\u0026#34;,\u0026#34;def\u0026#34;); /* system.out.println(list);*/ // ② fill(list\u0026lt; ? super t\u0026gt; list, t obj) 替换 /* collections.fill(list,\u0026#34;kkk\u0026#34;); system.out.println(list);*/ // ③ max/min (collection\u0026lt;? extends t\u0026gt; coll, comparator\u0026lt;? super t\u0026gt; comp) 求最大小值，如果没有第二个参数表示按照元素的自然顺序进行排序。 /* string max = collections.max(list, new comparator\u0026lt;string\u0026gt;() { @override public int compare(string o1, string o2) { return o2.compareto(o1); } }); system.out.println(max);*/ // ⑤ shuffle(list\u0026lt;?\u0026gt; list) 随机置换 collections.addall(list,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;); collections.shuffle(list); system.out.println(list); } } class a { //int 3 4 5 public void add(int b,int... a){ for (int i = 0; i \u0026lt; a.length; i++) { system.out.println(a[i]); } } } 集合总结 单列集合 collection:\nlist:有序 可重复 可插入多个null\narraylist：底层： 大小可变的数组的实现。\n特点: 有序 可重复 可插入多个null 查询快\n增删慢 线程不安全\nlinkedlist：底层： 双向链表\n特点：有序 可重复 可插入多个null 查询慢\n增删快 线程不安全\nvector:用法同arraylist 线程安全\nset：无序 不重复 只能插入一个null\nhashset：底层： 哈希表\u0026ndash;》hashmap\n特点：无序 不重复 只能插入一个null 线程不安全\n自定义类对象去重：重写hashcode和equals方法\n存储原理：\n1.8jdk结构改进。\nlinkedhashset：底层： 哈希表+双向链表\n特点：有序 不重复 只能插入一个null 线程不安全\ntreeset：底层： 基于红黑树的treemap\n特点：可排序 无序 不重复 只能插入一个null 线程不安全\n比较器：① 元素的自然顺序比较器： comparable\n​\t② 第三方比较器：comparator\n通用方法\n1.add()\n2.list\u0026ndash;\u0026gt;get(index)\n3.集合的遍历: 五种 ，set ：迭代器 增强for 转数组r\n","date":"2021-10-28","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430212581/","summary":"集合框架 1:集合：（1） Collection(单列集合)List(有序,可重复)ArrayList底层数据结构是数组,查询快,增删慢 线程不安全,效率高Vecto","title":"集合框架"},{"content":"异常 概述 异常： 不正常。程序的运行结果与预想的结果不一致。\n常见异常 ① nullpointerexception 空指针异常\n② arrayindexoutofboundsexception 数组角标越界异常。\n③ classcastexception 类型转换异常\n④ numberformatexception 数字格式化异常\n⑤ arithmeticexception 算术异常/除0异常\n⑥ parseexception 解析异常\n⑦ inputmismatchexception 输入比对错误异常\n异常体系 throwable\n​\t|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; error 合理的应用程序不应该试图捕获的严重问题\n​\t|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-exception 合理的应用程序想要捕获的条件\n​\t|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-编译期异常:(除了runtimeexception) 编译时，如果不处理，程序就不能执行\n​\t|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-运行期异常:(runtimeexception)：在编译期可以不处理，运行期处理。\n异常处理的好处 提高程序的健壮性。\n异常的处理机制 原则：\n谁调用谁处理\n处理过程：\njvm一旦遇到异常，会将异常根据不同的特征封装成异常对象，并且返回给调用者，如果调用者处理\n不了，向上继续返回，直到返回到main方法，如果main中也处理不了。就返回到jvm。jvm会将异常打印在控制台上输出。\n异常的处理方式： 1.异常的声明：俗称 抛出异常：\n[权限修饰符][修饰符][返回值类型] 方法名称(参数列表) throws 异常名称1,异常名称2{}\n2.异常的捕获：\ntry{\n​\t可能会发生异常的代码\n}catch(异常的数据类型 异常的名称){\n​\t处理异常的代码\n}finally{\n​\t无论是否执行try 或catch，最终都会执行。\n}\ntry-catch-finally书写格式 格式一: 多catch try- catch- finally\ntry{\n​\t可能发生异常的代码\n}catch(异常的数据类型 异常的名称){\n​\t处理异常的代码\n}catch(异常的数据类型 异常的名称){\n​\t处理异常的代码\n}finally{\n}\n注意：\n如果catch块中异常有子父类的关系，子类在上 父类在下。\n格式二：多catch try- catch\ntry{\n}catch(){\n}\n格式三： try - finally\ntry{\n}finally{\n}\n注意：\n1》 try块中放置可能会发生异常的代码，该代码执行到发生异常为止，该位置下的try块中的代\n码不再执行。\n2》转而执行catch中的代码，前提是catch中可以捕获到该异常。\n3》 无论执行了try 还是 catch块 最终都会执行 finally。\n4》如果try块中没有发生异常，只执行try后，最终也会执行finally。\n代码 package com.demo; /** 1.格式： try{ }catch(异常的数据类型 异常的名称){ }finally 注意： 1》 try块中放置可能会发生异常的代码，该代码执行到发生异常为止，该位置下的try块中的代 码不再执行。 2》转而执行catch中的代码，前提是catch中可以捕获到该异常。 3》 无论执行了try 还是 catch块 最终都会执行 finally。 4》如果try块中没有发生异常，只执行try后，最终也会执行finally。 2.格式三： try - finally try{ }finally{ } */ public class 异常的捕获执行顺序 { public static void main(string[] args) { /* try{ system.out.println(\u0026#34;这是异常之前的代码。。。1\u0026#34;); int i= 5/1; system.out.println(\u0026#34;这是异常之后的代码。。。。2\u0026#34;); }catch(exception e ){ system.out.println(\u0026#34;这是捕获后处理异常的代码。。。3\u0026#34;); }finally { system.out.println(\u0026#34;这是无论是try或catch执行后，都会执行的代码。。。4\u0026#34;); }*/ // 格式三： try{ system.out.println(\u0026#34;这是try中的代码。。\u0026#34;); int i = 5/0; }finally{ system.out.println(\u0026#34;这是finally中的代码。。。\u0026#34;); } } } return返回值问题 原则上不建议在finally中添加return，一旦添加，由于无论执行try还是catch，都最终会执finally，最终导致finally中的return先执行。\n代码 package com.demo; import java.text.parseexception; import java.text.simpledateformat; /** 1.return 在try catch finally中同时存在时，return返回的问题 注意： 原则上不建议在finally中添加return，一旦添加，由于无论执行try还是catch，都最终会执行finally，最终导致finally中的return先执行。 */ public class return返回值问题 { public static void main(string[] args) /*throws parseexception*/ { system.out.println(fun()); simpledateformat sf = new simpledateformat(); try{ sf.parse(\u0026#34;111\u0026#34;); }catch (parseexception e){ } } public static int fun() { try{ int i = 5/0; return 1; }catch (exception e){ return 2; }finally { return 3; } } } 异常对象的创建 1.异常对象的创建:\n① 异常的发生可以阻止程序继续执行。\n② 模拟jvm抛出异常对象：\n格式：\nthrow new 异常对象(异常信息)\n代码 package com.demo; import java.util.scanner; /** 1.异常对象的创建: ① 异常的发生可以阻止程序继续执行。 ② 模拟jvm抛出异常对象： 格式： throw new 异常对象(异常信息) */ public class 异常对象的创建 { public static void main(string[] args) { /* a a = new a(); a.fun(); system.out.println(\u0026#34;======================2\u0026#34;);*/ bankaccount ba = new bankaccount(); ba.withdraw(); } } class a{ public void fun(){ int i = 5; i /= 0; system.out.println(\u0026#34;================1\u0026#34;); } } class bankaccount{ double balance = 1000; public void withdraw(){ scanner sc = new scanner(system.in); system.out.println(\u0026#34;请输入取款金额:\u0026#34;); double money = sc.nextdouble(); if (balance-money \u0026gt;=0){ balance -= money; }else{ // system.out.println(\u0026#34;余额不足。。。\u0026#34;+5/0); // throw 模拟jvm创建并抛出异常对象给调用者 throw new runtimeexception(\u0026#34;余额不足\u0026#34;); }system.out.println(balance +\u0026#34;=========================\u0026#34;); } } 自定义异常 继承exception 或runtimeexception\n常用异常方法 异常的常用方法：\n① getmessage() 获取异常的详细消息字符串\n② printstacktrace() 打印堆栈信息\n代码 package demo1; import java.util.scanner; /** 1.异常对象的创建: ① 异常的发生可以阻止程序继续执行。 ② 模拟jvm抛出异常对象： 格式： throw new 异常对象(异常信息) 2.异常的处理方式： ① 异常的声明:throws ② 异常的捕获 : try-catch-finally 3.异常的常用方法： ① getmessage() 获取异常的详细消息字符串 ② printstacktrace() 打印堆栈信息 */ public class 异常对象的创建 { public static void main(string[] args) { /* a a = new a(); a.fun(); system.out.println(\u0026#34;======================2\u0026#34;);*/ bankaccount ba = new bankaccount(); //异常的捕获 while (true) { try { ba.withdraw(); break; } catch (withdrawexception e) { // system.out.println(e.getmessage()); e.printstacktrace(); } } } } class a{ public void fun(){ int i = 5; i /= 0; system.out.println(\u0026#34;================1\u0026#34;); } } class bankaccount{ double balance = 1000; public void withdraw() throws withdrawexception{//异常的声明 scanner sc = new scanner(system.in); system.out.println(\u0026#34;请输入取款金额:\u0026#34;); double money = sc.nextdouble(); if (balance-money \u0026gt;=0){ balance -= money; }else{ // system.out.println(\u0026#34;余额不足。。。\u0026#34;+5/0); // throw 模拟jvm创建并抛出异常对象给调用者 // throw new runtimeexception(\u0026#34;余额不足\u0026#34;); throw new withdrawexception(\u0026#34;余额不足\u0026#34;); } system.out.println(balance +\u0026#34;=========================\u0026#34;); } } //继承exception 或runtimeexception class withdrawexception extends exception{ public withdrawexception(string msg){ super(msg); } } 异常的总结 1.try-catch-finally throw throws\n异常的处理机制： 谁调用谁处理\n异常的处理方式：\n① 异常的声明 throws\n② 异常的捕获 try-catch-finally 三种 try-catch try-catch-finally try -finally\n2.throw 与throws的区别？\n① throw 表示模拟jvm抛出异常对象。在方法中 创建异常对象时，使用的。\n② throws 表示异常的处理方式，在方法参数的后面 ，表明该方法可能会发生哪种异常。\n3.return 体系 方法\n","date":"2021-10-26","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430214030/","summary":"异常 概述 异常： 不正常。程序的运行结果与预想的结果不一致。 常见异常 ① NullPointerException 空指针异常 ② ArrayIndexOutOfBoundsException 数组角标越界异常。 ③ ClassCastException 类型转换异常 ④ NumberFormatException 数字格式化异常 ⑤ ArithmeticException 算术异常/除0异常 ⑥ ParseException","title":"异常处理"},{"content":"equals方法 object类 1.默认object类的equals方法，效果与 == 效果是相同的，必须是同一个对象 返回值为true，用来判断对象与参数对象是否相等。\n2.当equals方法重写时，一般都伴随hashcode方法的重写，达到相对的对象有相等的哈希码值的需求。\n代码 package com.demo; import java.util.objects; public class equals方法的使用 { public static void main(string[] args) { student s = new student(\u0026#34;张三\u0026#34; , 18); student s1 = new student(\u0026#34;张三1\u0026#34; , 18); // system.out.println(s.equals(s1)); // system.out.println(s.equals(null)); // system.out.println(s.equals(s)); a a = new a(); system.out.println(s.equals(a)); } } class a{} class student{ string name; int age; /*@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; student student = (student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @override public int hashcode() { int result = name != null ? name.hashcode() : 0; result = 31 * result + age; return result; } */ @override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; student student = (student) o; return age == student.age \u0026amp;\u0026amp; objects.equals(name, student.name); } @override public int hashcode() { return objects.hash(name, age); } /** ① 判断参数对象是否为null ② 判断参数对象与对象 是否为同一个 ③ 判断参数对象与对象的数据类型是否相同 ④ 判断需求的属性是否相同 */ /* @override public boolean equals(object st){ //判断是否为null if(st == null){ return false; } //判断对象与参数对象是否为同一个对象 if(this == st){ return true; } //判断是否是同一个数据类型 getclass() ? if( !(st instanceof student)){ return false; } //向下转型 student obj = (student) st; //判断对象与参数的属性值完全相同 认为同一个对象 //由于字符串是对象，需要通过equals方法来进行判断 return this.name.equals(obj.name) \u0026amp;\u0026amp; this.age == obj.age; }*/ @override public string tostring() { return \u0026#34;student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } public student() { } public student(string name, int age) { this.name = name; this.age = age; } } string 概述 string类是一个值不可改变的常量。可以共享的。字面值\u0026quot;abc\u0026quot;的都是该类的对象。\n底层： 字符数组。\n例如：\n​\tstring s = \u0026quot;abc\u0026quot; 总结：理解\n​\t对于没有new的，相当于在方法区的字符串常量池中创建对象，并且只创建一份。共享。\n​\t对于有new操作的，相当于在堆中创建一个新的对象，该对象中包含的字符序列从字符串常量池中来。 代码\npackage com.demo; /** 1.(***)equals与==的区别: ① == 用来判断数值是否相同，对于基本数据类型来说，判断的是数值，对于引用数据类型，判断的 是对象的地址值是否相同。 equals方法只能判断对象是否相同，不能判断基本数据类型。 ② 如果想根据需求进行判断，只能通过重写equals方法来实现。 ③ 对于object类的equals方法在没有重写的情况下，效果与== 相同。 */ public class equals方法与等等号的区别与联系 { public static void main(string[] args) { string s = \u0026#34;abc\u0026#34;; string s1 = new string(\u0026#34;abc\u0026#34;); string s2 = new string (\u0026#34;abc\u0026#34;); string s4 = \u0026#34;abc\u0026#34;; system.out.println(s == s4); //true system.out.println(s1 == s2);//false system.out.println(s.equals(s4)); //true system.out.println(s1.equals(s2));//true } } 字符串对象创建的细节问题 对于字符串的拼接形式，如果都是字符串常量，在编译时，直接计算，这种现象称为字符串的编译器优化。\n代码 package com.demo; /** 1.字符串对象创建的细节问题: 对于字符串的拼接形式，如果都是字符串常量，在编译时，直接计算，这种现象称为字符串的编译器优化。 */ public class 字符串对象创建的细节问题 { public static void main(string[] args) { t.fun(); } } class t{ public static void fun(){ string s = \u0026#34;abc\u0026#34;; //对于字符串的拼接形式，如果都是字符串常量，在编译时，直接计算，这种现象称为字符串的编译器优化。 string s1 = \u0026#34;a\u0026#34;+\u0026#34;b\u0026#34;+\u0026#34;c\u0026#34;; string s2 = \u0026#34;ab\u0026#34;; string s3 = s2 + \u0026#34;c\u0026#34;; system.out.println(s == s1);//true system.out.println( s == s3);//false } } 字符串常用方法一 1.charat(int index) 返回索引位置的字符\n2.compareto(string anotherstring) 按字典顺序比较两个字符串。\n​\t存在字符序列不同： 对象的unicode码- 参数的unicode码\n​\t① \u0026gt;0 对象在参数之后\n​\t② \u0026lt;0 对象在参数之前\n​\t③ =0 对象与参数相等\n​\t字符序列相同，长度不同:对象的长度-参数的长度\n3.contains(charsequence s) 判断包含\n4.endswith(string suffix)/startswith(string prefix) 后缀/前缀\n5.equals(object anobject) 对象与参数字符序列相同，返回true 判断对象与参数字符串是否相等。\n​\t1》 equalsignorecase(string anotherstring) 忽略大小写。\n6.getbytes(charset) 将字符串转换成字节数组。\n代码 package com.demo; import java.io.unsupportedencodingexception; import java.util.arrays; public class 字符串常用方法 { public static void main(string[] args) throws unsupportedencodingexception { // 1.charat(int index) 返回索引位置的字符 // system.out.println(\u0026#34;abcdef\u0026#34;.charat(3)); // 2.compareto(string anotherstring) 按字典顺序比较两个字符串。 // system.out.println(\u0026#34;abc\u0026#34;.compareto(\u0026#34;ab\u0026#34;)); // system.out.println(\u0026#34;a\u0026#34;.compareto(\u0026#34;a\u0026#34;)); // system.out.println(\u0026#34;a\u0026#34;.comparetoignorecase(\u0026#34;a\u0026#34;)); //concat(string str) 拼接 // system.out.println(\u0026#34;abc\u0026#34;.concat(\u0026#34;hello\u0026#34;)); // 3.contains(charsequence s) 判断包含 // system.out.println(\u0026#34;abc\u0026#34;.contains(\u0026#34;ab\u0026#34;)); // 4.endswith(string suffix)/startswith(string prefix) 后缀/前缀 // system.out.println(\u0026#34;abc.txt\u0026#34;.endswith(\u0026#34;txt\u0026#34;)); //查找姓张的学生 string[] names = {\u0026#34;张三\u0026#34;,\u0026#34;李思\u0026#34;,\u0026#34;王张五\u0026#34;,\u0026#34;马六\u0026#34;,\u0026#34;张龙\u0026#34;,\u0026#34;李元芳\u0026#34;}; /*for (int i = 0; i \u0026lt; names.length; i++) { if (names[i].startswith(\u0026#34;张\u0026#34;)){ system.out.println(names[i]); } }*/ // equalsignorecase(string anotherstring) /* system.out.println(\u0026#34;abc\u0026#34;.equals(\u0026#34;abc\u0026#34;)); system.out.println(\u0026#34;abc\u0026#34;.equalsignorecase(\u0026#34;abc\u0026#34;));*/ // 6.getbytes() 将字符串转换成字节数组。 string s5 = \u0026#34;今天天气真好\u0026#34;; //强制类型转换无法实现字符串转字节数组 //中文gbk 两个字节一个中文 byte[] bt = s5.getbytes(\u0026#34;gbk\u0026#34;); //utf-8 三个字节表示一个中文 byte[] bt1 = s5.getbytes(\u0026#34;utf-8\u0026#34;); system.out.println(arrays.tostring(bt)); system.out.println(arrays.tostring(bt1)); } } 字符串常用方法二 1.isempty() 判断是否为空串\n2.length() 字符串的长度\n注意：\n​\t数组中的length是属性，不带()\n​\t字符串的length是方法，带().\n3.replace(charsequence target, charsequence replacement) 替换所有\n4.split(string regex) 根据参数拆分字符串为字符串数组\n注意：\n​\t如果使用转义\\ ，两个表示一个\\ ，如果做拆分，4个表示两个。\n代码 package com.demo; public class string类常用方法一 { public static void main(string[] args) { // 1.isempty() 判断是否为空串 // system.out.println(\u0026#34;ab\u0026#34;.isempty()); // lastindexof(string str) 用法同indexof 返回参数字符串在字符串对象中最后一次 出现的索引值 // system.out.println(\u0026#34;01234567823\u0026#34;.lastindexof(\u0026#34;23\u0026#34;)); // 2.length() 字符串的长度 int[] arr = {1,2,3,4,5}; // arr.length // system.out.println(\u0026#34;abc\u0026#34;.length()); // 3.replace(charsequence target, charsequence replacement) 替换 // system.out.println(\u0026#34;01234523\u0026#34;.replace(\u0026#34;23\u0026#34;, \u0026#34;我\u0026#34;)); //敏感词过滤 // system.out.println(\u0026#34;xxsadfaxxlsdljslfs\u0026#34;.replace(\u0026#34;x\u0026#34;, \u0026#34;**\u0026#34;)); // 4.split(string regex) 根据参数拆分字符串为字符串数组 // string s1 = \u0026#34;a-b-c\u0026#34;; // string[] arr1 = s1.split(\u0026#34;-\u0026#34;); /* string s2 =\u0026#34;a b c\u0026#34;; string[] arr1 = s2.split(\u0026#34; \u0026#34;);*/ string s3 = \u0026#34;a\\\\b\\\\c\u0026#34;; // 如果使用转义\\ ，两个表示一个\\ ，如果做拆分，4个表示两个。 string[] arr1 = s3.split(\u0026#34;\\\\\\\\\u0026#34;); for (int i = 0; i \u0026lt; arr1.length; i++) { system.out.println(arr1[i]); } } } 字符串常用方法三 1.substring(int beginindex, int endindex) 截子串\n注意：\n如果只有一个参数，表示从该位置截取到末尾，如果还有第二个参数，表示从第一个参数\n开始截取，到第二个索引位置-1处结束。\n2.tochararray() 字符串转字符数组\n\\3. valueof(object obj) 返回对象的字符串表示形式\n代码 package com.demo; public class string类常用方法二 { public static void main(string[] args) { // substring(int beginindex, int endindex) // system.out.println(\u0026#34;0123456\u0026#34;.substring(1,4)); // 2.tochararray() 字符串转字符数组 /*string s = \u0026#34;abcdef\u0026#34;; char[] cs = s.tochararray(); for (int i = 0; i \u0026lt; cs.length; i++) { system.out.println(cs[i]); }*/ // tolowercase()/touppercase() 转小/大写 /*system.out.println(\u0026#34;abbcd\u0026#34;.tolowercase()); system.out.println(\u0026#34;abbcd\u0026#34;.touppercase());*/ //tostring() 转换成字符串 string s2 = new string(\u0026#34;abc\u0026#34;); // system.out.println(s2.tostring()); //trim() 返回字符串的副本，忽略前导空白和尾部空白。 string s3 = \u0026#34; a bc \u0026#34;; /* system.out.println(\u0026#34;============\u0026#34;+s3+\u0026#34;=============\u0026#34;); system.out.println(\u0026#34;============\u0026#34;+s3.trim()+\u0026#34;=============\u0026#34;);*/ // 3. valueof(object obj) 返回对象的字符串表示形式 system.out.println(string.valueof(\u0026#34;abc\u0026#34;)); } } stringbuffer 与stringbuilder stringbuffer 概括 线程安全的可变字符序列，类似于字符串的一个字符串缓冲区。\n缓冲区：\n​\t① 有富余容量\n​\t② 作为临时存储区\n构造方法\n​\t1.stringbuffer构造方法：\n​\t① stringbuffer() 不带字符的字符串缓冲区，初始容量为16\n​\t② stringbuffer(int capacity) 指名初始容量\n​\t③ stringbuffer(string str) 初始容量为16+字符串长度\n常用方法一 1.常用方法：\n① capacity() 容量\n②length()返回长度（字符数）。\n③ append(object obj) 追到到末尾\n④ delete(int start, int end)/deletecharat(int index) 删除\n注意：\n[start,end) 取不到end的值为end-1\n对于字符串 ，一般都是副本，是新的字符串对象，而对于字符串缓冲区来说，基本都是同一个。\n代码 package com.demo; public class stringbuffer类 { public static void main(string[] args) { stringbuffer sb = new stringbuffer(); // system.out.println(sb.capacity()); // system.out.println(sb.length()); //链式调用 sb.append(\u0026#34;abc\u0026#34;).append(true).append(13).append(12.3).append(1231); //system.out.println(\u0026#34;=========================\u0026#34;); // system.out.println(sb.capacity()); // system.out.println(sb.length()); // system.out.println(\u0026#34;====================\u0026#34;); stringbuffer sb1 = new stringbuffer(\u0026#34;abc\u0026#34;); // system.out.println(sb1.capacity()); // ④ delete(int start, int end)/deletecharat(int index) 删除 stringbuffer sb2 = new stringbuffer(\u0026#34;0123456789\u0026#34;); // system.out.println(sb2.delete(1, 4)); // system.out.println(sb2.deletecharat(3)); // stringbuffer sb3 = sb2.append(\u0026#34;345\u0026#34;); string ss = new string(sb2); string ss1 = ss.concat(\u0026#34;abc\u0026#34;); system.out.println(ss == ss1); } } 常用方法二 1.insert(int offset, object obj) 插入\n2.reverse() 反转\n​\t判断对称字符串：\n​\tabcba ==\u0026gt; abcba 3.tostring() 转字符串\n4.crud :增删改查\n代码 package com.demo; public class stringbuffer类常用方法 { public static void main(string[] args) { string s = \u0026#34;0123456789\u0026#34;; stringbuffer sb1 = new stringbuffer(s); // 1.insert(int offset, object obj) 插入 // sb1.insert(2, \u0026#34;我\u0026#34;); // replace(int start, int end, string str) 替换 半开半闭区间 [start,end) // system.out.println(sb1.replace(1, 4, \u0026#34;我们\u0026#34;)); // 2.reverse() 反转 // sb1.reverse(); // setcharat(int index, char ch) // sb1.setcharat(1, \u0026#39;我\u0026#39;); // system.out.println( sb1); // string与stringbuffer不是同一个类的对象 system.out.println( s.equals(sb1.tostring())); } } string与stringbuffer的区别 区别 1.stringbuffer在操作字符串本身时，速度比string要快，建议操作字符串本身时，用stringbuffer。\n2.equals方法，stringbuffer本身没有重写equals方法，使用的继承的object类的equals方法，而string重写了，只要字符序列相同，就是true。\n代码 package com.demo; public class string与stringbuffer之间的区别 { public static void main(string[] args) { string s = \u0026#34;\u0026#34;; stringbuffer sb = new stringbuffer(); long start = system.currenttimemillis(); for (int i = 0; i \u0026lt; 1000; i++) { // s += i; sb.append(i); } long end = system.currenttimemillis(); system.out.println(end - start); } } stringbuilder 区别\nstringbuilder线程不安全的，但是执行速度比stringbuffer快。\nsystem 概括 系统类：\n有标准输入、标准输出和错误输出流。\n标准输入in\n标准输出out\n错误输出流 err\n常用方法 ① currenttimemillis() 返回当前时间的毫秒值\n② exit(0) 退出jvm ，非0表示异常退出。\n③ gc() 用于垃圾回收的方法。\n代码 package com.demo; import java.util.*; /**1.属性 (***)标准输入 in 标准输出 out 错误输出流 err 2.常用方法 ① currenttimemillis() 返回当前时间的毫秒值 ② exit(0) 退出jvm ，非0表示异常退出。 ③ gc() 用于垃圾回收的方法。 */ public class system类 { public static void main(string[] args) { /* system.out.println(\u0026#34;=================1\u0026#34;); system.out.println(\u0026#34;=================2\u0026#34;); system.err.println(\u0026#34;=================3\u0026#34;); system.out.println(\u0026#34;=================4\u0026#34;); system.out.println(\u0026#34;=================5\u0026#34;); system.out.println(\u0026#34;=================6\u0026#34;);*/ // arraycopy(object src, int srcpos, // object dest, int destpos, int length) 快速数组复制。 /* src - 源数组。 srcpos - 源数组中的起始位置。 dest - 目标数组。 destpos - 目标数据中的起始位置。 length - 要复制的数组元素的数量。 */ /* int[] arr = {0,1,2,3,4,5,6,7}; int[] brr = new int[arr.length]; system.arraycopy(arr, 1, brr, 3, 5); system.out.println(arrays.tostring(brr));*/ // ① currenttimemillis() 返回当前时间的毫秒值 // 从计算机历元 即1970年1月1日0时0分0秒开始计算 // system.out.println(system.currenttimemillis()); // ② exit(0) 退出jvm ，非0表示异常退出。 /*for (int i = 0; i \u0026lt; 5; i++) { if (i==3){ system.exit(0); } system.out.println(i); } system.out.println(\u0026#34;==================\u0026#34;);*/ // ③ gc() 用于垃圾回收的方法。 /* person p = new person(); p = null; system.gc();*/ // getproperties() 系统属性 properties prp = system.getproperties(); set\u0026lt;map.entry\u0026lt;object, object\u0026gt;\u0026gt; set = prp.entryset(); iterator\u0026lt;map.entry\u0026lt;object, object\u0026gt;\u0026gt; it = set.iterator(); while (it.hasnext()){ map.entry\u0026lt;object, object\u0026gt; entry = it.next(); system.out.println(entry.getkey() + \u0026#34;===\u0026gt;\u0026#34;+ entry.getvalue()); } } } class person{ @override protected void finalize() throws throwable { system.out.println(\u0026#34;对象被垃圾回收了。。。。。\u0026#34;); } } math类 概括 math 类包含用于执行基本数学运算的方法\n常用方法 ① double ceil(double a) 向上取整 返回值为double\n② double floor(double a) 向下取整 返回值为double\n③ long round(double a) 四舍五入 返回值long类型\n④ pow(double a, double b) 返回第一个参数的第二个参数次幂\n⑤ random() 返回值 [0.0,1.0) 随机数\n代码 package com.demo; public class math类 { public static void main(string[] args) { //圆周率 math.pi // system.out.println(math.pi); //区别 /*system.out.println(math.ceil(12.3)); system.out.println(math.floor(12.3)); system.out.println(math.round(12.3)); system.out.println(\u0026#34;============\u0026#34;); system.out.println(math.ceil(12.5)); system.out.println(math.floor(12.5)); system.out.println(math.round(12.5));*/ // ④ pow(double a, double b) 返回第一个参数的第二个参数次幂 // system.out.println(math.pow(2 , 10)); // ⑤ random() 返回值 [0.0,1.0) 随机数 // system.out.println( math.round(math.random()*100)); } } 包装类 概括 包装类：\n1.引入：对基本数据类型进行功能的增强。\n2.包装类中存放了一个基本数据类型。\n基本数据类型 包装类\n​\tbyte byte ​\tshort short ​\tint ------》 integer ​\tlong long\n​\tfloat float ​\tdouble double ​\tchar --------》 character ​\tboolean boolean 3.以integer类为例：\n​\t① 构造方法：\n​\tinteger(int/string) 字符串转integer类型\n​\t② 常用方法：\n​\t1》 xxxvalue() xxx表示基本数据类型。类型转换 。xxx表示什么返回值就是什么。\n​\t2》 parseint(string s) 取整\n​\t3》 valueof(string s) 字符串转换成integer\n4.装箱 与 拆箱：\n​\t① 装箱 ： 基本数据类型转变成包装类。\n​\t② 拆箱： 包装类转变成基本数据类型。\n1.5jdk之后，自动拆箱与装箱，基本数据类型与包装类之间不用调用方法 可以直接转换。\n代码 package com.demo; public class 包装类 { public static void main(string[] args) { // 求int类型的最大值 /小 /*system.out.println(integer.max_value); system.out.println(integer.min_value);*/ // integer(int/string) /*integer t = new integer(\u0026#34;abc\u0026#34;); system.out.println(t );*/ integer i1 = new integer(12); // 自动拆箱与装箱 1.5jdk // int i = i1.intvalue(); int i = i1; double m = i1; //拆箱 integer i2 = 13;//装箱 //tobinarystring(int i) 二进制 tohexstring(int i) 十六进制 tooctalstring(int i) 八进制 // system.out.println(integer.tobinarystring(3)); // system.out.println(integer.tohexstring(\u0026#34;abc\u0026#34;.hashcode())); } } character类 常用方法：\n①isdigit(char ch)判断是否为数字\n② isletter(char ch) 判断是否为字母\n注意：\n中文也认为是字母\n③ isletterordigit(int codepoint) 判断是否为字母或数字。\n代码 package com.demo; public class character类 { public static void main(string[] args) // system.out.println(character.isdigit(\u0026#39;1\u0026#39;)); // system.out.println(character.isletter(\u0026#39;总\u0026#39;)); } } biginteger类 1.不可变的任意精度的整数\n2.构造方法：\nbiginteger(string val) 3.常用方法：\n​\t1》 加 add(biginteger val) ​\t2》 减 subtract(biginteger val) ​\t3》 乘 multiply(biginteger val)\n​\t4》 除 divide(biginteger val) 代码 package com.demo; import java.math.biginteger; public class biginteger类 { public static void main(string[] args) { // long l = 11111111111111111111l; //创建对象 biginteger big = new biginteger(\u0026#34;11111111111111111111\u0026#34;); biginteger big1 = new biginteger(\u0026#34;11\u0026#34;); system.out.println(big.add(big1)); system.out.println(big.subtract(big1)); system.out.println(big.multiply(big1)); system.out.println(big.divide(big1)); } } bigdecimal类 概念 不可变的、任意精度的有符号十进制数\n常用方法 1.不可变的、任意精度的有符号十进制数\n2.构造方法：\n​\t① bigdecimal(string val)\n3.常用方法：\n​\t① 加 add(bigdecimal augend)\n​\t② 减 subtract(bigdecimal subtrahend)\n​\t③ 乘 multiply(bigdecimal multiplicand)\n​\t④ 除 divide(bigdecimal divisor, int scale, int roundingmode)\n注意：\n​\t第二个参数表示小数点保留位数\n​\t第三个参数表示舍入模式 ：\n​\tround_half_up\t四舍五入\n代码 package com.demo; import java.math.bigdecimal; public class bigdecimal类 { public static void main(string[] args) { bigdecimal big = new bigdecimal(12.3); bigdecimal big1 = new bigdecimal(12.3f); bigdecimal big2 = new bigdecimal(\u0026#34;0.35\u0026#34;); bigdecimal big3 = new bigdecimal(\u0026#34;1\u0026#34;); /* system.out.println(big); system.out.println(big1); system.out.println(big2);*/ //运算/*system.out.println(big2.add(big3)); system.out.println(big2.subtract(big3)); system.out.println(big2.multiply(big3));*/ system.out.println(big2.divide(big3,1,bigdecimal.round_half_up)); } } 时间类 date java.util 表示特定的瞬间，精确到毫秒\n1.构造方法：\n​\t① date()\n​\t1\u0026gt; cst : 美国中部标准时间: 美国、澳大利亚、古巴或中国的标准时间。\n​\t② date(long date) 根据参数的毫秒值换算时间 从历元1970年1月1日0时0分0秒开始算。\n2.常用方法：\n① gettime() 返回对象到历元的毫秒值\n代码 package com.demo; import java.util.date; public class date类 { public static void main(string[] args) { date date = new date(); // system.out.println(date.togmtstring()); date date1 = new date(1000); // system.out.println(date1.tolocalestring()); // system.out.println(date.gettime()); // system.out.println(date1.gettime()); // system.out.println(system.currenttimemillis()); } } calendar类 1.calendar:日历类:抽象类\n2.创建对象：\n​\tgetinstance() 3.常用方法：\n​\t①get(int field)获取字段对应的值\n​\t② add(int field, int amount) 设置日历的方法，添加或减少\n注意：\n​\t通过 正数 、 负数来表示加或减\n③set(int field, int value)设置\n代码 package com.demo; import java.util.calendar; public class calendar类 { public static void main(string[] args) { //创建对象 calendar cd = calendar.getinstance(); /*system.out.println(cd.get(calendar.year)); //西方第一个月份为0 ，值需要加1 system.out.println(cd.get(calendar.month)+1); system.out.println(cd.get(calendar.date)); system.out.println(cd.get(calendar.hour_of_day)); system.out.println(cd.get(calendar.minute)); system.out.println(cd.get(calendar.second)); //西方从周日开始 值要减 1 system.out.println(cd.get(calendar.day_of_week)-1);*/ //设置日历的方法 cd.add(calendar.month, 13); system.out.println(cd.get(calendar.month)); } } simpledateformat 时间日期格式化类 1.格式化 ： 日期 \u0026ndash;》 字符串\n2.解析 : 字符串 \u0026ndash;》 日期\n3.dateformat :抽象类:\n子类：simpledateformat 4.常用方法：\n① 格式化 ：format(date date) ② 解析: parse(string source) 5.构造方法：\n① simpledateformat() 使用默认模式进行格式化或解析\n② simpledateformat(string pattern) 使用指定模式\n常见模式：\ny 年\nm 月\nd 日期\nh 0-23\nm 分钟\ns 秒\ne 星期\n代码 package com.demo; import java.text.parseexception; import java.text.simpledateformat; import java.util.date; public class 日期格式化类 { public static void main(string[] args) throws parseexception { simpledateformat sf = new simpledateformat(\u0026#34;yyyy年mm月dd hh:mm:ss e\u0026#34;); /* date date = new date(); string value = sf.format(date); system.out.println(value);*/ //2021年11月02 17:17:56 星期二 date date1 = sf.parse(\u0026#34;2021年11月02 17:17:56 星期二\u0026#34;); system.out.println(date1); } } 数字格式化类 概述 numberformat 数字格式化类 该类是一个抽象类\n1.构造方法：\n① getinstance() 返回当前默认语言环境的通用数值格式\n② getcurrencyinstance() 返回当前默认语言环境的货币格式\n③getpercentinstance()返回当前默认语言环境的百分比格式\n2.常用方法：\n① format(double number) 格式化\n② setmaximumfractiondigits(int newvalue) 小数部分允许最大位数\n③ setminimumfractiondigits(int newvalue) 小数部分允许的最少位数。\n④ setmaximumintegerdigits(int newvalue) 设置整数的最大位数\n代码 package com.demo; import java.text.numberformat; public class 数字格式化类 { public static void main(string[] args) { numberformat nf = numberformat.getinstance(); // numberformat nf = numberformat.getcurrencyinstance(); // numberformat nf = numberformat.getpercentinstance(); // nf.setmaximumfractiondigits(5); // nf.setminimumfractiondigits(3); // nf.setmaximumintegerdigits(3); system.out.println(nf.format(12345678.6)); } } decimalformat类 1.decimalformat:用于格式化十进制数字\n2.构造方法：\n​\tdecimalformat(string pattern) 注意：\n# 小数位数不够不补0\n0 小数位数不够 补0。\n代码 package com.demo; import java.text.decimalformat; public class decimalformat类 { public static void main(string[] args) { // decimalformat df = new decimalformat(\u0026#34;##,##.##\u0026#34;); decimalformat df = new decimalformat(\u0026#34;00,00.00\u0026#34;); system.out.println(df.format(12345678.1)); } } ","date":"2021-10-25","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430212354/","summary":"equals方法 Object类 1.默认Object类的equals方法，效果与 == 效果是相同的，必须是同一个对象 返回值为true，用来判断对象与参数对象是否相等。","title":"常用类"},{"content":"面向对象 导包的细节问题 1.对于内部类，如果想要直接使用内部类，必须通过导包，导入内部类的完全限定名。\n2.对于java.lang包下的所有的类，不需要导包，默认编译器会去查找。\n常用类 文本扫描器 scanner 概述：\n​\t面向对象：\n​\t找\u0026quot;对象\u0026quot;来解决问题。\n文本扫描器：\n​\tjava提供的类： scanner\n位置：\n​\tjava.util.scanner ：类的完全限定名\n功能：\n​\t解析基本类型和字符串的简单文本扫描器\n对象的创建\n1.关键字：new\n​\tnew scanner(system.in)\n2.导包：指明使用的类在哪个路径下。\n​\t1》 关键字：import 类的路径 ;\n3.常用方法：\n1》nextint()\n​\t将获取的内容转换成int类型。\n注意：\n对于nextxxx的这种形式，基本数据类型中除了char类，其余都有。\n如果需要使用字符，用字符串代替。\n2》 next()\n​\t将获取的内容转换成string类型。\n代码：\n//导包： 指明使用的类在哪个路径下。 import java.util.scanner ; class 文本扫描器 { public static void main(string[] args) { //对象的创建 scanner sc = new scanner(system.in); //对象调用方法： 格式： 对象名称.方法名称() system.out.println(\u0026#34;请输入您要录入的内容:\u0026#34;); int value = sc.nextint(); system.out.println(value ); system.out.println(\u0026#34;请输入您的字符串内容\u0026#34;); string v1 = sc.next();//string system.out.println(v1); } } 随机数random random 随机数类。\n1.创建对象：\nrandom rd = new random();\n2.导包\nimport java.util.random;\n3.方法：\nnextint(n)\n可以随机[0,n) 包括0 不包括n的随机数\n代码 /** 随机数类。 1.创建对象： random rd = new random() 2.导包 import java.util.random; 3.方法： nextint(n) 可以随机[0,n) 包括0 不包括n的随机数 */ import java.util.random; class 随机数 { public static void main(string[] args) { //创建对象 random rd = new random(); //调用方法 随机 0-100之间的整数 for (int i = 1; i\u0026lt;=10 ;i++ ) { int value = rd.nextint(101); system.out.println(value); } } } 1.对于内部类，如果想要直接使用内部类，必须通过导包，导入内部类的完全限定名。\n2.对于java.lang包下的所有的类，不需要导包，默认编译器会去查找。\n匿名内部类 概述 没有名字的类，实质是子类对象\n格式：\nnew 类名(){\n}\n代码 package com.demo; /** 1.匿名内部类 */ public class 匿名内部类 { public static void main(string[] args) { /* class zit implements t{ @override public void fun() { } }*/ //简化 t t = new t(){ @override public void fun() { system.out.println(1111111); } }; t t1 = new t(){ @override public void fun() { system.out.println(2222); } }; t.fun(); t1.fun(); //多态向上转型 父类引用不能调用子类特有方法。 /* t t2 = new t(){ @override public void fun() { system.out.println(2222); } public void fun1(){ } }; t2.fun1();*/ new t(){ @override public void fun() { system.out.println(2222); } public void fun1(){ } }.fun1(); } } interface t{ public void fun(); } 工具类 概念 工具类： 帮助其它类进行便捷操作的类。\n常见位置：\nutil/ utils\n常见后缀: 以s结尾。\n常用静态方法。\n数组为例，自定义一个数组工具类 1.字符串拼接\n2.求最大值\napi 概念 api（application programming interface，应用程序接口）\n用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码，或理解内部\n工作机制的细节。\n俗称 ：说明书\napi的使用 api文档的生成 利用文档注释对java文件进行注释 常见文档注释 在类或方法上，选择文档注释，将来提取出来做说明使用。\n1.常见文档注释\n@author 作者\n@version 版本号\n@since 从哪个版本开始\n@param 参数名称 参数的作用 参数的声明\n@return 返回值的作用 返回值的声明\n2.通过javadoc提取出文档注释。\n3.在窗体中设置编码： -encoding utf-8 -charset utf-8\njava提供的数组工具类 arrays 常见方法：\n① binarysearch(int[] a, int key) 二分法进行查找:折半\n注意： 数组必须是有序的。\n② sort(int[] a) 升序排序\n③ tostring(int[] a) 数组的字符串表现形式\n代码 package com.demo; import java.util.arrays; public class arrays数组工具类 { public static void main(string[] args) { /* int[] arr = {1,2,3,4,5,6,7,8,9}; int key = 8; system.out.println(arrays.binarysearch(arr, key));*/ // ② sort(int[] a) 升序排序 int[] arr1 = {-1,20,15,-30,18,27}; system.out.println(arrays.tostring(arr1)); arrays.sort(arr1); system.out.println(arrays.tostring(arr1)); } } 打jar包 jar包的导入 可以直接放在模块下 将需要导入的jar包复制到该目录下。 在模块中导入 成功效果 删除导入的jar包 单个class文件打jar包 object object：类层次结构的根类，所有的类都是该类的子类，包括数组。\n细节 1.对象的创建 ： 构造方法\n​\tobject()\n2.equals方法：\n​\t注意：\n​\t① 对于object类的equals方法，与 == 等价的。\n​\t② 当且仅当object类对象调用equals方法时，如果参数与对象是同一个，返回值为true。\n3.getclass() 返回运行时类\n4.hashcode() 返回对象的哈希码值：\n注意：\n​\t返回的是根据对象的内存地址值通过哈希算法换算出来的整数.\n​\t对于不同的对象来说，该值不一样。\n5.tostring() 返回对象的字符串表示形式。\n注意：\n(***)\n1\u0026gt;类的安全限定名 @ 十六进制的哈希码值\n2\u0026gt; 在使用system.out.println()，对象会默认调用tostring方法，就算没有显式调用\n也有。\n3\u0026gt; 对于子类来说，一般会重写tostring方法，达到需求。\n代码 package com.demo; public class object类 { public static void main(string[] args) { object o = new object(); object o1 = o; // system.out.println(o.equals(o1)); // system.out.println(o.getclass()); person p = new person(); // system.out.println(p.getclass()); // system.out.println(o.hashcode()); // system.out.println(o); //不写也会调用tostring. // system.out.println(o.tostring()); // system.out.println(p.hashcode()); int[] arr = {1,2,3,45}; // system.out.println(arr.tostring()); // system.out.println(o); person p1 = new person(\u0026#34;张三\u0026#34;, 18); system.out.println(p1); person p2 = new person(\u0026#34;李思\u0026#34;, 18); system.out.println(p2); } } class person{ string name ; int age ; public person() { } public person(string name, int age) { this.name = name; this.age = age; } public string tostring(){ return name + \u0026#34;:\u0026#34;+ age; } } ","date":"2021-10-24","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430212111/","summary":"面向对象 导包的细节问题 1.对于内部类，如果想要直接使用内部类，必须通过导包，导入内部类的完全限定名。 2.对于java.lang包下的所有的类，不需要导包，默认编","title":"面向对象api"},{"content":"内部类 概念 类中的类\n内部类分类 1.成员内部类：类中方法外\n​\t① 一般成员内部类：\n​\tclass 类名{} ​\t② 静态成员内部类:\n​\tstatic class 类名{} ​\t③ 私有成员内部类:\n​\tprivate class 类名{} 2.局部内部类： 方法中\n3.内部类的命名：\n​\t外部类的名称 + $ + 内部类的名称 一般成员内部类 1.一般成员内部类中调用外部类的非静态方法：直接调用。 2.外部类的非静态成员调用一般成员内部类的非静态成员：创建对象，然后再调用。 3.一般成员内部类中不允许有静态方法。但是可以有static final修饰的静态成员属性。 4.外部类的外面创建内部类的对象： 1\u0026gt; 数据类型 外部类名.内部类名\n代码 package com.demo; public class 一般成员内部类 { public static void main(string[] args) { b.innerb ib = new b().new innerb(); } } class b{ int a = 15; public void show(){ system.out.println(\u0026#34;22222\u0026#34;); innerb ib = new innerb(); ib.fun(); } class innerb{ static final int b= 10; public void fun(){ show(); a = 16; system.out.println(\u0026#34;1111111111111\u0026#34;); } //一般成员内部类中不允许有静态方法。 // public static void fun1(){} } } 静态成员内部类 静态成员内部类： ① 静态成员内部类中非静态方法中调用外部类的非静态方法：创建外部类的对象，调用方法。\n② 静态成员内部类中非静态方法调用外部类的静态方法：直接调用。\n③ 外部类的非静态方法调用静态成员内部类中的非静态：创建内部类的对象，调用方法。\n④ 外部类的非静态方法调用静态成员内部类中的静态方法：内部类名.方法名称(参数)\n⑤ 静态成员内部类中静态方法中调用外部类的静态方法：直接调用\n⑥ 静态成员内部类中静态方法中调用外部类的非静态方法:创建外部类的对象，调用方法。\n⑦ 外部类的静态方法调用静态成员内部类中的静态：内部类名.方法名称(参数)\n⑧ 外部类的静态方法调用静态成员内部类中的非静态：创建内部类的对象，调用方法。\n总结：\n1》 静态成员内部类中 方法调用外部类的静态方法：直接调用。\n2》 静态成员内部类中 方法调用外部类的非静态方法：创建外部类的对象，调用方法。\n3》 外部类的方法 调用静态成员内部类的静态方法：内部类名.方法名称(参数)\n4》 外部类的方法 调用静态成员内部类的非静态方法:创建内部类的对象，调用方法。\n2.外部类外创建内部类的对象:\n外部类的名称.内部类的名称 对象的名称 = new 外部类名.内部类名()\n代码 package com.demo; public class 静态成员内部类 { public static void main(string[] args) { m.innerm mm = new m.innerm(); } } class m{ public void show(){ innerm im = new innerm(); im.fun(); innerm.sf(); } public static void sk(){ innerm.sf(); innerm im = new innerm(); im.fun(); } //静态成员内部类 static class innerm{ public void fun(){ // 由于外部类的show方法必须在有外部类的对象时，才能使用。 m m = new m(); m.show(); sf(); system.out.println(\u0026#34;111111111111111\u0026#34;); } public static void sf(){ sk(); m m = new m(); m.show(); system.out.println(\u0026#34;222222222222\u0026#34;); } } } 私有成员内部类 1.用法 同一般成员内部类：\n​\t① 在私有成员内部类的非静态方法中调用外部类的方法：直接调用。\n​\t② 外部类的非静态成员调用私有成员内部类的非静态成员：创建内部类的对象，调用方法。\n​\t③ 外部类的静态成员调用私有成员内部类的非静态成员：先创建外部类的对象，再创建内部类的对象，调用方法。\n2.外部类的外面创建私有成员内部类的对象：\n​\t不能。\n代码 package com.demo; public class 私有成员内部类 { public static void main(string[] args) { } } class f{ public void fun(){ innerf in = new innerf(); in.show(); } public static void sf(){ f f = new f(); innerf ik = f.new innerf(); ik.show(); } //私有成员内部类 private class innerf{ public void show(){ fun(); sf(); } } } 局部内部类 1.局部内部类： 方法中的类\n代码 package com.demo; /** 1.局部内部类： 方法中的类 */ public class 局部内部类 { public static void main(string[] args) { k k = new k(); k.fun(); } } class k { public void fun(){ //局部内部类 /*class innerk{ public void show(){ system.out.println(\u0026#34;22222\u0026#34;); } } //创建内部类的对象 调用方法 innerk in = new innerk(); in.show();*/ //匿名对象 /* tm t = new zitm(); t.fun1();*/ //一次性调用:实质就是对象。 new tm(){ @override public void fun1() { } }; } } interface tm{ public void fun1(); } class zitm implements tm{ @override public void fun1() { } } class zitm1 implements tm{ @override public void fun1() { } } ","date":"2021-10-23","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430212064/","summary":"内部类 概念 类中的类 内部类分类 1.成员内部类：类中方法外 ​ ① 一般成员内部类： ​ class 类名{} ​ ② 静态成员内部类: ​ static class 类名{} ​ ③ 私有成员内部类: ​ private class 类名{} 2.局","title":"内部类"},{"content":"面向对象的特征 三大基本特征：\n​\t封装 继承 多态\n特征：四个\n​\t封装 继承 多态 抽象\n封装 对外隐藏事物的实现细节，只提供接口供外界访问\n封装的好处 1.提高程序的安全性。\n2.提高代码的复用性。\n封装的体现 类：封装体\n方法：\n​\t最大的体现：\n​\t私有的属性 公有的方法。\n1.private：\n​\t私有的属性 表示通过private进行修饰的属性。\n2.公有的方法：\n​\t格式：\n​\t① 设置 setter\n​\tpublic void set属性的名称(参数){ ​\tthis.属性 = 参数的名称 ​\t}\n注意：\n​\tset属性名称 ，该属性名称第一个字母必须大写，遵循小驼峰原则。\n② 获取 getter\n​\tpublic 返回值类型 get属性的名称(){ ​\treturn 属性; ​\t}\n代码 package com.demo; /** 1.封装概述 2.private :权限修饰符，私有的，只有本类能使用。 */ public class 封装概述 { public static void main(string[] args) { student st = new student(); //st.age = -100; st.setage(-100); system.out.println(st.getage()); } } class student{ //私有的属性 private int age; //公有的方法 设置属性 public void setage(int age){ if(age \u0026gt;=0 \u0026amp;\u0026amp; age \u0026lt;=120){ this.age = age; } else { system.out.println(\u0026#34;年龄不合法\u0026#34;); } } //公有的方法 获取属性 public int getage(){ return age; } } setter与getter方法快捷键 格式：\n​\t① 设置 setter\n​\tpublic void set属性的名称(参数){ ​\tthis.属性 = 参数的名称 ​\t}\n​\t注意：\n​\tset属性名称 ，该属性名称第一个字母必须大写，遵循小驼峰原则。\n​\t② 获取 getter\n​\tpublic 返回值类型 get属性的名称(){ ​\treturn 属性; ​\t}\n快捷键：\n​\talt + insert 继承 子类拥有父类的属性和方法，具有父类的特征\n继承的实现 ① 关键字 extends\n​\tclass 子类 extends 父类\n​\t父类： superclass 超类\n​\t子类: subclass\n​\t一般可以写继承关系的 要求本质上是同一类事物 继承的好处 ① 提高代码的复用性。\n② 提高代码的扩展性\n继承的特点(***) ① 单继承：extends关键字后只能有一个父类，继承的直系父类只有一个。\n② 多重继承 继承的细节问题 对于父类与子类属性同名时，由于就近原则，如果是子类对象调用该属性，则使用的子类的属性。想使用父类的同名属性，\n关键字：\n​\tsuper:指代当前对象的父类部分。\n​\t用法同this:\n格式：\n​\tsuper. 属性名称 注意：\n​\t无论是this还是super 不能直接在静态方法中使用。\n代码 package com.demo; /** 1.学生对象、工人对象 老师对象 */ public class 继承 { public static void main(string[] args) { student st = new student(); /*st.study(); st.sleep();*/ /* littlestudent lt = new littlestudent(); lt.study();*/ system.out.println(st.name); st.show(); } } class person{ string name =\u0026#34;张三\u0026#34;; int age; public void sleep(){ system.out.println(\u0026#34;睡觉\u0026#34;); } } //单继承 class student extends person{ string name = \u0026#34;李思\u0026#34;; public void study(){ system.out.println(\u0026#34;goodgoodstudy\u0026#34;); } public void show(){ system.out.println(super.name); } } // 多重继承 class littlestudent extends student { } class worker{ string name; int age; public void sleep(){ system.out.println(\u0026#34;睡觉\u0026#34;); } public void working(){ system.out.println(\u0026#34;打工。。。\u0026#34;); } } class teacher{ string name; int age; public void sleep(){ system.out.println(\u0026#34;睡觉\u0026#34;); } public void teaching(){ system.out.println(\u0026#34;教java。。。。。。。。。。。。\u0026#34;); } } 继承的成员 1.继承的成员可以都继承，除了以下两种：\n​\t① 成员用private修饰。\n​\t② 构造方法不能被继承。\n方法的重写 1.方法的重载: overload 在同一个类中，方法名称相同，参数列表不同(个数，顺序，类型)，与返回值无关。\n2.方法的重写的原因：\n​\t父类的方法不适合子类的使用。\n3.方法的重写: override\n​\t在具有继承关系的子类中，如果父类的方法不满足子类的需求，子类需要重写父类方法，重写时，\n​\t1》方法名称相同\n​\t2》参数列表相同\n​\t3》目前，返回值类型也相同(多态之前可以这样认为)，\n​\t4》权限修饰符大于等于父类。\n4.如果子类中要想调用父类的同名方法，需要通过super来调用：\n​\t格式：\n​\tsuper.方法名称(参数) 4.方法重写的校验：\n​\t① 可以通过上图进行校验。\n​\t② 注解@override检测 代码 package com.exec; /** 1.描述手机的来电显示功能 phonei : 来电显示: 电话号码。 phoneii: 来电显示: 地区 大头贴 铃声 电话号码。 */ public class topic1 { public static void main(string[] args) { phoneii pii = new phoneii(); pii.display(); } } class phonei{ public void display(){ system.out.println(\u0026#34;电话号码\u0026#34;); } } class phoneii extends phonei{ public void display(){ //调用父类的同名方法 super.display(); system.out.println(\u0026#34;铃声\u0026#34;); system.out.println(\u0026#34;大头贴\u0026#34;); } } 方法的重写注意： ① 重写要求必须是子父类之间，在子类中重写。\n② 静态方法是不能被重写的。\n③ 可以重写的方法都是非静态方法。通过对象调用，主要是为多态做准备。\nthis与super的用法 ① this/super 指代对象\n​\tthis 表示当前类的当前对象\n​\tsuper 表示当前类的当前对象的属于父类部分的引用。\n注意：\n​\tthis与super可以想象在子类对象中，一旦具有继承关系，就相当于子类对象创建时，由两部分组成，一部分属于继承父类super，另外一部分属于子类特有，称为this。\n​\t当查找时，this从本类开始进行查找。遇到第一个为止。super从父类开始查找，遇到第一个为止。 ② this与super指代构造方法。\n​\tthis指代本类的构造方法\n​\tsuper指代父类的构造方法。\n格式:\n​\tthis/super(参数) 注意：\n1.默认如果一个子类的构造方法中没有显式的调用父类的构造方法，默认会有一个super() 默认的父类的无参空构造被调用。这种现象被称为隐式三步第一步.\n2.如果父类构造中在有显式声明构造方法后，这些声明的构造方法中没有无参构造方法，此时，建议添加无参构造。\n原因：\n​\t子类在进行构造方法的声明时，会在第一行默认调用父类无参构造方法。super()，如果类没有，就报错。\n解决：\n​\t① 建议添加无参构造\n​\t② 也可以在构造方法第一行指定调用的是父类哪个构造方法。(不建议)\n总结：\n​\tthis与super的用法：\n​\t① 指代对象：\n​\t格式：\n​\tthis/super.方法(参数)/属性 ​\t② 指代构造方法\n​\t格式：\n​\tthis/super(参数)\n代码 package com.demo; /** 注意：1.默认如果一个子类的构造方法中没有显式的调用父类的构造方法，默认会 有一个super() 默认的父类的无参空构造被调用。这种现象被称为隐式三步第一步. 2.如果父类构造中在有显式声明构造方法后，这些声明的构造方法中没有无参构造方法，此时， 建议添加无参构造。 原因：子类在进行构造方法的声明时，会在第一行默认调用父类无参构造方法。super()，如果父 类没有，就报错。 解决：① 建议添加无参构造 ② 也可以在构造方法第一行指定调用的是父类哪个构造方法。(不建议) 总结：this与super的用法： ① 指代对象： 格式： this/super.方法(参数)/属性 ② 指代构造方法 格式：this/super(参数) */ public class super指代构造方法 { public static void main(string[] args) { zik zk = new zik(); } } class zk{ public zk(string s){ system.out.println(\u0026#34;这是zk类的无参构造方法。。。1\u0026#34;); } } class zik extends zk{ public zik(){ // 隐式三步：第一步 super() super(\u0026#34;abc\u0026#34;); system.out.println(\u0026#34;这是zik的无参构造方法。。。2\u0026#34;); } } 多态 概念 多态是同一个行为具有多个不同表现形式或形态的能力\n多态的好处 提高了代码的扩展性\n提高了代码的复用性\n多态的分类 多态的类型：\n向上转型:\n​\t父类引用指向子类对象。\n向下转型：\n​\t解决多态向上转型的弊端。\n多态向上转型弊端: 一旦发生了向上转型之后，由于对外是父类数据类型，不能调用子类特有的属性和方法。\n代码 package com.demo; /** 1.多态： 2.小女孩养宠物: 猫 哈士奇 老虎 */ public class 多态 { public static void main(string[] args) { littlegirl lg = new littlegirl(); cat c = new cat(); lg.feed(c);// animal c = new cat() 多态的向上转型 dog d = new dog(); lg.feed(d); tiger t = new tiger(); lg.feed(t); bird b = new bird(); lg.feed(b); animal c1 = new cat(); //一旦发生了向上转型之后，由于对外是父类数据类型，不能调用子类特有的属性和方法。 //c1.catchmouse(); } } class littlegirl { /* public void feed(cat c){ c.eat(); } public void feed(dog c){ c.eat(); } public void feed(tiger c){ c.eat(); } */ public void feed(animal c){ c.eat(); } } class animal{ public void eat(){} } class cat extends animal { public void eat(){ system.out.println(\u0026#34;猫吃鱼\u0026#34;); } public void catchmouse(){} } class dog extends animal{ public void eat(){ system.out.println(\u0026#34;哈士奇吃猫\u0026#34;); } } class tiger extends animal{ public void eat(){ system.out.println(\u0026#34;老虎吃哈士奇\u0026#34;); } } class bird extends animal{ @override public void eat() { system.out.println(\u0026#34;鸟吃虫\u0026#34;); } } 类与类之间的关系 分类\n​\t① 继承关系:本质是同一类事物 。 动物 \u0026ndash;》猫\n​\t② 聚合关系： 整体和部分，可以分开。\n​\t③ 组合关系： 整体和部分，不可分割。\n向上转型/里氏代换 概念 任何基类可以出现的地方，子类一定可以出现\n多态的向下转型 原因 解决多态向上转型的弊端。\n细节 1.多态向下转型:\n​\t格式：\n​\t强制类型转换\n​\t(要转换的类型)要转换的变量\n2.向下转型弊端：\n​\t如果真实对象不是要转换的数据类型的对象，会报classcastexception类型转换异常。\n3.解决向下转型的弊端：\n​\t关键字:\n​\tinstanceof ​\t格式：\n​\t要转换的变量 instanceof 要转换成的数据类型\n​\t返回值为布尔类型。如果是对应的数据类型 ，返回true 否则 返回false。\n​\t注意：\n​\tinstanceof后面的数据类型必须写精确，要转换成哪个类型就是哪个类型。不能使用父类。\n代码： package com.demo; /** 1.多态向下转型: 格式：强制类型转换 (要转换的类型)要转换的变量 2.向下转型弊端： 如果真实对象不是要转换的数据类型的对象，会报classcastexception类型转换异常。 3.解决向下转型的弊端： 关键字: instanceof 格式：要转换的变量 instanceof 要转换成的数据类型 返回值为布尔类型。如果是对应的数据类型 ，返回true 否则 返回false。 注意： instanceof后面的数据类型必须写精确，要转换成哪个类型就是哪个类型。不能使用父 类。 */ public class 多态向下转型 { public static void main(string[] args) { animal a = new dog(); //向下转型 强制类型转换 /* if (a instanceof cat) { cat c = (cat) a; c.catchmouse(); } */ system.out.println(a instanceof animal); } } class animal { public void eat(){} } class cat extends animal{ @override public void eat() { system.out.println(\u0026#34;猫吃鱼\u0026#34;); } public void catchmouse(){ system.out.println(\u0026#34;猫抓老鼠\u0026#34;); } } class dog extends animal{ @override public void eat() { system.out.println(\u0026#34;狗吃肉\u0026#34;); } public void keepdoor(){ system.out.println(\u0026#34;看门\u0026#34;); } } 多态成员之间的调用问题 方法绑定 绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来\n方法绑定的分类 1.静态绑定/前期绑定/编译期绑定：在编译时 就能确定执行哪个类的哪个方法。\n2.动态绑定/后期绑定/运行期绑定: 在运行时，才能确定执行哪个类的哪个方法。\n成员 1.编译期绑定： 属性(静态 或 非静态 ) 、静态方法、\n2.运行期绑定： 非静态方法。\n总结 编译看左 ： 属性 和静态方法\n运行先看左后看右： 非静态\n先看赋值符号左侧的数据类型，确定要执行的方法，运行时，看右侧真实对象，决定是调用父类还是子类的重写方法。\n编译看左 ： 属性 和静态方法\n运行先看左后看右： 非静态\n先看赋值符号左侧的数据类型，确定要执行的方法，运行时，看右侧真实对象，决定是调用父类还是子类的重写方法。\n代码： package com.demo; /** 1.编译期绑定： 属性(静态 或 非静态 ) 、静态方法、 2.运行期绑定： 非静态方法。 */ public class 多态成员之间的调用问题 { public static void main(string[] args) { f f = new f(); zif z = new zif(); //向上转型 /** 10:20 30:40 10:20 */ f zif = new zif(); /* system.out.println(f.a + \u0026#34;:\u0026#34; + f.b); system.out.println(z.a + \u0026#34;:\u0026#34; + z.b); system.out.println(zif.a + \u0026#34;:\u0026#34; + zif.b); */ /*f.sfun(); z.sfun(); zif.sfun(); */ f.show(); z.show(); zif.show(); } } class f{ int a = 10; static int b = 20; public void show (){ system.out.println(\u0026#34;这是父类的非静态方法。。。。。1\u0026#34;); } public static void sfun(){ system.out.println(\u0026#34;这是父类的静态方法。。。。。。。。2\u0026#34;); } } class zif extends f{ int a = 30; static int b = 40; public void show (){ system.out.println(\u0026#34;这是子类的非静态方法。。。。。3\u0026#34;); } public static void sfun(){ system.out.println(\u0026#34;这是子类的静态方法。。。。。。。。4\u0026#34;); } } 代码块 概述 1.代码块：{}\n2.常见代码块:\n​\tstatic {} 静态代码块 类中 方法外 ​\t{} 构造代码块 类中 方法外 ​\t{} 局部代码块 方法中 3.特性：\n静态代码块： 随着类的加载而加载，并且只加载一次。多个之间 按照代码执行顺序，顺序加载，适用场景：类存在就需要使用的代码。\n构造代码块：随着构造方法的执行而执行，并且每执行一次构造方法，都会执行一次代码块。并且在构造方法中的代码执行之前执行。多个也是按照代码执行顺序顺序执行。适用场景：当多个构造方法中有共性代码时，可以提取到构造代码块中执行。\n局部代码块：位于方法中，主要是用来限定变量的作用域。\n代码： package com.demo; /** 1.代码块： {} 2.常见代码块: static {} 静态代码块 类中 方法外 {} 构造代码块 类中 方法外 {} 局部代码块 方法中 3.特性： 静态代码块： 随着类的加载而加载，并且只加载一次。多个之间 按照代码执行顺序，顺序加 载，适用场景：类存在就需要使用的代码。 构造代码块：随着构造方法的执行而执行，并且每执行一次构造方法，都会执行一次代码块。 并且在构造方法中的代码执行之前执行。 多个也是按照代码执行顺序顺序执行。适用场景：当多个构造方法中有共性代码 时，可以提取到构造代码块中执行。 局部代码块：位于方法中，主要是用来限定变量的作用域。 */ public class 代码块 { static int a; //静态代码块 static{ a = 10; system.out.println(\u0026#34;这是静态代码块。。。。2\u0026#34;); } //构造代码块 { system.out.println(\u0026#34;这是一个构造代码块...1\u0026#34;); } { system.out.println(\u0026#34;这是一个构造代码块...5\u0026#34;); } public static void main(string[] args) { // system.out.println(a); // new 代码块(); // new 代码块(5); fun(); } public static void fun(){ //局部代码块 { int b = 5; system.out.println(b+\u0026#34;========\u0026#34;); } // system.out.println(b+\u0026#34;...\u0026#34;); } public 代码块(){ system.out.println(\u0026#34;这是无参构造方法。。。。3\u0026#34;); } public 代码块(int a){ system.out.println(\u0026#34;这是有参构造方法。。。。4\u0026#34;); } } 对象的加载顺序问题 类的成员 属性\n方法\n构造方法\n代码块 代码： public class 对象的加载顺序 { public static void main(string[] args) { new f().fun(); } } class f{ static{ system.out.println(\u0026#34;这是f类的静态代码块。。。。5\u0026#34;); } { system.out.println(\u0026#34;这是f类的构造代码块。。。。6\u0026#34;); } int a = seta(); private int seta() { system.out.println(\u0026#34;这是f类的显式初始化。。。4\u0026#34;); return 0; } public void fun(){ system.out.println(\u0026#34;这是f类的非静态方法。。。1\u0026#34;); } public f(){ system.out.println(\u0026#34;这是f类的无参构造方法。。。。2\u0026#34;); } public f(int a){ system.out.println(\u0026#34;这是f类的有参构造方法。。。。3\u0026#34;); } } 执行步骤 1.判断对象的加载顺序该类是否存在在方法区中，存在，直接使用，不存在，向硬盘上进行加载到方法区。\n2.查找到main方法 压栈执行。\n3.判断f类是否在方法区存在，存在，直接使用，不存在，向硬盘上进行加载到方法区。\n4.由于有new关键字，在堆中开辟f类的对象空间，并且对属性a进行默认初始化。\n5.根据构造方法，选择构造方法进行执行。\n6.在执行构造方法中的代码之前，该位置需要执行隐式三步：\n​\t① super(参数)\n​\t② 构造代码块\n​\t③ 属性显式初始化\n​\t其中 ，②③根据程序的书写顺序，顺序执行。\n7.隐式三步执行完毕之后，才会执行构造方法里面的代码。\n8.如果有方法调用，此时再执行方法。没有不执行。\n总结：\n​\t1》 先加载类：考虑继承 ，先父后子。 静态方法 静态属性 静态代码块，静态方法不调用 不执行。静态属性 静态代码块 顺序执行。\n​\t2》 对象：构造方法的执行：\n​\t① 隐式三步：super(参数) 考虑 继承 构造代码块 属性的显式初始化 顺序执行。\n​\t② 构造方法的代码的执行。\n​\t③ 有方法调用才会执行。\n抽象类 抽象概念 不具体 共性的特征。\n关键字：abstract abstract 表示抽象\n抽象方法 声明格式：\n[权限修饰符]abstract 返回值类型 方法名称(参数列表); 抽象类\n当一个类中拥有抽象方法时，该类也必须是抽象的。类的前面加关键字 abstract\n抽象类声明格式：\n[权限修饰符] abstract class 类名{ } 抽象类的特点 ① 抽象类也是类，拥有的类的特点。可以有 属性 方法 构造方法 ② 抽象类不能直接创建对象的。要创建对象，必须通过子类实现抽象类中的抽象方法，才能创建子类对象。\n③ 一个类中如果有抽象方法，该类必须是一个抽象类，如果一个类是抽象类，未必有抽象方法。只要加关键字 abstract在类上就可以。\n代码： package com.demo; public class 抽象类 { public static void main(string[] args) { animal a = new cat(); a.fun(); a.eat(); animal a1 = new dog(); a1.eat(); } } abstract class animal{ public abstract void eat(); public void fun(){ system.out.println(\u0026#34;这是一个fun方法。。。1\u0026#34;); } int a = 5; public animal(){} } class cat extends animal{ @override public void eat() { system.out.println(\u0026#34;猫吃鱼\u0026#34;); } } class dog extends animal{ @override public void eat() { system.out.println(\u0026#34;狗吃肉\u0026#34;); } } 抽象类与一般类的区别？ 1.写法：\n​\t抽象类 abstract class\n​\t类 class\n2.组成成员：\n​\t抽象类： 属性 方法 抽象方法 构造方法\n​\t类： 除了抽象方法。\n3.创建对象：\n​\t抽象类： 不能创建对象\n​\t类： 可以直接创建对象。\n4.对于方法的实现：\n​\t抽象类：如果有抽象方法，必须要重写。\n​\t类： 继承自父类的方法，可以重写也可以不重写。\n模板设计模式 设计模式 是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。\n常见的设计模式 23种 。\n模板设计模式：\n在模板模式（template pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式\n代码： package com.demo; /** 学生一天的生活: ① 吃 ② 睡 ③ 学习 */ public class 模板设计模式 { public static void main(string[] args) { student st = new littlestudent(); /*st.eat(); st.sleep(); st.study(); */ st.life(); student mt = new middelstudent(); /* mt.eat(); mt.sleep(); mt.study(); */ mt.life(); } } abstract class student{ public abstract void eat(); public abstract void sleep(); public abstract void study(); public void life(){ eat(); sleep(); study(); } } class littlestudent extends student{ @override public void eat() { system.out.println(\u0026#34;小学生吃零食\u0026#34;); } @override public void sleep() { system.out.println(\u0026#34;小学生很晚睡。。。\u0026#34;); } @override public void study() { system.out.println(\u0026#34;小学生天天玩耍\u0026#34;); } } class middelstudent extends student{ @override public void eat() { system.out.println(\u0026#34;初中生边吃边学\u0026#34;); } @override public void sleep() { system.out.println(\u0026#34;初中生边睡边读书\u0026#34;); } @override public void study() { system.out.println(\u0026#34;初中生边学边睡。。\u0026#34;); } } 构造方法与sette方法的区别 属性赋值\n​\t1.直接赋值：\n​\t对象.属性名 = 值 ​\t2.构造方法：\n​\t对于属性赋值，只能赋值一次，并且是在创建对象时 赋值一次。\n​\t3.setter方法\n​\t创建对象后，需要修改属性的值。\nfinal用法 final final用法：\n​\t① 修饰变量\u0026ndash;》常量\n​\t② 修饰方法\u0026ndash;》不能被重写\n​\t③ 修饰类 \u0026ndash;》 不能被继承\n代码： package com.demo; /** 1.final用法： ① 修饰变量--》常量 ② 修饰方法--》不能被重写 ③ 修饰类 --》 不能被继承 string */ public class final用法 { } abstract class a{ public /*final*/ void fun(){} //public abstract final void f1(); 注意 final 与abstract不能连用 } class zia extends a{ @override public void fun() { super.fun(); } } final finally finalize区别 1.final 用法\n2.finally 异常 ： 无论执行try还是执行catch最终都会执行 finally里面的内容。 3.finalize() 用于垃圾回收的方法。\n接口 概念 接口： 协议 约定。\n​\t一系列的规范和约定，目前，接口中所有的方法都是抽象方法。(1.8之前 不包括)\n接口的声明 格式：\n​\t关键字 interface\n​\t[权限修饰符] interface 接口的名称{ ​\t}\n1.接口中的方法的声明：\n​\t接口中的方法都是抽象方法，一般会省略abstract不写。\n2.接口中的属性的声明：\n​\t接口中的属性都是静态常量，一般会省略public static final不写。\n接口的对象的创建 1.接口中的方法都是抽象方法，所以接口不能直接创建对象。\n2.要想创建对象，必须要实现接口中的抽象方法。\n3.要使用子类创建对象。\n​\t关键字：\n​\timplements\n​\t格式：\n​\tclass 子类 implements 父接口1,父接口2{ ​\t} 代码： package com.demo; public class 接口的声明 { public static void main(string[] args) { t t = new zit(); t.fun(); } } //接口 interface t{ public void fun();//不写 也有abstract int a =10;// 省略了 public static final 也是 静态常量 } //子类 class zit implements t{ @override public void fun() { system.out.println(\u0026#34;这是接口中的子类。。。。\u0026#34;); } } 接口的细节问题 1.接口的特点：\n​\t① 接口可以多实现： ​\t② 接口可以多继承 ​\t③ 接口可以多重继承\n2.接口与抽象类的区别与联系：\n​\t区别：\n​\t1》 写法：\n​\t抽象类： abstract class\n​\t接口： interface\n​\t2》 成员：\n​\t抽象类： 属性 方法 抽象方法 构造方法 代码块\n​\t接口： 抽象方法 静态常量 没有构造方法 代码块\n​\t3》 子类实现：\n​\t抽象类： extends\n​\t接口: implements\n​\t4》 特点：\n​\t抽象类： 继承 ：单继承 多重继承\n​\t接口： 继承 ： 多继承 多重继承 多实现\n​\t5》 用途：\n​\t抽象类： 同一种事物的共性的特征\n​\t接口： 不同事物之间的相同功能\n联系:\n把接口看成是特殊的抽象类，该类中所有的方法都是抽象方法的抽象类。\n包 概述 包 ：package\n① 功能：分类管理java的文件。\n② 包的命名规则：\n​\t原则：全球唯一。\n​\t公司域名的倒置 + 项目名称 + 模块名称 + 包的功能名称\n​\t如：cn.com.baidu.studentmanager.crud.add ③ 包的分隔符：\n​\t用点进行分隔，每一个点表示一层。\n④ 包的声明：表明该类在哪个包下。如果没有package声明，在src下。\n​\tpackage 包的路径;\n​\t注意：\n​\t包的声明只有一个，并且在第一行。\n⑤ 导包：指名该类在哪个包下。\n​\timport 类的路径\n注意：\n​\t导包可以是多个，位于package下面。\n代码： package com.demo; import java.util.scanner; public class 包 { public static void main(string[] args) { //类的完全限定名 // java.util.scanner sc = new java.util.scanner(system.in); } } ","date":"2021-10-21","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430211406/","summary":"面向对象的特征 三大基本特征： ​ 封装 继承 多态 特征：四个 ​ 封装 继承 多态 抽象 封装 对外隐藏事物的实现细节，只提供接口供外界访问 封装的好处 1.提高程序的安全性。 2.提高代","title":"面向对象的特征"},{"content":"面向对象 常见的编程思想 面向过程：procedure oriented：pop 解决问题的方法与步骤。\n面向对象： object oriented ：oop 找\u0026quot;对象\u0026quot;解决问题。\n面向过程是实现面向对象的基础\n面向对象步骤 1.抓 特征:\n​\t\u0026ldquo;静态特征\u0026rdquo;: 属性：实质全局变量 。身高 体重 毛色 姓名\n​\t\u0026ldquo;动态特征\u0026rdquo;: 行为。功能。方法。函数。method\n2.面向对象更适用于复杂问题的解决，而面向过程更适用于简单问题的解决。\n​\t例如：面向对象类比盖饭，面向过程 类比蛋炒饭\n​\t耦合\n3.总结：\n​\t面向对象思想：\n​\t1\u0026gt; 找\u0026quot;对象\u0026quot;。类 \u0026ndash;》 创建对象。\n​\t① java或别人提供了，直接用\n​\t② 没提供，自己写，再用\n面向对象代码： package com.demo1; /** 1.猫捉老鼠的场景: ① 猫看见老鼠 ② 老鼠跑 ③ 猫追逐 ④ 猫抓住老鼠 2.对象: 猫 老鼠 3.类： 猫 老鼠 抓 特征: \u0026#34;静态特征\u0026#34;: 属性：实质全局变量 。身高 体重 毛色 姓名 \u0026#34;动态特征\u0026#34;: 行为。功能。方法。函数。method 4.面向对象更适用于复杂问题的解决，而面向过程更适用于简单问题的解决。 例如：面向对象类比盖饭，面向过程 类比蛋炒饭 耦合 5.总结： 面向对象思想： 1\u0026gt; 找\u0026#34;对象\u0026#34;。类 --》 创建对象。 ① java或别人提供了，直接用 ② 没提供，自己写，再用 */ public class 面向对象版猫捉老鼠 { public static void main(string[] args) { // 创建： new 类名() cat cat = new cat(); cat cat1 = new cat(); mouse mouse = new mouse(); //实现功能 对象名称.方法(参数) cat.seemouse(); cat1.seemouse(); mouse.mouserun(); cat.catrun(); cat.catchmouse(); } } class cat{ string color ;//属性 毛色 public static void seemouse(){ system.out.println(\u0026#34;猫看见老鼠\u0026#34;); } public static void catrun(){ system.out.println(\u0026#34;猫追逐\u0026#34;); } public static void catchmouse(){ system.out.println(\u0026#34;猫抓住老鼠\u0026#34;); } } class mouse{ public static void mouserun(){ system.out.println(\u0026#34;老鼠跑\u0026#34;); } } 面向过程代码 package com.demo1; /** 1.猫捉老鼠的场景: ① 猫看见老鼠 ② 老鼠跑 ③ 猫追逐 ④ 猫抓住老鼠 */ public class 面向过程版猫捉老鼠 { public static void main(string[] args) { seemouse(); mouserun(); catrun(); catchmouse(); } public static void seemouse(){ system.out.println(\u0026#34;猫看见老鼠\u0026#34;); } public static void mouserun(){ system.out.println(\u0026#34;老鼠跑\u0026#34;); } public static void catrun(){ system.out.println(\u0026#34;猫追逐\u0026#34;); } public static void catchmouse(){ system.out.println(\u0026#34;猫抓住老鼠\u0026#34;); } } 类和对象 概念 1.类：模板 蓝图 设计稿 。抽象的概念\n抽象是从众多的事物中抽取出共同的、本质性的特征\n2.猫\u0026ndash;》共性 凡是符合这种特征。\n3.类：具有共性特征的事物的抽象。\n4.对象：由类创建，具体的事物。\n对象的内存图 单个对象的内存图 步骤：\n​\t1.将对象的内存图.class加载到方法区，找到其中的main方法开始压栈执行。\n​\t2.加载person类到方法区，在main方法中为p引用变量开辟空间。\n​\t3.在堆中以person类为模板，创建person对象，为person中的属性name和age赋默认值，这个过程称为默认初始化。\n​\t4.将创建完毕的对象的内存地址值赋给引用变量p。\n​\t5.p.name p.age根据p找到堆中的对象进行赋值操作。\n​\t6.show方法压栈执行，show方法中默认会带有一个隐式指针，存放该方法由哪个对象执行。\n总结：\n① 创建的对象在堆中存放，对象的属性也是在堆中存放。\n② 类的加载只加载一次 ，首先去方法区中查找是否存在，存在，直接用，不存在，才会去硬盘上 加载该类\n创建两个对象的内存图 总结:\n① 凡是new操作，都会在堆中创建新的对象。\n② 属性属于不同对象的，每个对象都有自身的属性，只能改变自身的属性，不能改变其它对象的属 性\n值传递和引用传递 值传递 引用传递 无论是值传递还是引用传递，实质都是值传递，在参数传递的过程中，对于基本数据类型来说，传递的 值，而对于引用数据类型来说，传递的的地址值。\n匿名对象 概念 1.匿名对象：没有名字的对象\n2.好处：\n​\t① 简化书写\n​\t② 节省内存空间：垃圾回收机制：自动回收。\n3.注意：\n​\t① 对于匿名对象来说，同一个对象，调用属性或方法，只能调用一次。\n代码 package com.demo; /** 1.匿名对象: 2.好处： ① 简化书写 ② 节省内存空间：垃圾回收机制：自动回收。 3.注意： ① 对于匿名对象来说，同一个对象，调用属性或方法，只能调用一次。 */ public class 匿名对象 { public static void main(string[] args) { new b().fun(); new b().fun(); b b = new b(); b.fun(); system.out.println(2222); } } class b{ public void fun(){ system.out.println(\u0026#34;1111\u0026#34;); } } 构造方法 概念 constructor ：构造器\n作用 ① 创建对象时，调用的方法。\n​\t格式：\n​\tnew 构造方法(参数) ​\t② 初始化\n​\t注意：\n​\t初始化 可以是 属性，也可以调用其它方法。 细节 1.构造方法的声明：\n​\t格式:\n​\t[权限修饰符] 类名(参数列表){ ​\t} 2.注意：\n​\t① 一个类中，如果没有显式的声明构造方法，java编译器会自动添加一个无参空构造。\n​\t② 一个类中，如果显式声明了构造方法，编译器就不会添加\n代码 package com.demo; /** 1.构造方法的声明： 格式: [权限修饰符] 类名(参数列表){ } 2.注意： ① 一个类中，如果没有显式的声明构造方法，java编译器会自动添加一个无参空构造。 ② 一个类中，如果显式声明了构造方法，编译器就不会添加。 */ public class 构造方法 { public static void main(string[] args) { /* c c = new c(); c.name = \u0026#34;zs\u0026#34;; c.age = 19; */ c c1 = new c(\u0026#34;张三\u0026#34;,19); system.out.println(c1.name); } } class c{ string name; int age; /*public c(int a){ }*/ public c(string name,int age){ this.name = name; this.age = age; } public void fun(){ system.out.println(\u0026#34;这是c中的一个一般方法。\u0026#34;); } //方法 public void c(){} } 构造方法与一般方法的区别 1.写法上：\n​\t构造方法：没有返回值类型的，连void也没有。\n​\t一般方法：必须有返回值类型。\n2.调用方式上：\n​\t构造方法：new使用，创建对象时才会被调用。\n​\t一般方法： (除static修饰)在创建对象后，被对象调用。\n3.使用次数上：\n​\t构造方法： 对同一个对象来说，只能使用一次。\n​\t一般方法： 对同一个对象来说，可以使用无数次。\n构造方法的重载形式 格式：\n​\t[权限修饰符] 类名(参数){} 根据参数的不同，可以有不同的构造方法，这种叫做构造方法的重载的形式。\n成员变量与局部变量 概念 成员变量： 属性，全局变量，类中 方法外\n局部变量： 方法中。\n成员变量与局部变量重名问题 ① 当成员变量与局部变量同名时，由于就近原则，局部优先，使用的是局部变量，如果想使用成员变 量，需要在成员变量的名称前面加this。格式：this.成员变量名称。\n② this的用法之一： 代表当前类的当前对象。this一般不用区分的时候，可以省略，必须要与局部 变量区分的，必须带。\n成员变量与局部变量的区别： 1.位置：\n​\t成员变量：类中方法外\n​\t局部变量：方法中\n2.内存中的位置：\n​\t成员变量：堆中对象里\n​\t局部变量：栈中方法里\n3.生命周期：\n​\t成员变量： 随着对象的存在而存在，随着对象的消亡而消亡\n​\t局部变量： 随着方法的压栈而存在，随着方法的弹栈而消亡。\n静态 概念 静态： static 总结：\n​\t① 对于静态修饰的成员，用static进行修饰的成员，存放在方法区的静态区中。\n​\t② 静态成员随着类的加载而加载，并且只加载一次。\n​\t③ 静态成员特点：实例共享。即所有的对象共享该成员。\n​\t实例：就是对象\n静态成员格式 ① 凡是static修饰的 ，都是静态成员。\n② 调用格式：\n​\t类名.属性名称/方法名称(参数) ③ 静态成员又叫类成员，属性被称为类属性，方法被称为类方法。\n静态成员与非静态成员之间的调用关系 1.静态成员与非静态成员之间的调用关系:\n​\t① 静态成员与静态成员之间：\n​\t静态成员调用静态成员：直接调用。\n​\t② 非静态成员与非静态成员之间:直接调用。\n​\t③ 非静态成员调用静态成员：直接调用\n​\t④ 静态成员调用非静态成员：不能直接调用。\n​\t要想使用:\n​\t可以添加为静态\n​\t创建对象，保证非静态成员存在，才可以使用。\n总结：\n静态成员中调用非静态，不能直接调用的\n代码 package com.demo; /** （***）1.静态成员与非静态成员之间的调用关系: ① 静态成员与静态成员之间： 1\u0026gt;静态成员调用静态成员：直接调用。 ② 非静态成员与非静态成员之间:直接调用。 ③ 非静态成员调用静态成员：直接调用 ④ 静态成员调用非静态成员：不能直接调用。 要想使用: 1\u0026gt; 可以添加为静态 2\u0026gt; 创建对象，保证非静态成员存在，才可以使用。 总结：静态成员中调用非静态，不能直接调用的。 */ public class 静态成员与非静态成员之间的调用关系 { public static void main(string[] args) { 静态成员与非静态成员之间的调用关系 m = new 静态成员与非静态成员之间的调用关系(); m.fun1(); } public void fun1(){} } class c{ int a ; static int b; public void fun(){ a = 10; b = 30; } public static void sfun(){ b = 5; //c c = new c(); c.a = 15; } } 静态成员与非静态成员区别: 1.写法：\n​\t静态成员： static修饰\n​\t非静态成员： 没有static修饰\n2.内存中的位置：\n​\t静态成员： 方法区的静态区中\n​\t非静态成员：\n​\t属性： 堆中的对象里\n​\t方法： 方法区的非静态区\n3.调用：\n​\t静态成员： 类成员。\n​\t类名.属性/方法(参数)\n​\t非静态成员: 实例成员\n​\t对象名称.属性/方法(参数)\n4.生命周期:\n​\t静态成员: 随着类的加载而加载，随着类的消亡而消亡\n​\t非静态成员: 随着对象的加载而加载,随着对象的消亡而消亡。\njavabean javabean：符合某种规范的java的类，\n规范：\n​\t① 必须有getter与setter方法。\n​\t② 必须有无参构造器。如果显式声明了其它构造，没有无参的话，需要手动添加。\n初始化问题 1.默认初始化:开辟空间，赋默认值。\n2.显式初始化：直接在声明属性时 为属性赋值\n3.构造初始化:在构造方法中为属性赋值。\n​\t顺序：\n​\t默认初始化 \u0026ndash;\u0026gt; 显式初始化 \u0026ndash;\u0026gt; 构造初始化\n代码\npackage com.demo; /** 1.默认初始化 .显式初始化 3.构造初始化 顺序：默认初始化 --\u0026gt; 显式初始化 --\u0026gt; 构造初始化 */ public class 初始化顺序 { public static void main(string[] args) { d d = new d(15); } } class d{ int a = seta();//显式初始化 public d(int a ){ // system.out.println(this.a); this.a = a;//构造初始化 // system.out.println(this.a); } public int seta(){ system.out.println(a); return 1; } } 包（package） 功能\n分类管理java文件\n命名规则\n原则：全球唯一\n公司域名的倒置+项目名称+模块名称+包的功能名称\n包的分隔符\n用点进行分割，每个点表示一层\n包的声明：表明该类在哪个包下。如果没有package声明，z在src下\npackage 包的路径；\n注意：\n包的声明只能有一个\n权限修饰符 四种权限 public\n公开的,在整个项目中都可以访问\nprotected\n受保护的，在当前和其他包的子类\ndefault/friendly\n这种就是省略不写，表示该种，没有权限修饰符的 专门词\n默认的 本包可以访问\nprivate\n私有的 本类可以访问\n","date":"2021-10-20","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430211218/","summary":"面向对象 常见的编程思想 面向过程：Procedure Oriented：pop 解决问题的方法与步骤。 面向对象： Object Oriented ：oop 找\u0026quot;对象\u0026quot;解决问题。 面","title":"面向对象"},{"content":"数组 数组的概念 用来存储数据的，多个变量组成的一个整体，用来便于批量操作数据的。\n​\t元素：每一个数组中的变量空间。\n​\t格式：\n​\t数组名称[索引] ​\t索引:每个元素的编号 称为索引，从0开始。又叫角标。\n​\t长度：数组中可以存储多少个数据。用length表示\n数组的声明和赋值: ① 动态初始化:\n​\t数据类型[] 数组名称 = new 数据类型[长度] ​\t注意：\n由于动态初始化开辟空间之后，赋的是数组数据类型的默认值。\n数据类型[]中 [] 可以跟在数据类型的后面，也可以跟在数组名称的后面。\n例如 :\n​\tint[] arr ​\tint arr[] ​\t写法都对。\n② 静态初始化 :\n​\t数据类型[] 数组名称 = new 数据类型[]{数据值1,数据值2,数据值3} ​\t注意：\n静态初始化 创建数组的时候，就被赋值了，有初始值 。\nnew 数据类型[]里面不放长度值，由{}里面的数据个数决定长度。\n③ 静态初始化的简写形式:\n​\t数据类型[] 数组名称 = {数据值1,数据值2,数据值3} ​\t注意：\n声明与赋值不能分开写 /** ① 动态初始化: 数据类型[] 数组名称 = new 数据类型[长度] ② 静态初始化 : 数据类型[] 数组名称 = new 数据类型[]{数据值1,数据值2,数据值3} ③ 静态初始化的简写形式: 数据类型[] 数组名称 = {数据值1,数据值2,数据值3} 注意： 1》 声明与赋值不能分开写。 */ class 数组概述 { public static void main(string[] args) { //学生 40人 //40变量 int score = 98; int score1 = 90; //声明一个数组 ，用来存储学生的成绩 3个学生 成绩分别为 98 90 79 int[] scores = new int[3]; //system.out.println(scores[1]); scores[0] = 98;//索引为0的数组元素赋值 scores[1] = 90; scores[2] = 79; //system.out.println( scores[1]); string[] arr = new string[3]; //system.out.println(arr[0]); //长度 //system.out.println(scores.length); //静态初始化 数据类型[] 数组名称 = new 数据类型[]{数据值1,数据值2,数据值3} double[] drr = new double[]{1.2,3.5,4.8,6.9}; //③ 静态初始化的简写形式: //数据类型[] 数组名称 = {数据值1,数据值2,数据值3} //声明与赋值不能分开写。 char[] crr = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;}; } } 数组的遍历 将数组中的元素依次拿出来，输出一遍\n采用for循环的形式\n代码 class 数组的遍历 { public static void main(string[] args) { //声明一个数组 int[] arr = {1,2,3,4,5,6,7,8}; for (int i = 0; i\u0026lt;arr.length ;i++ ) { system.out.println(arr[i]); } } } 数组的常见异常 1.数组角标越界异常：访问到了数组索引之外的空间。\narrayindexoutofboundsexception 2.空指针异常: 对象为null\nnullpointerexception\n数组的常见应用 求最值 标志位法\n代码 /** 1.求最大值: 标志位法： 思路： 假设 数组的第一个元素是最大的，找一个变量空间存放该值。 */ class 数组的求最值 { public static void main(string[] args) { int[] arr = {1,-5,23,-48,90,25}; //标记最大值 int max = arr[0]; //标记最小值 int min = arr[0]; for (int i = 0 ; i\u0026lt; arr.length ;i++ ) { //判断最大值 if(max \u0026lt; arr[i]){ max = arr[i]; } //判断最小值 if( min \u0026gt; arr[i]){ min = arr[i]; } } system.out.println(max); system.out.println(min); } } 数组的倒序/逆序 例如：\n{1,2,3,4,5,6} ===\u0026gt; 倒序{ 6,5,4,3,2,1} 代码 /** 思路： 通过开始 和结束 标记指针的位置，来进行交换 */ class 数组的倒序 { public static void main(string[] args) { int[] arr ={1,2,3,4,5,6,7}; /*for (int i = arr.length-1; i\u0026gt;=0 ; i-- ) { system.out.println(arr[i]); }*/ //开始指针 结束指针 int start = 0; int end = arr.length-1; for (;start \u0026lt;= end ; start++,end-- ) { //交换 int temp = arr[start]; arr[start]= arr[end]; arr[end] = temp; } //遍历数组 for (int i = 0; i\u0026lt;arr.length; i++ ) { system.out.println(arr[i]); } } } 数组的字符串拼接形式 默认打印数组时，打印的实际是数组的对象的形式。需要自己写方法，来显示数组中的元素值\n代码： class 数组的字符串拼接形式 { public static void main(string[] args) { int[] arr1 = {1,2,3,4,5}; system.out.println(arraytostring(arr1)); int[] arr2 = {-10,28,19,30}; system.out.println(arraytostring(arr2)); } //arraytostring 转字符串 public static string arraytostring(int[] arr){ string value = \u0026#34;{\u0026#34;; for (int i=0; i\u0026lt;arr.length ;i++ ) { value += arr[i]; if(i != arr.length-1 ){ value += \u0026#34;,\u0026#34;; } } value += \u0026#34;}\u0026#34;; return value; } } 数组内存图 一个引用指向一个数组 1.当main方法开始压栈执行时，在main方法中开辟arr的引用变量空间。\n2.在堆中创建数组对象，并进行初始化，如果是动态初始化的形式 ，数组中的值就是数据类型的默认 值，由于此时是静态初始化的简写形式，里面存放的就是初始值。\n3.当数组对象初始化完毕之后，将内存首地址赋值给引用变量arr.\n总结：\n① arr 称为引用变量，并不是真实的数组。空间开辟在栈中。\n② 真实的数组对象，空间开辟在堆中。\n两个引用指向同一个数组 排序 概述 1.冒泡排序（bubble sort） 思路：\n它重复地走访过要排序的元素列，依次比较两个相邻的元素，\n如果顺序（如从大到小、首字母从z到a）错误就把他们交换过来。\n走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成\n2.排序的方式:\n① 升序排序：从小到大\n② 降序排序: 从大到下 代码 /** 1.冒泡排序（bubble sort） 思路： 它重复地走访过要排序的元素列，依次比较两个相邻的元素， 如果顺序（如从大到小、首字母从z到a）错误就把他们交换过来。 走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成 2.排序的方式: ① 升序排序：从小到大 ② 降序排序: 从大到下 */ class 冒泡排序 { public static void main(string[] args) { int[] arr = {-19,23,38,47,15,19,-30}; //外层控制比多少趟 for (int i = 0 ; i\u0026lt;arr.length ;i++ ) { for (int j = 0; j\u0026lt; arr.length -1 /*-i*/ ; j++ ) { //第一个数大于第二个数 升序 就交换 if( arr[j] \u0026gt; arr[j+1]){ int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } system.out.println(arraytostring(arr)); } //arraytostring 转字符串 public static string arraytostring(int[] arr){ string value = \u0026#34;{\u0026#34;; for (int i=0; i\u0026lt;arr.length ;i++ ) { value += arr[i]; if(i != arr.length-1 ){ value += \u0026#34;,\u0026#34;; } } value += \u0026#34;}\u0026#34;; return value; } } 二维数组 多维数组 java中 没有多维数组的概念，所谓的多维数组，实质就是数组套数组。\n二维数组声明与赋值 ① 动态初始化\n数据类型[][] 数组名称 = new 数据类型[长度][长度];` ② 静态初始化\n**数据类型 数组名称 = new 数据类型*{*{*}{*}*,*{*}*}*;** ③ 静态初始化的简写形式\n数据类型[][] 数组名称 = *{*{*}*,*{*}*,*{*}*}*; 二维数组的内存图 1.二维数组声明与赋值\n① 动态初始化\n数据类型[][] 数组名称 = new 数据类型[长度1][长度2]; 注意：\n长度2可以省略不写的。\n但是省略后，需要先赋值再使用。\n② 静态初始化\n数据类型[][] 数组名称 = new 数据类型[][]*{*{*}*,*{*}*,*{*}*}; ③ 静态初始化的简写形式\n数据类型[][] 数组名称 = *{*{*}*,*{*}*,*{*}*}; 2.默认值：\n基本数据类型：\n整数类型： byte short int long 0\n浮点数类型:float double 0.0\n布尔类型: false\n字符类型:\u0026rsquo;\\u0000'\n引用数据类型:\nnull\n结论：\n① 第一个[]表示外层的数组。第二个[]表示内层的嵌套数组。\n② 外层的数组中存储的内层嵌套数组的引用地址。\n代码 /** 1.二维数组声明与赋值 ① 动态初始化 数据类型[][] 数组名称 = new 数据类型[长度1][长度2]; 注意： 长度2可以省略不写的。 但是省略后，需要先赋值再使用。 ② 静态初始化 数据类型[][] 数组名称 = new 数据类型[][]{{},{},{}} ③ 静态初始化的简写形式 数据类型[][] 数组名称 = {{},{},{}} 2.默认值： 基本数据类型： 整数类型： byte short int long 0 浮点数类型:float double 0.0 布尔类型: false 字符类型:\u0026#39;\\u0000\u0026#39; 引用数据类型: null 3.二维数组的遍历： */ class 二维数组 { public static void main(string[] args) { //① 动态初始化 int[][] arr = new int [3][5]; //system.out.println(arr[0][0]); //system.out.println(arr[0]); //③ 静态初始化的简写形式 int[][] arr1 = {**{1,2,3},{4,5},{7,8,9,10}**}; //system.out.println(arr1[0][1]); //system.out.println(arr1[1][0]); //system.out.println(arr1[2][2]); //② 静态初始化 int[][] arr2 = new int[][]{**{1,2,3},{4,5},{7,8,9,10}**}; //system.out.println(arr2[1][0]); //动态初始化需要注意的问题：但是省略后，需要先赋值再使用。 int[][] arr3 = new int[3][]; arr3[1] = new int[3]; //system.out.println(arr3[1][0]); //二维数组的遍历: for (int i = 0; i\u0026lt;arr2.length ;i++ ) { for (int j = 0; j\u0026lt;arr2[i].length ; j++) { system.out.print( arr2[i][j] +\u0026#34;\\t\u0026#34;); } system.out.println(); } } } ","date":"2021-10-18","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430210364/","summary":"数组 数组的概念 用来存储数据的，多个变量组成的一个整体，用来便于批量操作数据的。 ​ 元素：每一个数组中的变量空间。 ​ 格式： ​ 数组名称[索引] ​ 索引:每个元素的编号 称","title":"数组"},{"content":"方法 方法概述 方法是社么： 具有特定的代码段。\n方法的声明： [权限修饰符][修饰符] 返回值类型 方法名称 (参数列表){ 方法体; } ① 权限修饰符：public ② 修饰符: static ③ 返回值类型: void 无返回值的。 ④ 方法名称：任意标识符。 注意：程序的入口 在javase阶段，就是main。 ⑤ 参数： 实质： 外界传入的数据。 格式： (数据类型 参数名称,数据类型 参数名称) 实参与形参：\n实参：实际参数： 方法调用时，传递的数据\n形参：形式参数：方法声明时，声明的参数名称\n方法的使用 不调用 不执行。\n调用格式：\n如果在同一个类中，直接用方法名称调用。\n如果在不同类中，通过对象的名称.方法()\n代码 /** 1.方法： 具有特定的代码段。 2.方法的声明： [权限修饰符][修饰符] 返回值类型 方法名称 (参数列表){ 方法体; } ① 权限修饰符：public ② 修饰符: static ③ 返回值类型:1\u0026gt; void 无返回值的。 ④ 方法名称：任意标识符。 注意：程序的入口 在javase阶段，就是main。 ⑤ 参数：实质：外界传入的数据。 格式：(数据类型 参数名称,数据类型 参数名称) 3.方法的使用： 不调用 不执行。 调用格式： 1》 如果在同一个类中，直接用方法名称调用。 2》 如果在不同类中，通过对象的名称.方法() */ class 方法概述{ public static void main(string[] args) { //printrect(1); //printrect(2); //printrect(3); } public static void printrect(int a){ //数据类型 变量名称 = 值 for (int i = 1; i \u0026lt;=a; i++ ) { for (int j = 1; j\u0026lt;=a;j++ ) { system.out.print(\u0026#34;*\u0026#34;); } system.out.println(); } } } 方法的概述 1.方法的返回值：\nvoid 无返回值\n数据类型 有返回值的\n格式：\n[权限修饰符][修饰符] 数据类型 方法名称(参数列表){ 方法体; return 数据; }\n​\t其中，return后面的数据是哪种类型，方法声明上的数据类型就是哪个。\n2.带有返回值的方法调用：\n​\t① 通过变量记录返回值。\n​\t② 直接在输出语句中打印。\n​\t③ 作为方法的参数使用。\n3.return 关键字：\n​\t表示方法返回调用位置并结束该方法。\n​\t① return + 数据值 表示方法的返回值\n​\t② return 单独用 表示方法结束，实质方法中默认含有return，我们没写，编译器为我们添加。\n代码 /** 1.方法的返回值： 1》 void 无返回值 2》 数据类型 有返回值的 格式：[权限修饰符][修饰符] 数据类型 方法名称(参数列表){ 方法体; return 数据; } 其中，return后面的数据是哪种类型，方法声明上的数据类型就是哪个。 2.带有返回值的方法调用： ① 通过变量记录返回值。 ② 直接在输出语句中打印。 ③ 作为方法的参数使用。 3.return 关键字： 表示方法返回调用位置并结束该方法。 ① return + 数据值 表示方法的返回值 ② return 单独用 表示方法结束，实质方法中默认含有return， 我们没写，编译器为我们添 加。 */ class 方法的返回值 { public static void main(string[] args) { //① 通过变量记录返回值 /* int value = add(1,2); //1+2的基础上 +3 system.out.println(value +\u0026#34;=============\u0026#34;); */ //② 直接在输出语句中打印。 //system.out.println(add(1,2)); //③ 作为方法的参数使用。 //system.out.println(add(add(1,2),3)); /* add(1,2); scanner sc = new scanner(system.in); int value1 = sc.nextint(); */ //add(3,4); show(); } //加法 public static int add(int a,int b){ //system.out.println(a+b); return a+b; } public static void add1(int a,int b,int c){ system.out.println(a+b+c); } public static void show(){ if(true){ system.out.println(\u0026#34;bbbb\u0026#34;); return; //默认编译器会加，我们省略不写。 } system.out.println(\u0026#34;aaaa\u0026#34;); } } 方法的重载 方法的好处 提高代码的复用性\n方法的重载 1.好处： 为了降低程序员记忆的复杂度。\n2.方法重载 overload\n​\t在同一个类中，方法名称相同，参数列表不同，称为方法重载。\n与返回值类型无关。\n参数列表不同:\n参数个数不同。 参数数据类型不同。 参数顺序不同。\n/** 1.好处： 为了降低程序员记忆的复杂度。 (***)2.方法重载 overload 在同一个类中，方法名称相同，参数列表不同，称为方法重载。 1\u0026gt; 与返回值类型无关。 2\u0026gt; 参数列表不同: ① 参数个数不同。 ② 参数数据类型不同。 ③ 参数顺序不同。 */ class 方法的重载 { public static void main(string[] args) { //add(10,15); //add(1,2,3); //system.out.println(1); //system.out.println(\u0026#34;abc\u0026#34;); add(10.1,10); } /*public static int add(int a,int b){ return a+b; }*/ // ① 参数个数不同。 /*public static void add(int c,int d){ system.out.println(11111111); }*/ public static void add(int a,int b ,int c){ } //② 参数数据类型不同。 public static void add(int a,double b){ system.out.println(2222222); } //③ 参数顺序不同。 public static void add(double a,int b){ system.out.println(333333); } } 方法的内存图 jvm运行时内存图 栈 stack\n​\t栈 : 运算受限的线性表。 只能从一端 进行插入和删除操作。\n栈的特点:\n​\t先进后出，后进先出。\n​\t栈底: 封口端\n​\t栈顶:可以进行插入或删除数据的。\n​\t压栈: 存入数据 push .\n​\t弹栈: 从里面取出数据。pop 方法 正在执行的方法，在栈中执行。 ","date":"2021-10-17","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430210211/","summary":"方法 方法概述 方法是社么： 具有特定的代码段。 方法的声明： [权限修饰符][修饰符] 返回值类型 方法名称 (参数列表){ 方法体; } ① 权限修饰符：public ② 修饰符: static ③","title":"方法"},{"content":"流程控制语句 概述 顺序结构 分支结构：多选一，选择结构 if语句 写法 格式：\nif(布尔类型的表达式){\n​\t语句体;\n}\n注意：\n如果表达式结果为true 执行语句体，否则，不执行。\nif-else语句 写法 格式：\nif(布尔类型的表达式){\n​\t语句体;\n}else{\n}\n注意：\nelse 表示否则的意思，当if后面的小括号中的值结果为false时，执行else中的语句。\nif-else-if结构 写法 格式：\nif(布尔类型的表达式){\n​\t语句体;\n}else if(布尔类型的表达式){\n}else if(布尔类型的表达式){\n}else if(布尔类型的表达式){\n}else{\n}\n注意：\n其中，else 可以省略。\nelse if(布尔类型的表达式) 可以有多个。\nif-else-if 是一个整体，遇到第一个表达式结果为true时，执行里面的语句，就算下面的\n条件为true也不执行。但是单个的if条件，必须会执行。\nswitchi-case语句 写法 格式：\nswitch(表达式){ ​\tcase 常量1: break;\n​\tcase 常量2:\n​\tcase 常量3:\n​\tdefault:\n}\n注意：\n① case有穿透现象，当case符合条件时，会从该位置开始向下执行，直到执行到switch语句体\n整个结束为止。\n② 如果需要打断穿透现象，需要使用关键字 break。表示中断。\n③ default 关键字表示当以上条件都不成立时，执行该语句，相当于if-else中的else。\n(***) ④ 表达式的数据类型问题：\nbyte short char int string(1.7jdk) 枚举\n循环结构 概述\n反复反复执行的操作\n结构分类\nwhile:\n1\u0026gt; while\n2\u0026gt;do-while\nfor:\nwhile循环结构 写法： 格式：\nwhile(布尔类型的表达式){\n​\t循环体;\n}\n注意： 布尔类型的表达式结果恒为true 表示死循环。\n可以通过控制布尔类型的表达式结果，来控制何时退出循环。\n实例： public class test { public static void main(string args[]) { int x = 10; while( x \u0026lt; 20 ) { system.out.print(\u0026#34;value of x : \u0026#34; + x ); x++; system.out.print(\u0026#34;\\n\u0026#34;); } } } 以上实例编译运行结果如下：\nvalue of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 do-while结构 写法： 1.格式：\ndo{\n​\t循环体;\n}while(布尔类型的表达式);\n(***)2.while与do-while的区别：\n① 写法：\ndo{\n循环体\n}while(表达式)\nwhile(表达式){\n循环体\n}\n注意： 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\ndo…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。\n对于do-while无论判断条件是否成立，都会至少执行一次，但是对于while来说，只能是判断条件成立，才会执行。\n布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false\n实例： public class test { public static void main(string args[]){ int x = 10; do{ system.out.print(\u0026#34;value of x : \u0026#34; + x ); x++; system.out.print(\u0026#34;\\n\u0026#34;); }while( x \u0026lt; 20 ); } } 以上实例编译运行结果如下：\nvalue of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 for循环 虽然所有循环结构都可以用 while 或者 do\u0026hellip;while表示，但 java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。\nfor循环执行的次数是在执行前就确定的。语法格式如下：\n写法： for (初始化语句 ; 循环的条件判断语句 ;初始化变量的自增){\n循环体;\n}\n执行流程： 1.先执行初始化语句① ，做条件判断，执行循环的条件判断语句② ，根据② 进行判断：\n1》 如果②结果为false ，退出循环\n2》 如果②结果为true，进入循环，执行循环体语句④ ，④ 执行完毕后，执行初始化变量的自增③\n3》根据②的判断结果，是否能进入循环体，此时就相当于跳转到1》 或 2》的步骤\n注意：\n1.初始化语句，只执行一次。\n2.初始化变量的自增，叫法上是这样说，但实际上既可以增也可以减。也可以叫迭代表达式。\n实例： public class test { public static void main(string args[]) { for(int x = 10; x \u0026lt; 20; x = x+1) { system.out.print(\u0026#34;value of x : \u0026#34; + x ); system.out.print(\u0026#34;\\n\u0026#34;); } } } 以上实例编译运行结果如下：\nvalue of x : 10 value of x : 11 value of x : 12 value of x : 13 value of x : 14 value of x : 15 value of x : 16 value of x : 17 value of x : 18 value of x : 19 java 增强 for 循环 java5 引入了一种主要用于数组的增强型 for 循环。\n写法： java 增强 for 循环语法格式如下:\nfor(声明语句 : 表达式) { //代码句子 } **声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。\n实例： public class test { public static void main(string args[]){ int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ){ system.out.print( x ); system.out.print(\u0026#34;,\u0026#34;); } system.out.print(\u0026#34;\\n\u0026#34;); string [] names ={\u0026#34;james\u0026#34;, \u0026#34;larry\u0026#34;, \u0026#34;tom\u0026#34;, \u0026#34;lacy\u0026#34;}; for( string name : names ) { system.out.print( name ); system.out.print(\u0026#34;,\u0026#34;); } } } 以上实例编译运行结果如下：\n10,20,30,40,50, james,larry,tom,lacy, 循环的中断 break： 中断循环\ncontinue：跳过本次循环，执行下一次循环\n注意：\n无论break或continue也好，中断或跳过的是循环体中，它下面的内容\nbreak 关键字 break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n语法 break 的用法很简单，就是循环结构中的一条语句：\nbreak; 实例 public class test { public static void main(string args[]) { int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ) { // x 等于 30 时跳出循环 if( x == 30 ) { break; } system.out.print( x ); system.out.print(\u0026#34;\\n\u0026#34;); } } } 以上实例编译运行结果如下：\n10 20 continue关键字 continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\n语法 continue 就是循环体中一条简单的语句：\ncontinue; 实例 public class test { public static void main(string args[]) { int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ) { if( x == 30 ) { continue; } system.out.print( x ); system.out.print(\u0026#34;\\n\u0026#34;); } } } 以上实例编译运行结果如下：\n10 20 40 50 循环的嵌套 循环套循环。\n常见的：\n双for循环\n1.格式：\nfor(){ //外循环\n​\tfor(){ //内循环\n​\t}\n}\n俗称：大圈套小圈\n总结：\n​\t外层控制行，内层控制列。\n","date":"2021-10-16","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430200635/","summary":"流程控制语句 概述 顺序结构 分支结构：多选一，选择结构 if语句 写法 格式： if(布尔类型的表达式){ ​ 语句体; } 注意： 如果表达式结果为true 执行语句体，否则，不执行","title":"流程控制语句"},{"content":"java基础语法 关键字和标识符 关键字：java赋予了特殊含义的单词。\n例如:\nclass类public公开的void无返回值\n关键字特点：\n一般都是小写。\n保留字:java暂时没用，但是不保证后面不用\ngoto const\n标识符:程序员为类、方法、变量等成员起的字符序列,用于区分不同的成员的,起标识作用的符号\n标识符起名规则:\n字母 数字 _ $ 组成，并且数字不能开头\n支持中文，区分大小写。但是不建议用中文，也不建议通过大小写区分。\n见名之意\n驼峰原则\n大驼峰:从每个单词首字母大写.给类起名.例如:axxbxx\n小驼峰:从第二个单词开始首字母大写.给变量、方法.例如:axxbxx\n不能用关键字。\n不能用java提供的类名。\nstring\n注释 注释作用：解释说明代码的.\n分类:\n单行注释：对一行有效 // 多行注释:对多行有效但是不能嵌套使用/* */由于不能嵌套这个地方中间用了一个空格。 文档注释:/** */由于不能嵌套，这个地方中间用了一个空格。 注释好处：\n解释说明 排错 梳理思路 代码:\n/** 1.注释作用：解释说明代码的. 2.分类: 1\u0026gt;单行注释：对一行有效// 2\u0026gt;多行注释:对多行有效但是不能嵌套使用/* */由于不能嵌套，这个地方中间用了一个空格。 3\u0026gt;文档注释:/** */由于不能嵌套，这个地方中间用了一个空格。 3.注释好处： ①解释说明 ②排错 ③梳理思路 */ 注释快捷键\n快捷键:\n注释：\n单行注释 // ctrl+ / 多行注释 ctrl+shift +/ 文档注释 权限修饰符 权限修饰符：\n四种权限： public：公开的，在整个项目中都可以访问。 protected：受保护的，当前包和其它包的子类。 default/friendly 这种就是省略不 写，表示该种，没有权限修饰符的 专门词。 默认的 本包可以访问 private 私有的 本类可以访问。 变量 、常量和数据类型 常量： 概念：内存中开辟的一块存储区域，该区域存储的值不能发生改变的，称为常量.\n例如：1 12.5 长虹 true\n常量的分类：\n字面值常量:例如：1 12.5 长虹 true\n整数常量 浮点数常量 字符常量 布尔常量\n符号常量: 例如： a b 变量： 概念：内存中开辟的一块存储区域，该区域存储的值可以改变，称为变量。 java 基本数据类型： 变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\n内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。\njava 的两大数据类型:\n内置数据类型 引用数据类型 基本数据类型(简单数据类型): java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\n整数类型： byte： byte 字节型 1个字节\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\n默认值是 0；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a = 100，byte b = -50。\nshort： short 短整型 2个字节\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nshort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n默认值是 0；\n例子：short s = 1000，short r = -20000。\nint： int 整型 4个字节\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n默认值是 0 ；\n例子：int a = 100000, int b = -200000。\nlong： long 长整型 8个字节\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n默认值是 0l；\n例子： long a = 100000l，long b = -200000l。 \u0026ldquo;l\u0026quot;理论上不分大小写，但是若写成\u0026quot;l\u0026quot;容易与数字\u0026quot;1\u0026quot;混淆，不容易分辩。所以最好大写。\n代码 class 整数类型 { public static void main(string[] args) { //声明一个byte类型的变量，存储数据100 /*byte b = 100; system.out.println(b);*/ //声明一个long类型的变量,存储数据1234567890123456 //注意: 默认没有指定数据类型时，为int类型，那么会存在溢出问题，需要加l或l表示是 long类型。 long l = 1234567890123456l; system.out.println(l); } } 浮点数类型 ： float： float 单精度浮点型 4个字节\nfloat 数据类型是单精度、32位、符合ieee 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n默认值是 0.0f；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 = 234.5f。\ndouble： double 双精度浮点型 8 个字节\ndouble 数据类型是双精度、64 位、符合 ieee 754 标准的浮点数；\n浮点数的默认类型为 double 类型；\ndouble类型同样不能表示精确的值，如货币；\n默认值是 0.0d；\n默认没有指定数据类型时，double为默认类型。\n浮点型在使用的时候，都会有精度损失问题。是一个近似值。在银行等要求精度高的项目中， 使用bigdecimal类来计算。\n代码 import java.math.bigdecimal; class 浮点数类型 { public static void main(string[] args) { //声明一个double类型的变量，并且赋值为12.5 double d = 12.51; system.out.println(d); bigdecimal bg = new bigdecimal(d); system.out.println(bg); //声明一个float类型的变量,并且赋值为12.51 //注意:为float类型数据赋值时，必须指定为float类型，可以通过加f或f表示 float f = 12.51f; bigdecimal bg1 = new bigdecimal(f); system.out.println(bg1); } } 字符类型： 字符类型:char 2个字节 0-65535\n① 常见写法:\n格式：\n\u0026lsquo;\u0026lsquo;引起来的单个字符\n例如：\u0026lsquo;a\u0026rsquo;\n② 数字\n③ unicode码的形式:\n格式:\u0026rsquo;\\u0000\u0026rsquo; ④ (***)转义字符：\n格式：\n\u0026lsquo;\\t\u0026rsquo;制表符 表示8个位置的空格\n\u0026lsquo;\\r\u0026rsquo;回车\n\u0026lsquo;\\n\u0026rsquo;换行\n在window系统下 \\r\\n连用\n代码\nclass 字符 { public static void main(string[] args) { // ① 常见写法: //声明一个变量 赋值为\u0026#39;a\u0026#39; /*char m = \u0026#39;我\u0026#39;; system.out.println(m);*/ // ② 数字 //声明一个变量，赋值为97 /*char m1 = 97; // m1 = m1 + 3; system.out.println(m1);*/ //③ unicode码的形式: /*char m2 = \u0026#39;\\u4e50\u0026#39;; system.out.println(m2);*/ /*④ 转义字符： 格式： \u0026#39;\\t\u0026#39;制表符 表示8个位置的空格 \u0026#39;\\r\u0026#39;回车 \u0026#39;\\n\u0026#39;换行 */ /*system.out.print(\u0026#34;aaa\u0026#34;); system.out.print(\u0026#39;\\t\u0026#39;); system.out.println(\u0026#34;bbb\u0026#34;);*/ system.out.println(\u0026#34;\\\u0026#34;\u0026#34;); } } 布尔类型： boolean：\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true/false 情况；\n默认值是 false；\n例子：boolean one = true。\nboolean 表示 值只有true或false 没有其他的值。\n代码\nclass 布尔类型 { public static void main(string[] args) { //声明一个布尔类型的变量 boolean flag = true ; boolean flag1 = false; } } 引用数据类型(复杂数据类型)： 数组\n类： string (不是基本数据类型)\n接口:\n字节: bit ：比特。计算机中存储的都是0或者1 ，一个0或者1表示一位，称为比特。\nbyte：8个0或者1表示一个字节。用b表示。\n1kb = 1024 b\nk m g t\n变量和常量的声明 变量格式：\n​\t数据类型 变量的名称(标识符)\n注意：\n​\t不能多次声明，但是可以多次赋值，对于变量来说。\n常量格式:\n​\tfinal 数据类型 常量的名称\n注意:\n​\t常量的名称 往往都大写\n变量和常量的赋值 变量的名称 = 数据值\n注意:\n​\t= 在java上有个专业术语 称为赋值符号，该符号将右侧的数据值赋值给左侧。\n声明与赋值的简写形式 数据类型 变量的名称 = 数据值\nfinal 数据类型 常量的名称 = 数据值\n代码 /** 1.变量的声明和赋值： ① 声明: 数据类型 变量名称 ② 赋值: 变量名称 = 数据值 */ class 变量 { public static void main(string[] args) { //声明一个int类型的变量，并且存储数据为15 //常量声明需要加final，变量不需要 /*final*/ int a ; //赋值 a = 15 ; system.out.println(a); a = 20; system.out.println(a); //声明一个常量 final int b ; } } 变量的作用域 变量的作用域 1.变量的作用域：\n变量的使用范围. 2.常见作用域:(位置)\n1\u0026gt; 全局变量: 类中方法外\n作用域：整个类中，类中所有的方法都可以使用该变量 2\u0026gt; 局部变量: 方法中\n作用域: 方法中，出了该方法，就不能被使用。 3.全局变量与局部变量区别：\n1\u0026gt; 局部变量要先声明赋值然后再使用。\n全局变量一旦声明后，就有默认值。 2\u0026gt; 当全局变量与局部变量重名时，就近原则，局部优先。\n4.全局变量的默认值.\n1\u0026gt; (***)基本数据类型：\n整数类型： byte short int long 默认值 0 浮点数类型: float double 默认值0.0 布尔类型: boolean 默认值false 字符类型： char 默认值 \u0026lsquo;\\u0000\u0026rsquo; 2\u0026gt; (***)引用数据类型:\nstring 默认值:null 代码 class 变量的作用域 { static int b = 20;//全局变量 static int c ; static byte b1; static short b2; static double d; static char c1; static boolean b3; static string s; public static void main(string[] args) { //声明一个int类型的变量 int a = 10; //局部变量 // 1\u0026gt; 局部变量要先声明赋值然后再使用。 int m = 5; //system.out.println(m); /*system.out.println(\u0026#34;c=\u0026#34;+c); system.out.println(\u0026#34;b1=\u0026#34;+b1); system.out.println(\u0026#34;b2=\u0026#34;+b2); system.out.println(\u0026#34;d=\u0026#34;+d); system.out.println(\u0026#34;c1=\u0026#34;+c1); system.out.println(\u0026#34;b3=\u0026#34;+b3); system.out.println(\u0026#34;s=\u0026#34;+s);*/ //重名问题 int b = 30; system.out.println(b); } public static void add() { system.out.println(c); } } 数据类型转换 数据类型转换 1.数据的运算 25 + 13\n2.操作数据，数据的运算原则:\n​\t同种数据类型进行运算,如果数据类型不同，要转换成相同数据类型才能运算。\n​\t并且运算结果也是同种数据类型。\n3.数据类型转换分类：\n​\t1》自动类型提升：从小的空间转换成大的空间。\n​\tbyte short char -\u0026gt; int-\u0026gt; long -\u0026gt; float -\u0026gt; double\n​\t注意：\n​\tbyte short char但凡运算，都会转成int类型。\n​\t2》强制类型转换: 从大的空间转换成小的空间。\n​\t格式：\n​\t(要转换成的数据类型) 要转换的变量/数据\n​\t注意：\n​\t强制类型转换可能会发生精度损失问题\n代码 class 数据类型转换 { public static void main(string[] args) { //1》自动类型提升 /*system.out.println( 25 + 13 ); //25 int 13 int ==\u0026gt; int system.out.println( 25 + 13.0 );//25 int 13 double ==\u0026gt; 25 double 13 double ==》double system.out.println( 25 / 13 );// 25 int 13 int ==\u0026gt; int system.out.println( 25/13.0 );*///25 int 13 double ==\u0026gt; 25 double 13 double ==》double //2》自动类型提升需要注意的事项,byte short char 都会自动转int类型，才运算。 byte a = 127; byte b = 1; /*byte c = a + b ;*/ //3》 强制类型转换 //将上述的数据 存储到byte类型的c中 byte c = (byte)(a + b); //system.out.println(c); char c1 = 97 ; c1 = (char)(c1 + 3); system.out.println(c1); } } 算术运算符 算术运算符 1.算术运算符:\n+ - * / ``%\n加 减 乘 除 取余/模\n2.++ /--\n自增 / 自减\n在变量原有基础上加1 然后赋值给变量.\n格式:\na++:变量在前 ,先取变量的值，然后自身加1\n++a:变量在后,先自身加1，然后再去变量的值\n3.加号的用法：\n① 加法：\n② 正号（正数）:+5 -5\n③ 表示字符串的拼接：\n但凡有一侧有字符串，表示字符串的拼接，如果两侧都是数字，表示加法运算\n代码： class 算术运算符 { public static void main(string[] args) { /*system.out.println( 5 % 2 ); system.out.println( 5 / 2 );*/ //自增 int a = 5; //a++ ; //++a; //int b = a++; //int b = ++a; //int b = (++a)+(a++)+(++a); int b = (a--) + (++a) + (--a)+ (a++); /*system.out.println(a); system.out.println(b);*/ //③ 表示字符串的拼接： string s = \u0026#34;abc\u0026#34;; system.out.println( 123 + 45 + s); } } 赋值运算符 赋值运算符 用来给变量赋值\n1.赋值运算符 :\n基本赋值运算符: =\n扩展赋值运算符: += 、 -= 、 *= 、 /= 、 %= 2.作用：\n① 简化书写。\n② 自动类型转换。\n注意：\n可能会有精度损失问题。\n代码 class 赋值运算符 { public static void main(string[] args) { int a = 5; int b = 7 ; b = b + a; //简写 b += a;// b = b+a byte m = 10; byte k = 15; //笔试简单题:以下两种方式，哪种可以编译成功。第一种可以编译成功，第二种不行， //不行的原因在于，对于数据类型运算来说，byte类型的数据需要转换成int才能运算， //不能放置在byte类型的空间里，如果要放,必须要强制类型转换，而第一种，可以自动类 型转换。 //k -= m; k = k-m ; } } 比较运算符 比较运算符 1.比较运算符:\n\u0026gt; \u0026lt; \u0026gt;= \u0026lt;=\n== 等于\n!=不等于\n运算结果：都是布尔类型的值 true/false\n注意:\na \u0026lt; b \u0026lt; c 在java中不允许，java中比较运算只有一个运算符。\n如果非要用这种形式，可以通过逻辑运算符进行连接。\n代码 class 比较运算符 { public static void main(string[] args) { system.out.println( 2 \u0026gt; 3); system.out.println(2 == 5 ); system.out.println(3 != 5); } } 逻辑运算符 逻辑运算符 \\1. 逻辑运算符\n​\t\u0026amp; \u0026amp;\u0026amp; | || ^ ! 与 逻辑与 或 逻辑或 异或 非\n\\2. \u0026amp; 与：集合中的交集\n​\ttrue \u0026amp; true \u0026ndash;》 true\n​\ttrue \u0026amp; false \u0026ndash;》 false\n​\tfalse \u0026amp; true \u0026ndash;》 false\n​\tfalse \u0026amp; false \u0026ndash;》 false\n3.\u0026amp;\u0026amp;与\u0026amp;的区别：\n​\t\u0026amp;\u0026amp; 称为短路与，一般用于逻辑运算。当第一个表达式结果为false的情况下，第二个表达式不再执行。\n​\t\u0026amp; 一般用于位运算，不参与逻辑运算。\n4.| 或： 集合中的并集\n​\ttrue | true \u0026ndash;》 true\n​\ttrue | false \u0026ndash;》 true\n​\tfalse | true \u0026ndash;》 true\n​\tfalse | false \u0026ndash;》 false\n\\5. (***)||与|的区别\n​\t|| 称为短路或，一般用于逻辑运算。当第一个表达式结果为true的情况下，第二个表达式不再执行。\n​\t| 一般用于位运算，不参与逻辑运算。\n6.^ 异或 :相同为false 相异为true\n7.! 非 ，取反\n代码 class 逻辑运算符 { public static void main(string[] args) { //a\u0026lt;b\u0026lt;c b大于2 小于10 int b = 5; /*system.out.println(2 \u0026lt; b || (++b) \u0026lt; 10); system.out.println(b);*/ //^ 异或 :相同为false 相异为true //system.out.println(true ^ false ); // 7.! 非 system.out.println(!false); } } 三元运算符 三元运算符 1.三元运算符 ： 三目运算符\n格式：\n​\t结果为true或false\n表达式 ? 表达式1(true) : 表达式2 (false) 注意：\n​\t其中 表达式1 和2 ，数据类型其实可以不一致，但是建议一致。\n代码 class 三元运算符 { public static void main(string[] args) { int a = 5; system.out.println(a\u0026gt;7 ? 1 : 2); //string b = a\u0026gt;7 ? \u0026#34;1\u0026#34; :2; system.out.println(a\u0026gt;7 ? \u0026#34;1\u0026#34; :2); } } 进制 进制 常见进制\n​\t① 二进制：组成0 1 ，前缀0b\n​\t② 八进制：组成0-7， 前缀0\n③ 十进制：组成 0-9\n④ 十六进制：组成0-9 abcdef 10-15用字符来表示,前缀0x\n计算机的进制：二进制\n① 数的进制：逢?进一\n二进制: 0 1\n八进制: 0-7\n十进制: 0-9\n十六进制: 0-9 a-f a 10 b 11 c 12 d 13 e 14 f 15\n② 写法：\n15 默认为十进制。\n二进制前缀 0b\n八进制 0\n十六进制 0x\n③ 进制的转换:\n十进制与二进制之间的转换:\n将十进制转换成二进制: 除商取余倒序输出\n转换成二进制：除以2，直到商为0，将余数倒序输出。\n例如：\n13\n转成二进制：\n1101 十进制转其它进制\n除商取余倒序输出，转几进制就除以几，直到商为0，倒序输出余数\n将二进制转换成十进制: 位权法\n位权:每一位上代表的基数值\n位权指数制中每一固定位置对应的单位值\n例如 ：十进制 1025 \u0026ndash;》 1 表示千位 位权 10^3 2 表示十位 位权 10^1\n二进制 1101 \u0026ndash;》 任意进制转换成十进制\n位权法： 系数乘以该进制的位权之和。\n二进制与八 、十六进制转换\n三个二进制位表示一个八进制位，四个二进制位表示一个十六进制位。\n例如：\n015\n转二进制\n00001101\n代码：\n/**1.常见进制: ① 二进制：组成0 1 ，前缀0b ② 八进制：组成0-7， 前缀0 ③ 十进制：组成 0-9 ④ 十六进制：组成0-9 abcdef 10-15用字符来表示,前缀0x 2.进制转换： ① 十进制与二进制转换。 */ class 进制 { public static void main(string[] args) { system.out.println(0b11); system.out.println(23); system.out.println(023); system.out.println(0x23); } } 计算机中数据的存储 概述 1.计算机中数据存储都是以二进制的形式进行存储。\n(***)2.数据存放以二进制补码的形式进行存放。\n3.一个字节为例：\n+0 0000 0000\n-0 1000 0000\n4.计算机中正数 表示时，最高位，表示符号位，如果为0 表示正数。如果为1，表示负数。\n5.补码形式：\n1》 原码： 符号位 + 该数的绝对值的表示形式\n2》 反码： 除了符号位之外，按位取反。\n3》 补码： 反码 + 1\n6.其中，正数的补码与原码相同，负数的补码等于 反码+1\n例如：\n一个字节为例：\n13\n原码： 0000 1101\n补码： 0000 1101\n-13\n原码： 1000 1101\n反码： 1111 0010 反码+1\n补码： 1111 0011\n两个字节：\n-13\n原码: 1000 0000 0000 1101\n反码： 1111 1111 1111 0010\n补码： 1111 1111 1111 0011\n例如：\n一个字节：\n25\n原码： 0001 1001\n补码： 0001 1001\n- 25\n原码： 1001 1001\n反码： 1110 0110\n补码： 1110 0111\n从计算机中取出二进制的数据 byte a= 127 :0000 0000 0000 0000 0000 0000 0111 1111\nbyte b =1 :0000 0000 0000 0000 0000 0000 0000 0001\n+ ======\u0026gt; 0000 0000 0000 0000 0000 0000 1000 0000\n+= ======\u0026gt; 1000 0000 计算机 该数由于最高位为1 表示就是负数\n补码：1000 0000\n反码：1111 1111 补码-1\n原码：1000 0000\n例如：\n一个字节：\n10010011\n该数 在计算机中表示补码。\n该数由于是一个字节，最高位1，该数表示的负数。反码 \u0026ndash;》 原码\n反码： 1001 0010\n原码： 1110 1101\n- 109\n二个字节：\n该数在计算机中表示正数，补码与原码相同。\n总结 计算机数据的存储：\n① 将数据存储到计算机：其它进制转二进制。数据存储 以补码形式存放。正数原码与补码相同，负\n数以补码形式存储。\n正数最高位为0 ，负数最高位为1.\n② 从计算机中取出：\n根据字节数判断最高位是多少，最高位为0 表示该数是正数，最高位为1 表示该数是负数。\n位运算 概述 \u0026laquo; \u0026raquo; \u0026raquo;\u0026gt; ^ \u0026amp; |\n\u0026laquo; 1.\u0026laquo; 左移：按位向左侧移动，左移后，空位全补0\n格式：\n操作数 \u0026laquo; 左移的位数\n规律(一般规律，会有特殊情况)：\n左移多少位，就相当于操作数乘以2的多少次幂\n例如：\n5 \u0026laquo; 1\n以一个字节为例：\n5的二进制： 0000 0101\n0000 1010\n**\n\u0026raquo; \\2. \u0026raquo; 右移：又称有符号右移，按位向右侧移动，右移后，空位按最高位补，最高位为1补1 最高位\n为0 补0\n格式：\n操作数 \u0026raquo; 右移的位数\n规律(正数一般规律,会有特殊情况:)\n右移多少位，相当于操作数除以2的多少次幂\n例如：\n5 \u0026raquo; 1\n\u0026raquo;\u0026gt; 3.\u0026raquo;\u0026gt; 右移 ：又称无符号右移，按位向右侧移动。 右移后，空位全部补0.\n格式：\n操作数 \u0026raquo;\u0026gt; 右移的位数\n4.\u0026amp; | ^\n\u0026amp; 按位于\n| 按位或\n^ 按位异或 ： 相同为0 不同为1\n~ 取反\n代码 /** 1.\u0026lt;\u0026lt; 左移：按位向左侧移动，左移后，空位全补0 格式： 操作数 \u0026lt;\u0026lt; 左移的位数 规律(一般规律，会有特殊情况)： 左移多少位，就相当于操作数乘以2的多少次幂 2. \u0026gt;\u0026gt; 右移：又称有符号右移，按位向右侧移动，右移后，空位按最高位补，最高位为1补1 最高位 为0 补0 格式：操作数 \u0026gt;\u0026gt; 右移的位数 规律(正数一般规律,会有特殊情况:) 右移多少位，相当于操作数除以2的多少次幂。 3.\u0026gt;\u0026gt;\u0026gt; 右移 ：又称无符号右移，按位向右侧移动。 右移后，空位全部补0. 格式：操作数 \u0026gt;\u0026gt;\u0026gt; 右移的位数 4.\u0026amp; | ^ \u0026amp; 按位于 | 按位或 ^ 按位异或 ： 相同为0 不同为1 ~ 取反 */ class 位运算 { public static void main(string[] args) { // 1.\u0026lt;\u0026lt; 左移 /*system.out.println(5 \u0026lt;\u0026lt; 1); system.out.println(5 \u0026lt;\u0026lt; 2); system.out.println(5 \u0026lt;\u0026lt; 3); system.out.println(5 \u0026lt;\u0026lt; 4);*/ // 2.\u0026gt;\u0026gt; 右移 /*system.out.println(5 \u0026gt;\u0026gt; 1); system.out.println(5 \u0026gt;\u0026gt; 2); system.out.println(5 \u0026gt;\u0026gt; 3); system.out.println( -5 \u0026gt;\u0026gt; 1); system.out.println( -5 \u0026gt;\u0026gt; 2); system.out.println( -5 \u0026gt;\u0026gt; 3);*/ //3.\u0026gt;\u0026gt;\u0026gt; 无符号右移 /*system.out.println(-5 \u0026gt;\u0026gt;\u0026gt; 1); system.out.println(-5 \u0026gt;\u0026gt;\u0026gt; 2); system.out.println(-5 \u0026gt;\u0026gt;\u0026gt; 3); system.out.println(-5 \u0026gt;\u0026gt; 1); system.out.println(-5 \u0026gt;\u0026gt; 2); system.out.println(-5 \u0026gt;\u0026gt; 3);*/ // 4.\u0026amp; | ^ /*system.out.println(2 \u0026amp; 3); system.out.println(2 | 3); system.out.println(2 ^ 3);*/ //异或 既可以做位运算也可以做逻辑运算 //system.out.println(true ^ false); system.out.println(~2); } } ","date":"2021-10-15","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430195346/","summary":"Java基础语法 关键字和标识符 关键字：java赋予了特殊含义的单词。 例如: class类public公开的void无返回值 关键字特点： 一般都是小写。 保留字:jav","title":"java基础语法"},{"content":"java基础知识总结（超级经典）\n写代码：\n1，明确需求。我要做什么？\n2，分析思路。我要怎么做？1,2,3。\n3，确定步骤。每一个思路部分用到哪些语句，方法，和对象。\n4，代码实现。用具体的java语言代码把思路体现出来。\n学习新技术的四点：\n1，该技术是什么？\n2，该技术有什么特点(使用注意)：\n3，该技术怎么使用。demo\n4，该技术什么时候用？test。\n——————————————————————————————————————————————————————\n一：java概述：\n1991 年sun公司的james gosling等人开始开发名称为 oak 的语言，希望用于控制嵌入在有线电视交换盒、pda等的微处理器；\n1994年将oak语言更名为java；\njava的三种技术架构:\njavaee：java platform enterprise edition，开发企业环境下的应用程序，主要针对web程序开发；\njavase：java platform standard edition，完成桌面应用程序的开发，是其它两者的基础；\njavame：java platform micro edition，开发电子消费产品和嵌入式设备，如手机中的程序；\n**1，jdk：java development kit：**java的开发和运行环境，java的开发工具和jre。\n2，jre：java runtime environment：java程序的运行环境，java运行的所需的类库+jvm(java虚拟机)。\n3，配置环境变量：让java jdk\\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。\n环境变量的配置：\n①：永久配置方式：java_home=%安装路径%\\java\\jdk\npath=%java_home%\\bin\n②：临时配置方式：set path=%path%;c:\\program files\\java\\jdk\\bin\n特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。\nclasspath的配置:\n①：永久配置方式：classpath=.;c:\\;e:\\\n②：临时配置方式：set classpath=.;c:\\;e:\\\n注意：在定义classpath环境变量时，需要注意的情况\n如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件；\n如果指定了classpath，那么会在指定的目录下查找要运行的类文件。\n还会在当前目录找吗？两种情况：\n①：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。\n②：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。\n一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。\n4，javac命令和java命令做什么事情呢？\n要知道java是分两部分的：一个是编译，一个是运行。\njavac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。\njava：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数.\n——————————————————————————————————————————————————————\n二：java语法基础：\n1，关键字：其实就是某种语言赋予了特殊含义的单词。\n保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。 2，标示符：其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0—9、a—z、$、_ ；\n注意：\n①：数字不可以开头。\n②：不可以使用关键字。\n3，常量：是在程序中的不会变化的数据。\n4，变量：其实就是内存中的一个存储空间，用于存储常量数据。\n作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。\n特点：变量空间可以重复使用。 **什么时候定义变量？**只要是数据不确定的时候，就定义变量。\n变量空间的开辟需要什么要素呢？\n①：这个空间要存储什么数据？数据类型。\n②：这个空间叫什么名字啊？变量名称。\n③：这个空间的第一次的数据是什么？ 变量的初始化值。\n变量的作用域和生存期:\n变量的作用域：\n作用域从变量定义的位置开始，到该变量所在的那对大括号结束；\n生命周期：\n变量从定义的位置开始就在内存中活了；\n变量到达它所在的作用域的时候就在内存中消失了；\n数据类型：\n①：基本数据类型：byte、short、int、long、float、double、char、boolean ②：引用数据类型: 数组、类、接口。\n级别从低到高为：byte,char,short(这三个平级)——\u0026gt;int——\u0026gt;float——\u0026gt;long——\u0026gt;double\n自动类型转换：从低级别到高级别，系统自动转的；\n强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量；\n运算符号：\n①、算术运算符。\n+ — * / % %:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。\n+:连接符。\n++,——\n②、赋值运算符。\n= += —= *= /= %=\n③、比较运算符。\n特点：该运算符的特点是：运算完的结果，要么是true，要么是false。 ④、逻辑运算符。\n\u0026amp; | ^ ! \u0026amp;\u0026amp; ||\n逻辑运算符除了 ! 外都是用于连接两个boolean类型表达式。\n\u0026amp;: 只有两边都为true结果是true。否则就是false。\n|:只要两边都为false结果是false，否则就是true\n^:异或：和或有点不一样。\n两边结果一样，就为false。\n两边结果不一样，就为true.\n\u0026amp; 和 \u0026amp;\u0026amp;区别： \u0026amp; ：无论左边结果是什么，右边都参与运算。\n\u0026amp;\u0026amp;:短路与，如果左边为false，那么右边不参数与运算。\n| 和|| 区别： |：两边都运算。\n||：短路或，如果左边为true，那么右边不参与运算。\n⑤、位运算符:用于操作二进制位的运算符。\n\u0026amp; | ^ \u0026laquo; \u0026raquo; \u0026raquo;\u0026gt;(无符号右移)\n练习：对两个变量的数据进行互换。不需要第三方变量。\nint a = 3,b = 5;//——\u0026gt;b = 3,a = 5;\na = a + b; a = 8;\nb = a — b; b = 3;\na = a — b; a = 5;\na = a ^ b;//\nb = a ^ b;//b = a ^ b ^ b = a\na = a ^ b;//a = a ^ b ^ a = b;\n练习：高效的算出 2*8 = 2\u0026laquo;3;\n5，语句。\nif switch do while while for 这些语句什么时候用？\n1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。\n但是建议使用switch，效率相对较高。\nswitch(变量){\ncase 值:要执行的语句;break;\n…\ndefault:要执行的语句;\n}\n工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了\n就执行哪个case后面的语句，如果没有相同的则执行default后面的语句；\n细节：①：break是可以省略的，如果省略了就一直执行到遇到break为止；\n②、switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种；\n③、default可以写在switch结构中的任意位置；如果将default语句放在了第一行，\n则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。\n2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。\n3）、当某些语句需要执行很多次时，就用循环结构。\nwhile和for可以进行互换。\n区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。\nbreak:作用于switch ，和循环语句，用于跳出，或者称为结束。\nbreak语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。\ncontinue:只作用于循环结构，继续循环用的。\n作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。\n6，函 数：为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。\njava中的函数的定义格式：\n修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){\n执行语句；\nreturn 返回值；\n}\n当函数没有具体的返回值时，返回的返回值类型用void关键字表示。\n如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。\nreturn的作用：结束函数。结束功能。\n如何定义一个函数？\n函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成：\n①、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。\n②、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型\u0026amp;参数个数)。\n函数的作用：\n1）、用于定义功能。\n2）、用于封装代码提高代码的复用性。\n注意：函数中只能调用函数，不能定义函数。\n主函数：\n1）、保证该类的独立运行。\n2）、因为它是程序的入口。\n3）、因为它在被jvm调用。\n函数定义名称是为什么呢？\n答：1）、为了对该功能进行标示，方便于调用。\n2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。\n重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。\n如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。\n7，数 组：用于存储同一类型数据的一个容器。\n好处：可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。\n如何在java中表现一个数组呢？两种表现形式。\n1）、元素类型[] 变量名 = new 元素类型[元素的个数]；\n2）、元素类型[] 变量名 = {元素1，元素2\u0026hellip;}；\n元素类型[] 变量名 = new 元素类型[]{元素1，元素2\u0026hellip;}；\n——————————————————————————————————————————————————————\n//二分查找法。必须有前提：数组中的元素要有序。 public static int halfseach_2(int[] arr,int key){\nint min,max,mid;\nmin = 0;\nmax = arr.length—1;\nmid = (max+min)\u0026raquo;1; //(max+min)/2;\nwhile(arr[mid]!=key){\nif(key\u0026gt;arr[mid]){\nmin = mid + 1;\n}\nelse if(key\u0026lt;arr[mid])\nmax = mid — 1;\nif(max\u0026lt;min)\nreturn —1;\nmid = (max+min)\u0026raquo;1;\n}\nreturn mid;\n}\n——————————————————————————————————————————————————————\njava分了5片内存。\n1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。\n栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；\n只要数据运算完成所在的区域结束，该数据就会被释放。\n堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。\n1：每一个实体都有内存首地址值。\n2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。 3：垃圾回收机制。\n——————————————————————————————————————————————————————\n三：面向对象：★★★★★\n特点：1：将复杂的事情简单化。\n2：面向对象将以前的过程中的执行者，变成了指挥者。\n3：面向对象这种思想是符合现在人们思考习惯的一种思想。\n过程和对象在我们的程序中是如何体现的呢？\n过程其实就是函数；\n对象是将函数等一些内容进行了封装。\n匿名对象使用场景：\n1：当对方法只进行一次调用的时候，可以使用匿名对象。\n2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。\n在类中定义其实都称之为成员。成员有两种：\n1：成员变量：其实对应的就是事物的属性。\n2：成员函数：其实对应的就是事物的行为。\n所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。\nprivate int age;//私有的访问权限最低，只有在本类中的访问有效。\n注意：私有仅仅是封装的一种体现形式而已。\n私有的成员：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，\n可以通过对外提供函数的形式对其进行访问。\n好处：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。\n总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。\n这个方法一般有两个，规范写法：对于属性 xxx，可以使用setxxx(),getxxx()对其进行操作。\n类中怎么没有定义主函数呢？\n注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。\n主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。\n成员变量和局部变量的区别：\n1：成员变量直接定义在类中。\n局部变量定义在方法中，参数上，语句中。\n2：成员变量在这个类中有效。\n局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。\n3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。\n局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。\n构造函数：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。\n特点：\n1：该函数的名称和所在类的名称相同。\n2：不需要定义返回值类型。\n3：该函数没有具体的返回值。\n记住：所有对象创建时，都需要初始化才可以使用。\n注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，\n为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。\n一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，\n一个类中如果出现多个构造函数。它们的存在是以重载体现的。\n构造函数和一般函数有什么区别呢？\n1：两个函数定义格式不同。\n2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。\n一般函数，是对象创建后，需要调用才执行，可以被调用多次。\n什么时候使用构造函数呢？\n分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。\n构造代码块和构造函数有什么区别？\n构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。\n构造函数：是给与之对应的对象进行初始化。它具有针对性。\nperson p = new person();\n创建一个对象都在内存中做了什么事情？\n1：先将硬盘上指定位置的person.class文件加载进内存。\n2：执行main方法时，在栈内存中开辟了main方法的空间(压栈—进栈)，然后在main方法的栈区分配了一个变量p。\n3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new\n4：在该实体空间中进行属性的空间分配，并进行了默认初始化。\n5：对空间中的属性进行显示初始化。\n6：进行实体的构造代码块初始化。\n7：调用该实体对应的构造函数，进行构造函数初始化。（）\n8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)\n——————————————————————————————————————————————————————\n封 装**（面向对象特征之一）**：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。\n好处：将变化隔离；便于使用；提高重用性；安全性。\n封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。\nthis:代表对象。就是所在函数所属对象的引用。\nthis到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。\n开发时，什么时候使用this呢？\n在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。\nthis 还可以用于构造函数间的调用。\n调用格式：this(实际参数)；\nthis对象后面跟上 . 调用的是成员属性和成员方法(一般方法)；\nthis对象后面跟上 () 调用的是本类中的对应参数的构造函数。\n注意：用this调用构造函数，必须定义在构造函数的第一行。\n因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。\nstatic：★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。\n特点：\n1，想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。\n**2，被静态修饰的成员，可以直接被类名所调用。**也就是说，静态的成员多了一种调用方式。类名.静态方式。\n3，静态随着类的加载而加载。而且优先于对象存在。\n弊端：\n1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。\n2，静态方法只能访问静态成员，不可以访问非静态成员。\n因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。\n3，静态方法中不能使用this，super关键字。\n因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。\n4，主函数是静态的。\n**什么时候定义静态成员呢？**或者说：定义成员时，到底需不需要被静态修饰呢？\n成员分两种：\n1，成员变量。（数据共享时静态化）\n该成员变量的数据是否是所有对象都一样：\n如果是，那么该变量需要被静态修饰，因为是共享的数据。 如果不是，那么就说这是对象的特有数据，要存储到对象中。 2，成员函数。（方法中没有调用特有数据时就定义成静态）\n如果判断成员函数是否需要被静态修饰呢？\n只要参考，该函数内是否访问了对象中的特有数据：\n如果有访问特有数据，那方法不能被静态修饰。\n如果没有访问过特有数据，那么这个方法需要被静态修饰。\n成员变量和静态变量的区别：\n1，成员变量所属于对象。所以也称为实例变量。\n静态变量所属于类。所以也称为类变量。\n2，成员变量存在于堆内存中。\n静态变量存在于方法区中。\n3，成员变量随着对象创建而存在。随着对象被回收而消失。\n静态变量随着类的加载而存在。随着类的消失而消失。\n4，成员变量只能被对象所调用 。\n静态变量可以被对象调用，也可以被类名调用。\n所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。\n静态的注意：静态的生命周期很长。\n**静态代码块：**就是一个有静态关键字标示的一个代码块区域。定义在类中。\n作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。\npublic：访问权限最大。\nstatic：不需要对象，直接类名即可。\nvoid：主函数没有返回值。\nmain：主函数特定的名称。\n(string[] args)：主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new string[0]。\njvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。\n静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块 ———\u0026gt; 构造代码块 ———\u0026gt; 构造函数；\n生成java帮助文档：命令格式：javadoc –d 文件夹名 –auther –version *.java\n//格式\n/** *类描述\n*@author 作者名\n*@version 版本号\n*/\n/**\n*方法描述\n*@param 参数描述\n*@return 返回值描述\n*/\n——————————————————————————————————————————————————————\n设计模式：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。\njava中有23种设计模式：\n单例设计模式：★★★★★\n解决的问题：保证一个类在内存中的对象唯一性。\n比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。\nruntime()方法就是单例设计模式进行设计的。\n如何保证对象唯一性呢？\n思想：\n1，不让其他程序创建该类对象。\n2，在本类中创建一个本类对象。\n3，对外提供方法，让其他程序获取这个对象。\n步骤：\n1，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；\n2，就在类中创建一个本类的对象；\n3，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）\n代码体现：\n1，私有化构造函数；\n2，创建私有并静态的本类对象；\n3，定义公有并静态的方法，返回该对象。\n——————————————————————————————————————————————————————\n饿汉式\nclass single{\nprivate single(){} //私有化构造函数。\nprivate static single s = new single(); //创建私有并静态的本类对象。\npublic static single getinstance(){ //定义公有并静态的方法，返回该对象。\nreturn s;\n}\n}\n——————————————————————————————————————————————————————\n懒汉式:延迟加载方式。\nclass single2{\nprivate single2(){}\nprivate static single2 s = null;\npublic static single2 getinstance(){\nif(s==null)\ns = new single2();\nreturn s;\n}\n}\n——————————————————————————————————————————————————————\n继 承（面向对象特征之一）\n好处：\n1：提高了代码的复用性。\n2：让类与类之间产生了关系，提供了另一个特征多态的前提。\n父类的由来：其实是由多个类不断向上抽取共性内容而来的。\njava中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。\n单继承：一个类只能有一个父类。\n多继承：一个类可以有多个父类。\n为什么不支持多继承呢？\n因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。\n但是java支持多重继承。a继承b b继承c c继承d。\n多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。\n所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。\n简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。\n子父类出现后，类中的成员都有了哪些特点：\n1：成员变量。\n当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。\n如果想要调用父类中的属性值，需要使用一个关键字：super this：代表是本类类型的对象引用。\nsuper：代表是子类所属的父类中的内存空间引用。\n注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。\n2：成员函数。\n当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)\n什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。\n3：构造函数。\n发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?\n原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();\nsuper(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。\n为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)\n因为子类继承父类，会继承到父类中的数据，必须要看父类是如何对自己的数据进行初始化的。\n所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。\n注意：\n子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();\n如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。\n如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。\n问题：super()和this()是否可以同时出现的构造函数中。\n两个语句只能有一个定义在第一行，所以只能出现其中一个。\nsuper()或者this():为什么一定要定义在第一行？\n因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。\n继承的细节：\n什么时候使用继承呢？\n当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。\n英文书中，所属关系：\u0026quot; is a \u0026quot;\n注意：不要仅仅为了获取其他类中的已有成员进行继承。\n所以判断所属关系，可以简单看，\n如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。\n细节二：\n在方法覆盖时，注意两点：\n1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。\n2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)\n继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。\n这时如何解决问题呢？介绍一个关键字，final:最终。\nfinal特点：\n1：这个关键字是一个修饰符，可以修饰类，方法，变量。\n2：被final修饰的类是一个最终类，不可以被继承。\n3：被final修饰的方法是一个最终方法，不可以被覆盖。\n4：被final修饰的变量是一个常量，只能赋值一次。\n其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。\n不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。\n抽象类: abstract\n抽象：不具体，看不明白。抽象类表象体现。\n在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。\n抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。\n抽象类的特点：\n1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。\n2：抽象方法只定义方法声明，并不定义方法实现。\n3：抽象类不可以被创建对象(实例化)。\n4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。\n抽象类的细节：\n1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。\n2：抽象类中是否可以定义非抽象方法？\n可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。\n3：抽象关键字abstract和哪些不可以共存？final , private , static\n4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。\n——————————————————————————————————————————————————————\n模板方法设计模式：\n解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。\nabstract class gettime{\npublic final void gettime(){ //此功能如果不需要复写，可加final限定\nlong start = system.currenttimemillis();\ncode(); //不确定的功能部分，提取出来，通过抽象方法实现\nlong end = system.currenttimemillis();\nsystem.out.println(\u0026ldquo;毫秒是：\u0026quot;+(end—start));\n}\npublic abstract void code(); //抽象不确定的功能，让子类复写实现\n}\nclass subdemo extends gettime{\npublic void code(){ //子类复写功能方法\nfor(int y=0; y\u0026lt;1000; y++){\nsystem.out.println(\u0026ldquo;y\u0026rdquo;);\n}\n}\n}\n——————————————————————————————————————————————————————\n接 口：★★★★★\n1：是用关键字interface定义的。\n2：接口中包含的成员，最常见的有全局常量、抽象方法。\n注意：接口中的成员都有固定的修饰符。\n成员变量：public static final\n成员方法：public abstract\ninterface inter{\npublic static final int x = 3;\npublic abstract void show();\n}\n3：接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。\n4：类与类之间存在着继承关系，类与接口中间存在的是实现关系。\n继承用extends ；实现用implements ；\n5：接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。 6：一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。\n7：其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。\n接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）\n1：接口是对外提供的规则。\n2：接口是功能的扩展。\n3：接口的出现降低了耦合性。\n抽象类与接口：\n抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。\n接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。\n抽象类和接口的共性：都是不断向上抽取的结果。\n抽象类和接口的区别：\n1：抽象类只能被继承，而且只能单继承。\n接口需要被实现，而且可以多实现。\n2：抽象类中可以定义非抽象方法，子类可以直接继承使用。\n接口中都有抽象方法，需要子类去实现。\n3：抽象类使用的是 is a 关系。\n接口使用的 like a 关系。\n4：抽象类的成员修饰符可以自定义。\n接口中的成员修饰符是固定的。全都是public的。\n在开发之前，先定义规则，a和b分别开发，a负责实现这个规则，b负责使用这个规则。至于a是如何对规则具体实现的，b是不需要知道的。这样这个接口的出现就降低了a和b直接耦合性。 ——————————————————————————————————————————————————————\n多 态★★★★★（面向对象特征之一）：函数本身就具备多态性，某一种事物有不同的具体的体现。\n体现：父类引用或者接口的引用指向了自己的子类对象。//animal a = new cat();\n多态的好处：提高了程序的扩展性。\n多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)\n多态的前提：\n1：必须要有关系，比如继承、或者实现。\n2：通常会有覆盖操作。\n多态的出现思想上也做着变化：以前是创建对象并指挥对象做事情。有了多态以后，我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，即通过操作父类或接口实现。\n——————————————————————————————————————————————————————\nclass 毕姥爷{\nvoid 讲课(){\nsystem.out.println(\u0026ldquo;企业管理\u0026rdquo;);\n}\nvoid 钓鱼(){\nsystem.out.println(\u0026ldquo;钓鱼\u0026rdquo;);\n}\n}\nclass 毕老师 extends 毕姥爷{\nvoid 讲课(){\nsystem.out.println(\u0026ldquo;java\u0026rdquo;);\n}\nvoid 看电影(){\nsystem.out.println(\u0026ldquo;看电影\u0026rdquo;);\n}\n}\nclass {\npublic static void main(string[] args) {\n毕姥爷 x = new 毕老师(); //毕老师对象被提升为了毕姥爷类型。\n// x.讲课();\n// x.看电影(); //错误.\n毕老师 y = (毕老师)x; //将毕姥爷类型强制转换成毕老师类型。 y.看电影();//在多态中，自始自终都是子类对象在做着类型的变化。\n}\n}\n——————————————————————————————————————————————————————\n如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？\n可以可以通过一个关键字 instanceof ;//判断对象是否实现了指定的接口或继承了指定的类\n格式：\u0026lt;对象 instanceof 类型\u0026gt; ，判断一个对象是否所属于指定的类型。\nstudent instanceof person = true;//student继承了person类\n多态在子父类中的成员上的体现的特点：\n1，成员变量：在多态中，子父类成员变量同名。\n在编译时期：参考的是引用型变量所属的类中是否有调用的成员。（编译时不产生对象，只检查语法错误）\n运行时期：也是参考引用型变量所属的类中是否有调用的成员。\n简单一句话：无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量。\n再说的更容易记忆一些：成员变量 ——— 编译运行都看 = 左边。\n2，成员函数。\n编译时期：参考引用型变量所属的类中是否有调用的方法。\n运行事情：参考的是对象所属的类中是否有调用的方法。\n为什么是这样的呢？因为在子父类中，对于一模一样的成员函数，有一个特性：覆盖。\n简单一句：成员函数，编译看引用型变量所属的类，运行看对象所属的类。\n更简单：成员函数 ——— 编译看 = 左边，运行看 = 右边。\n3，静态函数。 编译时期：参考的是引用型变量所属的类中是否有调用的成员。\n运行时期：也是参考引用型变量所属的类中是否有调用的成员。\n为什么是这样的呢？因为静态方法，其实不所属于对象，而是所属于该方法所在的类。\n调用静态的方法引用是哪个类的引用调用的就是哪个类中的静态方法。\n简单说：静态函数 ——— 编译运行都看 = 左边。\n——————————————————————————————————————————————————————\n——————java.lang.object\nobject：所有类的直接或者间接父类，java认为所有的对象都具备一些基本的共性内容，这些内容可以不断的向上抽取，最终就抽取到了一个最顶层的类中的，该类中定义的就是所有对象都具备的功能。\n具体方法：\n1，boolean equals(object obj)：用于比较两个对象是否相等，其实内部比较的就是两个对象地址。\n而根据对象的属性不同，判断对象是否相同的具体内容也不一样。所以在定义类时，一般都会复写equals方法，建立本类特有的判断对象是否相同的依据。\npublic boolean equals(object obj){\nif(!(obj instanceof person))\nreturn false;\nperson p = (person)obj;\nreturn this.age == p.age;\n}\n2，string tostring()：将对象变成字符串；默认返回的格式：类名@哈希值 = getclass().getname() + \u0026lsquo;@\u0026rsquo; + integer.tohexstring(hashcode())\n为了对象对应的字符串内容有意义，可以通过复写，建立该类对象自己特有的字符串表现形式。 public string tostring(){\nreturn \u0026ldquo;person : \u0026ldquo;+age;\n}\n3，class getclass()：获取任意对象运行时的所属字节码文件对象。\n4，int hashcode()：返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。\n通常equals，tostring，hashcode，在应用中都会被复写，建立具体对象的特有的内容。\n——————————————————————————————————————————————————————\n**内部类：**如果a类需要直接访问b类中的成员，而b类又需要建立a类的对象。这时,为了方便设计和访问，直接将a类定义在b类中。就可以了。a类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。\n——————————————————————————————————————————————————————\nclass outer{\nint num = 4;\nclass inner {\nvoid show(){\nsystem.out.println(\u0026ldquo;inner show run \u0026ldquo;+num);\n}\n}\npublic void method(){\ninner in = new inner();//创建内部类的对象。\nin.show();//调用内部类的方法。 }\n}\n——————————————————————————————————————————————————————\n当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。\n1：默认修饰符。\n直接访问内部类格式：外部类名.内部类名 变量名 = 外部类对象.内部类对象;\nouter.inner in = new outer.new inner();//这种形式很少用。\n但是这种应用不多见，因为内部类之所以定义在内部就是为了封装。想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。\n2：私有修饰符。\n通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。 3：静态修饰符。\n如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。\n注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。\n内部类编译后的文件名为：“外部类名$内部类名.java”；\n为什么内部类可以直接访问外部类中的成员呢？\n那是因为内部中都持有一个外部类的引用。这个是引用是 外部类名.this\n内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。\n当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。\n匿名内部类：没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。\n匿名内部类的格式：new 父类名\u0026amp;接口名(){ 定义子类成员或者覆盖父类方法 }.方法。\n匿名内部类的使用场景：\n当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。\n其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。\n——————————————————————————————————————————————————————\n//面试\n//1\nnew object(){\nvoid show(){\nsystem.out.println(\u0026ldquo;show run\u0026rdquo;);\n}\n}.show();\n//2\nobject obj = new object(){\nvoid show(){\nsystem.out.println(\u0026ldquo;show run\u0026rdquo;);\n}\n};\nobj.show();\n1和2的写法正确吗？有区别吗？说出原因。\n写法是正确，1和2都是在通过匿名内部类建立一个object类的子类对象。\n区别：\n第一个可是编译通过，并运行。\n第二个编译失败，因为匿名内部类是一个子类对象，当用object的obj引用指向时，就被提升为了\nobject类型，而编译时检查object类中是否有show方法，所以编译失败。\n——————————————————————————————————————————————————————\nclass innerclassdemo6 {\n**+（static）**class inner{\nvoid show(){}\n}\npublic void method(){\n**this.**new inner().show();//可以\n}\npublic static void main(string[] args) {//static不允许this\nthis.new inner().show();//错误，inner类需要定义成static\n}\n}\n——————————————————————————————————————————————————————\ninterface inter{\nvoid show();\n}\nclass outer{//通过匿名内部类补足outer类中的代码。\npublic static inter method(){\nreturn new inter(){\npublic void show(){}\n};\n}\n}\nclass innerclassdemo7 {\npublic static void main(string[] args) {\nouter.method().show();\n/*\nouter.method():意思是：outer中有一个名称为method的方法，而且这个方法是静态的。\nouter.method().show():当outer类调用静态的method方法运算结束后的结果又调用了show方法，意味着：method()方法运算完一个是对象，而且这个对象是inter类型的。\n*/\nfunction (new inter(){\npublic void show(){}\n}); //匿名内部类作为方法的参数进行传递。\n}\npublic static void function(inter in){\nin.show();\n}\n}\n——————————————————————————————————————————————————————\n异 常：★★★★\n异常：就是不正常。程序在运行时出现的不正常情况。其实就是程序中出现的问题。这个问题按照面向对象思想进行描述，并封装成了对象。因为问题的产生有产生的原因、有问题的名称、有问题的描述等多个属性信息存在。当出现多属性信息最方便的方式就是将这些信息进行封装。异常就是java按照面向对象的思想将问题进行对象封装。这样就方便于操作问题以及处理问题。\n出现的问题有很多种，比如角标越界，空指针等都是。就对这些问题进行分类。而且这些问题都有共性内容比如：每一个问题都有名称，同时还有问题描述的信息，问题出现的位置，所以可以不断的向上抽取。形成了异常体系。 ————————java.lang.throwable：\n**throwable：**可抛出的。 |——error：错误，一般情况下，不编写针对性的代码进行处理，通常是jvm发生的，需要对程序进行修正。\n|——exception：异常，可以有针对性的处理方式\n无论是错误还是异常，它们都有具体的子类体现每一个问题，它们的子类都有一个共性，就是都以父类名才作为子类的后缀名。\n这个体系中的所有类和对象都具备一个独有的特点；就是可抛性。\n可抛性的体现：就是这个体系中的类和对象都可以被throws和throw两个关键字所操作。\n——————————————————————————————————————————————————————\nclass exceptiondemo{\npublic static void main(string[] args) {\n// byte[] buf = new byte[1024*1024*700];//java.lang.outofmemoryerror内存溢出错误\n}\n}\n——————————————————————————————————————————————————————\n在开发时，如果定义功能时，发现该功能会出现一些问题，应该将问题在定义功能时标示出来，这样调用者就可以在使用这个功能的时候，预先给出处理方式。\n如何标示呢？通过throws关键字完成，格式：throws 异常类名,异常类名\u0026hellip;\n这样标示后，调用者，在使用该功能时，就必须要处理，否则编译失败。\n处理方式有两种：1、捕捉；2、抛出。\n对于捕捉：java有针对性的语句块进行处理。\ntry {\n需要被检测的代码；\n}\ncatch(异常类 变量名){\n异常处理代码；\n}\nfianlly{\n一定会执行的代码；\n}\n——————————————————————————————————————————————————————\ncatch (exception e) { //e用于接收try检测到的异常对象。\nsystem.out.println(\u0026ldquo;message:\u0026quot;+e.getmessage());//获取的是异常的信息。\nsystem.out.println(\u0026ldquo;tostring:\u0026quot;+e.tostring());//获取的是异常的名字+异常的信息。\ne.printstacktrace();//打印异常在堆栈中信息；异常名称+异常信息+异常的位置。\n}\n——————————————————————————————————————————————————————\n异常处理原则：功能抛出几个异常，功能调用如果进行try处理，需要与之对应的catch处理代码块，这样的处理有针对性，抛几个就处理几个。\n特殊情况：try对应多个catch时，如果有父类的catch语句块，一定要放在下面。\nthrow 和throws关键字的区别：\nthrow用于抛出异常对象，后面跟的是异常对象；throw用在函数内。\nthrows用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。\n通常情况：函数内容如果有throw，抛出异常对象，并没有进行处理，那么函数上一定要声明，否则编译失败。但是也有特殊情况。\n异常分两种：\n1：编译时被检查的异常，只要是exception及其子类都是编译时被检测的异常。\n2：运行时异常，其中exception有一个特殊的子类runtimeexception，以及runtimeexception的子类是运行异常，也就说这个异常是编译时不被检查的异常。\n编译时被检查的异常和运行时异常的区别：\n编译被检查的异常在函数内被抛出，函数必须要声明，否编译失败。\n声明的原因：是需要调用者对该异常进行处理。\n运行时异常如果在函数内被抛出，在函数上不需要声明。\n不声明的原因：不需要调用者处理，运行时异常发生，已经无法再让程序继续运行，所以，不让调用处理的，直接让程序停止，由调用者对代码进行修正。\n定义异常处理时，什么时候定义try，什么时候定义throws呢？\n功能内部如果出现异常，如果内部可以处理，就用try；\n如果功能内部处理不了，就必须声明出来，让调用者处理。\n自定义异常：当开发时，项目中出现了java中没有定义过的问题时，这时就需要我们按照java异常建立思想，将项目的中的特有问题也进行对象的封装。这个异常，称为自定义异常。\n对于除法运算，0作为除数是不可以的。java中对这种问题用arithmeticexception类进行描述。对于这个功能，在我们项目中，除数除了不可以为0外，还不可以为负数。可是负数的部分java并没有针对描述。所以我们就需要自定义这个异常。\n自定义异常的步骤：\n1：定义一个子类继承exception或runtimeexception，让该类具备可抛性。\n2：通过throw 或者throws进行操作。\n异常的转换思想：当出现的异常是调用者处理不了的，就需要将此异常转换为一个调用者可以处理的异常抛出。\ntry catch finally的几种结合方式：\n1，\ntry catch\nfinally\n2,\ntry\ncatch\n3,\ntry\nfinally\n这种情况，如果出现异常，并不处理，但是资源一定关闭，所以try finally集合只为关闭资源。\n记住：finally很有用，主要用户关闭资源。无论是否发生异常，资源都必须进行关闭。\nsystem.exit(0); //退出jvm，只有这种情况finally不执行。\n当异常出现后，在子父类进行覆盖时，有了一些新的特点：\n1：当子类覆盖父类的方法时，如果父类的方法抛出了异常，那么子类的方法要么不抛出异常要么抛出父类异常或者该异常的子类，不能抛出其他异常。\n2：如果父类抛出了多个异常，那么子类在覆盖时只能抛出父类的异常的子集。\n注意：\n如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，如果子类的覆盖的方法中出现了异常，只能try不能throws。\n如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出runtimeexception异常或者其子类，这样，子类的方法上是不需要throws声明的。\n常见异常：\n1、脚标越界异常（indexoutofboundsexception）包括数组、字符串；\n空指针异常（nullpointerexception）\n2、类型转换异常：classcastexception\n3、没有这个元素异常：nullpointerexception\n4、不支持操作异常；\n异常要尽量避免，如果避免不了，需要预先给出处理方式。比如家庭备药，比如灭火器。\n——————————————————————————————————————————————————————\n包：定义包用package关键字。\n1：对类文件进行分类管理。\n2：给类文件提供多层名称空间。\n如果生成的包不在当前目录下，需要最好执行classpath，将包所在父目录定义到classpath变量中即可。\n一般在定义包名时，因为包的出现是为了区分重名的类。所以包名要尽量唯一。怎么保证唯一性呢？可以使用url域名来进行包名称的定义。\npackage pack;//定义了一个包，名称为pack。 注意：包名的写法规范：所有字母都小写。\n//package cn.itcast.pack.demo;\n类的全名称是 包名.类名\n编译命令：javac –d 位置（.当前路径） java源文件 （就可以自动生成包）\n包是一种封装形式，用于封装类，想要被包以外的程序访问，该类必须public；\n类中的成员，如果被包以外访问，也必须public；\n包与包之间访问可以使用的权限有两种：\n1：public 2：protected：只能是不同包中的子类可以使用的权限。\n总结java中的四种权限：\n范围 public protected default private\n同一个类中 ok　ok ok ok\n同一包中 ok ok　ok\n子类 ok 不同包中 ok\n——————————————————————————————————————————————————————\nimport — 导入：类名称变长，写起来很麻烦。为了简化，使用了一个关键字：import，可以使用这个关键字导入指定包中的类。记住：实际开发时,到的哪个类就导入哪个类，不建议使用*.\nimport packa.*;//这个仅仅是导入了packa当前目录下的所有的类。不包含子包。\nimport packa.abc.*;//导入了packa包中的子包abc下的当前的所有类。\n如果导入的两个包中存在着相同名称的类。这时如果用到该类，必须在代码中指定包名。\n常见的软件包:\njava.lang : language java的核心包，object system string throwable jdk1.2版本后，该包中的类自动被导入。\njava.awt : 定义的都是用于java图形界面开发的对象。\njavax.swing: 提供所有的windows桌面应用程序包括的控件,比如：frame , dialog, table, list 等等,就是java的图形界面库。\njava.net : 用于java网络编程方面的对象都在该包中。\njava.io : input output 用于操作设备上数据的对象都在该包中。比如：读取硬盘数据，往硬盘写入数据。\njava.util : java的工具包，时间对象，集合框架。\njava.applet: application+let 客户端java小程序。server+let ——\u0026gt; servlet 服务端java小程序。\njar ：java的压缩包，主要用于存储类文件，或者配置文件等。\n命令格式：jar –cf 包名.jar 包目录\n解压缩：jar –xvf 包名.jar 将jar包目录列表重定向到一个文件中：jar –tf 包名.jar \u0026gt;c:\\1.txt\n——————————————————————————————————————————————————————\n多线程：★★★★\n进程：正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。\n线程：其实就是进程中一个程序执行控制单元，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。\n一个进程至少有一个线程在运行，当一个进程中出现多个线程时，就称这个应用程序是多线程应用程序，每个线程在栈区中都有自己的执行空间，自己的方法区、自己的变量。\njvm在启动的时，首先有一个主线程，负责程序的执行，调用的是main函数。主线程执行的代码都在main方法中。\n当产生垃圾时，收垃圾的动作，是不需要主线程来完成，因为这样，会出现主线程中的代码执行会停止，会去运行垃圾回收器代码，效率较低，所以由单独一个线程来负责垃圾回收。 随机性的原理：因为cpu的快速切换造成，哪个线程获取到了cpu的执行权，哪个线程就执行。\n返回当前线程的名称：thread.currentthread().getname()\n线程的名称是由：thread—编号定义的。编号从0开始。\n线程要运行的代码都统一存放在了run方法中。\n线程要运行必须要通过类中指定的方法开启。start方法。（启动后，就多了一条执行路径）\nstart方法：1）、启动了线程；2）、让jvm调用了run方法。\n创建线程的第一种方式：继承thread ，由子类复写run方法。\n步骤：\n1，定义类继承thread类；\n2，目的是复写run方法，将要让线程运行的代码都存储到run方法中；\n3，通过创建thread类的子类对象，创建线程对象；\n4，调用线程的start方法，开启线程，并执行run方法。\n线程状态：\n被创建：start()\n运行：具备执行资格，同时具备执行权；\n冻结：sleep(time),wait()—notify()唤醒；线程释放了执行权，同时释放执行资格；\n临时阻塞状态：线程具备cpu的执行资格，没有cpu的执行权；\n消亡：stop()\n创建线程的第二种方式：实现一个接口runnable。\n步骤：\n1，定义类实现runnable接口。\n2，覆盖接口中的run方法（用于封装线程要运行的代码）。\n3，通过thread类创建线程对象；\n4，将实现了runnable接口的子类对象作为实际参数传递给thread类中的构造函数。\n为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。\n5，调用thread对象的start方法。开启线程，并运行runnable接口子类中的run方法。\nticket t = new ticket();\n/*直接创建ticket对象，并不是创建线程对象。\n因为创建对象只能通过new thread类，或者new thread类的子类才可以。\n所以最终想要创建线程。既然没有了thread类的子类，就只能用thread类。*/\nthread t1 = new thread(t); //创建线程。\n/*只要将t作为thread类的构造函数的实际参数传入即可完成线程对象和t之间的关联\n为什么要将t传给thread类的构造函数呢？其实就是为了明确线程要运行的代码run方法。*/\nt1.start();\n为什么要有runnable接口的出现？\n1：通过继承thread类的方式，可以完成多线程的建立。但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承thread类，因为java单继承的局限性。\n可是该类中的还有部分代码需要被多个线程同时执行。这时怎么办呢？\n只有对该类进行额外的功能扩展，java就提供了一个接口runnable。这个接口中定义了run方法，其实run方法的定义就是为了存储多线程要运行的代码。\n所以，通常创建线程都用第二种方式。\n因为实现runnable接口可以避免单继承的局限性。\n2：其实是将不同类中需要被多线程执行的代码进行抽取。将多线程要运行的代码的位置单独定义到接口中。为其他类进行功能扩展提供了前提。\n所以thread类在描述线程时，内部定义的run方法，也来自于runnable接口。\n实现runnable接口可以避免单继承的局限性。而且，继承thread，是可以对thread类中的方法，进行子类复写的。但是不需要做这个复写动作的话，只为定义线程代码存放位置，实现runnable接口更方便一些。所以runnable接口将线程要执行的任务封装成了对象。\n——————————————————————————————————————————————————————\n//面试\nnew thread(new runnable(){ //匿名\npublic void run(){\nsystem.out.println(\u0026ldquo;runnable run\u0026rdquo;);\n}\n})\n{\npublic void run(){\nsystem.out.println(\u0026ldquo;subthread run\u0026rdquo;);\n}\n}.start(); //结果：subthread run\n——————————————————————————————————————————————————————\ntry {\nthread.sleep(10);\n}catch(interruptedexception e){}// 当刻意让线程稍微停一下，模拟cpu 切换情况。\n多线程安全问题的原因：\n通过图解：发现一个线程在执行多条语句时，并运算同一个数据时，在执行过程中，其他线程参与进来，并操作了这个数据。导致到了错误数据的产生。\n涉及到两个因素：\n1，多个线程在操作共享数据。\n2，有多条语句对共享数据进行运算。\n原因：这多条语句，在某一个时刻被一个线程执行时，还没有执行完，就被其他线程执行了。\n解决安全问题的原理：\n只要将操作共享数据的语句在某一时段让一个线程执行完，在执行过程中，其他线程不能进来执行就可以解决这个问题。\n如何进行多句操作共享数据代码的封装呢？\njava中提供了一个解决方式：就是同步代码块。\n格式：\nsynchronized(对象) { // 任意对象都可以。这个对象就是锁。\n需要被同步的代码；\n}\n——————————————————————————————————————————————————————\n同步：★★★★★\n好处：解决了线程安全问题。\n弊端：相对降低性能，因为判断锁需要消耗资源，产生了死锁。\n定义同步是有前提的：\n1，必须要有两个或者两个以上的线程，才需要同步。\n2，多个线程必须保证使用的是同一个锁。\n同步的第二种表现形式：\n同步函数：其实就是将同步关键字定义在函数上，让函数具备了同步性。\n同步函数是用的哪个锁呢？\n通过验证，函数都有自己所属的对象this，所以同步函数所使用的锁就是this锁。\n当同步函数被static修饰时，这时的同步用的是哪个锁呢？\n静态函数在加载时所属于类，这时有可能还没有该类产生的对象，但是该类的字节码文件加载进内存就已经被封装成了对象，这个对象就是该类的字节码文件对象。\n所以静态加载时，只有一个对象存在，那么静态同步函数就使用的这个对象。\n这个对象就是 类名.class\n同步代码块和同步函数的区别？\n同步代码块使用的锁可以是任意对象。\n同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。\n在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。\n——————————————————————————————————————————————————————\n★考点问题：请写一个延迟加载的单例模式？写懒汉式；当出现多线程访问时怎么解决？加同步，解决安全问题；效率高吗？不高；怎样解决？通过双重判断的形式解决。\n//懒汉式：延迟加载方式。\n当多线程访问懒汉式时，因为懒汉式的方法内对共性数据进行多条语句的操作。所以容易出现线程安全问题。为了解决，加入同步机制，解决安全问题。但是却带来了效率降低。\n为了效率问题，通过双重判断的形式解决。\nclass single{\nprivate static single s = null;\nprivate single(){}\npublic static single getinstance(){ //锁是谁？字节码文件对象；\nif(s == null){\nsynchronized(single.class){\nif(s == null)\ns = new single();\n}\n}\nreturn s;\n}\n}\n——————————————————————————————————————————————————————\n同步死锁：通常只要将同步进行嵌套，就可以看到现象。同步函数中有同步代码块，同步代码块中还有同步函数。\n线程间通信：思路：多个线程在操作同一个资源，但是操作的动作却不一样。\n1：将资源封装成对象。\n2：将线程执行的任务(任务其实就是run方法。)也封装成对象。\n等待唤醒机制：涉及的方法：\nwait:将同步中的线程处于冻结状态。释放了执行权，释放了资格。同时将线程对象存储到线程池中。\nnotify：唤醒线程池中某一个等待线程。\nnotifyall:唤醒的是线程池中的所有线程。\n注意：\n1：这些方法都需要定义在同步中。 2：因为这些方法必须要标示所属的锁。\n你要知道 a锁上的线程被wait了,那这个线程就相当于处于a锁的线程池中，只能a锁的notify唤醒。\n3：这三个方法都定义在object类中。为什么操作线程的方法定义在object类中？\n因为这三个方法都需要定义同步内，并标示所属的同步锁，既然被锁调用，而锁又可以是任意对象，\n那么能被任意对象调用的方法一定定义在object类中。\nwait和sleep区别： 分析这两个方法：从执行权和锁上来分析：\nwait：可以指定时间也可以不指定时间。不指定时间，只能由对应的notify或者notifyall来唤醒。\nsleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。\nwait：线程会释放执行权，而且线程会释放锁。\nsleep：线程会释放执行权，但不是不释放锁。\n线程的停止：通过stop方法就可以停止线程。但是这个方式过时了。\n停止线程：原理就是：让线程运行的代码结束，也就是结束run方法。\n怎么结束run方法？一般run方法里肯定定义循环。所以只要结束循环即可。\n第一种方式：定义循环的结束标记。\n第二种方式：如果线程处于了冻结状态，是不可能读到标记的，这时就需要通过thread类中的interrupt方法，将其冻结状态强制清除。让线程恢复具备执行资格的状态，让线程可以读到标记，并结束。\n—————————\u0026lt; java.lang.thread \u0026gt;————\ninterrupt()：中断线程。\nsetpriority(int newpriority)：更改线程的优先级。\ngetpriority()：返回线程的优先级。\ntostring()：返回该线程的字符串表示形式，包括线程名称、优先级和线程组。\nthread.yield()：暂停当前正在执行的线程对象，并执行其他线程。\nsetdaemon(true)：将该线程标记为守护线程或用户线程。将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，\njava 虚拟机退出。该方法必须在启动线程前调用。\njoin：临时加入一个线程的时候可以使用join方法。\n当a线程执行到了b线程的join方式。a线程处于冻结状态，释放了执行权，b开始执行。\na什么时候执行呢？只有当b线程运行结束后，a才从冻结状态恢复运行状态执行。\n——————————————————————————————————————————————————————\nlock接口：多线程在jdk1.5版本升级时，推出一个接口lock接口。\n解决线程安全问题使用同步的形式，(同步代码块，要么同步函数)其实最终使用的都是锁机制。\n到了后期版本，直接将锁封装成了对象。线程进入同步就是具备了锁，执行完，离开同步，就是释放了锁。\n在后期对锁的分析过程中，发现，获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。\n所以同步是隐示的锁操作，而lock对象是显示的锁操作，它的出现就替代了同步。\n在之前的版本中使用object类中wait、notify、notifyall的方式来完成的。那是因为同步中的锁是任意对象，所以操作锁的等待唤醒的方法都定义在object类中。\n而现在锁是指定对象lock。所以查找等待唤醒机制方式需要通过lock接口来完成。而lock接口中并没有直接操作等待唤醒的方法，而是将这些方式又单独封装到了一个对象中。这个对象就是condition，将object中的三个方法进行单独的封装。并提供了功能一致的方法 **await()、signal()、signalall()**体现新版本对象的好处。\n\u0026lt; java.util.concurrent.locks \u0026gt; condition接口：await()、signal()、signalall()；\n——————————————————————————————————————————————————————\nclass boundedbuffer {\nfinal lock lock = new reentrantlock();\nfinal condition notfull = lock.newcondition();\nfinal condition notempty = lock.newcondition();\nfinal object[] items = new object[100];\nint putptr, takeptr, count;\npublic void put(object x) throws interruptedexception {\nlock.lock();\ntry {\nwhile (count == items.length) notfull.await();\nitems[putptr] = x; if (++putptr == items.length) putptr = 0;\n++count;\nnotempty.signal();\n}\nfinally {\nlock.unlock();\n}\n}\npublic object take() throws interruptedexception {\nlock.lock();\ntry {\nwhile (count == 0) notempty.await();\nobject x = items[takeptr]; if (++takeptr == items.length) takeptr = 0;\n——count;\nnotfull.signal();\nreturn x;\n}\nfinally {\nlock.unlock();\n}\n} }\n——————————————————————————————————————————————————————\napi：（application programming interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。\n——\u0026lt; java.lang \u0026gt;—— string字符串：★★★☆\njava中用string类进行描述。对字符串进行了对象的封装。这样的好处是可以对字符串这种常见数据进行方便的操作。对象封装后，可以定义n多属性和行为。\n如何定义字符串对象呢？string s = \u0026ldquo;abc\u0026rdquo;;只要是双引号引起的数据都是字符串对象。\n特点：字符串一旦被初始化，就不可以被改变，存放在方法区中的常量池中。\n——————————————————————————————————————————————————————\nstring s1 = \u0026ldquo;abc\u0026rdquo;; // s1指向的内存中只有一个对象abc。\nstring s2 = new string(\u0026ldquo;abc\u0026rdquo;); // s2指向的内容中有两个对象abc、new 。\nsystem.out.println(s1==s2);//false\nsystem.out.println(s1.equals(s2));//true ，字符串中equals比较的是字符串内容是否相同。\n——————————————————————————————————————————————————————\n字符串的方法：\n**1：构造方法：**将字节数组或者字符数组转成字符串。\nstring s1 = new string();//创建了一个空内容的字符串。 string s2 = null;//s2没有任何对象指向，是一个null常量值。\nstring s3 = \u0026ldquo;\u0026rdquo;;//s3指向一个具体的字符串对象，只不过这个字符串中没有内容。\n//一般在定义字符串时，不用new。\nstring s4 = new string(\u0026ldquo;abc\u0026rdquo;);\nstring s5 = \u0026ldquo;abc\u0026rdquo;; 一般用此写法\nnew string(char[]);//将字符数组转成字符串。\nnew string(char[],offset,count);//将字符数组中的一部分转成字符串。\n2：一般方法：\n按照面向对象的思想：\n2.1 获取：\n2.1.1：获取字符串的长度。length();\n2.1.2：指定位置的字符。char charat(int index);\n2.1.3：获取指定字符的位置。如果不存在返回—1，所以可以通过返回值—1来判断某一个字符不存在的情况。\nint indexof(int ch);//返回第一次找到的字符角标\nint indexof(int ch,int fromindex); //返回从指定位置开始第一次找到的角标\nint indexof(string str); //返回第一次找到的字符串角标\nint indexof(string str,int fromindex);\nint lastindexof(int ch);\nint lastindexof(int ch,int fromindex);\nint lastindexof(string str);\nint lastindexof(string str,int fromindex);\n2.1.4：获取子串。\nstring substring(int start);//从start位开始，到length()—1为止.\nstring substring(int start,int end);//从start开始到end为止。//包含start位，不包含end位。\nsubstring(0,str.length());//获取整串\n2.2 判断：\n2.2.1：字符串中包含指定的字符串吗？\nboolean contains(string substring);\n2.2.2：字符串是否以指定字符串开头啊？\nboolean startswith(string);\n2.2.3：字符串是否以指定字符串结尾啊？\nboolean endswith(string);\n2.2.4：判断字符串是否相同\nboolean equals(string);//覆盖了object中的方法，判断字符串内容是否相同。\n2.2.5：判断字符串内容是否相同，忽略大小写。\nboolean equalsignorecase(string) ;\n2.3 转换：\n2.3.1：通过构造函数可以将字符数组或者字节数组转成字符串。\n2.3.2：可以通过字符串中的静态方法，将字符数组转成字符串。\nstatic string copyvalueof(char[] );\nstatic string copyvalueof(char[],int offset,int count);\nstatic string valueof(char[]);\nstatic string valueof(char[],int offset,int count);\n2.3.3：将基本数据类型或者对象转成字符串。\nstatic string valueof(char);\nstatic string valueof(boolean);\nstatic string valueof(double);\nstatic string valueof(float);\nstatic string valueof(int);\nstatic string valueof(long);\nstatic string valueof(object);\n2.3.4：将字符串转成大小写。\nstring tolowercase();\nstring touppercase();\n2.3.5：将字符串转成数组。\nchar[] tochararray();//转成字符数组。\nbyte[] getbytes();//可以加入编码表。转成字节数组。\n2.3.6：将字符串转成字符串数组。切割方法。\nstring[] split(分割的规则—字符串);\n2.3.7：将字符串进行内容替换。注意：修改后变成新字符串，并不是将原字符串直接修改。\nstring replace(oldchar,newchar);\nstring replace(oldstring,newstring);\n2.3.8： string concat(string); //对字符串进行追加。\nstring trim();//去除字符串两端的空格\nint compareto();//如果参数字符串等于此字符串，则返回值 0；如果此字符串按字典顺序小于字符串参数，\n则返回一个小于 0 的值；如果此字符串按字典顺序大于字符串参数，则返回一个大于 0 的值。\n——————————————————————————————————————————————————————\n——\u0026lt; java.lang \u0026gt;—— stringbuffer字符串缓冲区：★★★☆\n构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。\n特点：\n1：可以对字符串内容进行修改。\n2：是一个容器。\n3：是可变长度的。\n4：缓冲区中可以存储任意类型的数据。\n5：最终需要变成字符串。\n容器通常具备一些固定的方法：\n1，添加。\nstringbuffer append(data):在缓冲区中追加数据。追加到尾部。\nstringbuffer insert(index,data):在指定位置插入数据。\n2，删除。\nstringbuffer delete(start,end);删除从start至end—1范围的元素\nstringbuffer deletecharat(index);删除指定位置的元素\n//sb.delete(0,sb.length());//清空缓冲区。\n3，修改。\nstringbuffer replace(start,end,string);将start至end—1替换成string\nvoid setcharat(index,char);替换指定位置的字符\nvoid setlength(len);将原字符串置为指定长度的字符串\n4，查找。（查不到返回—1）\nint indexof(string); 返回指定子字符串在此字符串中第一次出现处的索引。\nint indexof(string,int fromindex);从指定位置开始查找字符串\nint lastindexof(string); 返回指定子字符串在此字符串中最右边出现处的索引。\nint lastindexof(string,int fromindex); 从指定的索引开始反向搜索\n5，获取子串。\nstring substring(start); 返回start到结尾的子串\nstring substring(start,end); 返回start至end—1的子串\n6，反转。\nstringbuffer reverse();字符串反转\n——————————————————————————————————————————————————————\n——\u0026lt; java.lang \u0026gt;—— stringbuilder字符串缓冲区：★★★☆\njdk1.5出现stringbuiler；构造一个其中不带字符的字符串生成器，初始容量为 16 个字符。该类被设计用作 stringbuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。\n方法和stringbuffer一样；\nstringbuffer 和 stringbuilder 的区别：\nstringbuffer线程安全。\nstringbuilder线程不安全。\n单线程操作，使用stringbuilder 效率高。\n多线程操作，使用stringbuffer 安全。\n——————————————————————————————————————————————————————\nstringbuilder sb = new stringbuilder(\u0026ldquo;abcdefg\u0026rdquo;);\nsb.append(\u0026ldquo;ak\u0026rdquo;); //abcdefgak\nsb.insert(1,\u0026ldquo;et\u0026rdquo;);//aetbcdefg\nsb.deletecharat(2);//abdefg\nsb.delete(2,4);//abefg\nsb.setlength(4);//abcd\nsb.setcharat(0,\u0026lsquo;k\u0026rsquo;);//kbcdefg\nsb.replace(0,2,\u0026ldquo;hhhh\u0026rdquo;);//hhhhcdefg\n//想要使用缓冲区，先要建立对象。\nstringbuffer sb = new stringbuffer();\nsb.append(12).append(\u0026ldquo;haha\u0026rdquo;);//方法调用链。\nstring s = \u0026ldquo;abc\u0026rdquo;+4+\u0026lsquo;q\u0026rsquo;;\ns = new stringbuffer().append(\u0026ldquo;abc\u0026rdquo;).append(4).append(\u0026lsquo;q\u0026rsquo;).tostring();\n——————————————————————————————————————————————————————\nclass test{\npublic static void main(string[] args) {\nstring s1 = \u0026ldquo;java\u0026rdquo;;\nstring s2 = \u0026ldquo;hello\u0026rdquo;;\nmethod_1(s1,s2);\nsystem.out.println(s1+\u0026rdquo;\u0026hellip;.\u0026quot;+s2); //java\u0026hellip;.hello\nstringbuilder s11 = new stringbuilder(\u0026ldquo;java\u0026rdquo;);\nstringbuilder s22 = new stringbuilder(\u0026ldquo;hello\u0026rdquo;);\nmethod_2(s11,s22);\nsystem.out.println(s11+\u0026quot;—————\u0026quot;+s22); //javahello—————hello\n}\npublic static void method_1(string s1,string s2){\ns1.replace(\u0026lsquo;a\u0026rsquo;,\u0026lsquo;k\u0026rsquo;);\ns1 = s2;\n}\npublic static void method_2(stringbuilder s1,stringbuilder s2){\ns1.append(s2);\ns1 = s2;\n}\n}\n——————————————————————————————————————————————————————\n基本数据类型对象包装类：是按照面向对象思想将基本数据类型封装成了对象。\n好处：\n1：可以通过对象中的属性和行为操作基本数据。\n2：可以实现基本数据类型和字符串之间的转换。\n关键字 对应的类名\nbyte byte\nshort short pasershort(numstring);\nint integer 静态方法：parseint(numstring)\nlong long\nfloat float\ndouble double\nchar character\nboolean boolean\n基本数据类型对象包装类：都有 xxx parsexxx 方法\n只有一个类型没有parse方法：character ；\n——————————————————————————————————————————————————————\ninteger对象： ★★★☆\n数字格式的字符串转成基本数据类型的方法：\n1：将该字符串封装成了integer对象，并调用对象的方法intvalue();\n2：使用integer.parseint(numstring):不用建立对象，直接类名调用；\n将基本类型转成字符串：\n1：integer中的静态方法 string tostring(int);\n2：int+\u0026rdquo;\u0026rdquo;;\n将一个十进制整数转成其他进制：\n转成二进制：tobinarystring\n转成八进制：tooctalstring\n转成十六进制：tohexstring\ntostring(int num,int radix);\n将其他进制转换十进制：\nparseint(string,radix); //将给定的数转成指定的基数进制；\n在jdk1.5版本后，对基本数据类型对象包装类进行升级。在升级中，使用基本数据类型对象包装类可以像使用基本数据类型一样，进行运算。\ninteger i = new integer(4); //1.5版本之前的写法；\ninteger i = 4; //自动装箱，1.5版本后的写法；\ni = i + 5;\n//i对象是不能直接和5相加的，其实底层先将i转成int类型，在和5相加。而转成int类型的操作是隐式的。自动拆箱：拆箱的原理就是i.intvalue();i+5运算完是一个int整数。如何赋值给引用类型i呢？其实有对结果进行装箱。\ninteger c = 127;\ninteger d = 127;\nsystem.out.println(c = = d); //true\n//在装箱时，如果数值在byte范围之内，那么数值相同，不会产生新的对象，也就是说多个数值相同的引用指向的是同一个对象。\n——————————————————————————————————————————————————————\n集合框架：★★★★★，用于存储数据的容器。\n特点：\n1：对象封装数据，对象多了也需要存储。集合用于存储对象。\n2：对象的个数确定可以使用数组，但是不确定怎么办？可以用集合。因为集合是可变长度的。\n集合和数组的区别：\n1：数组是固定长度的；集合可变长度的。\n2：数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。\n3：数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。\n数据结构：就是容器中存储数据的方式。\n对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。\n集合容器在不断向上抽取过程中。出现了集合体系。\n在使用一个体系时，原则：参阅顶层内容。建立底层对象。\n——————————————————————————————————————————————————————\n——\u0026lt; java.util \u0026gt;—— collection接口：\ncollection：\n|——list：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。\n|——set：无序(存入和取出顺序有可能不一致)，不可以存储重复元素。必须保证元素唯一性。\n1，添加：\nadd(object)：添加一个元素\naddall(collection) ：添加一个集合中的所有元素。\n2，删除：\nclear()：将集合中的元素全删除，清空集合。\nremove(obj) ：删除集合中指定的对象。注意：删除成功，集合的长度会改变。\nremoveall(collection) ：删除部分元素。部分元素和传入collection一致。\n3，判断：\nboolean contains(obj) ：集合中是否包含指定元素 。\nboolean containsall(collection) ：集合中是否包含指定的多个元素。\nboolean isempty()：集合中是否有元素。 4，获取：\nint size()：集合中有几个元素。\n5，取交集：\nboolean retainall(collection) ：对当前集合中保留和指定集合中的相同的元素。如果两个集合元素相同，返回flase；如果retainall修改了当前集合，返回true。\n6，获取集合中所有元素：\niterator iterator()：迭代器\n7，将集合变成数组：\ntoarray();\n——————————————————————————————————————————————————————\n——\u0026lt; java.util \u0026gt;—— iterator接口：\n迭代器：是一个接口。作用：用于取集合中的元素。\nboolean\nhasnext() 如果仍有元素可以迭代，则返回 true。\ne\nnext() 返回迭代的下一个元素。\nvoid\nremove() 从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。\n每一个集合都有自己的数据结构，都有特定的取出自己内部元素的方式。为了便于操作所有的容器，取出元素。将容器内部的取出方式按照一个统一的规则向外提供，这个规则就是iterator接口。\n也就说，只要通过该接口就可以取出collection集合中的元素，至于每一个具体的容器依据自己的数据结构，如何实现的具体取出细节，这个不用关心，这样就降低了取出元素和具体集合的耦合性。\niterator it = coll.iterator();//获取容器中的迭代器对象，至于这个对象是是什么不重要。这对象肯定符合一个规则iterator接口。\n——————————————————————————————————————————————————————\npublic static void main(string[] args) {\ncollection coll = new arraylist();\ncoll.add(\u0026ldquo;abc0\u0026rdquo;);\ncoll.add(\u0026ldquo;abc1\u0026rdquo;);\ncoll.add(\u0026ldquo;abc2\u0026rdquo;);\n//————————方式1——————————\niterator it = coll.iterator();\nwhile(it.hasnext()){\nsystem.out.println(it.next());\n}\n//—————————方式2用此种——————————\nfor(iterator it = coll.iterator();it.hasnext(); ){\nsystem.out.println(it.next());\n}\n}\n——————————————————————————————————————————————————————\n——\u0026lt; java.util \u0026gt;—— list接口：\nlist本身是collection接口的子接口，具备了collection的所有方法。现在学习list体系特有的共性方法，查阅方法发现list的特有方法都有索引，这是该集合最大的特点。\nlist：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。\n|——arraylist：底层的数据结构是数组,线程不同步，arraylist替代了vector，查询元素的速度非常快。\n|——linkedlist：底层的数据结构是链表，线程不同步，增删元素的速度非常快。\n|——vector：底层的数据结构就是数组，线程同步的，vector无论查询和增删都巨慢。\n1，添加：\nadd(index,element) ：在指定的索引位插入元素。\naddall(index,collection) ：在指定的索引位插入一堆元素。\n2，删除：\nremove(index) ：删除指定索引位的元素。 返回被删的元素。\n3，获取：\nobject get(index) ：通过索引获取指定元素。\nint indexof(obj) ：获取指定元素第一次出现的索引位，如果该元素不存在返回—1；\n所以，通过—1，可以判断一个元素是否存在。\nint lastindexof(object o) ：反向索引指定元素的位置。\nlist sublist(start,end) ：获取子列表。\n4，修改：\nobject set(index,element) ：对指定索引位进行元素的修改。\n5，获取所有元素：\nlistiterator listiterator()：list集合特有的迭代器。\nlist集合支持对元素的增、删、改、查。\nlist集合因为角标有了自己的获取元素的方式： 遍历。\nfor(int x=0; x\u0026lt;list.size(); x++){\nsop(\u0026ldquo;get:\u0026quot;+list.get(x));\n}\n在进行list列表元素迭代的时候，如果想要在迭代过程中，想要对元素进行操作的时候，比如满足条件添加新元素。会发生.concurrentmodificationexception并发修改异常。\n导致的原因是：\n集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现异常情况。\n如何解决呢？\n既然是在迭代中对元素进行操作,找迭代器的方法最为合适.可是iterator中只有hasnext,next,remove方法.通过查阅的它的子接口,listiterator,发现该列表迭代器接口具备了对元素的增、删、改、查的动作。\nlistiterator是list集合特有的迭代器。\nlistiterator it = list.listiterator;//取代iterator it = list.iterator;\n方法摘要\nvoid\nadd(e e) 将指定的元素插入列表（可选操作）。\nboolean\nhasnext() 以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果 next 返回一个元素而不是抛出异常，则返回 true）。\nboolean\nhasprevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。\ne\nnext() 返回列表中的下一个元素。\nint\nnextindex() 返回对 next 的后续调用所返回元素的索引。\ne\nprevious() 返回列表中的前一个元素。\nint\npreviousindex() 返回对 previous 的后续调用所返回元素的索引。\nvoid\nremove() 从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）。\nvoid\nset(e e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。\n可变长度数组的原理：\n当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。\narraylist：是按照原数组的50%延长。构造一个初始容量为 10 的空列表。\nvector：是按照原数组的100%延长。\n注意：对于list集合，底层判断元素是否相同，其实用的是元素自身的equals方法完成的。所以建议元素都要复写equals方法，建立元素对象自己的比较相同的条件依据。\nlinkedlist：的特有方法。\naddfirst();\naddlast();\n在jdk1.6以后。\nofferfirst();\nofferlast();\ngetfirst():获取链表中的第一个元素。如果链表为空，抛出nosuchelementexception;\ngetlast();\n在jdk1.6以后。\npeekfirst();获取链表中的第一个元素。如果链表为空，返回null。\npeeklast();\nremovefirst()：获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，抛出nosuchelementexception\nremovelast();\n在jdk1.6以后。\npollfirst();获取链表中的第一个元素，但是会删除链表中的第一个元素。如果链表为空，返回null。\npolllast();\n——————————————————————————————————————————————————————\n——\u0026lt; java.util \u0026gt;—— set接口：\nset接口中的方法和collection中方法一致的。set接口取出方式只有一种，迭代器。\n|——hashset：底层数据结构是哈希表，线程是不同步的。无序，高效；\nhashset集合保证元素唯一性：通过元素的hashcode方法，和equals方法完成的。\n当元素的hashcode值相同时，才继续判断元素的equals是否为true。\n如果为true，那么视为相同元素，不存。如果为false，那么存储。\n如果hashcode值不同，那么不判断equals，从而提高对象比较的速度。\n|——linkedhashset：有序，hashset的子类。\n|——treeset：对set集合中的元素的进行指定顺序的排序。不同步。treeset底层的数据结构就是二叉树。\n哈希表的原理：\n1，对对象元素中的关键字(对象中的特有数据)，进行哈希算法的运算，并得出一个具体的算法值，这个值 称为哈希值。\n2，哈希值就是这个元素的位置。\n3，如果哈希值出现冲突，再次判断这个关键字对应的对象是否相同。如果对象相同，就不存储，因为元素重复。如果对象不同，就存储，在原来对象的哈希值基础 +1顺延。\n4，存储哈希值的结构，我们称为哈希表。\n5，既然哈希表是根据哈希值存储的，为了提高效率，最好保证对象的关键字是唯一的。\n这样可以尽量少的判断关键字对应的对象是否相同，提高了哈希表的操作效率。\n对于arraylist集合，判断元素是否存在，或者删元素底层依据都是equals方法。\n对于hashset集合，判断元素是否存在，或者删除元素，底层依据的是hashcode方法和equals方法。\ntreeset:\n用于对set集合进行元素的指定顺序排序，排序需要依据元素自身具备的比较性。\n如果元素不具备比较性，在运行时会发生classcastexception异常。\n所以需要元素实现comparable接口，强制让元素具备比较性，复写compareto方法。\n依据compareto方法的返回值，确定元素在treeset数据结构中的位置。\n**treeset方法保证元素唯一性的方式：**就是参考比较方法的结果是否为0，如果return 0，视为两个对象重复，不存。\n注意：在进行比较时，如果判断元素不唯一，比如，同姓名，同年龄，才视为同一个人。\n在判断时，需要分主要条件和次要条件，当主要条件相同时，再判断次要条件，按照次要条件排序。\ntreeset集合排序有两种方式，comparable和comparator区别：\n1：让元素自身具备比较性，需要元素对象实现comparable接口，覆盖compareto方法。\n2：让集合自身具备比较性，需要定义一个实现了comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给treeset集合的构造函数。\n第二种方式较为灵活。\n——————————————————————————————————————————————————————\nmap集合：\n|——hashtable：底层是哈希表数据结构，是线程同步的。不可以存储null键，null值。\n|——hashmap：底层是哈希表数据结构，是线程不同步的。可以存储null键，null值。替代了hashtable.\n|——treemap：底层是二叉树结构，可以对map集合中的键进行指定顺序的排序。\nmap集合存储和collection有着很大不同：\ncollection一次存一个元素；map一次存一对元素。\ncollection是单列集合；map是双列集合。\nmap中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。\n特点：要保证map集合中键的唯一性。\n1，添加。\nput(key,value)：当存储的键相同时，新的值会替换老的值，并将老值返回。如果键没有重复，返回null。\nvoid putall(map);\n2，删除。\nvoid clear()：清空\nvalue remove(key) ：删除指定键。\n3，判断。\nboolean isempty()：\nboolean containskey(key)：是否包含key\nboolean containsvalue(value) ：是否包含value\n4，取出。\nint size()：返回长度\nvalue get(key) ：通过指定键获取对应的值。如果返回null，可以判断该键不存在。当然有特殊情况，就是在hashmap集合中，是可以存储null键null值的。\ncollection values()：获取map集合中的所有的值。\n5，想要获取map中的所有元素：\n原理：map中是没有迭代器的，collection具备迭代器，只要将map集合转成set集合，可以使用迭代器了。之所以转成set，是因为map集合具备着键的唯一性，其实set集合就来自于map，set集合底层其实用的就是map的方法。\n★ 把map集合转成set的方法：\nset keyset();\nset entryset();//取的是键和值的映射关系。\nentry就是map接口中的内部接口；\n为什么要定义在map内部呢？entry是访问键值关系的入口，是map的入口，访问的是map中的键值对。\n——————————————————————————————————————————————————————\n取出map集合中所有元素的方式一：keyset()方法。\n可以将map集合中的键都取出存放到set集合中。对set集合进行迭代。迭代完成，再通过get方法对获取到的键进行值的获取。\nset keyset = map.keyset();\niterator it = keyset.iterator();\nwhile(it.hasnext()) {\nobject key = it.next();\nobject value = map.get(key);\nsystem.out.println(key+\u0026rdquo;:\u0026quot;+value);\n}\n——————————————————————————————————————————————————————\n取出map集合中所有元素的方式二：entryset()方法。\nset entryset = map.entryset();\niterator it = entryset.iterator();\nwhile(it.hasnext()) {\nmap.entry me = (map.entry)it.next();\nsystem.out.println(me.getkey()+\u0026rdquo;::::\u0026quot;+me.getvalue());\n}\n——————————————————————————————————————————————————————\n使用集合的技巧：\n看到array就是数组结构，有角标，查询速度很快。\n看到link就是链表结构：增删速度快，而且有特有方法。addfirst； addlast； removefirst()； removelast()； getfirst()；getlast()；\n看到hash就是哈希表，就要想要哈希值，就要想到唯一性，就要想到存入到该结构的中的元素必须覆盖hashcode，equals方法。\n看到tree就是二叉树，就要想到排序，就想要用到比较。\n比较的两种方式：\n一个是comparable：覆盖compareto方法；\n一个是comparator：覆盖compare方法。\nlinkedhashset，linkedhashmap:这两个集合可以保证哈希表有存入顺序和取出顺序一致，保证哈希表有序。\n集合什么时候用？\n当存储的是一个元素时，就用collection。当存储对象之间存在着映射关系时，就使用map集合。\n保证唯一，就用set。不保证唯一，就用list。\n——————————————————————————————————————————————————————\ncollections：它的出现给集合操作提供了更多的功能。这个类不需要创建对象，内部提供的都是静态方法。\n静态方法：\ncollections.sort(list);//list集合进行元素的自然顺序排序。\ncollections.sort(list,new comparatorbylen());//按指定的比较器方法排序。\nclass comparatorbylen implements comparator{\npublic int compare(string s1,string s2){\nint temp = s1.length()—s2.length();\nreturn temp==0?s1.compareto(s2):temp;\n}\n}\ncollections.max(list); //返回list中字典顺序最大的元素。\nint index = collections.binarysearch(list,\u0026ldquo;zz\u0026rdquo;);//二分查找，返回角标。\ncollections.reverseorder();//逆向反转排序。\ncollections.shuffle(list);//随机对list中的元素进行位置的置换。\n将非同步集合转成同步集合的方法：collections中的 xxx synchronizedxxx(xxx);\nlist synchronizedlist(list);\nmap synchronizedmap(map);\n原理：定义一个类，将集合所有的方法加同一把锁后返回。\ncollection 和 collections的区别：\ncollections是个java.util下的类，是针对集合类的一个工具类,提供一系列静态方法,实现对集合的查找、排序、替换、线程安全化（将非同步的集合转换成同步的）等操作。\ncollection是个java.util下的接口，它是各种集合结构的父接口，继承于它的接口主要有set和list,提供了关于集合的一些操作,如插入、删除、判断一个元素是否其成员、遍历等。\n——————————————————————————————————————————————————————\narrays：\n用于操作数组对象的工具类，里面都是静态方法。\naslist方法：将数组转换成list集合。\nstring[] arr = {\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;kk\u0026rdquo;,\u0026ldquo;qq\u0026rdquo;};\nlist list = arrays.aslist(arr);//将arr数组转成list集合。\n将数组转换成集合，有什么好处呢？用aslist方法，将数组变成集合；\n可以通过list集合中的方法来操作数组中的元素：isempty()、contains、indexof、set； 注意（局限性）：数组是固定长度，不可以使用集合对象增加或者删除等，会改变数组长度的功能方法。比如add、remove、clear。（会报不支持操作异常unsupportedoperationexception）；\n如果数组中存储的引用数据类型，直接作为集合的元素可以直接用集合方法操作。\n如果数组中存储的是基本数据类型，aslist会将数组实体作为集合元素存在。\n集合变数组：用的是collection接口中的方法：toarray();\n如果给toarray传递的指定类型的数据长度小于了集合的size，那么toarray方法，会自定再创建一个该类型的数据，长度为集合的size。\n如果传递的指定的类型的数组的长度大于了集合的size，那么toarray方法，就不会创建新数组，直接使用该数组即可，并将集合中的元素存储到数组中，其他为存储元素的位置默认值null。\n所以，在传递指定类型数组时，最好的方式就是指定的长度和size相等的数组。\n**将集合变成数组后有什么好处？**限定了对集合中的元素进行增删操作，只要获取这些元素即可。\n——————————————————————————————————————————————————————\njdk5.0新特性：\ncollection在jdk1.5以后，有了一个父接口iterable，这个接口的出现的将iterator方法进行抽取，提高了扩展性。\n——————————————————————————————————————————————————————\n增强for循环：foreach语句，foreach简化了迭代器。\n格式：// 增强for循环括号里写两个参数，第一个是声明一个变量，第二个就是需要迭代的容器\nfor( 元素类型 变量名 : collection集合 \u0026amp; 数组 ) {\n…\n}\n高级for循环和传统for循环的区别：\n高级for循环在使用时，必须要明确被遍历的目标。这个目标，可以是collection集合或者数组，如果遍历collection集合，在遍历过程中还需要对元素进行操作，比如删除，需要使用迭代器。\n如果遍历数组，还需要对数组元素进行操作，建议用传统for循环因为可以定义角标通过角标操作元素。如果只为遍历获取，可以简化成高级for循环，它的出现为了简化书写。\n**高级for循环可以遍历map集合吗？**不可以。但是可以将map转成set后再使用foreach语句。\n1)、作用：对存储对象的容器进行迭代： 数组 collection map\n2)、增强for循环迭代数组：\nstring [] arr = {\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;};//数组的静态定义方式，只试用于数组首次定义的时候\nfor(string s : arr) {\nsystem.out.println(s);\n}\n3)、单列集合 collection：\nlist list = new arraylist();\nlist.add(\u0026ldquo;aaa\u0026rdquo;);\n// 增强for循环, 没有使用泛型的集合能不能使用增强for循环迭代？能\nfor(object obj : list) {\nstring s = (string) obj;\nsystem.out.println(s);\n}\n4)、双列集合 map：\nmap map = new hashmap();\nmap.put(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;aaa\u0026rdquo;);\n// 传统方式：必须掌握这种方式\nset entrys = map.entryset(); // 1.获得所有的键值对entry对象\niter = entrys.iterator(); // 2.迭代出所有的entry\nwhile(iter.hasnext()) {\nmap.entry entry = (entry) iter.next();\nstring key = (string) entry.getkey(); // 分别获得key和value\nstring value = (string) entry.getvalue();\nsystem.out.println(key + \u0026ldquo;=\u0026rdquo; + value);\n}\n// 增强for循环迭代：原则上map集合是无法使用增强for循环来迭代的，因为增强for循环只能针对实现了iterable接口的集合进行迭代；iterable是jdk5中新定义的接口，就一个方法iterator方法，只有实现了iterable接口的类，才能保证一定有iterator方法，java有这样的限定是因为增强for循环内部还是用迭代器实现的，而实际上，我们可以通过某种方式来使用增强for循环。\nfor(object obj : map.entryset()) {\nmap.entry entry = (entry) obj; // obj 依次表示entry\nsystem.out.println(entry.getkey() + \u0026ldquo;=\u0026rdquo; + entry.getvalue());\n}\n5）、集合迭代注意问题：在迭代集合的过程中，不能对集合进行增删操作（会报并发访问异常）；可以用迭代器的方法进行操作（子类listiterator：有增删的方法）。\n6)、增强for循环注意问题：在使用增强for循环时，不能对元素进行赋值；\nint[] arr = {1,2,3};\nfor(int num : arr) {\nnum = 0; //不能改变数组的值\n}\nsystem.out.println(arr[1]); //2\n——————————————————————————————————————————————————————\n可变参数（\u0026hellip;）：用到函数的参数上，当要操作的同一个类型元素个数不确定的时候，可是用这个方式，这个参数可以接受任意个数的同一类型的数据。\n和以前接收数组不一样的是：\n以前定义数组类型，需要先创建一个数组对象，再将这个数组对象作为参数传递给函数。现在，直接将数组中的元素作为参数传递即可。底层其实是将这些元素进行数组的封装，而这个封装动作，是在底层完成的，被隐藏了。所以简化了用户的书写，少了调用者定义数组的动作。\n如果在参数列表中使用了可变参数，可变参数必须定义在参数列表结尾(也就是必须是最后一个参数，否则编译会失败。)。\n如果要获取多个int数的和呢？可以使用将多个int数封装到数组中，直接对数组求和即可。\n——————————————————————————————————————————————————————\n静态导入：导入了类中的所有静态成员，简化静态成员的书写。\nimport static java.util.collections.*; //导入了collections类中的所有静态成员\n——————————————————————————————————————————————————————\n枚举：关键字 enum\n问题：对象的某个属性的值不能是任意的，必须为固定的一组取值其中的某一个；\n解决办法：\n1）、在setgrade方法中做判断，不符合格式要求就抛出异常；\n2）、直接限定用户的选择，通过自定义类模拟枚举的方式来限定用户的输入，写一个grade类，私有构造函数，对外提供5个静态的常量表示类的实例；\n3)、jdk5中新定义了枚举类型，专门用于解决此类问题；\n4)、枚举就是一个特殊的java类，可以定义属性、方法、构造函数、实现接口、继承类；\n——————————————————————————————————————————————————————\n自动拆装箱：java中数据类型分为两种 ： 基本数据类型 引用数据类型(对象)\n在 java程序中所有的数据都需要当做对象来处理，针对8种基本数据类型提供了包装类，如下：\nint ——\u0026gt; integer\nbyte ——\u0026gt; byte\nshort ——\u0026gt; short\nlong ——\u0026gt; long\nchar ——\u0026gt; character\ndouble ——\u0026gt; double\nfloat ——\u0026gt; float\nboolean ——\u0026gt; boolean\njdk5以前基本数据类型和包装类之间需要互转：\n基本———引用 integer x = new integer(x);\n引用———基本 int num = x.intvalue();\n1)、integer x = 1; x = x + 1; 经历了什么过程？装箱 ——\u0026gt; 拆箱——\u0026gt; 装箱；\n2)、为了优化，虚拟机为包装类提供了缓冲池，integer池的大小 —128~127 一个字节的大小；\n3)、string****池：java为了优化字符串操作 提供了一个缓冲池；\n——————————————————————————————————————————————————————\n**泛型：**jdk1.5版本以后出现的一个安全机制。表现格式：\u0026lt; \u0026gt;\n好处：\n1：将运行时期的问题classcastexception问题转换成了编译失败，体现在编译时期，程序员就可以解决问题。\n2：避免了强制转换的麻烦。\n只要带有\u0026lt;\u0026gt;的类或者接口，都属于带有类型参数的类或者接口，在使用这些类或者接口时，必须给\u0026lt;\u0026gt;中传递一个具体的引用数据类型。\n泛型技术：其实应用在编译时期，是给编译器使用的技术，到了运行时期，泛型就不存在了。\n为什么? 因为泛型的擦除：也就是说，编辑器检查了泛型的类型正确后，在生成的类文件中是没有泛型的。\n在运行时，如何知道获取的元素类型而不用强转呢？\n泛型的补偿：因为存储的时候，类型已经确定了是同一个类型的元素，所以在运行时，只要获取到该元素的类型，在内部进行一次转换即可，所以使用者不用再做转换动作了。\n什么时候用泛型类呢？\n当类中的操作的引用数据类型不确定的时候，以前用的object来进行扩展的，现在可以用泛型来表示。这样可以避免强转的麻烦，而且将运行问题转移到的编译时期。\n——————————————————————————————————————————————————————\n泛型在程序定义上的体现：\n//泛型类：将泛型定义在类上。\nclass tool {\nprivate q obj;\npublic void setobject(q obj) {\nthis.obj = obj;\n}\npublic q getobject() {\nreturn obj;\n}\n}\n//当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上。\npublic void method(w w) {\nsystem.out.println(\u0026ldquo;method:\u0026quot;+w);\n}\n//静态方法上的泛型：静态方法无法访问类上定义的泛型。如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。\npublic static void function(q t) {\nsystem.out.println(\u0026ldquo;function:\u0026quot;+t);\n}\n//泛型接口.\ninterface inter {\nvoid show(t t);\n}\nclass interimpl implements inter {\npublic void show(r r) {\nsystem.out.println(\u0026ldquo;show:\u0026quot;+r);\n}\n}\n——————————————————————————————————————————————————————\n泛型中的通配符：可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用object类中的功能。那么可以用 ? 通配符来表未知类型。\n泛型限定：\n上限：？extends e：可以接收e类型或者e的子类型对象。\n下限：？super e：可以接收e类型或者e的父类型对象。\n上限什么时候用：往集合中添加元素时，既可以添加e类型对象，又可以添加e的子类型对象。为什么？因为取的时候，e类型既可以接收e类对象，又可以接收e的子类型对象。\n**下限什么时候用：**当从集合中获取元素进行操作的时候，可以用当前元素的类型接收，也可以用当前元素的父类型接收。\n泛型的细节：\n1）、泛型到底代表什么类型取决于调用者传入的类型，如果没传，默认是object类型；\n2）、使用带泛型的类创建对象时，等式两边指定的泛型必须一致；\n原因：编译器检查对象调用方法时只看变量，然而程序运行期间调用方法时就要考虑对象具体类型了；\n3）、等式两边可以在任意一边使用泛型，在另一边不使用(考虑向后兼容)；\narraylist al = new arraylist(); //错\n//要保证左右两边的泛型具体类型一致就可以了，这样不容易出错。\narraylist\u0026lt;? extends object\u0026gt; al = new arraylist();\nal.add(\u0026ldquo;aa\u0026rdquo;); //错\n//因为集合具体对象中既可存储string，也可以存储object的其他子类，所以添加具体的类型对象不合适，类型检查会出现安全问题。 ？extends object 代表object的子类型不确定，怎么能添加具体类型的对象呢？\npublic static void method(arraylist\u0026lt;? extends object\u0026gt; al) {\nal.add(\u0026ldquo;abc\u0026rdquo;); //错\n//只能对al集合中的元素调用object类中的方法，具体子类型的方法都不能用，因为子类型不确定。\n}\n——————————————————————————————————————————————————————\napi**——— java.lang.**system: 属性和行为都是静态的。\nlong currenttimemillis(); // 返回当前时间毫秒值\nexit(); // 退出虚拟机\nproperties getproperties**() ;** // 获取当前系统的属性信息\nproperties prop = system.getproperties(); //获取系统的属性信息，并将这些信息存储到properties集合中。\nsystem.setproperty(\u0026ldquo;myname\u0026rdquo;,\u0026ldquo;毕老师\u0026rdquo;); //给系统属性信息集添加具体的属性信息\n//临时设置方式：运行jvm时，可以通过jvm的参数进行系统属性的临时设置，可以在java命令的后面加入 –d= 用法：java –dmyname=小明 类名。\nstring name = system.getproperty(\u0026ldquo;os.name\u0026rdquo;);//获取指定属性的信息\n//想要知道该系统是否是该软件所支持的系统中的一个。\nset hs = new hashset();\nhs.add(\u0026ldquo;windows xp\u0026rdquo;);\nhs.add(\u0026ldquo;windows 7\u0026rdquo;);\nif(hs.contains(name))\nsystem.out.println(\u0026ldquo;可以支持\u0026rdquo;);\nelse\nsystem.out.println(\u0026ldquo;不支持\u0026rdquo;);\n——————————————————————————————————————————————————————\napi**——— java.lang.**runtime: 类中没有构造方法，不能创建对象。\n但是有非静态方法。说明该类中应该定义好了对象，并可以通过一个static方法获取这个对象。用这个对象来调用非静态方法。这个方法就是 static runtime getruntime();\n这个runtime其实使用单例设计模式进行设计。\nclass runtimedemo {\npublic static void main(string[] args) throws exception {\nruntime r = runtime.getruntime();\nprocess p = r.exec(\u0026ldquo;notepad.exe systemdemo.java\u0026rdquo;); //运行指定的程序\nthread.sleep(4000);\np.destroy(); //杀掉进程\n}\n}\n——————————————————————————————————————————————————————\napi**——— java.util.math**: 用于数学运算的工具类，属性和行为都是静态的。该类是final不允许继承。\nstatic double ceil(double a) ; //返回大于指定数值的最小整数\nstatic double floor(double a) ; //返回小于指定数值的最大整数\nstatic long round(double a) ; //四舍五入成整数\nstatic double pow(double a, double b) ; //a的b次幂\nstatic double random(); //返回0~1的伪随机数\npublic static void main(string[] args) {\nrandom r = new random();\nfor(int x=0; x\u0026lt;10; x++) {\n//double d = math.floor(math.random()*10+1);\n//int d = (int)(math.random()*10+1);\nint d = r.nextint(10)+1;\nsystem.out.println(d);\n}\n}\n——————————————————————————————————————————————————————\napi——— java.util.date：日期类，月份从0—11；\n/*\n日期对象和毫秒值之间的转换。\n1，日期对象转成毫秒值。date类中的gettime方法。\n2，如何将获取到的毫秒值转成具体的日期呢？\ndate类中的settime方法。也可以通过构造函数。\n*/\n//日期对象转成毫秒值\ndate d = new date();\nlong time1 = d.gettime();\nlong time2 = system.currenttimemillis(); / /毫秒值。\n//毫秒值转成具体的日期\nlong time = 1322709921312l;\ndate d = new date();\nd.settime(time);\n/*\n将日期字符串转换成日期对象：使用的就是dateformat方法中的 date parse(string source) ；\n*/\npublic static void method() throws exception {\nstring str_time = \u0026ldquo;2011/10/25\u0026rdquo;;\ndateformat df = new simpledateformat(\u0026ldquo;yyyy/mm/dd\u0026rdquo;); //simpledateformat作为可以指定用户自定义的格式来完成格式化。\ndate d = df.parse(str_time);\n}\n/*\n如果不需要使用特定的格式化风格，完全可以使用dateformat类中的静态工厂方法获取具体的已经封装好风格的对象。getdateinstance();getdatetimeinstance();\n*/\ndate d = new date();\ndateformat df = dateformat.getdateinstance(dateformat.long);\ndf = dateformat.getdatetimeinstance(dateformat.long,dateformat.long);\nstring str_time = df.format(d);\n//将日期对象转换成字符串的方式：dateformat类中的format方法。\n//创建日期格式对象。\ndateformat df = new simpledateformat(); //该对象的建立内部会封装一个默认的日期格式。11—12—1 下午1:48\n//如果想要自定义日期格式的话。可使用simpledateformat****的构造函数。将具体的格式作为参数传入到构造函数中。如何表示日期中年的部分呢？可以必须要参与格式对象文档。 df = new simpledateformat(\u0026ldquo;yyyy年mm月dd日 hh:mm:ss\u0026rdquo;);\n//调用dateformat中的format方法。对已有的日期对象进行格式化。\nstring str_time = df.format(d);\n——————————————————————————————————————————————————————\napi——— java.util. calendar：日历类\npublic static void method(){\ncalendar c = calendar.getinstance();\nsystem.out.println(c.get(calendar.year)+\u0026ldquo;年\u0026rdquo;+(c.get(calendar.month)+1)+\u0026ldquo;月\u0026rdquo;\n+getnum(c.get(calendar.day_of_month))+\u0026ldquo;日\u0026rdquo;\n+\u0026ldquo;星期\u0026rdquo;+getweek(c.get(calendar.day_of_week)));\n}\npublic static string getnum(int num){\nreturn num\u0026gt;9 ? num+\u0026rdquo;\u0026rdquo; : \u0026ldquo;0\u0026rdquo;+num;\n}\npublic static string getweek(int index){\n/*\n查表法：建立数据的对应关系.\n最好：数据个数是确定的，而且有对应关系。如果对应关系的一方，是数字，而且可以作为角标，那么可以通过数组来作为表。\n*/\nstring[] weeks = {\u0026rdquo;\u0026rdquo;,\u0026ldquo;日\u0026rdquo;,\u0026ldquo;一\u0026rdquo;,\u0026ldquo;二\u0026rdquo;,\u0026ldquo;三\u0026rdquo;,\u0026ldquo;四\u0026rdquo;,\u0026ldquo;五\u0026rdquo;,\u0026ldquo;六\u0026rdquo;};\nreturn weeks[index];\n}\n——————————————————————————————————————————————————————\nio流：★★★★★，用于处理设备上数据。\n流：可以理解数据的流动，就是一个数据流。io流最终要以对象来体现，对象都存在io包中。\n流也进行分类：\n1：输入流（读）和输出流（写）。\n2：因为处理的数据不同，分为字节流和字符流。 字节流：处理字节数据的流对象。设备上的数据无论是图片或者dvd，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。\n**那么为什么要有字符流呢？**因为字符每个国家都不一样，所以涉及到了字符编码问题，那么gbk编码的中文用unicode编码解析是有问题的，所以需要获取中文字节数据的同时+ 指定的编码表才可以解析正确数据。为了方便于文字的解析，所以将字节流和编码表封装成对象，这个对象就是字符流。只要操作字符数据，优先考虑使用字符流体系。\n注意：流的操作只有两种：读和写。\n流的体系因为功能不同，但是有共性内容，不断抽取，形成继承体系。该体系一共有四个基类，而且都是抽象类。\n字节流：inputstream outputstream\n字符流：reader writer\n在这四个系统中，它们的子类，都有一个共性特点：子类名后缀都是父类名，前缀名都是这个子类的功能名称。\n——————————————————————————————————————————————————————\npublic static void main(string[] args) throws ioexception { //读、写都会发生io异常\n/*\n1：创建一个字符输出流对象，用于操作文件。该对象一建立，就必须明确数据存储位置，是一个文件。\n2：对象产生后，会在堆内存中有一个实体，同时也调用了系统底层资源，在指定的位置创建了一个存储数据的文件。\n3：如果指定位置，出现了同名文件，文件会被覆盖。\n*/\nfilewriter fw = new filewriter(\u0026ldquo;demo.txt\u0026rdquo;); // filenotfoundexception\n/*\n调用writer类中的write方法写入字符串。字符串并未直接写入到目的地中，而是写入到了流中，(其实是写入到内存缓冲区中)。怎么把数据弄到文件中？\n*/\nfw.write(\u0026ldquo;abcde\u0026rdquo;);\nfw.flush(); // 刷新缓冲区，将缓冲区中的数据刷到目的地文件中。\nfw.close(); // 关闭流，其实关闭的就是java调用的系统底层资源。在关闭前，会先刷新该流。\n}\nclose()和flush()的区别：\nflush()：将缓冲区的数据刷到目的地中后，流可以使用。\nclose()：将缓冲区的数据刷到目的地中后，流就关闭了，该方法主要用于结束调用的底层资源。这个动作一定做。\n——————————————————————————————————————————————————————\nio异常的处理方式：io一定要写finally；\nfilewriter写入数据的细节：\n1：window中的换行符：\\r\\n两个符号组成。 linux：\\n。\n2：续写数据，只要在构造函数中传入新的参数true。\n3：目录分割符：window \\\\ /\npublic static void main(string[] args) {\nfilewriter fw = null;\ntry {\nfw = new filewriter(\u0026ldquo;demo.txt\u0026rdquo;,true);\nfw.write(\u0026ldquo;abcde\u0026rdquo;);\n}\ncatch (ioexception e ){\nsystem.out.println(e.tostring()+\u0026rdquo;\u0026hellip;.\u0026rdquo;);\n}\nfinally{\nif(fw!=null)\ntry{\nfw.close();\n}\ncatch (ioexception e){\nsystem.out.println(\u0026ldquo;close:\u0026quot;+e.tostring());\n}\n}\n}\n——————————————————————————————————————————————————————\nfilereader：使用reader体系，读取一个文本文件中的数据。返回 —1 ，标志读到结尾。\nimport java.io.*;\nclass filereaderdemo {\npublic static void main(string[] args) throws ioexception {\n/*\n创建可以读取文本文件的流对象，filereader让创建好的流对象和指定的文件相关联。\n*/\nfilereader fr = new filereader(\u0026ldquo;demo.txt\u0026rdquo;);\nint ch = 0;\nwhile((ch = fr.read())!= —1) { //条件是没有读到结尾\nsystem.out.println((char)ch); //调用读取流的read方法，读取一个字符。\n}\nfr.close();\n}\n}\n——————————————————————————————————————————————————————\n读取数据的第二种方式：第二种方式较为高效，自定义缓冲区。\nimport java.io.*;\nclass filereaderdemo2 {\npublic static void main(string[] args) throws ioexception {\nfilereader fr = new filereader(\u0026ldquo;demo.txt\u0026rdquo;); //创建读取流对象和指定文件关联。\n//因为要使用read(char[])方法，将读取到字符存入数组。所以要创建一个字符数组，一般数组的长度都是1024的整数倍。\nchar[] buf = new char[1024];\nint len = 0;\nwhile(( len=fr.read(buf)) != —1) {\nsystem.out.println(new string(buf,0,len));\n}\nfr.close();\n}\n}\n——————————————————————————————————————————————————————\nio中的使用到了一个设计模式：装饰设计模式。\n装饰设计模式解决：对一组类进行功能的增强。\n包装：写一个类(包装类)对被包装对象进行包装；\n* 1、包装类和被包装对象要实现同样的接口；\n* 2、包装类要持有一个被包装对象；\n* 3、包装类在实现接口时，大部分方法是靠调用被包装对象来实现的，对于需要修改的方法我们自己实现；\n——————————————————————————————————————————————————————\n字符流：\n**reader：**用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。\n|———bufferedreader：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。\n|———linenumberreader：跟踪行号的缓冲字符输入流。此类定义了方法 setlinenumber(int) 和 getlinenumber()，它们可分别用于设置和获取当前行号。\n|———inputstreamreader：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。\n|———filereader：用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 fileinputstream 上构造一个 inputstreamreader。\n|———chararrayreader：\n|———stringreader：\n——————————————————————————————————————————————————————\nwriter：写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。\n|———bufferedwriter：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。\n|———outputstreamwriter：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。\n|———filewriter：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 fileoutputstream 上构造一个 outputstreamwriter。\n|———printwriter：\n|———chararraywriter：\n|———stringwriter：\n——————————————————————————————————————————————————————\n字节流：\ninputstream：是表示字节输入流的所有类的超类。\n|——— fileinputstream：从文件系统中的某个文件中获得输入字节。哪些文件可用取决于主机环境。fileinputstream 用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 filereader。\n|——— filterinputstream：包含其他一些输入流，它将这些流用作其基本数据源，它可以直接传输数据或提供一些额外的功能。\n|——— bufferedinputstream：该类实现缓冲的输入流。\n|——— stream：\n|——— objectinputstream：\n|——— pipedinputstream：\n——————————————————————————————————————————————————————\noutputstream：此抽象类是表示输出字节流的所有类的超类。\n|——— fileoutputstream：文件输出流是用于将数据写入 file 或 filedescriptor 的输出流。\n|——— filteroutputstream：此类是过滤输出流的所有类的超类。\n|——— bufferedoutputstream：该类实现缓冲的输出流。\n|——— printstream：\n|——— dataoutputstream：\n|——— objectoutputstream：\n|——— pipedoutputstream：\n——————————————————————————————————————————————————————\n缓冲区是提高效率用的，给谁提高呢？\nbufferedwriter：是给字符输出流提高效率用的，那就意味着，缓冲区对象建立时，必须要先有流对象。明确要提高具体的流对象的效率。\nfilewriter fw = new filewriter(\u0026ldquo;bufdemo.txt\u0026rdquo;);\nbufferedwriter bufw = new bufferedwriter(fw);//让缓冲区和指定流相关联。\nfor(int x=0; x\u0026lt;4; x++){\nbufw.write(x+\u0026ldquo;abc\u0026rdquo;);\nbufw.newline(); //写入一个换行符，这个换行符可以依据平台的不同写入不同的换行符。\nbufw.flush();//对缓冲区进行刷新，可以让数据到目的地中。\n}\nbufw.close();//关闭缓冲区，其实就是在关闭具体的流。\n——————————————————————————————————————————————————————\nbufferedreader：\nfilereader fr = new filereader(\u0026ldquo;bufdemo.txt\u0026rdquo;);\nbufferedreader bufr = new bufferedreader(fr);\nstring line = null;\nwhile((line=bufr.readline())!=null){ //readline方法返回的时候是不带换行符的。\nsystem.out.println(line);\n}\nbufr.close();\n——————————————————————————————————————————————————————\n//记住，只要一读取键盘录入，就用这句话。\nbufferedreader bufr = new bufferedreader(new inputstreamreader(system.in));\nbufferedwriter bufw = new bufferedwriter(new outputstreamwriter(system.out));//输出到控制台\nstring line = null;\nwhile((line=bufr.readline())!=null){\nif(\u0026ldquo;over\u0026rdquo;.equals(line))\nbreak;\nbufw.write(line.touppercase());//将输入的字符转成大写字符输出\nbufw.newline();\nbufw.flush();\n}\nbufw.close();\nbufr.close();\n——————————————————————————————————————————————————————\n流对象：其实很简单，就是读取和写入。但是因为功能的不同，流的体系中提供n多的对象。那么开始时，到底该用哪个对象更为合适呢？这就需要明确流的操作规律。\n流的操作规律：\n1，明确源和目的。\n数据源：就是需要读取，可以使用两个体系：inputstream、reader；\n数据汇：就是需要写入，可以使用两个体系：outputstream、writer；\n2，操作的数据是否是纯文本数据？\n如果是：数据源：reader\n数据汇：writer 如果不是：数据源：inputstream\n数据汇：outputstream\n3，虽然确定了一个体系，但是该体系中有太多的对象，到底用哪个呢？\n明确操作的数据设备。\n数据源对应的设备：硬盘(file)，内存(数组)，键盘(system.in)\n数据汇对应的设备：硬盘(file)，内存(数组)，控制台(system.out)。\n4，需要在基本操作上附加其他功能吗？比如缓冲。\n如果需要就进行装饰。\n转换流特有功能：转换流可以将字节转成字符，原因在于，将获取到的字节通过查编码表获取到指定对应字符。\n转换流的最强功能就是基于 字节流 + 编码表 。没有转换，没有字符流。\n发现转换流有一个子类就是操作文件的字符流对象：\ninputstreamreader\n|——filereader\noutputstreamwriter\n|——filewrier\n想要操作文本文件，必须要进行编码转换，而编码转换动作转换流都完成了。所以操作文件的流对象只要继承自转换流就可以读取一个字符了。\n但是子类有一个局限性，就是子类中使用的编码是固定的，是本机默认的编码表，对于简体中文版的系统默认码表是gbk。\nfilereader fr = new filereader(\u0026ldquo;a.txt\u0026rdquo;);\ninputstreamreader isr = new inputstreamreader(new fileinputstream(\u0026ldquo;a.txt\u0026rdquo;),\u0026ldquo;gbk\u0026rdquo;);\n以上两句代码功能一致，\n如果仅仅使用平台默认码表，就使用filereader fr = new filereader(\u0026ldquo;a.txt\u0026rdquo;); //因为简化。\n如果需要制定码表，必须用转换流。\n转换流 = 字节流+编码表。\n转换流的子类file = 字节流 + 默认编码表。\n凡是操作设备上的文本数据，涉及编码转换，必须使用转换流。\n——————————————————————————————————————————————————————\n**file类：**将文件系统中的文件和文件夹封装成了对象。提供了更多的属性和行为可以对这些文件和文件夹进行操作。这些是流对象办不到的，因为流只操作数据。\nfile类常见方法：\n1：创建。\nboolean createnewfile()：在指定目录下创建文件，如果该文件已存在，则不创建。而对操作文件的输出流而言，输出流对象已建立，就会创建文件，如果文件已存在，会覆盖。除非续写。\nboolean mkdir()：创建此抽象路径名指定的目录。\nboolean mkdirs()：创建多级目录。 2：删除。\nboolean delete()：删除此抽象路径名表示的文件或目录。\nvoid deleteonexit()：在虚拟机退出时删除。\n注意：在删除文件夹时，必须保证这个文件夹中没有任何内容，才可以将该文件夹用delete删除。\nwindow的删除动作，是从里往外删。注意：java删除文件不走回收站。要慎用。\n3：获取.\nlong length()：获取文件大小。\nstring getname()：返回由此抽象路径名表示的文件或目录的名称。\nstring getpath()：将此抽象路径名转换为一个路径名字符串。\nstring getabsolutepath()：返回此抽象路径名的绝对路径名字符串。\nstring getparent()：返回此抽象路径名父目录的抽象路径名，如果此路径名没有指定父目录，则返回 null。\nlong lastmodified()：返回此抽象路径名表示的文件最后一次被修改的时间。\nfile.pathseparator：返回当前系统默认的路径分隔符，windows默认为 “；”。\nfile.separator：返回当前系统默认的目录分隔符，windows默认为 “\\”。\n4：判断：\nboolean exists()：判断文件或者文件夹是否存在。\nboolean isdirectory()：测试此抽象路径名表示的文件是否是一个目录。\nboolean isfile()：测试此抽象路径名表示的文件是否是一个标准文件。\nboolean ishidden()：测试此抽象路径名指定的文件是否是一个隐藏文件。\nboolean isabsolute()：测试此抽象路径名是否为绝对路径名。\n5：重命名。\nboolean renameto(file dest)：可以实现移动的效果。剪切+重命名。\nstring[] list()：列出指定目录下的当前的文件和文件夹的名称。包含隐藏文件。\n如果调用list方法的file 对象中封装的是一个文件，那么list方法返回数组为null。如果封装的对象不存在也会返回null。只有封装的对象存在并且是文件夹时，这个方法才有效。\n——————————————————————————————————————————————————————\n递归：就是函数自身调用自身。\n什么时候用递归呢？\n当一个功能被重复使用，而每一次使用该功能时的参数不确定，都由上次的功能元素结果来确定。\n简单说：功能内部又用到该功能，但是传递的参数值不确定。(每次功能参与运算的未知内容不确定)。\n递归的注意事项：\n1：一定要定义递归的条件。\n2：递归的次数不要过多。容易出现 stackoverflowerror 栈内存溢出错误。\n其实递归就是在栈内存中不断的加载同一个函数。\n——————————————————————————————————————————————————————\njava.util.properties：一个可以将键值进行持久化存储的对象。map——hashtable的子类。\nmap\n|——hashtable\n|——properties：用于属性配置文件，键和值都是字符串类型。\n特点：1：可以持久化存储数据。2：键值都是字符串。3：一般用于配置文件。\n|—— load()：将流中的数据加载进集合。\n原理：其实就是将读取流和指定文件相关联，并读取一行数据，因为数据是规则的key=value，所以获取一行后，通过 = 对该行数据进行切割，左边就是键，右边就是值，将键、值存储到properties集合中。\n|—— store()：写入各个项后，刷新输出流。\n|—— list()：将集合的键值数据列出到指定的目的地。\n——————————————————————————————————————————————————————\n以下介绍io包中扩展功能的流对象：基本都是装饰设计模式。\njava.io.outputstream.printstream：打印流\n1：提供了更多的功能，比如打印方法。可以直接打印任意类型的数据。\n2：它有一个自动刷新机制，创建该对象，指定参数，对于指定方法可以自动刷新。\n3：它使用的本机默认的字符编码. 4：该流的print方法不抛出ioexception。\n该对象的构造函数。\nprintstream(file file) ：创建具有指定文件且不带自动行刷新的新打印流。 printstream(file file, string csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 printstream(outputstream out) ：创建新的打印流。 printstream(outputstream out, boolean autoflush) ：创建新的打印流。 printstream(outputstream out, boolean autoflush, string encoding) ：创建新的打印流。 printstream(string filename) ：创建具有指定文件名称且不带自动行刷新的新打印流。 printstream(string filename, string csn) printstream可以操作目的：1：file对象。2：字符串路径。3：字节输出流。\n前两个都jdk1.5版本才出现。而且在操作文本文件时，可指定字符编码了。\n当目的是一个字节输出流时，如果使用的println方法，可以在printstream对象上加入一个true参数。这样对于println方法可以进行自动的刷新，而不是等待缓冲区满了再刷新。最终print方法都将具体的数据转成字符串，而且都对io异常进行了内部处理。\n既然操作的数据都转成了字符串，那么使用printwriter更好一些。因为printwrite是字符流的子类，可以直接操作字符数据，同时也可以指定具体的编码。\n——————————————————————————————————————————————————————\nprintwriter：具备了printstream的特点同时，还有自身特点：\n该对象的目的地有四个：1：file对象。2：字符串路径。3：字节输出流。4：字符输出流。\n开发时尽量使用printwriter。\n方法中直接操作文件的第二参数是编码表。\n直接操作输出流的，第二参数是自动刷新。\n//读取键盘录入将数据转成大写显示在控制台.\nbufferedreader bufr = new bufferedreader(new inputstreamreader(system.in));//源：键盘输入\n//目的：把数据写到文件中，还想自动刷新。\nprintwriter out = new printwriter(new filewriter(\u0026ldquo;out.txt\u0026rdquo;),true);//设置true后自动刷新\nstring line = null;\nwhile((line=bufr.readline())!=null){\nif(\u0026ldquo;over\u0026rdquo;.equals(line))\nbreak;\nout.println(line.touppercase());//转大写输出\n}\n//注意：system.in，system.out这两个标准的输入输出流，在jvm启动时已经存在了。随时可以使用。当jvm结束了，这两个流就结束了。但是，当使用了显示的close方法关闭时，这两个流在提前结束了。\nout.close();\nbufr.close();\n——————————————————————————————————————————————————————\nsequenceinputstream：序列流，作用就是将多个读取流合并成一个读取流。实现数据合并。\n表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。\n这样做，可以更方便的操作多个读取流，其实这个序列流内部会有一个有序的集合容器，用于存储多个读取流对象。\n该对象的构造函数参数是枚举，想要获取枚举，需要有vector集合，但不高效。需用arraylist，但arraylist中没有枚举，只有自己去创建枚举对象。\n但是方法怎么实现呢？因为枚举操作的是具体集合中的元素，所以无法具体实现，但是枚举和迭代器是功能一样的，所以，可以用迭代替代枚举。\n合并原理：多个读取流对应一个输出流。\n切割原理：一个读取流对应多个输出流。\nimport java.io.*;\nimport java.util.*;\nclass splitfiledemo{\nprivate static final string cfg = \u0026ldquo;.properties\u0026rdquo;;\nprivate static final string sp = \u0026ldquo;.part\u0026rdquo;;\npublic static void main(string[] args) throws ioexception{\nfile file = new file(\u0026ldquo;c:\\\\0.bmp\u0026rdquo;);\nfile dir = new file(\u0026ldquo;c:\\\\partfiles\u0026rdquo;);\nmeger(dir);\n}\n//数据的合并。\npublic static void meger(file dir)throws ioexception{\nif(!(dir.exists() \u0026amp;\u0026amp; dir.isdirectory()))\nthrow new runtimeexception(\u0026ldquo;指定的目录不存在，或者不是正确的目录\u0026rdquo;);\nfile[] files = dir.listfiles(new suffixfilter(cfg));\nif(files.length==0)\nthrow new runtimeexception(\u0026ldquo;扩展名.proerpties的文件不存在\u0026rdquo;);\n//获取到配置文件\nfile config = files[0];\n//获取配置文件的信息。\nproperties prop = new properties();\nfileinputstream fis = new fileinputstream(config);\nprop.load(fis);\nstring filename = prop.getproperty(\u0026ldquo;filename\u0026rdquo;);\nint partcount = integer.parseint(prop.getproperty(\u0026ldquo;partcount\u0026rdquo;));\n//——————————————\nfile[] partfiles = dir.listfiles(new suffixfilter(sp));\nif(partfiles.length!=partcount)\nthrow new runtimeexception(\u0026ldquo;缺少碎片文件\u0026rdquo;);\n//—————————\narraylist al = new arraylist();\nfor(int x=0; x\u0026lt;partcount; x++){\nal.add(new fileinputstream(new file(dir,x+sp)));\n}\nenumeration en = collections.enumeration(al);\nsequenceinputstream sis = new sequenceinputstream(en);\nfile file = new file(dir,filename);\nfileoutputstream fos = new fileoutputstream(file);\nbyte[] buf = new byte[1024];\nint len = 0;\nwhile((len=sis.read(buf))!=—1){\nfos.write(buf,0,len);\n}\nfos.close();\nsis.close();\n}\n//带有配置信息的数据切割。\npublic static void splitfile(file file)throws ioexception{\n//用一个读取流和文件关联。\nfileinputstream fis = new fileinputstream(file);\n//创建目的地。因为有多个。所以先创建引用。\nfileoutputstream fos = null;\n//指定碎片的位置。\nfile dir = new file(\u0026ldquo;c:\\\\partfiles\u0026rdquo;);\nif(!dir.exists())\ndir.mkdir();\n//碎片文件大小引用。\nfile f = null;\nbyte[] buf = new byte[1024*1024];\n//因为切割完的文件通常都有规律的。为了简单标记规律使用计数器。\nint count = 0;\nint len = 0;\nwhile((len=fis.read(buf))!=—1){\nf = new file(dir,(count++)+\u0026quot;.part\u0026rdquo;);\nfos = new fileoutputstream(f);\nfos.write(buf,0,len);\nfos.close();\n}\n//碎片文件生成后，还需要定义配置文件记录生成的碎片文件个数。以及被切割文件的名称。\n//定义简单的键值信息，可是用properties。\nstring filename = file.getname();\nproperties prop = new properties();\nprop.setproperty(\u0026ldquo;filename\u0026rdquo;,filename);\nprop.setproperty(\u0026ldquo;partcount\u0026rdquo;,count+\u0026quot;\u0026quot;);\nfile config = new file(dir,count+\u0026quot;.properties\u0026quot;);\nfos = new fileoutputstream(config);\nprop.store(fos,\u0026quot;\u0026quot;);\nfos.close();\nfis.close();\n}\n}\nclass suffixfilter implements filefilter{\nprivate string suffix;\nsuffixfilter(string suffix){\nthis.suffix = suffix;\n}\npublic boolean accept(file file){\nreturn file.getname().endswith(suffix);\n}\n}\n——————————————————————————————————————————————————————\nrandomaccessfile:\n特点：\n1：该对象即可读取，又可写入。\n2：该对象中的定义了一个大型的byte数组，通过定义指针来操作这个数组。\n3：可以通过该对象的getfilepointer()获取指针的位置，通过seek()方法设置指针的位置。\n4：该对象操作的源和目的必须是文件。 5：其实该对象内部封装了字节读取流和字节写入流。\n注意：实现随机访问，最好是数据有规律。\nclass randomaccessfiledemo{\npublic static void main(string[] args) throws ioexception{\nwrite();\nread();\nrandomwrite();\n}\n//随机写入数据，可以实现已有数据的修改。\npublic static void randomwrite()throws ioexception{\nrandomaccessfile raf = new randomaccessfile(\u0026ldquo;random.txt\u0026rdquo;,\u0026ldquo;rw\u0026rdquo;);\nraf.seek(8*4);\nsystem.out.println(\u0026ldquo;pos :\u0026quot;+raf.getfilepointer());\nraf.write(\u0026ldquo;王武\u0026rdquo;.getbytes());\nraf.writeint(102);\nraf.close();\n}\npublic static void read()throws ioexception{\nrandomaccessfile raf = new randomaccessfile(\u0026ldquo;random.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;);//只读模式。\n//指定指针的位置。\nraf.seek(8*1);//实现随机读取文件中的数据。注意：数据最好有规律。\nsystem.out.println(\u0026ldquo;pos1 :\u0026quot;+raf.getfilepointer());\nbyte[] buf = new byte[4];\nraf.read(buf);\nstring name = new string(buf);\nint age = raf.readint();\nsystem.out.println(name+\u0026rdquo;::\u0026quot;+age);\nsystem.out.println(\u0026ldquo;pos2 :\u0026quot;+raf.getfilepointer());\nraf.close();\n}\npublic static void write()throws ioexception{\n//rw：当这个文件不存在，会创建该文件。当文件已存在，不会创建。所以不会像输出流一样覆盖。\nrandomaccessfile raf = new randomaccessfile(\u0026ldquo;random.txt\u0026rdquo;,\u0026ldquo;rw\u0026rdquo;);//rw读写模式\n//往文件中写入人的基本信息，姓名，年龄。\nraf.write(\u0026ldquo;张三\u0026rdquo;.getbytes());\nraf.writeint(97);\nraf.close();\n}\n}\n——————————————————————————————————————————————————————\n管道流：管道读取流和管道写入流可以像管道一样对接上，管道读取流就可以读取管道写入流写入的数据。\n注意：需要加入多线程技术，因为单线程，先执行read，会发生死锁，因为read方法是阻塞式的，没有数据的read方法会让线程等待。\npublic static void main(string[] args) throws ioexception{\npipedinputstream pipin = new pipedinputstream();\npipedoutputstream pipout = new pipedoutputstream();\npipin.connect(pipout);\nnew thread(new input(pipin)).start();\nnew thread(new output(pipout)).start();\n}\n——————————————————————————————————————————————————————\n对象的序列化：目的：将一个具体的对象进行持久化，写入到硬盘上。\n注意：静态数据不能被序列化，因为静态数据不在堆内存中，是存储在静态方法区中。\n如何将非静态的数据不进行序列化？用transient 关键字修饰此变量即可。\nserializable：用于启动对象的序列化功能，可以强制让指定类具备序列化功能，该接口中没有成员，这是一个标记接口。这个标记接口用于给序列化类提供uid。这个uid是依据类中的成员的数字签名进行运行获取的。如果不需要自动获取一个uid，可以在类中，手动指定一个名称为serialversionuid id号。依据编译器的不同，或者对信息的高度敏感性。最好每一个序列化的类都进行手动显示的uid的指定。\nimport java.io.*;\nclass objectstreamdemo {\npublic static void main(string[] args) throws exception{\nwriteobj();\nreadobj();\n}\npublic static void readobj()throws exception{\nobjectinputstream ois = new objectinputstream(new fileinputstream(\u0026ldquo;obj.txt\u0026rdquo;));\nobject obj = ois.readobject();//读取一个对象。\nsystem.out.println(obj.tostring());\n}\npublic static void writeobj()throws ioexception{\nobjectoutputstream oos = new objectoutputstream(new fileoutputstream(\u0026ldquo;obj.txt\u0026rdquo;));\noos.writeobject(new person(\u0026ldquo;lisi\u0026rdquo;,25)); //写入一个对象。\noos.close();\n}\n}\nclass person implements serializable{\nprivate static final long serialversionuid = 42l;\nprivate transient string name;//用transient修饰后name将不会进行序列化\npublic int age;\nperson(string name,int age){\nthis.name = name;\nthis.age = age;\n}\npublic string tostring(){\nreturn name+\u0026rdquo;::\u0026quot;+age;\n}\n}\n——————————————————————————————————————————————————————\ndataoutputstream、datainputstream：专门用于操作基本数据类型数据的对象。\ndataoutputstream dos = new dataoutputstream(new fileoutputstream(\u0026ldquo;data.txt\u0026rdquo;));\ndos.writeint(256);\ndos.close();\ndatainputstream dis = new datainputstream(new fileinputstream(\u0026ldquo;data.txt\u0026rdquo;));\nint num = dis.readint();\nsystem.out.println(num);\ndis.close();\n——————————————————————————————————————————————————————\nbytearrayinputstream：源：内存\nbytearrayoutputstream：目的：内存。\n这两个流对象不涉及底层资源调用，操作的都是内存中数组，所以不需要关闭。\n直接操作字节数组就可以了，为什么还要把数组封装到流对象中呢？因为数组本身没有方法，只有一个length属性。为了便于数组的操作，将数组进行封装，对外提供方法操作数组中的元素。\n对于数组元素操作无非两种操作：设置（写）和获取（读），而这两操作正好对应流的读写操作。这两个对象就是使用了流的读写思想来操作数组。\n//创建源：\nbytearrayinputstream bis = new bytearrayinputstream(\u0026ldquo;abcdef\u0026rdquo;.getbytes());\n//创建目的：\nbytearrayoutputstream bos = new bytearrayoutputstream();\nint ch = 0;\nwhile((ch=bis.read())!=—1){\nbos.write(ch);\n}\nsystem.out.println(bos.tostring());\n——————————————————————————————————————————————————————\n网络编程：\n端口：\n物理端口：\n逻辑端口：用于标识进程的逻辑地址，不同进程的标识；有效端口：0~65535，其中0~1024系统使用或保留端口。\njava 中ip对象：inetaddress.\nimport java.net.*;\nclass ipdemo{\npublic static void main(string[] args) throws unknownhostexception{\n//通过名称(ip字符串or主机名)来获取一个ip对象。\ninetaddress ip = inetaddress.getbyname(\u0026ldquo;www.baidu.com\u0026rdquo;);//java.net.unknownhostexception\nsystem.out.println(\u0026ldquo;addr:\u0026quot;+ip.gethostaddress());\nsystem.out.println(\u0026ldquo;name:\u0026quot;+ip.gethostname());\n}\n}\nsocket：★★★★，套接字，通信的端点。\n就是为网络服务提供的一种机制，通信的两端都有socket，网络通信其实就是socket间的通信，数据在两个socket间通过io传输。\nudp传输：\n1，只要是网络传输，必须有socket 。\n2，数据一定要封装到数据包中，数据包中包括目的地址、端口、数据等信息。\n直接操作udp不可能，对于java语言应该将udp封装成对象，易于我们的使用，这个对象就是datagramsocket. 封装了udp传输协议的socket对象。\n因为数据包中包含的信息较多，为了操作这些信息方便，也一样会将其封装成对象。这个数据包对象就是：datagrampacket.通过这个对象中的方法，就可以获取到数据包中的各种信息。\ndatagramsocket具备发送和接受功能，在进行udp传输时，需要明确一个是发送端，一个是接收端。\nudp的发送端：\n1，建立udp的socket服务，创建对象时如果没有明确端口，系统会自动分配一个未被使用的端口。\n2，明确要发送的具体数据。\n3，将数据封装成了数据包。\n4，用socket服务的send方法将数据包发送出去。\n5，关闭资源。\n——————————————————————————————————————————————————————\nimport java.net.*;\nclass udpsend{\npublic static void main(string[] args)throws exception {\n// 1，建立udp的socket服务。\ndatagramsocket ds = new datagramsocket(8888);//指定发送端口，不指定系统会随机分配。\n// 2，明确要发送的具体数据。\nstring text = \u0026ldquo;udp传输演示 哥们来了\u0026rdquo;;\nbyte[] buf = text.getbytes();\n// 3，将数据封装成了数据包。\ndatagrampacket dp = new datagrampacket(buf,\nbuf.length,inetaddress.getbyname(\u0026ldquo;10.1.31.127\u0026rdquo;),10000);\n// 4，用socket服务的send方法将数据包发送出去。\nds.send(dp);\n// 5，关闭资源。\nds.close();\n}\n}\n——————————————————————————————————————————————————————\nudp的接收端：\n1，创建udp的socket服务，必须要明确一个端口，作用在于，只有发送到这个端口的数据才是这个接收端可以处理的数据。\n2，定义数据包，用于存储接收到数据。\n3，通过socket服务的接收方法将收到的数据存储到数据包中。\n4，通过数据包的方法获取数据包中的具体数据内容，比如ip、端口、数据等等。\n5，关闭资源。\n——————————————————————————————————————————————————————\nclass udprece {\npublic static void main(string[] args) throws exception{\n// 1，创建udp的socket服务。\ndatagramsocket ds = new datagramsocket(10000);\n// 2，定义数据包，用于存储接收到数据。先定义字节数组，数据包会把数据存储到字节数组中。\nbyte[] buf = new byte[1024];\ndatagrampacket dp = new datagrampacket(buf,buf.length);\n// 3，通过socket服务的接收方法将收到的数据存储到数据包中。\nds.receive(dp);//该方法是阻塞式方法。\n// 4，通过数据包的方法获取数据包中的具体数据内容，比如ip，端口，数据等等。\nstring ip = dp.getaddress().gethostaddress();\nint port = dp.getport();\nstring text = new string(dp.getdata(),0,dp.getlength());//将字节数组中的有效部分转成字符串。\nsystem.out.println(ip+\u0026rdquo;:\u0026quot;+port+\u0026quot;——\u0026quot;+text);\n// 5，关闭资源。\nds.close();\n}\n}\n——————————————————————————————————————————————————————\ntcp传输：两个端点的建立连接后会有一个传输数据的通道，这通道称为流，而且是建立在网络基础上的流，称之为socket流。该流中既有读取，也有写入。\ntcp的两个端点：一个是客户端，一个是服务端。\n客户端：对应的对象，socket\n服务端：对应的对象，serversocket\ntcp客户端：\n1，建立tcp的socket服务，最好明确具体的地址和端口。这个对象在创建时，就已经可以对指定ip和端口进行连接(三次握手)。\n2，如果连接成功，就意味着通道建立了，socket流就已经产生了。只要获取到socket流中的读取流和写入流即可，只要通过getinputstream和getoutputstream就可以获取两个流对象。\n3，关闭资源。\n——————————————————————————————————————————————————————\nimport java.net.*;\nimport java.io.*;\n//需求：客户端给服务器端发送一个数据。\nclass tcpclient{\npublic static void main(string[] args) throws exception{\nsocket s = new socket(\u0026ldquo;10.1.31.69\u0026rdquo;,10002);\noutputstream out = s.getoutputstream();//获取了socket流中的输出流对象。\nout.write(\u0026ldquo;tcp演示，哥们又来了!\u0026quot;.getbytes());\ns.close();\n}\n}\n——————————————————————————————————————————————————————\ntcp服务端：\n1，创建服务端socket服务，并监听一个端口。\n2，服务端为了给客户端提供服务，获取客户端的内容，可以通过accept方法获取连接过来的客户端对象。\n3，可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。\n4，如果通讯结束，关闭资源。注意：要先关客户端，再关服务端。\n——————————————————————————————————————————————————————\nclass tcpserver{\npublic static void main(string[] args) throws exception{\nserversocket ss = new serversocket(10002);//建立服务端的socket服务\nsocket s = ss.accept();//获取客户端对象\nstring ip = s.getinetaddress().gethostaddress();\nsystem.out.println(ip+\u0026rdquo;\u0026hellip;..connected\u0026rdquo;);\n// 可以通过获取到的socket对象中的socket流和具体的客户端进行通讯。\ninputstream in = s.getinputstream();//读取客户端的数据，使用客户端对象的socket读取流\nbyte[] buf = new byte[1024];\nint len = in.read(buf);\nstring text = new string(buf,0,len);\nsystem.out.println(text);\n// 如果通讯结束，关闭资源。注意：要先关客户端，在关服务端。\ns.close();\nss.close();\n}\n}\n——————————————————————————————————————————————————————\n反射技术：其实就是动态加载一个指定的类，并获取该类中的所有的内容。而且将字节码文件封装成对象，并将字节码文件中的内容都封装成对象，这样便于操作这些成员。简单说：反射技术可以对一个类进行解剖。\n**反射的好处：**大大的增强了程序的扩展性。\n反射的基本步骤：\n1、获得class对象，就是获取到指定的名称的字节码文件对象。\n2、实例化对象，获得类的属性、方法或构造函数。\n3、访问属性、调用方法、调用构造函数创建对象。\n获取这个class对象，有三种方式：\n1：通过每个对象都具备的方法getclass来获取。弊端：必须要创建该类对象，才可以调用getclass方法。\n2：每一个数据类型(基本数据类型和引用数据类型)都有一个静态的属性class。弊端：必须要先明确该类。\n前两种方式不利于程序的扩展，因为都需要在程序使用具体的类来完成。\n3：使用的class类中的方法，静态的forname方法。\n指定什么类名，就获取什么类字节码文件对象，这种方式的扩展性最强，只要将类名的字符串传入即可。\n// 1. 根据给定的类名来获得 用于类加载\nstring classname = \u0026ldquo;cn.itcast.reflect.person\u0026rdquo;;// 来自配置文件\nclass clazz = class.forname(classname);// 此对象代表person.class\n// 2. 如果拿到了对象，不知道是什么类型 用于获得对象的类型\nobject obj = new person();\nclass clazz1 = obj.getclass();// 获得对象具体的类型\n// 3. 如果是明确地获得某个类的class对象 主要用于传参\nclass clazz2 = person**.class**;\n反射的用法：\n1）、需要获得java类的各个组成部分，首先需要获得类的class对象，获得class对象的三种方式：\nclass.forname(classname) 用于做类加载\nobj.getclass() 用于获得对象的类型\n类名.class 用于获得指定的类型，传参用\n2)、反射类的成员方法：\nclass clazz = person.class;\nmethod method = clazz.getmethod(methodname, new class[]{paramclazz1, paramclazz2});\nmethod.invoke();\n3)、反射类的构造函数：\nconstructor con = clazz.getconstructor(new class[]{paramclazz1, paramclazz2,\u0026hellip;})\ncon.newinstance(params\u0026hellip;)\n4)、反射类的属性：\nfield field = clazz.getfield(fieldname);\nfield.setaccessible(true);\nfield.setobject(value);\n获取了字节码文件对象后，最终都需要创建指定类的对象：\n创建对象的两种方式(其实就是对象在进行实例化时的初始化方式)：\n1，调用空参数的构造函数：使用了class类中的newinstance()方法。\n2，调用带参数的构造函数：先要获取指定参数列表的构造函数对象，然后通过该构造函数的对象的newinstance(实际参数) 进行对象的初始化。\n综上所述，第二种方式，必须要先明确具体的构造函数的参数类型，不便于扩展。所以一般情况下，被反射的类，内部通常都会提供一个公有的空参数的构造函数。\n——————————————————————————————————————————————————————\n// 如何生成获取到字节码文件对象的实例对象。\nclass clazz = class.forname(\u0026ldquo;cn.itcast.bean.person\u0026rdquo;);//类加载\n// 直接获得指定的类型\nclazz = person.class;\n// 根据对象获得类型\nobject obj = new person(\u0026ldquo;zhangsan\u0026rdquo;, 19);\nclazz = obj.getclass();\nobject obj = clazz.newinstance();//该实例化对象的方法调用就是指定类中的空参数构造函数，给创建对象进行初始化。当指定类中没有空参数构造函数时，该如何创建该类对象呢？请看method_2();\npublic static void method_2() throws exception {\nclass clazz = class.forname(\u0026ldquo;cn.itcast.bean.person\u0026rdquo;);\n//既然类中没有空参数的构造函数,那么只有获取指定参数的构造函数,用该函数来进行实例化。\n//获取一个带参数的构造器。\nconstructor constructor = clazz.getconstructor(string.class,int.class);\n//想要对对象进行初始化，使用构造器的方法newinstance();\nobject obj = constructor.newinstance(\u0026ldquo;zhagnsan\u0026rdquo;,30);\n//获取所有构造器。\nconstructor[] constructors = clazz.getconstructors();//只包含公共的\nconstructors = clazz.getdeclaredconstructors();//包含私有的\nfor(constructor con : constructors) {\nsystem.out.println(con);\n}\n}\n——————————————————————————————————————————————————————\n反射指定类中的方法：\n//获取类中所有的方法。\npublic static void method_1() throws exception {\nclass clazz = class.forname(\u0026ldquo;cn.itcast.bean.person\u0026rdquo;);\nmethod[] methods = clazz.getmethods();//获取的是该类中的公有方法和父类中的公有方法。\nmethods = clazz.getdeclaredmethods();//获取本类中的方法，包含私有方法。\nfor(method method : methods) {\nsystem.out.println(method);\n}\n}\n//获取指定方法；\npublic static void method_2() throws exception {\nclass clazz = class.forname(\u0026ldquo;cn.itcast.bean.person\u0026rdquo;);\n//获取指定名称的方法。\nmethod method = clazz.getmethod(\u0026ldquo;show\u0026rdquo;, int.class,string.class);\n//想要运行指定方法，当然是方法对象最清楚，为了让方法运行，调用方法对象的invoke方法即可，但是方法运行必须要明确所属的对象和具体的实际参数。\nobject obj = clazz.newinstance();\nmethod.invoke(obj, 39,\u0026ldquo;hehehe\u0026rdquo;);//执行一个方法\n}\n//想要运行私有方法。\npublic static void method_3() throws exception {\nclass clazz = class.forname(\u0026ldquo;cn.itcast.bean.person\u0026rdquo;);\n//想要获取私有方法。必须用getdeclearmethod();\nmethod method = clazz.getdeclaredmethod(\u0026ldquo;method\u0026rdquo;, null);\n// 私有方法不能直接访问，因为权限不够。非要访问，可以通过暴力的方式。\nmethod.setaccessible(true);//一般很少用，因为私有就是隐藏起来，所以尽量不要访问。\n}\n//反射静态方法。\npublic static void method_4() throws exception {\nclass clazz = class.forname(\u0026ldquo;cn.itcast.bean.person\u0026rdquo;);\nmethod method = clazz.getmethod(\u0026ldquo;function\u0026rdquo;,null);\nmethod.invoke(null,null);\n}\n——————————————————————————————————————————————————————\n正则表达式：★★★☆，其实是用来操作字符串的一些规则。\n好处：正则的出现，对字符串的复杂操作变得更为简单。\n特点：将对字符串操作的代码用一些符号来表示。只要使用了指定符号，就可以调用底层的代码对字符串进行操作。符号的出现，简化了代码的书写。\n弊端：符号的出现虽然简化了书写，但是却降低了阅读性。\n其实更多是用正则解决字符串操作的问题。\n组：用小括号标示，每定义一个小括号，就是一个组，而且有自动编号，从1开始。\n只要使用组，对应的数字就是使用该组的内容。别忘了，数组要加\\\\。\n(aaa(wwww(ccc))(eee))技巧，从左括号开始数即可。有几个左括号就是几组。\n常见操作：\n1，匹配：其实用的就是string类中的matches方法。\nstring reg = \u0026ldquo;[1—9][0—9]{4,14}\u0026rdquo;;\nboolean b = qq.matches(reg);//将正则和字符串关联对字符串进行匹配。\n2，切割：其实用的就是string类中的split方法。\n3，替换：其实用的就是string类中的replaceall();\n4，获取：\n1），先要将正则表达式编译成正则对象。使用的是pattern中静态方法 compile(regex);\n2），通过pattern对象获取matcher对象。\npattern用于描述正则表达式，可以对正则表达式进行解析。\n而将规则操作字符串，需要从新封装到匹配器对象matcher中。\n然后使用matcher对象的方法来操作字符串。\n如何获取匹配器对象呢？\n通过pattern对象中的matcher方法。该方法可以正则规则和字符串想关联。并返回匹配器对象。\n3），使用matcher对象中的方法即可对字符串进行各种正则操作。\n——————————————————————————————————————————————————————\n","date":"2021-10-12","permalink":"https://lovemjh.vercel.app/posts/_java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","summary":"Java基础知识总结（超级经典） 写代码： 1，明确需求。我要做什么？ 2，分析思路。我要怎么做？1,2,3。 3，确定步骤。每一个思路部分用到哪些语句，方法，和对象。","title":"java基础总结"},{"content":"一、基础知识：\n1、jvm、jre和jdk的区别：\njvm(java virtual machine):java虚拟机，用于保证java的跨平台的特性。\njava语言是跨平台，jvm不是跨平台的。\njre(java runtime environment):java的运行环境,包括jvm+java的核心类库。\njdk(java development kit):java的开发工具,包括jre+开发工具\n2、环境变量path和classpath的作用是什么？\n(1)path是配置windows可执行文件的搜索路径，即扩展名为.exe的程序文件所在的目录，\n用于指定dos窗口命令的路径。\n(2)classpath是配置class文件所在的目录，用于指定类搜索路径，jvm就是通过它来寻找该类的class类文件的。\n3、变量有什么用？为什么要定义变量？什么时候用？\n答：变量的作用：用来存储数据。\n为什么要定义变量：用来不断的存放同一类型的常量，并可以重复使用\n4、\u0026amp;和\u0026amp;\u0026amp;的区别?\n答：（1）\u0026amp;\u0026amp;会出现短路，如果可以通过第一个表达式判断出整个表达式的结果，则不继续后面表达式的运算；\n只能操作boolean类型数据；\n（2）\u0026amp;不会出现短路，将整个表达式都运算。既可以操作boolean数据还可以操作数。\n5、标示符命名规则：\n由数字(0-9)，大小写英文字母，以及_和$组成。\n不能以数字开头。\n不能使用关键字来自定义命名。\n6、数据类型：\n(1)基本数据类型(4类8种)：\n整数类型：byte、short、int、long\n浮点数类型：float、double\n字符类型：char\n布尔类型：boolean(ture false)\n(2)引用数据类型：\n类\n接口\n数组\n7、类型转换\n精度从高到低 double float long int short(char) byte\n(1)自动类型转换 将一个低精度\u0026mdash;高精度\n(2)强制类型转换 将一个高精度\u0026mdash;低精度(精度会下降)\n8、java语言的三种技术架构\nj2ee：企业版\n是为开发企业环境下的应用程序提供的一套解决方案。\n该技术体系中包含的技术如 servlet、jsp等，主要针对于web应用程序开发。\nj2se：标准版\n是为开发普通桌面和商务应用程序提供的解决方案。\n该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发。\n比如java版的扫雷。\nj2me：小型版\n是为开发电子消费产品和嵌入式设备提供的解决方案。\n该技术体系主要应用于小型电子消费类产品，如手机中的应用程序等。\n9、java的跨平台性：\n通过java语言编写的应用程序在不同的系统平台上都可以运行。\n跨平台的原因：\n只要在需要运行java应用程序的操作系统上，先安装一个java虚拟机(jvm java virtual machine)即可。\n由jvm来负责java程序在该系统中的运行。\n10、有符号数据的表示法(次重点)\n原码，反码(原码取反)，补码(反码+1)。\n11、函数\n定义：函数就是定义在类中的具有特定功能的一段独立小程序。\n特点：\n定义函数可以将功能代码进行封装\n便于对该功能进行复用\n函数只有被调用才会被执行\n函数的出现提高了代码的复用性\n对于函数没有具体返回值的情况，返回值类型用关键字void表示，\n那么该函数中的return语句如果在最后一行可以省略不写。\n函数的应用两个明确：\n明确要定义的功能最后的结果是什么？\n明确在定义该功能的过程中，是否需要未知内容参与运算\n12、重载：\n概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。\n特点：与返回值类型无关，只看参数列表(参数类型以及参数个数)。\n好处：方便于阅读，优化了程序设计。\n13、数组：\n概念：同一种数据类型的集合。\n好处：可以自动给数组中的元素从0开始编号，方便操作这些元素。\n14、内存结构：\n栈内存：用于存储局部变量，当数据使用完，所占空间会自动释放。\n堆内存：数组和对象，通过new建立的实例都存放在堆内存中。\n方法区：静态成员、构造函数、常量池、线程池\n本地方法区：window系统占用\n寄存器：\n二、面向对象\n1、面向对象思想：\n(1)概述：面向对象是相对于面向过程而言的，面向过程强调的是功能，面向对象强调的是将功能封装进对象，\n强调具备功能的对象；\n(2)思想特点：\na:是符合人们思考习惯的一种思想；\nb:将复杂的事情简单化了；\nc:将程序员从执行者变成了指挥者；\n比如我要达到某种结果，我就寻找能帮我达到该结果的功能的对象，如我要洗衣服我就买洗衣机，\n至于怎么洗我不管。\n(3)特征：\n封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式\n继承: 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义\n这些属性和行为，只要继承那个类即可。\n多态: 一个对象在程序不同运行时刻代表的多种状态，父类或者接口的引用指向子类对象\n2、类和对象：\n类：对现实世界中某类事物的描述,是抽象的，概念上的定义。\n对象：事物具体存在的个体。\n3：成员变量和局部变量的区别(重点)\n(1)作用域\n成员变量：针对整个类有效。\n局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)\n(2)存储位置\n成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。\n局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。\n当方法调用完，或者语句结束后，就自动释放。\n(3)初始值\n成员变量：有默认初始值。\n局部变量：没有默认初始值，使用前必须赋值。\n4、匿名对象\n(1)匿名对象就是没有名字的对象。是对象的一种简写形式。\n(2)应用场景\na:只调用一次类中的方法。\nb:可以作为实际参数在方法传递中使用\n5、封装：\n指隐藏对象的属性和实现细节，仅对外提供公共访问方式；比如电脑机箱、笔记本等\n好处：\n将变化隔离；\n方便使用；\n提高复用性；\n提高安全性\n6、关键字private：封装在代码中的体现\n(1)私有的意思，权限修饰符\n(2)用来修饰成员变量和成员函数\n(3)用private修饰的成员只在本类中有效\n(4)私有是封装的一种体现\n7、构造方法：\n(1)特点：\n方法名与类名相同\n没有返回类型\n没有返回值\n(2)作用：构造函数是用于创建对象，并对其进行初始化赋值，对象一建立就自动调用相对应的构造函数，\n(3)构造方法的注意事项:\na:如果一个自定义类没有构造方法，系统会默认给出一个无参构造方法。\nb:如果一个自定义类提供了构造方法，那么，系统将不再给出无参构造方法。\n这个时候，你可以不使用无参构造方法。\n如果你想使用，那么，就必须手动给出无参构造方法。\n建议：一般情况下，我们的自定义类都要手动给出无参构造方法。\n(4)构造方法和成员方法的区别\na:格式区别\n构造方法和类名相同，并且没有返回类型，也没有返回值。\n普通成员方法可以任意起名，必须有返回类型，可以没有返回值。\nb:作用区别\n构造方法用于创建对象，并进行初始化值。\n普通成员方法是用于完成特定功能的。\nc:调用区别\n构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数\n普通成员方法是由创建好的对象调用，可以调用多次\n8、构造代码块：\n(1)作用：给对象进行初始化，对象一建立就执行，而且优先于构造函数执行\n(2)构造代码块和构造函数的区别：\n构造代码块是给所有不同对象的共性进行统一初始化\n构造函数是给对应的对象进行初始化\n9、this关键字\n(1)this关键字代表本类对象的一个引用，谁调用this所在的方法，this就代表谁\n(2)this的使用场景\na:用于区分同名成员变量和局部变量；\nb:在定义函数时，该函数内部要用到调用该函数的对象时，因为此时对象还没建立，故this代表此对象\nb:构造函数间调用\n**这个时候，this(参数)必须作为第一条语句存在。\n10、person p = new person();在内存中做了哪些事情。\n(1)将person.class文件加载进内存中。\n(2)如果p定义在主方法中，那么，就会在栈空间开辟一个变量空间p。\n(3)在堆内存给对象分配空间。\n(4)对对象中的成员进行默认初始化。\n(5)对对象中的成员进行显示初始化。\n(6)调用构造代码块对对象进行初始化。(如果没有就不执行)\n(7)调用构造方法对对象进行初始化。对象初始化完毕。\n(8)将对象的内存地址赋值给p变量，让p变量指向该对象。\n11、static关键字：\n(1)静态的意思，用来修饰成员变量和成员函数\n(2)静态的特点:\n随着类的加载而加载\n优先于对象存在\n对所有对象共享\n可以被类名直接调用\n(3)静态的注意事项\na:静态方法只能访问静态成员\n为什么：因为静态的内容是随着类的加载而加载，它是先进内存的。\nb:静态方法中不能使用this,super关键字\nc:主方法是静态的\npublic static void main(string[] args)\npublic:公共的意思，是最大权限修饰符。\nstatic:由于jvm调用main方法的时候，没有创建对象。\n只能通过类名调用。所以，main必须用static修饰。\nvoid:由于main方法是被jvm调用，不需要返回值。用void修饰。\nmain:main是主要的意思，所以jvm采用了这个名字。是程序的入口。\nstring[]:字符串数组\nargs:数组名\n在运行的时候，通过java命令给args数组赋值。\n格式：java maintest hello world itcast\n(4)静态变量和成员变量的区别\na：调用方式\n静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。\n这个变量属于类。\n成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。\nb：存储位置\n静态变量存储在方法区长中的静态区。\n成员变量存储在堆内存。\nc：生命周期\n静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。\n成员变量随着对象的创建而存在，随着对象的消失而消失。\nd：与对象的相关性\n静态变量是所有对象共享的数据。\n成员变量是每个对象所特有的数据。\n(5)静态的优点和弊端\n优点：\n对对象的共享数据进行单独空间的存储，节省内存，没有必要每个对象都存储一份\n可直接被类名调用\n弊端：\n生命周期过长，随着类的消失而消失\n访问出现权限，即静态虽好但只能访问静态\n(6)什么使用使用静态呢？\na:当所有对象共享某个数据的时候，就把这个成员变量定义为静态修饰的。\nb:当某个方法没有访问该类中的非静态成员，就可以把这个方法定义为静态修饰。\n静态的生命周期比较长，所以一般不推荐使用。\n(7)静态代码块\na:它只执行一次，它比main还先执行。\nb:执行顺序\n静态代码块\u0026ndash;构造代码块\u0026ndash;构造方法\n12、制作api(次重点)\napi(全拼):application program interface 应用程序编程接口。\n(1)类中的内容需要用文档注释。\n(2)使用jdk\\bin目录下的javadoc工具。\n格式:javadoc -d 目录 -author -version arraytool.java\n13、单例设计模式：\n(1)设计模式：\n解决某类问题行之有效的方法，是一种思想，是规律的总结\n(2)用来保证某个类在内存中只有一个对象\n(3)保证唯一性的思想及步骤\n**为了避免其他程序建立该类对象，先禁止其他程序建立该类对象，即将构造函数私有化\n**为了其他程序访问到该类对象，须在本类中创建一个该类私有对象\n**为了方便其他程序访问到该类对象，可对外提供一个公共访问方式\n比如api中的runtime类就是单例设计模式。\n(4)单例设计模式的两种方式\na:饿汉式 当类加载的时候，就创建对象。\nclass student { private student(){} private static final student s = new student(); public static student getinstance() { return s; } }\nb:懒汉式 当使用的使用，才去创建对象。\nclass student { private student(){} private static final student s = null; public static student getinstance() { if(s==null) {\n//线程1就进来了，线程2就进来了。\ns = new student();\n}\nreturn s;\n}\n}\n饿汉式和懒汉式的区别：\n**\n饿汉式是类一加载进内存就创建好了对象；\n懒汉式则是类才加载进内存的时候，对象还没有存在，只有调用了getinstance()方法时，\n对象才开始创建。\n**\n懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题，解决线程安全问题\n可以加同步来解决。但是加了同步之后，每一次都要比较锁，效率就变慢了，\n所以可以加双重判断来提高程序效率。\n注：开发常用饿汉式，因为饿汉式简单安全。懒汉式多线程的时候容易发生问题\n14、math类的使用(重点)\n(1)数学操作类:该类没有构造函数，方法均为静态的\n(2)掌握内容\na:成员变量\n**e：比任何其他值都更接近e（即自然对数的底数）的double值。\n**pi：比任何其他值都更接近pi（即圆的周长与直径之比）的double值。\nb:成员方法\n**static double abs(double a)\n返回 double 值的绝对值。返回绝对值\n**static double ceil(double a)\n返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数。\n**static double floor(double a)\n返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。\n**max：返回两个值中较大的那个\n**min：返回两个值中较小的那个\n**static long round(double a) 返回最接近参数的 long。\nstatic int round(float a) 返回最接近参数的 int。\n**static double random()\n返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。\n**static double pow(double a, double b)\n返回第一个参数的第二个参数次幂的值。\n**static double sqrt(double a)\n返回正确舍入的 double 值的正平方根。\n15、random类的使用(重点)\n(1)产生随机数的类\n(2)掌握内容\na:构造方法\n**random() 创建一个新的随机数生成器。\n**random(long seed) 使用单个 long 种子创建一个新的随机数生成器。\nb:成员方法\n**int nextint() 返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。\n**int nextint(int n) 返回一个伪随机数，它是取自此随机数生成器序列的、\n在 0（包括）和指定值（不包括）之间均匀分布的 int 值。\n16、scanner类的使用\n(1)可以获取从键盘的输入数据\n(2)掌握内容\n构造方法：\nscanner(inputstream source) 构造一个新的 scanner，它生成的值是从指定的输入流扫描的。\n如：scanner sc = new scanner(system.in);\n方法摘要\nsc.nextint();获取整型数据\nsc.nextline();获取字符串数据\n17、继承(重点)\n(1)把很多类的相同特征和行为进行抽取，用一个类来描述。让多个类和这个类产生一个关系。\n这样的话，多个类就可以省略很多代码。这个关系就是继承。java中用extends关键字表示。\n(2)继承的体系结构\na:多个具体的对象，不断的向上抽取共享的内容，最终形成了一个体系。这个体系叫做继承体系。\nb:继承体系的学习和使用原则\n**学习顶层的内容。因为他是整个体系的共性内容。\n**创建子类使用。也就是使用底层的具体对象。\n(3)继承的特点:\na:java中只能单继承，没有多继承。\nb:java可以有多重(层)继承。\n(4)继承的好处：\n继承的出现提高了代码的复用性。\n继承的出现让类与类之间产生了关系，提供了多态的前提。\n(5)子父类中的成员关系\na:成员变量\n在子类方法中使用一个变量时：\n首先，在方法的局部变量中找这个变量，有则使用。\n否则，在本类中找成员变量，有则使用。\n否则，在父类中找成员变量，有则使用。\n否则，报错。\nb:成员方法\n用子类对象使用一个方法时。\n首先，在子类中找这个方法，有则使用。\n否则，在父类中找这个方法，有则使用。\n否则，报错。\n重写和重载的区别？\n重载：在同一类中。方法名相同，参数列表不同。重载可以改变返回类型。\n重写：在不同类中(子父类中)。\n方法声明相同(返回类型，方法名，参数列表均相同)。\n重写需要注意：\n**子类方法的访问权限要大于等于父类方法的访问权限。\n**静态只能重写静态。但是这种情况一般不会出现。\n构造方法\n**子类的实例化过程\n***子类创建对象时，会先去创建父类的对象。\n默认是去调用父类的无参构造方法。\n***子类构造方法中，第一行默认是super()\n***为什么子类中第一行会默认有super()\n因为他继承父类的成员使用，使用前这些成员必须初始化，\n而他们是父类的成员，所以，必须通过父类进行初始化。\n所以，会先创建一个父类的对象。\n**当父类没有无参构造方法时\n必须使用this或者super调用其他的构造方法。\n(6)this和super的区别\nthis:代表本类对象的引用。\nsuper:代表父类的存储空间。\n18、final关键字(重点)\n(1)最终的意思，可以用于修饰类，方法，变量。\n(2)final修饰的类不能被继承。\nfinal修饰的方法不能被重写。\nfinal修饰的变量是一个常量。只能被赋值一次。\n内部类只能访问被final修饰的局部变量。\n19、抽象类(重点)\n(1)多个类有相同的方法声明，但是方法体不一样。这个时候，我们考虑把方法声明进行抽取。\n让子类继承后，自己去实现方法体。没有方法体的方法，我们需要用抽象标志下。\n抽象的关键字是：abstract。\n(2)抽象类：\n该方法称为抽象方法，包含抽象方法的类就是抽象类。\n(3)抽象类的特点：\na:抽象类和抽象方法都要用abstract进行修饰\nb:抽象类不能被实例化\nc:抽象类中不一定有抽象方法，但是，有抽象方法的类一定是抽象类。\n(4)抽象类中数据的特点\na:成员变量\n抽象类中可以有变量，也可以有常量。\nb:成员方法\n抽象类中可以有抽象方法，也可以有非抽象方法。\nc:构造方法\n抽象类是一个类，所以，它有构造方法。\n虽然本身不能实例化。但是可以给子类实例化使用。\n(5)抽象类中的问题\na:抽象类中是否有构造方法？能不能被实例化？如果不能，为什么有构造方法？\n抽象类有构造方法。\n抽象类不能被实例化。\n抽象类中的构造方法供子类实例化调用。\nb:抽象关键字abstract不可以和哪些关键字共存？\n**private:\n私有内容子类继承不到，所以，不能重写。\n但是abstract修饰的方法，要求被重写。两者冲突。\n**final\nfinal修饰的方法不能被重写。\n而abstract修饰的方法，要求被重写。两者冲突。\n**static\n假如一个抽象方法能通过static修饰，那么这个方法，就可以直接通过类名调用。\n而抽象方法是没有方法体的，这样的调用无意义。所以，不能用static修饰。\nc:抽象类中可不可以没有抽象方法？如果可以，这样的类有什么用吗？\n抽象类可以没有抽象方法。\n抽象类中没有抽象方法的作用，只是为了不让别的类建立该抽象类对象。这个在awt中有体现。\n20、接口interface\n(1)当一个类中的方法都是抽象的时候，java提供了另一种表示方式，叫接口。\n用interface关键字表示。类与接口关系用implements表示。\n(2)接口的成员特点\na:成员变量\n是常量，默认修饰 public static final\nb:成员方法\n都是抽象的，默认修饰 public abstract\n(3)关系\na:类与类的关系\n是继承关系。类与类只能单继承，可以多重继承。\nb:类和接口的关系\n是实现关系。类可以多实现接口。\n类在继承一个类的同时，可以实现多个接口。\nc:接口和接口的关系\n是继承关系。接口可以多继承接口。\n(4)接口的特点\na:是对外暴露的规则\nb:是功能的扩展\nc:接口的出现降低耦合性。\n耦合(类与类之间的关系)\n内聚(类完成功能的能力)\n编程规范：低耦合，高内聚。\nd:接口可以多实现。如：cpu和主板、笔记本的usb插口、插座\n(5)接口和抽象类的区别\na：抽象类只能被单继承\n接口可以多实现,接口的出现避免了多继承的局限性。\nb：抽象类中的数据特点：\n成员变量：可以是变量，也可以是常量\n成员方法：可以是抽象方法，也可以是非抽象方法\n构造方法：有构造方法\n接口中的数据特点：\n成员变量：是常量。默认修饰 public static final\n成员方法：都是抽象方法。都有默认修饰 public abstract\n构造方法：没有构造方法\nc：抽象类中定义的是继承体系中的共性功能。\n接口中定义的是继承体系中的扩展功能。\nd：抽象类被继承是\u0026quot;is a\u0026quot;关系:xx是yy的一种\n接口被实现是\u0026quot;like a\u0026quot;关系:xx像yy的一种\n21、多态：\n(1)同一个对象，在程序不同时刻的多种运行状态。举例：动物，狗是狗，狗是动物。水(气态，液态，固态)\n(2)多态前提\na:存在着继承或者实现关系\nb:有方法的重写\nc:父类(接口)引用指向子类(实现)对象\n(3)多态的好处和弊端：\n好处：多态的存在提高了程序的扩展性和后期可维护性\n弊端：虽然可以预先使用，但是只能访问父类中已有的功能，运行的是后期子类的功能内容。\n不能预先使用子类中定义的特有功能。\n(4)多态中对象调用成员的特点\nfu f = new zi();\na:成员变量\n编译看左边，运行看左边\nb:成员方法\n编译看左边，运行看右边\nc:静态方法\n编译看左边，运行看左边\n(5)多态的思想\n指挥同一批对象做事情。举例：带兵打仗，下课等。\n22、instanceof关键字\na:用于判断某个对象是否是某种类型。\nb:格式\n对象名 instanceof 子类(实现)名\n23、object类：\n(1)是所有类的根类，超类。\njava中提供的类以及我们自定义的类都直接或者间接的继承自object类。\n(2)object类中的方法\na:void finalize()\n当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。\nb:class getclass()\n获取对象的字节码文件的描述类，后面再讲反射的时候还会在说这个类。\nstring name = s.getclass().getname();\nc:int hashcode()\n获取对象的哈希值。其实就是对象的内存地址值十进制表示\nd:string tostring()\n返回对象的字符串表示。\n表示格式：\ngetclass().getname()+\u0026quot;@\u0026quot;+integer.tohexstring(hashcode());\n一般我们输出对象名的时候，其实底层调用的就是该对象的tostring()方法。\n这种返回没有意义，所以，我们会重写这个方法，显示类的成员变量信息。\ne:boolean equals(object obj)\n用于比较两个对象的地址值是否相同。\n我们获取对象后，比较它的地址值意义不大。所以也会对这个方法进行重写。\n重写要完成什么功能，是根据需求定的。\n(3)==和equals的用法：\na:==怎么用？\n**可以用于比较基本数据类型，比较的就是基本数据类型的值是否相等。\n**可以用于比较引用数据类型，比较的是对象的地址值是否相等。\nb:equals怎么用？\nequals只能用于比较引用数据类型的。\n**object提供的equals是用于比较对象地址值是否相同。\n**自定义类中，如果重写了equals方法，那么就是按照你自己的需求来比较的。\n24、package关键字\n(1)包：其实就是文件夹。用于区分不同包下相同的类名。\n(2)好处：\na：对类文件进行分类管理。\nb：给类提供了多层命名空间\naaa.demo\nbbb.demo\nc：写在程序文件的第一行。\nd：包也是一种封装形式。\n25、import关键字\n(1)导入包的关键字\n(2)格式：\nimport 包名;\n(3)注意：\na:一个程序文件中只有一个package，可以有多个import。\nb:用来导包中的类，不导入包中的包。\nc:通常写import mypack.demo，明确自己使用的类。\n(4)关键字的顺序\n类，包，导包这些关键的顺序。\n包 \u0026ndash; \u0026gt; 到包 \u0026ndash; \u0026gt; 类\n26、不同修饰符可以修饰哪些内容\n本类中 同一个包中 不同包中的子类中 不同包中\nprivate ok\n默认 ok ok\nprotected ok ok ok\npublic ok ok ok ok\n类 构造方法 成员变量 成员方法\nprivate ok ok ok\n默认 ok ok ok ok\nprotected ok ok ok\npublic ok ok ok ok\nstatic ok ok\nfinal ok ok ok\nabstract ok ok\n一般格式：\n成员变量：\n权限修饰符+static/final+数据类型+成员变量名\npublic static final int num = 10;\n成员方法：\n权限修饰符+static/final/abstract+返回类型+方法名\n27、内部类(次重点)\n(1)把一个类定义在某个类中的，这个类就被称为内部类，内置类，嵌套类。\n(2)访问特点：\na:内部类可以直接访问外部类中的成员，因为内部类持有外部类的引用，\n格式为：外部类名.this\nb:外部类要想访问内部类的成员，必须创建对象访问。\n(3)内部类的访问格式：\na:当内部类定义在外部类的成员位置，而且非私有，则可以在其他外部类中直接建立内部类对象\n格式：外部类名.内部类名 变量名 = new 外部类对象.内部类对象\n如：outer.inner in = new outer().new inner()\nb:当内部类在外部类成员位置，且被static修饰时\n**外部其他类可直接访问静态内部类的非静态成员\n格式：new 外部类名.内部类名().内部类成员\n如：new outer.inner().function();\n**外部其他类可直接访问静态内部类的静态成员\n格式：new 外部类名.内部类名.内部类成员\n如：new outer.inner.function();\n(4)什么使用时候内部类呢？\n假如有a类和b类，a类想直接访问b类的成员，b类访问a类成员的时候，\n需要创建a类对象进行访问，这个时候，就可以把a类定义为b类的内部类。\n(5)内部类的位置\na:成员位置\n**可以被private修饰(body，heart)\n**可以被static修饰。(它访问的外部类的成员必须是静态的)\nb:局部位置\n**可以直接访问外部类中的成员，因为还持有外部类的持用\n也可以直接访问局部成员，但是局部成员要用final修饰。\n注意：局部内部类不能用private和static修饰\n(6)通过class文件我们就可以区分是否带有内部类，以及内部类的位置\nouter$inner:成员内部类\nouter$1inner:局部内部类\n28、匿名内部类(局部内部类的简写) (重点)\n(1)前提：继承一个类或者实现一个接口\n(注意不要弄混匿名内部类的前提和多态的前提)\n(2)格式：\nnew 父类名或者接口名()\n{\n重写父类方法或者实现接口中的方法。\n也可以自定义其他方法。\n};\n(3)什么时候定义匿名内部类？\n匿名内部类只是为了简化书写，匿名内部类有局限，通常定义匿名内部类时，该类方法不超过3个\n(4)匿名内部类的好处和弊端：\n好处：简化代码书写\n弊端：\n不能直接调用自己的特有方法\n不能执行强转换动作\n如果该类里面方法较多，不允许使用匿名内部类\n29、模板设计模式：\n在定义功能时，功能的一部分是确定的，有一部分是不确定的，而且确定的部分在使用不确定的部分，\n可将不确定的部分暴露出去，由该类的子类去完成。\n如：求一段程序的运行时间例子。\n30、异常\n(1)程序运行过程中的不正常现象就叫异常。\n(2)导致程序运行不正常的现象有很多，所以，就有很多的异常对象。\n而这些异常对象存在着共性的内容，所以，可以不断的进行抽取。最终形成了异常的体系结构。\n异常体系的根类是:throwable\nthrowable：\n|\u0026ndash;error:重大的问题，我们处理不了。也不需要编写代码处理。比如说内存溢出。\n|\u0026ndash;exception:一般性的错误，是需要我们编写代码进行处理的。\n|\u0026ndash;runtimeexception:运行时异常，这个我们也不需要处理。\n其实就是为了让他在运行时出问题，然后我们回来修改代码。\n(3)异常的分类\n异常有两种：\n编译时被检测异常：\n该异常在编译时，如果没有处理(没有抛也没有try)，编译失败。\n该异常被标识，代表这可以被处理。\n运行时异常(编译时不检测)\n在编译时，不需要处理，编译器不检查。\n该异常的发生，建议不处理，让程序停止。需要对代码进行修正。\n(4)异常体系的特点：\n异常体系中的所有类及其子类对象都具备可抛性。也就是说可以被throw和throws关键字所操作。\n(5)main方法是如何处理异常的。\na:在main里面编写代码进行处理\nb:交给jvm自己进行处理。采用的是jvm的默认处理方式。\n其实就是相当于调用了异常对象的printstacktrace()方法。\n(6)throwable类的学习\ngetmessage():获取异常信息，返回字符串。\ntostring():获取异常类名和异常信息，返回字符串。\nprintstacktrace():获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。\n(7)异常的处理·\na:try\u0026hellip;catch\u0026hellip;finally\n基本格式：\ntry { 可能出现异常的代码 } catch(异常对象) { 异常处理代码 } finally { 释放资源 }\n变形格式：\ntry\u0026hellip;catch\ntry\u0026hellip;catch\u0026hellip;catch\u0026hellip;\ntry\u0026hellip;catch\u0026hellip;catch\u0026hellip;finally\n**多个异常同时被捕获的时候，记住一个原则：\n先逮小的，再逮大的。\n**finally:永远被执行，除非退出jvm。system.exit(0);\n面试题2个。\n***：final,finally,finalize区别。\nfinal是最终的意思。它可以用于修饰类，成员变量，成员方法。\n它修饰的类不能被继承，它修饰的变量时常量，它修饰的方法不能被重写。\nfinally:是异常处理里面的关键字。\n它其中的代码永远被执行。特殊情况：在执行它之前jvm退出。system.exit(0);\nfinalize:是object类中的一个方法。\n它是于垃圾回收器调用的方式。\n***：假如catch中有return语句， finally里中的代码会执行吗？\n是在return前，还是在return后呢？\n会，在return前执行finally里面的代码。\n(8)exception和runtimeexception的区别\na:exception:一般性的错误，是需要我们编写代码进行处理的。\nb:runtimeexception:运行时异常，这个我们也不需要处理。\n其实就是为了让他在运行时出问题，然后我们回来修改代码。\n在用throws抛出一个的时候，如果这个异常是属于runtimeexception的体系的时候，\n我们在调用的地方可以不用处理。(runtimeexception和runtimeexception的子类)\n在用throws抛出一个的时候，如果这个异常是属于exception的体系的时候，\n我们在调用的地方必须进行处理或者继续抛出。\n(9)自定义异常\n定义类继承exception或者runtimeexception\n1,为了让该自定义类具备可抛性。\n2，让该类具备操作异常的共性方法。\nclass myexcepiton extends exception { myexcepiton(){}\nmyexcepiton(string message) { super(message); } } class myexception extends runtimeexception { myexcepiton(){}\nmyexcepiton(string message) { super(message); } }\n(10)throws和throw的区别\na：有throws的时候可以没有throw。\n有throw的时候，如果throw抛的异常是exception体系，那么必须有throws在方法上声明。\nb：throws用于方法的声明上，其后跟的是异常类名，后面可以跟多个异常类，之间用逗号隔开\nthrow用于方法体中，其后跟的是一个异常对象名\n三、多线程：\n1、进程和线程：\n进程：正在进行的程序。每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。\n线程：进程内部的一条执行路径或者一个控制单元。\n两者的区别：\n一个进程至少有一个线程\n进程在执行过程中拥有独立的内存单元，而多个线程共享内存；\n2、jvm多线程的启动是多线程吗？\njava的虚拟机jvm启动的是单线程，就有发生内存泄露的可能，而我们使用java程序没出现这样的问题，\n也就是jvm启动至少有两个线程，一个执行java程序，一个执行垃圾回收。所以是多线程。\n2、多线程的优势：\n解决了多部分同时运行的问题，提高效率\n3、线程的弊端：\n线程太多会导致效率的降低，因为线程的执行依靠的是cpu的来回切换。\n4、什么叫多线程：\n一个进程中有多个线程，称为多线程。\n5、实现多线程的方法：\n实现多线程可以通过继承thread类和实现runnable接口。\n(1)继承thread\n定义一个类继承thread类\n复写thread类中的public void run()方法，将线程的任务代码封装到run方法中\n直接创建thread的子类对象，创建线程\n调用start()方法，开启线程(调用线程的任务run方法)\n//另外可以通过thread的getname()获取线程的名称。\n(2)实现runnable接口；\n定义一个类，实现runnable接口；\n覆盖接口的public void run()的方法，将线程的任务代码封装到run方法中；\n创建runnable接口的子类对象\n将runnabl接口的子类对象作为参数传递给thread类的构造函数，创建thread类对象\n（原因：线程的任务都封装在runnable接口子类对象的run方法中。\n所以要在线程对象创建时就必须明确要运行的任务）。\n调用start()方法，启动线程。\n两种方法区别：\n(1)实现runnable接口避免了单继承的局限性\n(2)继承thread类线程代码存放在thread子类的run方法中\n实现runnable接口线程代码存放在接口的子类的run方法中；\n在定义线程时，建议使用实现runnable接口，因为几乎所有多线程都可以使用这种方式实现\n6、创建线程是为什么要复写run方法？\nthread类用于描述线程。thread类定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。\n7、start()和run方法有什么区别？\n调用start方法方可启动线程，而run方法只是thread的一个普通方法，调用run方法不能实现多线程；\nstart()方法:\nstart方法用来启动线程,实现了多线程运行,这时无需等待run方法体代码执行完毕而直接继续执行下面的\n代码。通过调用thread类的start()方法来启动一个线程,这时此线程处于就绪(可运行)状态，并没有运行，\n一旦得到cpu时间片(执行权),就开始执行run()方法,这里方法run()称为线程体，\n它包含了要执行的这个线程的内容，run方法运行结束,此线程随即终止。\nrun()方法:\nrun()方法只是thread类的一个普通方法,如果直接调用run方法,程序中依然只有主线程这一个线程,\n其程序执行路径还是只有一条，还是要等待run方法体执行完毕后才可继续执行下面的代码，\n这样就没有达到多线程的目的。\n8、线程的几种状态：\n新建：new一个thread对象或者其子类对象就是创建一个线程，当一个线程对象被创建，但是没有开启，这个时候，\n只是对象线程对象开辟了内存空间和初始化数据。\n就绪：新建的对象调用start方法，就开启了线程，线程就到了就绪状态。\n在这个状态的线程对象，具有执行资格，没有执行权。\n运行：当线程对象获取到了cpu的资源。\n在这个状态的线程对象，既有执行资格，也有执行权。\n冻结：运行过程中的线程由于某些原因(比如wait,sleep)，释放了执行资格和执行权。\n当然，他们可以回到运行状态。只不过，不是直接回到。\n而是先回到就绪状态。\n死亡：当线程对象调用的run方法结束，或者直接调用stop方法，就让线程对象死亡，在内存中变成了垃圾。\n9、sleep()和wait()的区别：\n(1)这两个方法来自不同的类，sleep()来自thread类，和wait()来自object类。\n(2)sleep是thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，\n要让b线程睡觉要在b的代码中调用sleep。而wait()是object类的非静态方法\n(3)sleep()释放资源不释放锁，而wait()释放资源释放锁；\n(4)使用范围：wait,notify和notifyall只能在同步控制方法或者同步控制块里面使用,而sleep可以在任何地方使用\n10、多线程安全问题：\n(1)原因:当程序的多条语句在操作线程共享数据时(如买票例子中的票就是共享资源)，由于线程的随机性导致\n一个线程对多条语句，执行了一部分还没执行完，另一个线程抢夺到cpu执行权参与进来执行，\n此时就导致共享数据发生错误。比如买票例子中打印重票和错票的情况。\n(2)解决方法:对多条操作共享数据的语句进行同步，一个线程在执行过程中其他线程不可以参与进来\n11、java中多线程同步是什么？\n同步是用来解决多线程的安全问题的，在多线程中，同步能控制对共享数据的访问。如果没有同步，当一个线程在\n修改一个共享数据时，而另外一个线程正在使用或者更新同一个共享数据，这样容易导致程序出现错误的结果。\n12、什么是锁?锁的作用是什么?\n锁就是对象\n锁的作用是保证线程同步，解决线程安全问题。\n持有锁的线程可以在同步中执行，没有锁的线程即使获得cpu执行权，也进不去。\n13、同步的前提:\n(1)必须保证有两个以上线程\n(2)必须是多个线程使用同一个锁，即多条语句在操作线程共享数据\n(3)必须保证同步中只有一个线程在运行\n14、同步的好处和弊端\n好处：同步解决了多线程的安全问题\n弊端：多线程都需要判断锁，比较消耗资源\n15、同步的两种表现形式：\n(1)同步代码块:\n可以指定需要获取哪个对象的同步锁,使用synchronized的代码块同样需要锁,但他的锁可以是任意对象\n考虑到安全问题，一般还是使用同一个对象，相对来说效率较高。\n注意：\n**虽然同步代码快的锁可以使任何对象，但是在进行多线程通信使用同步代码快时，\n必须保证同步代码快的锁的对象和，否则会报错。\n**同步函数的锁是this，也要保证同步函数的锁的对象和调用wait、notify和notifyall的对象是\n同一个对象，也就是都是this锁代表的对象。\n格式：\nsynchronized(对象)\n{\n需同步的代码;\n}\n(2)同步函数\n同步方法是指进入该方法时需要获取this对象的同步锁，在方法上使用synchronized关键字，\n使用this对象作为锁，也就是使用了当前对象，因为锁住了方法，所以相对于代码块来说效率相对较低。\n注:静态同步函数的锁是该方法所在的类的字节码文件对象，即类名.class文件\n格式：\n修饰词 synchronized 返回值类型 函数名(参数列表)\n{\n需同步的代码;\n}\n在jdk1.5后，用lock锁取代了synchronized，个人理解也就是对同步代码块做了修改，\n并没有提供对同步方法的修改，主要还是效率问题吧。\n16、多线程的单例设计模式：保证某个类中内存中只有一个对象\n(1)饿汉式:\n1 class single 2 { 3 private single(){}//将构造函数私有化，不让别的类建立该类对象 4 private static final single s=new single();//自己建立一个对象 5 public static single getinstance()//提供一个公共访问方式 6 { 7 return s; 8 } 9 } 10 (2)懒汉式： 11 class single 12 { 13 private single(){} 14 private static single s; 15 public static single getinstance() 16 { 17 if(s==null) 18 s=new single(); 19 return s; 20 } 21 }\n饿汉式和懒汉式的区别：\n**\n饿汉式是类一加载进内存就创建好了对象；\n懒汉式则是类加载进内存的时候，对象还没有存在，只有调用了getinstance()方法时，对象才开始创建。\n**\n懒汉式是延迟加载，如果多个线程同时操作懒汉式时就有可能出现线程安全问题，解决线程安全问题\n可以加同步来解决。但是加了同步之后，每一次都要比较锁，效率就变慢了，\n所以可以加双重判断来提高程序效率。\n如将上述懒汉式的instance函数改成同步：\npublic static single getinstance()\n{\nif(s==null)\n{\nsynchronized(single.class)\n{\nif(s==null)\ns=new single();\n}\n}\nreturn s;\n}\n17、死锁\n两个线程对两个同步对象具有循环依赖时，就会发生死锁。即同步嵌套同步，而锁却不同。\n18、wait()、sleep()、notify()、notifyall()\nwait():使一个线程处于等待状态，并且释放所持有的对象的lock。\nsleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉interruptedexception异常。\nnotify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，\n而是由jvm确定唤醒哪个线程(一般是最先开始等待的线程)，而且不是按优先级。\nallnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。\n18、为什么wait()、notify()、notifyall()这些用来操作线程的方法定义在object类中？\n(1)这些方法只存在于同步中；\n(2)使用这些方法时必须要指定所属的锁，即被哪个锁调用这些方法；\n(3)而锁可以是任意对象，所以任意对象调用的方法就定义在object中。\n19、多线程间通讯：\n多线程间通讯就是多个线程在操作同一资源,但是操作的动作不同.\n(1)为什么要通信\n多线程并发执行的时候, 如果需要指定线程等待或者唤醒指定线程, 那么就需要通信.比如生产者消费者的问题，\n生产一个消费一个,生产的时候需要负责消费的进程等待,生产一个后完成后需要唤醒负责消费的线程,\n同时让自己处于等待，消费的时候负责消费的线程被唤醒，消费完生产的产品后又将等待的生产线程唤醒，\n然后使自己线程处于等待。这样来回通信，以达到生产一个消费一个的目的。\n(2)怎么通信\n在同步代码块中, 使用锁对象的wait()方法可以让当前线程等待, 直到有其他线程唤醒为止.\n使用锁对象的notify()方法可以唤醒一个等待的线程，或者notifyall唤醒所有等待的线程.\n多线程间通信用sleep很难实现，睡眠时间很难把握。\n20、lock和condition\n实现提供比synchronized方法和语句可获得的更广泛的锁的操作，可支持多个相关的condition对象\nlock是个接口\n锁是控制多个线程对共享数据进行访问的工具。\njdk1.5中提供了多线程升级的解决方案：\n将同步synchonized替换成了显示的lock操作，将object中的wait、notify、notifyall替换成了condition对象。\n该对象可以lock锁进行获取\nlock的方法摘要：\nvoid lock() 获取锁。\ncondition newcondition() 返回绑定到此 lock 实例的新 condition 实例。\nvoid unlock() 释放锁。\ncondition方法摘要：\nvoid await() 造成当前线程在接到信号或被中断之前一直处于等待状态。\nvoid signal() 唤醒一个等待线程。\nvoid signalall() 唤醒所有等待线程。\n21、停止线程：\nstop方法已经过时，如何停止线程？\n停止线程的方法只有一种，就是run方法结束。如何让run方法结束呢？\n开启多线程运行，运行代码通常是循环体，只要控制住循环，就可以让run方法结束，也就是结束线程。\n特殊情况：当线程属于冻结状态，就不会读取循环控制标记，则线程就不会结束。\n为解决该特殊情况，可引入thread类中的interrupt方法结束线程的冻结状态；\n当没有指定的方式让冻结线程恢复到运行状态时，需要对冻结进行清除，强制让线程恢复到运行状态\n22、interrupt:\nvoid interrupt() 中断线程:\n中断状态将被清除，它还将收到一个 interruptedexception\n22、守护线程(后台线程)\nsetdaemon(boolean on):将该线程标记为守护线程或者用户线程。\n当主线程结束，守护线程自动结束，比如圣斗士星矢里面的守护雅典娜，\n在多线程里面主线程就是雅典娜，守护线程就是圣斗士，主线程结束了，\n守护线程则自动结束。\n当正在运行的线程都是守护线程时，java虚拟机jvm退出；所以该方法必须在启动线程前调用；\n守护线程的特点：\n守护线程开启后和前台线程共同抢夺cpu的执行权，开启、运行两者都没区别，\n但结束时有区别，当所有前台线程都结束后，守护线程会自动结束。\n23、多线程join方法：\nvoid join() 等待该线程终止。\nvoid join(long millis) 等待该线程终止的时间最长为 millis 毫秒。\nthrows interruptedexception\n特点：当a线程执行到b线程的join方法时，a就会等待b线程都执行完，a才会执行\n作用: join可以用来临时加入线程执行；\n24、多线程优先级：yield()方法\nyield():暂停当前正在执行的线程对象，并执行其他线程\nsetpriority(int newpriority):更改线程优先级\nint getpriority() 返回线程的优先级。\nstring tostring() 返回该线程的字符串表示形式，包括线程名称、优先级和线程组\n(1)max_priority:最高优先级(10级)\n(1)min_priority:最低优先级(1级)\n(1)morm_priority:默认优先级(5级)\n25、什么是threadlocal类,怎么使用它？\nthreadlocal类提供了线程局部 (thread-local) 变量。是一个线程级别的局部变量，并非“本地线程”。\nthreadlocal 为每个使用该变量的线程,提供了一个独立的变量副本，每个线程修改副本时不影响其它线程对象的副本\n下面是线程局部变量(threadlocal variables)的关键点：\n一个线程局部变量(threadlocal variables)为每个线程方便地提供了一个单独的变量。\nthreadlocal 实例通常作为静态的私有的(private static)字段出现在一个类中，这个类用来关联一个线程。\n当多个线程访问 threadlocal 实例时，每个线程维护 threadlocal 提供的独立的变量副本。\n常用的使用可在 dao 模式中见到，当 dao 类作为一个单例类时，\n数据库链接(connection)被每一个线程独立的维护，互不影响。(基于线程的单例)\n26、什么时候抛出invalidmonitorstateexception异常?为什么？\n调用 wait ()/notify ()/notifyall ()中的任何一个方法时，如果当前线程没有获得该对象的锁，\n那么就会抛出 illegalmonitorstateexception 的异常\n也就是说程序在没有执行对象的任何同步块或者同步方法时，\n仍然尝试调用 wait ()/notify ()/notifyall ()时。由于该异常是 runtimeexcpetion 的子类，\n所以该异常不一定要捕获(尽管你可以捕获只要你愿意\n作为 runtimeexception，此类异常不会在 wait (),notify (),notifyall ()的方法签名提及。\n27、在静态方法上使用同步时会发生什么事？\n同步静态方法时会获取该类的“class”对象，所以当一个线程进入同步的静态方法中时，\n线程监视器获取类本身的对象锁，其它线程不能进入这个类的任何静态同步方法。\n它不像实例方法，因为多个线程可以同时访问不同实例同步实例方法。\n28、当一个同步方法已经执行，线程能够调用对象上的非同步实例方法吗？\n可以，一个非同步方法总是可以被调用而不会有任何问题。\n实际上，java 没有为非同步方法做任何检查，锁对象仅仅在同步方法或者同步代码块中检查。\n如果一个方法没有声明为同步，即使你在使用共享数据java照样会调用，而不会做检查是否安全，\n所以在这种情况下要特别小心。一个方法是否声明为同步取决于临界区访问(critial section access)，\n如果方法不访问临界区(共享资源或者数据结构)就没必要声明为同步的。\n29、在一个对象上两个线程可以调用两个不同的同步实例方法吗？\n不能，因为一个对象已经同步了实例方法，线程获取了对象的对象锁。\n所以只有执行完该方法释放对象锁后才能执行其它同步方法。\n30、什么是线程饿死，什么是活锁？\n线程饿死和活锁虽然不像死锁一样是常见的问题，但是对于并发编程的设计者来说就像一次邂逅一样。\n当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。\njavaapi 中线程活锁可能发生在以下情形：\n当所有线程在程序中执行 object.wait (0)，参数为 0 的 wait 方法。\n程序将发生活锁直到在相应的对象上有线程调用 object.notify ()或者 object.notifyall ()。\n当所有线程卡在无限循环中。\n四、集合框架\n1：string类：字符串(重点)\n(1)多个字符组成的一个序列，叫字符串。\n生活中很多数据的描述都采用的是字符串的。而且我们还会对其进行操作。\n所以，java就提供了这样的一个类供我们使用。\n(2)创建字符串对象\n1 a:string():无参构造 2 **举例： 3 string s = new string(); 4 s = \u0026ldquo;hello\u0026rdquo;; 5 sop(s); 6 b:string(byte[] bys):传一个字节数组作为参数 ***** 7 **举例 8 byte[] bys = {97,98,99,100,101}; 9 string s = new string(bys); 10 sop(s); 11 c:string(byte[] bys,int index,int length):把字节数组的一部分转换成一个字符串 ***** 12 **举例 13 byte[] bys = {97,98,99,100,101}; 14 string s = new string(bys,1,2); 15 sop(s); 16 d:string(char[] chs):传一个字符数组作为参数 ***** 17 **举例 18 char[] chs = {\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;}; 19 string s = new string(chs); 20 sop(s); 21 e:string(char[] chs,int index,int length):把字符数组的一部分转换成一个字符串 ***** 22 **举例 23 char[] chs = {\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;}; 24 string s = new string(chs,1,2); 25 sop(s); 26 f:string(string str):把一个字符串传递过来作为参数 27 char[] chs = {\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;}; 28 string ss = new string(s); 29 sop(ss); 30 g:直接把字符串常量赋值给字符串引用对象(最常用) ***** 31 **举例 32 string s = \u0026ldquo;hello\u0026rdquo;; 33 sop(s);\n(3)面试题\na:请问string s = new string(\u0026ldquo;hello\u0026rdquo;);创建了几个对象。\n两个。一个\u0026quot;hello\u0026quot;字符串对象，在方法区的常量池；一个s对象，在栈内存。\nb:请写出下面的结果\nstring s1 = new string(\u0026ldquo;abc\u0026rdquo;);\nstrign s2 = new string(\u0026ldquo;abc\u0026rdquo;);\nstring s3 = \u0026ldquo;abc\u0026rdquo;;\nstring s4 = \u0026ldquo;abc\u0026rdquo;;\nsop(s1==s2); //false\nsop(s1==s3); //false\nsop(s3==s4); //true\nc:字符串对象一旦被创建就不能被改变。\n指的是字符串常量值不改变。\n(4)字符串中各种功能的方法\na:判断\n**** boolean equals(object anobject):判断两个字符串的内容是否相同，复写了object的方法\n**** boolean equalsignorecase(string anotherstring):判断两个字符串的内容是否相同，\n不区分大小写\n**** boolean contains(string s):判断一个字符串中是否包含另一个字符串\n注意：判断字符串是否包含特殊字符.直接表示为str.contains(\u0026quot;.\u0026quot;)\nboolean endswith(string suffix):测试此字符串是否以指定的后缀结束\nboolean startswith(string suffix):测试此字符串是否以指定的前缀开始\nboolean isempty():测试字符串是否为空\nb:获取\n***** int length():返回此字符串的长度\n***** char charat(int index):返回指定索引处的 char值\n***** int indexof(int ch):返回指定字符在此字符串中第一次出现处的索引。\nint indexof(int ch, int fromindex):返回在此字符串中第一次出现指定字符处的索引，\n从指定的索引开始搜索。\nint indexof(string str):返回指定子字符串在此字符串中第一次出现处的索引。\nint indexof(string str, int fromindex):返回指定子字符串在此字符串中第一次\n出现处的索引，从指定的索引开始。\n*** int lastindexof(int ch)：返回指定字符在此字符串中最后一次出现处的索引。\nint lastindexof(int ch, int fromindex)\n返回指定字符在此字符串中最后一次出现处的索引,从指定的索引处开始进行反向搜索。\nint lastindexof(string str)\n返回指定子字符串在此字符串中最右边出现处的索引。\nint lastindexof(string str, int fromindex)\n返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。\n***** string substring(int beginindex) (注意：该方法substring的string是小写！！！)\n返回一个新的字符串，它是此字符串的一个子字符串。\nstring substring(int beginindex, int endindex) (注意该方法的string是小写！！！)\n返回一个新字符串，它是此字符串的一个子字符串,包含头不包含尾。\nc:转换\n***** byte[] getbytes()：(很常用！)从字符串到字节数组的方法\nvoid getchars(int srcbegin, int srcend, char[] dst, int dstbegin)\n将字符从此字符串复制到目标字符数组。\n***** char[] tochararray()：(很常用！)从字符串到字符数组的方法\n**** static string copyvalueof(char[] data)\n返回指定数组中表示该字符序列的 string。\nstatic string copyvalueof(char[] data, int offset, int count)\n返回指定数组中表示该字符序列的 string。\n***** static string valueof(数据类型):把该数据类型的数据转换成字符串。\n*** string tolowercase()：把字符串转换成小写\nstring touppercase()：把字符串转换成大写\n*** 字符串的连接\nstring concat(string str):将指定字符串连接到此字符串的结尾。\nd:替换\nstring replace(char oldchar, char newchar):用新字符替换旧字符(替换所有)\nstring replace(string target, string replacement):用新的子串换旧串\ne:分割\nstring[] split(string regex)：根据指定的字符串把一个字符串分割成一个字符串数组\nf:\nstring trim():去除字符串的前后空格\ng:\nint compareto(string anotherstring)\n按字典顺序比较两个字符串。\nint comparetoignorecase(string str)\n按字典顺序比较两个字符串，不考虑大小写。\n(5)练习\n1:模拟登录,给三次机会,并提示还有几次.\n默认的用户名和密码为admin。 区分大小写。\n自己从键盘输入用户名和密码。\n2:给定一个字符串统计,统计大写字母,小写字母,数字出现的个数.\n***注意:不包括特殊字符\n从键盘输入一个不包含特殊字符的字符串(只有26个字母和0-9组成)。\n3:给定一个字符串,把它变成首字母大写,其他字母小写的字符串.\n从键盘输入一个字符串，全部26个字母组成的。\n4:子串在整串中出现的次数。\n也就是说:获取一个字符串中,指定的字串在该字符串中出现的次数.\n例如:\n\u0026ldquo;nbasdnbafllgnbahjnbakqqqqlnba\u0026rdquo; 在这个字符串中，多有个nba.\n5:对字符串中字符进行自然顺序排序。\n\u0026ldquo;basckd\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;abcdks\u0026rdquo;\n先留做思考内容：\n6:两个字符串的最大相同子串。\n两个字符串的最大相同子串。\n比如:\n\u0026ldquo;sadabcdfghjkl\u0026rdquo;\nwerabcdtyu\u0026quot;\n2：stringbuffer\n(1)字符串的缓冲区，是一个容器。\n(2)它和string的区别\n它是缓冲区可变长度的。\n(3)构造方法\nstringbuffer() 构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。\nstringbuffer(int num) 构造一个不带字符，但具有指定初始容量的字符串缓冲区。\nstringbuffer(string str) 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。\n(4)常用方法\na:增加数据\n**append ：添加各种类型的数据\n**insert : 在容器指定位置插入各种类型的数据。\nb:删除数据\n**deletecharat : 删除指定位置的字符\n**delete 还可以用于清空stringbuffer的缓冲区\nc:替换\n**replace\nd:获取\n**charat\ne:长度和容量\n**length() 元素的个数\n**capacity 元素的理论值\nf:获取元素的位置\n**indexof\n**lastindexof\ng:截取\n**substring(int start)\n**substring(int start,int end)\nh:反转\n**reverse\n(5)字符串和stringbuffer的转换\nstring\u0026ndash;\u0026gt;stringbuffer通过构造:\n如:stringbuffer sb = new stringbuffer(string str)\nstringbuffer\u0026ndash;string通过tostring方法\n如:stringbuffer sb = new stringbuffer();\nsb.tostring();\n3：stringbuilder\n和stringbuffer的功能是一样的，但是有区别：\nstringbuffer(jdk1.0)是线程安全的。\nstringbuilder(jdk1.5)不保证线程安全。\n一般来说，我们写的程序都是单线程的，所以，用stringbuilder，效率高。\njdk版本的升级原则：\na:提高效率\nb:提高安全性\nc:简化书写\n4：基本数据类型的对象包装类\n(1)为了更方便的操作每个基本数据类型，java对其提供了很多的属性和方法供我们使用。\n(2)用途：\n**将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能操作该数据。\n**常用的操作之一：用于基本数据类型与字符串之间的转换。\na:方便操作\nb:用于和字符串进行相互转换\n(3)基本数据类型和对象类型的对应\nbyte byte\nshort short\nint integer\nlong long\nfloat float\ndouble double\nboolean boolean\nchar character\n(4)构造方法\n字段摘要：\nstatic int max_value 值为 2^31-1 的常量，它表示 int 类型能够表示的最大值\nstatic int min_value 值为 -2^31 的常量，它表示 int 类型能够表示的最小值\nstatic class type 表示基本类型int的class 实例\ninteger(int value) 构造一个新分配的integer对象，它表示指定的int值。\ninreger(string s) 注意：s必须是纯数字的字符串。否则会有异常numberformatexception\n(5)几个常用的方法\ninteger.tobinarystring();\n以二进制（基数 2）无符号整数形式返回一个整数参数的字符串表示形式。\ninteger.tooctalstring();\n以八进制（基数 8）无符号整数形式返回一个整数参数的字符串表示形式。\ninteger.tohexstring();\n以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式。\nstatic int integer.parseint(string s) 将字符串参数作为有符号的十进制整数进行解析,\n字符串必须是int型范围内的数字字符串\nstatic int integer.parseint(string s,int basic)\n使用第二个参数指定的基数,将字符串参数解析为有符号的整数.\n字符串必须是int型范围内的数字字符串\nshort shortvalue() 以short类型返回该integer的值。\nint intvalue() 以int类型返回该integer的值。\nstatic integer valueof(int num) 返回一个表示指定的 int 值的 integer 实例。\nstatic integer valueof(string s) 返回保存指定的string的值的integer对象。\nstatic integer valueof(string s, int radix)\n返回一个integer对象，该对象中保存了用第二个参数提供的基数进行\n解析时从指定的string中提取的值。\n(6)类型转换\n1 int \u0026ndash; integer 2 int num = 20; 3 a:integer i = new integer(num); 4 b:integer i = integer.valueof(num); 5 integer \u0026ndash; int 6 integer i = new integer(20); 7 a:int num = i.intvalue(); 8 9 int \u0026ndash; string 10 int num = 20; 11 a:string s = string.valueof(num); 12 b:string s = \u0026ldquo;\u0026quot;+num; 13 c:string s = integer.tostring(num); 14 string \u0026ndash; int 15 string s = \u0026ldquo;20\u0026rdquo;; 16 a:int num = integer.parseint(s); 17 b:integer i = new integer(s);或者integer i = integer.valueof(s); 18 int num = i.intvalue();\n6、集合框架：\n(1)为什么出现集合类？\n面向对象对事物的体现都是以对象的形式，为了方便对多个对象的操作，就对对象进行存储。\n集合就是存储对象最常用的一种方式.\n(2)数组和集合都是容器，两者有何不同？\n**数组长度固定，而集合长度是可变的\n**数组值可以存储对象，还可以存储基本数据类型;而集合只能存储对象\n**数组存储数据类型是固定的，而集合存储的数据类型不固定\n(3)集合类的特点：\n集合只能存储对象\n集合的长度是可变的\n集合可以存储不同类型的对象\n(4)集合类框架(重要！！！要分清几种容器间的区别)：\n**collection:顶层接口\n|\u0026mdash;\u0026gt;list:列表，元素是有序的(元素带角标索引)，可以有重复元素,可以有null元素。\n|\u0026mdash;\u0026gt;arraylist(jdk1.2):底层的数据结构是数组数据结构，特点是查询速度快(因为带角标)，\n但是增删速度稍慢,因为当元素多时，增删一个元素则所有元素的角标都得改变\n线程不同步。默认长度是10，当超过长度时，按50%延长集合长度。\n|\u0026mdash;\u0026gt;linkedlist(jdk1.2):底层数据结构式链表数据结构(即后面一个元素记录前一个)，\n特点：查询速度慢，因为每个元素只知道前面一个元素，但增删速度快\n因为元素再多，增删一个，只要让其前后的元素重新相连即可\n线程是不同步的。\n|\u0026mdash;\u0026gt;vector(jdk1.0):底层数据结构是数组数据结构.特点是查询和增删速度都很慢。\n默认长度是10，当超过长度时,按100%延长集合长度。\n线程同步。\n(vector功能跟arraylist功能一模一样，已被arraylist替代)\n**list使用注意！\n|\u0026mdash;\u0026gt;arraylist:\n(1)当往arraylist里面存入元素没什么要求时，即只要求有序就行时；\n(2)当往arraylist里面存入元素要求不重复时，比如存入学生对象，当同名同姓时\n视为同一个人，则不往里面存储。则定义学生对象时，需复写equals方法\npublic boolean equals(object obj)\n{\nif(!(obj instanceof student))\nreturn false;\nstudent stu = (student)obj;\nreturn this.name.equals(stu.name)\u0026amp;\u0026amp;this.age==stu.age;\n}\n则往arraylist集合通过add存入学生对象时，集合底层自己会调用学生类的equals方法，\n判断重复学生则不存入。\n注：对于list集合，无论是add、contains、还是remove方法，判断元素是否相同，\n都是通过复写equals方法来判断！\n|\u0026mdash;\u0026gt;linkedlist\n(1)linkledist的特有方法：\nboolean offerfirst(e e) 在此列表的开头插入指定的元素。\nboolean offerlast(e e) 在此列表末尾插入指定的元素。\ne peekfirst() 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\ne peeklast() 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\ne pollfirst() 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\ne polllast() 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\n(2)通过linkledist的特有方法，可以实现某些数据特殊方式的存取，比如堆栈和队列。\n一般情况下，使用哪种list接口下的实现类呢？\n如果要求增删快，考虑使用linkedlist\n如果要求查询快，考虑使用arraylist\n如果要求线程安全，考虑使用vector。\n|\u0026mdash;\u0026gt;set:集合，元素是无序的(因为没有索引)，元素不可以重复。可以有null元素。\n|\u0026mdash;\u0026gt;hashset(jdk1.2):底层数据结构是哈希表、存取速度快、元素唯一、线程不同步。\n保证性元素唯一的原理:\n先判断元素的hashcode值是否相同，再判断两元素的equals方法是否为true\n(往hashset里面存的自定义元素要复写hashcode和equals方法，\n以保证元素的唯一性！)\n|\u0026mdash;\u0026gt;treeset:底层数据结构式二叉树。可以对set集合中的元素进行排序。元素有序、线程不同步。\n保证元素唯一性的依据：compareto方法return 0\ntreeset排序的第一种方式:让元素自身具备比较性，比如八种基本数据类型或则字符串，\n实现compareble接口,覆盖compareto方法，\n此方式是元素的自然顺序\ntreeset排序的第一种方式:当元素自身不具备比较性(比如存储学生对象时)或者具备的\n比较性不是我们所需要的比较性时(比如想字符串的长度排序),\n此时就需要让集合自身具备自定义的比较性。\n那如何让集合自身具备比较性呢？可在集合初始化时，\n就让集合具备比较方式。即定义一个类，\n实现comparator接口，覆盖compare方法。\n**set集合使用注意事项：\n(1)hashset:\n通过new的方式往hashset里面存的元素的hashcode都不同，但通常我们定义对象，\n比如学生对象时，虽然是new的两个学生对象，但是当他们name和age一样时，我们认为是\n同一个对象，所以为了保证元素的唯一性，我们通常在往hashset集合里面存储元素时，\n在定义对象的类中通常复写hashcode和equals方法。\n1 public int hashcode() 2 { 3 return name.hashcode()+age*39; 4 } 5 public boolean equals(object obj) 6 { 7 if(!(obj instanceof student)) 8 return false; 9 student stu = (student)obj; 10 return this.name.equals(stu.name)\u0026amp;\u0026amp;this.age==stu.age; 11 }\nhashset是如何保证元素唯一性的呢？\n**如果两元素的hashcode值不同，则不会调用equals方法\n**如果两元素的hashcode值相同，则继续判断equals是否返回true；\n**hashcode和equals方法虽然定义在自定义对象类里面，但不是我们手动调用\n而是往hashset集合里面存储元素的时候，集合底层自己调用hashcode和equals\n它自己拿对象去判断，自己判断两元素是否是同一个元素。\n(2)treeset:\ntreeset要求往里面存的元素具备比较性，否则会报错。\ntreeset排序的第一种方式:让元素自身具备比较性\n定义对象类，实现compareble接口,复写compareto方法，此方式是元素的自然顺序\n1 class student implements comparable 2 { 3 private string name; 4 private int age; 5 public student(string name,int age) 6 { 7 this.name=name; 8 this.age=age; 9 } 10 public string getname() 11 { 12 return name; 13 } 14 public int getage() 15 { 16 return age; 17 } 18 public int compareto(object obj) 19 { 20 if(!(obj instanceof student)) 21 throw new runtimeexception(\u0026ldquo;不是学生对象！\u0026rdquo;); 22 student stu = (student)obj; 23 int num = this.age-stu.age; 24 if(num==0) 25 return this.name.compareto(stu.name); 26 return num; 27 } 28 }\ntreeset排序的第一种方式:让集合具备比较性\n当元素自身不具备比较性(比如存储学生对象时)或者具备的\n比较性不是我们所需要的比较性时(比如想字符串的长度排序),\n此时就需要让集合自身具备自定义的比较性。\n那如何让集合自身具备比较性呢？可在集合初始化时，\n就让集合具备比较方式。即定义一个类，\n实现comparator接口，覆盖compare方法。\n1 class stringlengthcomparator implements comparator 2 { 3 public int compare(object obj1,object obj2) 4 { 5 string s1 = (string)obj1; 6 string s2 = (string)obj2; 7 int num = new integer(s1.length()).compareto(new integer(s2.length())); 8 if(num==0) 9 return s1.compareto(s2); 10 return num; 11 } 12 } 13 class treesettest 14 { 15 public static void main(string[] args) 16 { 17 treeset ts = new treeset(new stringlengthcomparator()); 18 ts.add(\u0026ldquo;addfg\u0026rdquo;); 19 ts.add(\u0026ldquo;dfg\u0026rdquo;); 20 ts.add(\u0026ldquo;agtuug\u0026rdquo;); 21 ts.add(\u0026ldquo;vgjkg\u0026rdquo;); 22 sop(ts); 23 } 24 }\n基本数据类型或字符串对象均实现了comparable接口，故同种类型基本数据间具备比较性，即自然顺序。\n**map:顶层接口,该集合存储的是键值对,而且键是唯一的,map和set很像,set集合底层就是使用了map集合。\nmap集合没有迭代器，要取出元素必须先将map集合转换成set集合才能遍历元素\n|\u0026mdash;\u0026gt;hashtable(jdk1.0):\n底层是哈希表数据结构；\n不可以使用null键和null值；\n用作键的对象必须实现hashcode和equals方法来保证键的唯一性\n线程同步，效率低\n|\u0026mdash;\u0026gt;hashmap(jdk1.2):\n底层是哈希表数据结构；\n允许使用null键和null值；\n线程不同步，效率高；\n保证元素唯一性的:\n原理：先判断元素的hashcode值是否相同，再判断两元素的equals方法是否为true\n(往hashset里面存的自定义元素要复写hashcode和equals方法，\n以保证元素的唯一性！)\n1 class student { 2 private string name; 3 private int age; 4 public student(string name, int age) { 5 super(); 6 this.name = name; 7 this.age = age; 8 } 9 public int getage() { 10 return age; 11 } 12 public void setage(int age) { 13 this.age = age; 14 } 15 public string getname() { 16 return name; 17 } 18 public void setname(string name) { 19 this.name = name; 20 } 21 22 @override 23 public int hashcode(){ 24 return name.hashcode()+age*34; 25 } 26 @override 27 public boolean equals(object obj){ 28 29 if(!(obj instanceof student)) 30 return false; 31 student stu = (student)obj; 32 return this.name.equals(stu.name)\u0026amp;\u0026amp;this.age==stu.age; 33 } 34 public class hashmapdemo1 { 35 public static void main(string[] args) { 36 map\u0026lt;student , string\u0026gt; hmap = new hashmap\u0026lt;student , string\u0026gt;(); 37 hmap.put(new student(\u0026ldquo;001\u0026rdquo;,20), \u0026ldquo;beijing\u0026rdquo;); 38 hmap.put(new student(\u0026ldquo;002\u0026rdquo;,25), \u0026ldquo;hebei\u0026rdquo;); 39 hmap.put(new student(\u0026ldquo;003\u0026rdquo;,50), \u0026ldquo;hainan\u0026rdquo;); 40 hmap.put(new student(\u0026ldquo;001\u0026rdquo;,20), \u0026ldquo;beijing\u0026rdquo;); 41 42 system.out.println(hmap.size()); 43 set keyset = hmap.keyset(); 44 iterator it = keyset.iterator(); 45 while(it.hasnext()){ 46 student stu = it.next(); 47 string addr = hmap.get(stu); 48 system.out.println(stu.getname()+\u0026rdquo;..\u0026quot;+stu.getage()+\u0026quot;::\u0026quot;+addr); 49 } 50 } 51 } 52 |\u0026mdash;\u0026gt;treemap(jdk1.0): 53 底层是二叉树结构； 54 允许使用null键和null值； 55 线程不同步； 56 可以给map集合中的键进行排序. 57 treemap排序的第一种方式:让元素自身具备比较性，比如八种基本数据类型或则字符串， 58 实现compareble接口,覆盖compareto方法， 59 此方式是元素的自然顺序 60 treemap排序的第一种方式:当元素自身不具备比较性(比如存储学生对象时)或者具备的 61 比较性不是我们所需要的比较性时(比如想字符串的长度排序), 62 此时就需要让集合自身具备自定义的比较性。 63 那如何让集合自身具备比较性呢？可在集合初始化时， 64 就让集合具备比较方式。即定义一个类， 65 实现comparator接口，覆盖compare方法。 66 class student implements comparable{ 67 private string name; 68 private int age; 69 public student(string name, int age) { 70 super(); 71 this.name = name; 72 this.age = age; 73 } 74 public int getage() { 75 return age; 76 } 77 public void setage(int age) { 78 this.age = age; 79 } 80 public string getname() { 81 return name; 82 } 83 public void setname(string name) { 84 this.name = name; 85 } 86 @override 87 public int compareto(student stu) { 88 int num = new integer(this.age).compareto(new integer(stu.age)); 89 if(num==0) 90 return this.name.compareto(stu.name); 91 return num; 92 } 93 } 94 95 public class hashmapdemo1 { 96 public static void main(string[] args) { 97 98 map\u0026lt;student , string\u0026gt; tmap = new treemap\u0026lt;student , string\u0026gt;(); 99 tmap.put(new student(\u0026ldquo;001\u0026rdquo;,20), \u0026ldquo;beijing\u0026rdquo;); 100 tmap.put(new student(\u0026ldquo;002\u0026rdquo;,25), \u0026ldquo;hebei\u0026rdquo;); 101 tmap.put(new student(\u0026ldquo;003\u0026rdquo;,50), \u0026ldquo;hainan\u0026rdquo;); 102 tmap.put(new student(\u0026ldquo;001\u0026rdquo;,20), \u0026ldquo;beijing\u0026rdquo;); 103 104 system.out.println(tmap.size()); 105 set keyset1 = tmap.keyset(); 106 iterator it1 = keyset1.iterator(); 107 while(it1.hasnext()){ 108 student stu = it1.next(); 109 string addr = tmap.get(stu); 110 system.out.println(stu.getname()+\u0026quot;..\u0026quot;+stu.getage()+\u0026quot;::\u0026quot;+addr); 111 } 112 } 113 }\n**iterator：对collection进行迭代的迭代器.迭代器取代了enumeration。\n迭代器和枚举的区别：\n迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的collection移除元素\n方法名称得到了改进，简化书写\n**lisiterator：系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表\n**comparable：此接口强行对实现它的每个类的对象进行整体自然排序。使元素具备比较性\n**comparator：强行对某个对象collection进行整体排序的比较函数，使集合具备比较性\n**collections：此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。\n**arrays：此类包含用来操作数组(比如排序和搜索)的各种静态方法\n7、集合类各容器方法：\n**接口collection方法摘要(没有构造方法)\na)添加：\ni. boolean add(e e)\nj. boolean addall(collection c)\nb)删除：\ni. void clear():清空容器\nj. boolean remove(objec object):\nk. boolean removeall(collection c):\nc)判断：\ni. boolean contains(object object):判断是否包含此元素\nj. boolean containsall(collection c):判断是否包含一堆元素\nk. boolean equals(object object):比较此collection与指定对象是否相等\nm. boolean isempty():判断是否集合为空\nd)获取：\nh. iterator iterator():取出\ni. int hashcode():返回此collection的哈希值\nj. int size():返回此collection中元素的个数\nk. boolean retainall(collection c):取交集\nm. object toarray():返回此collection中所有元素的数组\nn. t[] toarray(t[] a):返回包含此collection中所有元素的数值。\n*****list集合子类及其方法\n(1)list接口是collection接口的一个子接口。\n(2)list接口中的元素有如下特点(对角标的操作都是特有方法，因为有序)：\na:元素有序(存储顺序和取出顺序一致)\nb:元素可以重复\n(3)list接口中的特有方法\na:add(int index,object obj):在指定位置加入元素\nb:remove(int index):移除指定位置的元素\nc:set(int index,object obj):修改指定位置的元素\nd:get(int index):获取指定位置的元素\ne:indexof(object obj):获取指定元素的位置\nf:sublist(int start,int end):从一个大的list中截取一个小的list\ng:listiterator():返回一个list接口特有的迭代器\n(1)、arraylist：\n|\u0026mdash;\u0026gt;构造方法摘要：(少用，不是重点)\narraylist()：构造一个初始容量为 10 的空列表。\narraylist(collection\u003c? extends e\u003e c)： 构造一个包含指定 collection 的元素的列表， arraylist(int initialcapacity)： 构造一个具有指定初始容量的空列表。 |---\u003e方法摘要： |---\u003e添加： boolean add(e e)： 将指定的元素添加到此列表的尾部。 void add(int index, e element)： 将指定的元素插入此列表中的指定位置。 boolean addall(collection\u003c? extends e\u003e c):按照指定 collection 的迭代器所返回的元素顺序， 将该 collection 中的所有元素添加到此列表的尾部 boolean addall(int index, collection\u003c? extends e\u003e c)： 从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。 |---\u003e删除： void clear(): 移除此列表中的所有元素。 e remove(int index): 移除此列表中指定位置上的元素。 boolean remove(object o): 移除此列表中首次出现的指定元素（如果存在）。 protected void removerange(int fromindex, int toindex): 移除列表中索引在 fromindex（包括）和 toindex（不包括）之间的所有元素。 boolean removeall(collection\u003c?\u003e c): 从列表中移除指定 collection 中包含的其所有元素\n|\u0026mdash;\u0026gt;获取：\ne get(int index): 返回此列表中指定位置上的元素。\nint indexof(object o): 返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。\nint lastindexof(object o) 返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。\npublic list sublist(int fromindex,int toindex): 返回列表中指定的 fromindex（包括 ） 和 toindex（不包括）之间的部分视图。\niterator iterator(): 返回按适当顺序在列表的元素上进行迭代的迭代器。\nlistiterator listiterator(int index):返回列表中元素的列表迭代器(按适当顺序),从列表的指定位置开始。\n|\u0026mdash;\u0026gt;修改：(特有方法！！)\ne set(int index, e element): 用指定的元素替代此列表中指定位置上的元素。\n(2)linkedlist:\n|\u0026mdash;\u0026gt;构造方法摘要：\nlinkedlist(): 构造一个空列表。\nlinkedlist(collection\u0026lt;? extends e\u0026gt; c): 构造一个包含指定 collection 中的元素的列表，\n这些元素按其 collection 的迭代器返回的顺序排列。\n|\u0026mdash;\u0026gt;方法摘要:(特有的)\n|\u0026mdash;\u0026gt;添加\nvoid addfirst(e e): 将指定元素插入此列表的开头。\nvoid addlast(e e): 将指定元素添加到此列表的结尾。\n|\u0026mdash;\u0026gt;获取元素，但不删除元素\ne get(int index): 返回此列表中指定位置处的元素。\ne getfirst(): 返回此列表的第一个元素。\ne getlast(): 返回此列表的最后一个元素。\n|\u0026mdash;\u0026gt;获取元素且删除元素\ne remove()： 获取并移除此列表的头（第一个元素）。\ne remove(int index)： 移除此列表中指定位置处的元素。\nboolean remove(object o)： 从此列表中移除首次出现的指定元素（如果存在）。\ne removefirst()： 移除并返回此列表的第一个元素。\ne removelast(): 移除并返回此列表的最后一个元素。\n|\u0026mdash;\u0026gt;修改\ne set(int index, e element) 将此列表中指定位置的元素替换为指定的元素。\n(3)vector\n|\u0026mdash;\u0026gt;构造方法摘要：\nvector(): 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。\nvector(collection\u0026lt;? extends e\u0026gt; c): 构造一个包含指定 collection 中的元素的向量，\n这些元素按其 collection 的迭代器返回元素的顺序排列。\n|\u0026mdash;\u0026gt;方法摘要：\n|\u0026mdash;\u0026gt;添加：\nboolean add(e e): 将指定元素添加到此向量的末尾。\nvoid add(int index, e element): 在此向量的指定位置插入指定的元素。\nboolean addall(collection\u0026lt;? extends e\u0026gt; c):\n将指定 collection 中的所有元素添加到此向量的末尾，\n按照指定 collection 的迭代器所返回的顺序添加这些元素。\nboolean addall(int index, collection\u0026lt;? extends e\u0026gt; c): 在指定位置将指定 collection 中的所有元素插入到此向量中。\n|\u0026mdash;\u0026gt;获取:\nenumeration elements(): 返回此向量的组件的枚举。\nvector特有的取出方式:\n枚举和迭代器很像，其实枚举和迭代器是一样的，只是因为枚举的名称和方法的名称\n名字都过长，所以枚举被迭代器取代了。\n|\u0026mdash;\u0026gt;枚举enumeration的方法摘要：\nboolean hasmoreelements(): 测试此枚举是否包含更多的元素。\ne nextelement(): 如果此枚举对象至少还有一个可提供的元素，\n则返回此枚举的下一个元素。\n*****set集合子类及其方法\n(1)hashset:它不保证set的迭代顺序;特别是它不保证该顺序恒久不变.此类允许使用null元素。\n|\u0026mdash;\u0026gt;构造方法：\nhashset() 构造一个新的空 set，其底层 hashmap 实例的默认初始容量是 16，加载因子是 0.75。\nhashset(collection\u0026lt;? extends e\u0026gt; c) 构造一个包含指定 collection 中的元素的新 set。\n|\u0026mdash;\u0026gt;方法摘要：\nboolean add(e e) 如果此 set 中尚未包含指定元素，则添加指定元素。\nvoid clear() 从此 set 中移除所有元素。\nobject clone() 返回此 hashset 实例的浅表副本：并没有复制这些元素本身。\nboolean contains(object o) 如果此 set 包含指定元素，则返回 true。\nboolean isempty() 如果此 set 不包含任何元素，则返回 true。\niterator iterator() 返回对此 set 中元素进行迭代的迭代器。\nboolean remove(object o) 如果指定元素存在于此 set 中，则将其移除。\nint size() 返回此 set 中的元素的数量（set 的容量）。\n(2)treeset:使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 comparator 进行排序.\n|\u0026mdash;\u0026gt;构造方法：\ntreeset() 构造一个新的空 set，该set根据其元素的自然顺序进行排序。\ntreeset(collection\u0026lt;? extends e\u0026gt; c)\n构造一个包含指定 collection 元素的新 treeset，它按照其元素的自然顺序进行排序。\ntreeset(comparator\u0026lt;? super e\u0026gt; comparator) 构造一个新的空 treeset，它根据指定比较器进行排序。\n|\u0026mdash;\u0026gt;方法摘要：\n添加：\nboolean add(e e) 将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。\nboolean addall(collection\u0026lt;? extends e\u0026gt; c) 将指定 collection 中的所有元素添加到此 set 中。\n删除：\nvoid clear() 移除此 set 中的所有元素。\nboolean remove(object o) 将指定的元素从 set 中移除（如果该元素存在于此 set 中）。\ne pollfirst() 获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。\ne polllast() 获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。\n获取：\niterator iterator() 返回在此 set 中的元素上按升序进行迭代的迭代器。\ne first() 返回此 set 中当前第一个（最低）元素。\ne last() 返回此 set 中当前最后一个（最高）元素。\nint size() 返回 set 中的元素数（set 的容量）。\n判断：\nboolean isempty() 如果此 set 不包含任何元素，则返回 true。\nboolean contains(object o) 如果此 set 包含指定的元素，则返回 true。\n**map:将键映射到值的对象。map集合没有迭代器！map集合特点：该集合存储键值对。而且键是唯一的。\n|\u0026mdash;\u0026gt;方法摘要：\n|\u0026mdash;\u0026gt;添加：\nv put(k key, v value) 将指定的值与此映射中的指定键关联（可选操作）。\nvoid putall(map\u0026lt;? extends k,? extends v\u0026gt; m) 从指定映射中将所有映射关系复制到此映射中\n|\u0026mdash;\u0026gt;删除：\nvoid clear() 从此映射中移除所有映射关系（可选操作）。\nv remove(object key) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。\n|\u0026mdash;\u0026gt;判断\nboolean containskey(object key) 如果此映射包含指定键的映射关系，则返回 true。\nboolean containsvalue(object value) 如果此映射将一个或多个键映射到指定值，则返回 true。\nboolean isempty() 如果此映射未包含键-值映射关系，则返回 true。\n|\u0026mdash;\u0026gt;获取\nint size() 返回此映射中的键-值映射关系数。\ncollection values() 返回此映射中包含的值的 collection 视图。\n重点：map集合没有迭代器，以下是map的两种取出方式：\n第一种：set keyset()\n返回此映射中包含的键的set视图，将map集合中所有的键存入set集合，然后再通过set集合的\n迭代器取出所有的键，再根据get方法获取每个键的值；\n第二种：set\u0026lt;map.entry\u0026lt;k,v\u0026raquo; entryset()\n返回此映射中包含的映射关系的set视图，将map集合中的映射关系存入到set集合中，\n这个映射关系的数据类型是map.entry,再通过map.entry类的方法再要取出关系里面的键和值\nmap.entry的方法摘要：\nboolean equals(object o) 比较指定对象与此项的相等性。\nk getkey() 返回与此项对应的键。\nv getvalue() 返回与此项对应的值。\nint hashcode() 返回此映射项的哈希码值。\nv setvalue(v value) 用指定的值替换与此项对应的值(特有！！！)。\n8、map集合和collection集合的区别？\n1，\nmap中一次存储是键值对。\ncollection中一次存储是单个元素。\n2，\nmap的存储使用的put方法。\ncollection存储使用的是add方法。\n3，\nmap集合没有迭代器，map的取出，是将map转成set，在使用迭代器取出。\ncollection取出，使用就是迭代器。\n4，\n如果对象很多，必须使用集合存储。\n如果元素存在着映射关系，可以优先考虑使用map存储或者用数组，\n如果没有映射关系，可以使用collection存储。\n8、迭代器：iterator(map集合没有迭代器)\n(1)迭代器就是取出集合元素的方式\n(2)迭代器的作用\n因为每个集合中元素的取出方式都不一样，于是就把元素的取出方式进行抽取，并定义在集合内部，\n这样取出方式就可以直接访问集合内部的元素；\n而每个容器的数据结构不同，所以取出动作的细节也不一样，但是有共性内容：判断和取出。\n那么就将共性内容进行抽取，从而形成了接口iterater\n(3)获取迭代器的方法：\niterator iterator() 返回在此 collection 的元素上进行迭代的迭代器。\niterator iterator() 返回在此 set 中的元素上进行迭代的迭代器。\n(3)迭代器方法：\nboolean hasnext() 如果仍有元素可以迭代,则返回 true。\ne next() 返回迭代的下一个元素。\nvoid remove() 从迭代器指向的collection中移除迭代器返回的最后一个元素（可选操作）。\n9、列表迭代器：listiterator\n(1)list集合特有的迭代器listiterator是iterator的子接口，在迭代时，不可以通过集合对象的\n方法操作集合中的元素，因为会发生concurrentmodificationexception(当方法检测到对象的并发修改，\n但不允许这种修改时，抛出此异常)\n(2)iterator方法有限，只能对元素进行判断、取出和删除的操作\nlistiterator可以对元素进行添加和修改动作等。\n(3)获取列表迭代器方法：\nlistiterator listiterator() 返回此列表元素的列表迭代器（按适当顺序）。\nlistiterator listiterator(int index)\n返回此列表中的元素的列表迭代器（按适当顺序），从列表中指定位置开始。\n(4)列表迭代器方法：\nvoid add(e e) 将指定的元素插入列表（可选操作）。\nboolean hasprevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。\nint nextindex() 返回对 next 的后续调用所返回元素的索引。\ne previous() 返回列表中的前一个元素。\nint previousindex() 返回对 previous 的后续调用所返回元素的索引。\nvoid set(e e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。\n10、堆栈和队列\n堆栈：先进后出，比如杯子里的水\n队列：先进先出，比如水管的水\n11、集合类各种容器的使用注意细节：\n(1)迭代器：\n**迭代器的next方法是自动向下取元素，要避免出现nosuchelementexception。\n也就是在迭代循环中调用一次next方法一次就要hasnext判断一次，比如语句\nsop(it.next()+\u0026quot;\u0026hellip;\u0026quot;+it.next())会发生上述异常。\n**迭代器的next方法返回值类型是object，所以要记得类型转换,应用泛型后就不用强转\n(2)list集合：\n**list集合里面的元素因为是带角标，所以list集合里面的元素都是有序的，\n另外list集合可以包含重复元素，也可以包含null。\n**list集合有迭代器iterator，还有一个特有迭代器列表listiterator\n**list集合中判断元素是否相同都是用equals方法，无论contains、remove都依赖equals方法\n比如往arraylist集合里面存放学生，同名同年龄视为同一个人，此时就需要在学生类复写object类\n里面的equals方法(非常重要！！！要注意！！)\n(3)set集合：\n**set接口里面存放的是元素是无序的，不可以有重复元素，可以包含null\n**set集合只有一种取出方式，就是迭代器iterator\n**set集合功能和collection是一致的，没有特殊方法\n|\u0026mdash;\u0026gt;hashset:\n**集合里面存放的元素是无序的，唯一的\n**底层数据结构是哈希表，哈希表结构的数据都是无序的，哈希表结构的操作效率都高效\n**线程不同步\n**保证元素唯一性的原理是：通过复写hashcode和equals方法\n****如果两元素的hashcode值相同，则继续判断两元素equals是否为真\n****如果两元素的hashcode值不同，则不会调用equals方法。\n**当我们往hashset集合存放自定义的元素时(比如学生对象)，通常都要复写hashcode和equals方法，\n而且hashcode和equals方法不通过我们调用，hashset集合底层内部自己调用，自己拿元素去比较\n|\u0026mdash;\u0026gt;treeset\n**treeset集合可以对存放的元素进行排序，弥补了set集合元素无序的缺点，且元素是唯一的\n**底层数据结构是二叉树，二叉树结构都是有序的\n**线程不同步\n**treeset集合要求往集合里存放的元素自身具备比较性，否则会报错\n**treeset集合保证元素唯一性的依据是：通过compareto或者compare方法中的来保证元素的唯一性。\ntreeset排序的第一种方式:让元素自身具备比较性，\n定义元素类实现compareble接口，覆盖compare方法，\n此方式是元素的自然顺序。\ntreeset排序的第二种方式:让集合具备比较性\n当元素自身不具备比较性或者具备的比较性不是\n我们所需要的比较性时，此时就需要让集合具备自定义的比较性。\n那如何让集合自身具备比较性呢？\n可在集合初始化时，就让集合具备比较方式。\n即定义一个类，实现comparator接口，覆盖compare方法。\n注：\n**判断元素唯一时，当主要条件一样时，判断次要条件\n**两种排序方式都在时，以比较器为主！！！\n(4)map集合：\n|\u0026ndash;hashtable\n底层是哈希表结构\n线程安全的，并且键和值不能为null。\n|\u0026ndash;hashmap\n底层是哈希表结构\n线程不安全的，键和值可以为null。\n|\u0026ndash;linkedhashmap\n底层是链表和哈希表\n线程不安全\n|\u0026ndash;treemap\n底层是二叉树\n线程不安全的\n12、如果你想将一组对象按一定顺序存取，在不考虑并发访问的情况下会使用____c_____ ,\n反之则会使用____a_____；如果你想存储一组无序但唯一的对象，你会使用___b______ ;\n如果你想按关键字对对象进行存取，在不考虑并发访问的情况下会使用___d______ ,反之则会使用_____e____。\na. vector\nb. hashset\nc. arraylist\nd. hashmap\ne. hashtable\n13、泛型：\n(1)为什么会出现泛型？\n因为集合存放的数据类型不固定，故往集合里面存放元素时，存在安全隐患，\n如果在定义集合时，可以想定义数组一样指定数据类型，那么就可以解决该类安全问题。\njdk1.5后出现了泛型，用于解决集合框架的安全问题。\n泛型是一个类型安全机制。\n(2)泛型定义格式：通过\u0026lt;\u0026gt;来定义要操作的引用数据类型\narraylist al = new arraylist;\n(3)泛型的好处：\n**将运行时期出现的classcastexception(类型转换异常)问题转移到编译时期；\n**避免了强制转换的麻烦\n(4)什么时候定义泛型？\n泛型在集合框架中很常见，只要见到\u0026lt;\u0026gt;就要定义泛型。其实\u0026lt;\u0026gt;就是用来接收类型的。\n当使用集合时，将集合中要存储的数据类型作为参数传递到\u0026lt;\u0026gt;中即可\n(5)泛型的形式\n**泛型类：即自定义泛型类\na：当类中要操作的引用数据类型不确定时，早起定义object来完成扩展，现在定义泛型来完成\nb：局限性：泛型类定义的泛型，在整个类中有效，如果该泛型类的方法被调用，\n当泛型类的对象明确要操作的类型后，所有要操作的类型就被固定。\n**泛型方法：泛型放在返回值前面，修饰符的后面\na:为了避免泛型类的局限性，让不同方法可以操作不同的类型，而且类型还不确定，\n则可以将泛型定义在方法上\nb:特殊之处：静态方法不可以反问类上定义的泛型\n如果静态方法操作的应用数据类型不确定，可以讲泛型定义在静态方法上\n**泛型接口：\n当泛型定义在接口上时，则子类中要指定实现接口类型，同时还可以子类也可以定义为泛型类\n(6)泛型的高级应用：？通配符\n**当指定两种泛型的集合，则迭代时也要定义两种泛型的迭代器，麻烦，此时可通过将迭代器的泛型\n改为？，如iterator\u003c?\u003e it=al.iterator();\n**两种泛型限定\n向上限定： ? extends e ;e可以接收e类型或者e的子类\n向下限定： ? super e ;e可以接收e类型或者e的父类\n14、高级for循环\n(1)jdk1.5新特性，代替迭代器使用时的不爽，简化书写，底层原理是迭代器凡是支持迭代器的都支持高级for循环\n高级for循环，只用于集合和数组的遍历，集合只能用collection不能用map集合\n只能把map集合转化成set集合，才能用for循环。\n(2)格式\nfor(数据类型 变量名:被遍历的集合(collection)或者数组)\n{\n}\n(3)局限性：\n必须要有遍历的目标\n对集合或者数组进行遍历时，只能获取集合元素，不能对集合元素进行操作\n迭代器除了遍历，还可以进行remove操作集合中的元素\n列表迭代器还可以在遍历过程中进行增删改查的操作\n(4)传统for循环和高级for循环的区别\n高级for循环有一个局限性，就是必须要有遍历的目标(集合或者数组)\n遍历数组时建议使用传统for循环，因为可以定义角标，比如打印100次helloworld时用传统for循环方便\n15、可变参数\n(1)数组的可变参数\n格式：\nint\u0026hellip; arr\n(3)方法的可变参数\n格式：\npublic static void show(string str，int\u0026hellip; arr)\n{\n}\n注意：可变参数一定要放在参数列表的最后面\n16、静态导入：\n**import static java.util.arrays.* 导入的是arrays这个类中所有的静态方法\n**当类名重名时，需要制定具体的报名\n**当方法重名时，需要制定具体所属的对象或者类\n17、collections类：\n(1)此类完全由在 collection 上进行操作或返回 collection 的静态方法组成。\n(2)静态方法摘要：\nstatic boolean addall(collection\u003c? super t\u003e c, t... elements) 将所有指定元素添加到指定 collection 中。 static void fill(list\u003c? super t\u003e list, t obj) 使用指定元素替换指定列表中的所有元素。 static boolean replaceall(list list, t oldval, t newval) 使用另一个值替换列表中出现的所有某一指定值。 static void reverse(list\u003c?\u003e list)\n反转指定列表中元素的顺序。\nstatic comparator reverseorder()\n返回一个比较器，它强行逆转实现了 comparable 接口的对象 collection 的自然顺序\nstatic comparator reverseorder(comparator cmp)\n返回一个比较器，它强行逆转指定比较器的顺序。\n(3)collections类特牛的方法：\n集合有一个共同的缺点，那就是线程不安全，被多线程操作时，容易出现问题，虽然可以自己加锁\n但是麻烦。collections提供特牛的方法，就是给它一个不同步的集合，它返回一个同步的安全的集合\nstatic collection synchronizedcollection(collection c)\n返回指定 collection 支持的同步（线程安全的）collection。\nstatic list synchronizedlist(list list)\n返回指定列表支持的同步（线程安全的）列表。\nstatic \u0026lt;k,v\u0026gt; map\u0026lt;k,v\u0026gt; synchronizedmap(map\u0026lt;k,v\u0026gt; m)\n返回由指定映射支持的同步（线程安全的）映射。\nstatic set synchronizedset(set s)\n返回指定 set 支持的同步（线程安全的）set。\nstatic \u0026lt;k,v\u0026gt; sortedmap\u0026lt;k,v\u0026gt; synchronizedsortedmap(sortedmap\u0026lt;k,v\u0026gt; m)\n返回指定有序映射支持的同步（线程安全的）有序映射。\nstatic sortedset synchronizedsortedset(sortedset s)\n返回指定有序 set 支持的同步（线程安全的）有序 set。\n18、arrays类：\n此类包含用来操作数组（比如排序和搜索）的各种方法。里面都是静态方法。\n如果指定数组引用为 null，则此类中的方法都会抛出 nullpointerexception。\n(1)静态方法摘要：\nstatic list aslist(t\u0026hellip; a)\n返回一个受指定数组支持的固定大小的列表。\n注意：\na:该方法将一个数组变成集合后，不可以使用集合的增删方法，因为数组的长度是固定的！\n如果增删，则发生unsupportedoprationexception(不支持操作异常)\nb:如果数组中的元素都是基本数据类型，则该数组变成集合时，会将该数组作为集合的一个\n元素出入集合\nc:如果数组中的元素都是对象，如string，那么数组变成集合后，数组中的元素就直接转成\n集合中的元素\n19、数组变集合以及集合变数组的对比：\n(1)数组变集合：\n方法：static list aslist(t\u0026hellip; a) 返回一个受指定数组支持的固定大小的列表。\n好处：可以使用集合的思想和方法操作数组中的元素，数组是一个对象，但是数组中的功能很少\n(2)集合变数组：\n方法：collction中的toarray方法\n好处：可以限定对集合元素的操作，防止对集合的元素进行增删，因为数组长度是固定的。\n20、collections类和arrays类的使用。(重点)\na:collections\n排序\n二分查找\n发转\nb:arrays\n把数组变成字符串输出\n排序\n二分查找\n21、system：\n(1)描述系统信息的类\n(2)该类没有构造方法，该类的方法和属性都是静态的\n(3)字段摘要：\nstatic inputstream in “标准”输入流。\nstatic printstream out “标准”输出流。\n(4)方法摘要：\nstatic void exit(int status) 终止当前正在运行的 java 虚拟机。\nstatic void gc() 运行垃圾回收器。\nstatic properties getproperties() 确定当前的系统属性\nstatic string getproperty(string key) 获取指定键指示的系统属性。\nstatic string getproperty(string key, string def) 获取用指定键描述的系统属性。\nstatic void setin(inputstream in) 重新分配“标准”输入流。\nstatic void setout(printstream out) 重新分配“标准”输出流。\nstatic void setproperties(properties props) 将系统属性设置为 properties 参数。\nstatic string setproperty(string key, string value) 设置指定键指示的系统属性。\n22、runtime:\n(1)每个 java 应用程序都有一个 runtime 类实例，使应用程序能够与其运行的环境相连接。\n可以通过 getruntime 方法获取当前运行时。 应用程序不能创建自己的 runtime 类实例。\n(2)该类没有构造函数，也就是它不能直接创建对象，但是它里里面的方法又不是静态的\n，故它一定有一个方法返回本类对象\n(3)故该类是单例设计模式，保证在内存中只有一个对象\n(4)方法摘要：\nprocess exec(string command) 在单独的进程中执行指定的字符串命令\nvoid gc() 运行垃圾回收器。\nstatic runtime getruntime() 返回与当前 java 应用程序相关的运行时对象\nvoid exit(int status) 通过启动虚拟机的关闭序列，终止当前正在运行的 java 虚拟机\n23、date:\n(1)date接口表示特定的瞬间，精确到毫秒\n(2)构造方法\ndate() 分配 date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\ndate(long date) 分配date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，\n即1970年1月1日00:00:00gmt）以来的指定毫秒数。\n(3)方法摘要：\nint compareto(date anotherdate) 比较两个日期的顺序。\nboolean equals(object obj) 比较两个日期的相等性。\n24、calendar：\n(1)直接已知子类： gregoriancalendar\n(2)构造方法：\nprotected calendar() 构造一个带有默认时区和语言环境的 calendar。\nprotected calendar(timezone zone, locale alocale) 构造一个带有指定时区和语言环境的 calendar。\n(3)方法摘要：\nstatic calendar getinstance() 使用默认时区和语言环境获得一个日历。\n四、jdk1.5的新特性\n(1)静态导入：\n**import语句可以导入一个类或某个包中的所有类\n**import static语句导入一个类中的某个静态方法或所有静态方法\n静态导入后，静态方法前面就不用写类名.方法的方式类调用\n**语法举例：\nimport static java.lang.math.sin;//导入一个静态方法\nimport static java.lang.math.*; //导入一个类中的所有静态方法\n**静态导入使用注意：\n当类名重复时，需要制定具体的包名；\n当方法重名时，需要制定具体所属的对象或者类\n(2)可变参数：\n**可变参数的特点：\n*可变参数只能出现在参数列表的最后；\n*\u0026hellip;位于变量类型和变量名之间，前后有无空格都可以;\n*调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，\n在方法体中以数组的形式访问可变参数。\n**可变参数举例：\n*变量类型\u0026hellip; 变量名 如 int\u0026hellip; arr 表示可变参数数组\n*public static void show(string str , int\u0026hellip; arr){}\n(3)增强for循环：\n**语法：\nfor ( type 变量名：集合变量名 ) { … }\n**注意事项：\n迭代变量必须在( )中定义！\n集合变量可以是数组或实现了iterable接口的集合类\n**举例：\npublic static int add(int x,int \u0026hellip;args) {\nint sum = x;\nfor(int arg:args) {\nsum += arg;\n}\nreturn sum;\n}\n**增强for循环代替了迭代器使用的不爽，简化书写\n**增强for循环局限性：\n对集合或者数组进行遍历时，只能取元素，不能对集合进行操作\n(4)基本数据类型的自动装箱和拆箱\n**基本数据类型\nbyte \u0026mdash;\u0026gt; byte\nshort \u0026mdash;\u0026gt; short\nint \u0026mdash;\u0026gt; integer\nlong \u0026mdash;\u0026gt; long\nfloat \u0026mdash;\u0026gt; float\ndouble \u0026mdash;\u0026gt; double\nchar \u0026mdash;\u0026gt; character\nboolean \u0026mdash;\u0026gt; boolean\n**例子：\n**装箱：自动把一个基本数据类型的数据装箱成一个该类型数据的对象引用\ninteger i = 3;(jdk1.5之前这样写是不行的，编译报错)\n**拆箱：自动把一个基本数据类型的对象引用拆箱成一个基本数据类型的数据，再参与运算\ninteger i = 12;\nsop(i+4);\n**享元模式：\ninteger num1 = 12;\ninteger num2 = 12;\nsystem.out.println(num1 == num2);//打印true\ninteger num5 = integer.valueof(12);\ninteger num6 = integer.valueof(12);\nsystem.out.println(num5 == num6);//打印true\ninteger num3 = 129;\ninteger num4 = 129;\nsystem.out.println(num3 == num4);//打印false\n为什么前面的返回true而后面的运算返回false呢？\n对于基本数据类型的整数，装箱成integer对象时，如果该数值在一个字节内,(-128~127)，\n一旦装箱成integer对象后，就把它缓存到磁里面，当下次，又把该数值封装成integer对象时\n会先看磁里面有没有该对象，有就直接拿出来用，这样就节省了内存空间。因为比较小的整数，\n用的频率比较高，就没必要每个对象都分配一个内存空间。\n这就是享元模式！比如26个英文字母，10个阿拉伯数字\n(5)枚举\n**为什么要有枚举？\n问题：要定义星期几或性别的变量，该怎么定义？假设用1-7分别表示星期一到星期日，\n但有人可能会写成int weekday = 0;或即使使用常量方式也无法阻止意外。\n枚举就是要让某个类型的变量的取值只能为若干个固定值中的一个，否则，编译器就会报错。\n枚举可以让编译器在编译时就可以控制源程序中填写的非法值，\n普通变量的方式在开发阶段无法实现这一目标。\n**用普通类如何实现枚举的功能？定义一个weekday类来模拟实现：\n步骤：\n*私有化构造方法\n*每个元素分别用一个公有的静态成员变量表示(public static final)\n*可以有若干公有方法或抽象方法。采用抽象方法定义nextday就将大量的if.else语句\n转移成了一个个独立的类。\n**枚举的应用：\n举例：定义一个weekday的枚举。\n扩展：枚举类的values,valueof,name,tostring,ordinal等方法\n（记住，讲课时要先于自定义方法前介绍，讲课更流畅）\n总结：枚举是一种特殊的类，其中的每个元素都是该类的一个实例对象。\n例如可以调用weekday.sun.getclass().getname和weekday.class.getname()。\n**枚举的高级应用：\n**枚举就相当于一个类，其中也可以定义构造方法、成员变量、普通方法和抽象方法。\n**枚举元素必须位于枚举体中的最开始部分，枚举元素列表的后要有分号与其他成员分隔。\n把枚举中的成员方法或变量等放在枚举元素的前面，编译器报告错误。\n**带构造方法的枚举\n构造方法必须定义成私有的\n如果有多个构造方法，该如何选择哪个构造方法？\n枚举元素mon和mon()的效果一样，都是调用默认的构造方法。\n**带方法的枚举\n定义枚举trafficlamp\n实现普通的next方法\n实现抽象的next方法：每个元素分别是由枚举类的子类来生成的实例对象，\n这些子类采用类似内部类的方式进行定义。增加上表示时间的构造方法\n**枚举只有一个成员时，就可以作为一种单例的实现方式。\n(6)泛型：\n**泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，\n编译器编译带类型说明的集合时会去除掉“类型”信息，使程序运行效率不受影响，\n对于参数化的泛型类型，getclass()方法的返回值和原始类型完全一样。\n由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，\n就可以往某个泛型集合中加入其它类型的数据，例如，用反射得到集合，再调用其add方法即可。\n**arraylist类定义和arraylist类引用中涉及如下术语：\n整个称为arraylist泛型类型\narraylist中的e称为类型变量或类型参数\n整个arraylist称为参数化的类型\narraylist中的integer称为类型参数的实例或实际类型参数\narraylist中的\u0026lt;\u0026gt;念着typeof\narraylist称为原始类型\n**参数化类型与原始类型的兼容性：\n参数化类型可以引用一个原始类型的对象，编译报告警告，\n例如，collection c = new vector();//可不可以，不就是编译器一句话的事吗？\n原始类型可以引用一个参数化类型的对象，编译报告警告，\n例如，collection c = new vector();//原来的方法接受一个集合参数，新的类型也要能传进去\n**参数化类型不考虑类型参数的继承关系：\nvector v = new vector(); //错误!///不写没错，写了就是明知故犯\nvector v = new vector(); //也错误!\n编译器不允许创建泛型变量的数组。即在创建数组实例时，\n数组的元素不能使用参数化的类型，\n例如，下面语句有错误：\nvector vectorlist[] = new vector[10];\n**泛型限定：\n**限定通配符的上边界：\n正确：vector\u0026lt;? extends number\u0026gt; x = new vector();\n错误：vector\u0026lt;? extends number\u0026gt; x = new vector();\n**限定通配符的下边界：\n正确：vector\u0026lt;? super integer\u0026gt; x = new vector();\n错误：vector\u0026lt;? super integer\u0026gt; x = new vector();\n**提示：\n限定通配符总是包括自己。\n?只能用作引用，不能用它去给其他变量赋值\nvector\u0026lt;? extends number\u0026gt; y = new vector();\nvector x = y;\n上面的代码错误，原理与vector x11 = new vector();相似，\n只能通过强制类型转换方式来赋值。\n五、io流\n1、io流概述\n(1)用来处理设备(硬盘，控制台，内存)间的数据。\n(2)java中对数据的操作都是通过流的方式。\n(3)java用于操作流的类都在io包中。\n(4)按照流操作的数据的类型不同：分为字节流和字符流。字符流是为了方便中文的操作而来的。\n(5)按照流的流向不同分为：输入流，输出流\n2、io流常用基类：\n(1)字节流\n输出字节流：outputstream：字节写入流抽象类\n|\u0026mdash;\u0026gt;fileoutputstream：\n字节写入流\n|\u0026mdash;\u0026gt;bufferedoutputstream：\n字节写入流缓冲区\n|\u0026mdash;\u0026gt;printstream：\n打印流\n输入字节流：inputstream：字节读取流抽象类\n|\u0026mdash;\u0026gt;fileinputstream：\n字节读取流\n|\u0026mdash;\u0026gt;bufferedinputstream：\n字节读取流缓冲区\n(2)字符流\n输出字符流：writer：字符写入流的抽象\n|\u0026mdash;\u0026gt;filewriter：\n字符写入流\n|\u0026mdash;\u0026gt;bufferedwriter：\n字符写入流缓冲区\n|\u0026mdash;\u0026gt;outputstreamwriter：\n字符通向字节的转换流(涉及键盘录入时用)\n|\u0026mdash;\u0026gt;outputstreamwriter：\n打印流，可处理各种类型的数据\n输入字符流：reader: 字符读取流的抽象类\n|\u0026mdash;\u0026gt;filereader：\n字符读取流\n|\u0026mdash;\u0026gt;linenumberreader：\n跟踪行号的缓冲字符读取流\n|\u0026mdash;\u0026gt;bufferedreader：\n字符读取流缓冲区\n|\u0026mdash;\u0026gt;inputstreamreader：\n字节通向字符的转换流(涉及键盘录入时用)\n(3)io流常用基类方法摘要：\n**字节写入流：outputstream：\nvoid close() 关闭此输出流并释放与此流有关的所有系统资源。\nvoid flush()刷新此输出流并强制写出所有缓冲的输出字节。\nabstract void write(int b) 将指定的字节写入此输出流。\nvoid write(byte[] b) 将 b.length 个字节从指定的 byte 数组写入此输出流。\nvoid write(byte[] b, int off, int len)\n将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。\n**字节读取流：inputstream：\nvoid close() 关闭此输入流并释放与该流关联的所有系统资源。\nint available() (特有方法！！)\n返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。\nabstract int read() 从输入流中读取数据的下一个字节。\nint read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。\nint read(byte[] b, int off, int len) 将输入流中最多 len 个数据字节读入 byte 数组。\nlong skip(long n) 跳过和丢弃此输入流中数据的 n 个字节。\n**字符写入流：writer：\nabstract void close() 关闭此流，但要先刷新它。\nabstract void flush() 刷新该流的缓冲。\nvoid write(int c) 写入单个字符。\nvoid write(char[] cbuf) 写入字符数组。\nabstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。\nvoid write(string str) 写入字符串。\nvoid write(string str, int off, int len) 写入字符串的某一部分。\n**字符读取流：reader：\nabstract void close() 关闭该流并释放与之关联的所有资源。\nint read() 读取单个字符。\nint read(char[] cbuf) 将字符读入数组\nabstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。\nlong skip(long n) 跳过字符。\n3、io流常用字节流基类的子类：\n**写入流：\n(1)fileoutputstream：\n**构造方法：\nfileoutputstream(string name)\n创建一个向具有指定名称的文件中写入数据的输出文件流。\nfileoutputstream(string name, boolean append)\n创建一个向具有指定 name 的文件中写入数据的输出文件流。\nfileoutputstream(file file)\n创建一个向指定 file 对象表示的文件中写入数据的文件输出流。\nfileoutputstream(file file, boolean append)\n创建一个向指定 file 对象表示的文件中写入数据的文件输出流。\n**方法摘要：\npublic void flush()\nvoid close() 关闭此文件输出流并释放与此流有关的所有系统资源。\nvoid write(int b) 将指定字节写入此文件输出流。\nvoid write(byte[] b, int off, int len)\n将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。\nvoid write(int b) 将指定字节写入此文件输出流。\n(2)bufferedoutputstream：\n**构造方法：\nbufferedoutputstream(outputstream out)\n创建一个新的缓冲输出流，以将数据写入指定的底层输出流。\nbufferedoutputstream(outputstream out, int size)\n创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。\n**方法摘要：\nvoid flush() 刷新此缓冲的输出流。\nvoid write(byte[] b, int off, int len)\n将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。\nvoid write(int b) 将指定的字节写入此缓冲的输出流。\n(3)printstream：打印流，可将各种类型的数据原样打印，有自动刷新功能\n**构造方法：\nprintstream(string filename)\n创建具有指定文件名称且不带自动行刷新的新打印流。\nprintstream(file file)\n创建具有指定文件且不带自动行刷新的新打印流。\nprintstream(outputstream out)\n创建新的打印流。\nprintstream(outputstream out, boolean autoflush) (当autoflush为true时具有自动刷新功能)\n创建新的打印流。\n**方法摘要：\nprintstream append(char c)\n将指定字符添加到此输出流。\nvoid close()\n关闭流。\nvoid flush()\n刷新该流的缓冲。\nvoid print(各种类型的数据：)\n打印各种类型的数据\nvoid println(各种类型的数据：)：自动换行\n打印各种类型的数据\nvoid write(byte[] buf, int off, int len)\n将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。\nvoid write(int b)\n将指定的字节写入此流。\n**读取流：\n(1)fileinputstream：\n**构造方法：\nfileinputstream(string name)\n通过打开一个到实际文件的连接来创建一个 fileinputstream，\n该文件通过文件系统中的路径名 name 指定。\nfileinputstream(file file)\n通过打开一个到实际文件的连接来创建一个 fileinputstream，\n该文件通过文件系统中的 file 对象 file 指定。\n**方法摘要：\nint available() (字节读取流特有方法！！！)\n返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。\nint read()\n从此输入流中读取一个数据字节。\nint read(byte[] b)\n从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。\nint read(byte[] b, int off, int len)\n从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。\nlong skip(long n)\n从输入流中跳过并丢弃 n 个字节的数据。\n(2)bufferedinputstream:\n**构造方法：\nbufferedinputstream(inputstream in)\n创建一个 bufferedinputstream 并保存其参数，即输入流 in，以便将来使用。\nbufferedinputstream(inputstream in, int size)\n创建具有指定缓冲区大小的 bufferedinputstream 并保存其参数，即输入流 in，以便将来使用。\n**方法摘要：\nint available() (字节读取流特有方法！！！)\n返回可以从此输入流读取（或跳过）、且不受此输入流接下来的方法调用阻塞的估计字节数。\nint read()\n参见 inputstream 的 read 方法的常规协定。\nint read(byte[] b, int off, int len)\n从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。\nlong skip(long n)\n参见 inputstream 的 skip 方法的常规协定。\n4、字符流常用基类的子类\n**写入流：\n(1)filewriter:\n**构造方法：\nfilewriter(string filename)\n根据给定的文件名构造一个 filewriter 对象。\nfilewriter(string filename, boolean append)\n根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 filewriter 对象。\nfilewriter(file file)\n根据给定的 file 对象构造一个 filewriter 对象。\nfilewriter(file file, boolean append)\n根据给定的 file 对象构造一个 filewriter 对象。\nfilewriter(filedescriptor fd)\n构造与某个文件描述符相关联的 filewriter 对象。\n**方法摘要：跟writer一样\nabstract void close() 关闭此流，但要先刷新它。\nabstract void flush() 刷新该流的缓冲。\nvoid write(int c) 写入单个字符。\nvoid write(char[] cbuf) 写入字符数组。\nabstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。\nvoid write(string str) 写入字符串。\nvoid write(string str, int off, int len) 写入字符串的某一部分。\n(2)bufferedwriter:\n**构造方法：\nbufferedwriter(writer out)\n创建一个使用默认大小输出缓冲区的缓冲字符输出流。\nbufferedwriter(writer out, int sz)\n创建一个使用给定大小输出缓冲区的新缓冲字符输出流。\n**方法摘要：\nvoid close()\n关闭此流，但要先刷新它。\nvoid flush()\n刷新该流的缓冲。\nvoid newline()\n写入一个行分隔符。\nvoid write(char[] cbuf, int off, int len)\n写入字符数组的某一部分。\nvoid write(int c)\n写入单个字符。\nvoid write(string s, int off, int len)\n写入字符串的某一部分。\n(3)outputstreamwriter：字节通向字符的转换流\n**构造方法：\noutputstreamwriter(outputstream out)\n创建使用默认字符编码的 outputstreamwriter。\n**方法摘要：\nvoid write(char[] cbuf, int off, int len)\n写入字符数组的某一部分。\nvoid write(int c)\n写入单个字符。\nvoid write(string str, int off, int len)\n写入字符串的某一部分。\n(4)printwriter:\n**构造方法：\nprintwriter(string filename)\n创建具有指定文件名称且不带自动行刷新的新 printwriter。\nprintwriter(file file)\n使用指定文件创建不具有自动行刷新的新 printwriter。\nprintwriter(writer out)\n创建不带自动行刷新的新 printwriter。\nprintwriter(writer out, boolean autoflush)\n创建新 printwriter。\nprintwriter(outputstream out)\n根据现有的 outputstream 创建不带自动行刷新的新 printwriter。\nprintwriter(outputstream out, boolean autoflush)\n通过现有的 outputstream 创建新的 printwriter。\n**方法摘要：\nprintwriter append(char c)\n将指定字符添加到此 writer。\nvoid print(各种类型的数据：)\n打印各种类型的数据\nvoid println(各种类型的数据：)：自动换行\n打印各种类型的数据\nvoid write(char[] buf)\n写入字符数组。\nvoid write(char[] buf, int off, int len)\n写入字符数组的某一部分。\nvoid write(int c)\n写入单个字符。\nvoid write(string s)\n写入字符串。\nvoid write(string s, int off, int len)\n写入字符串的某一部分。\n**读取流：\n(1)filereader:\n**构造方法：\nfilereader(string filename)\n在给定从中读取数据的文件名的情况下创建一个新 filereader。\nfilereader(file file)\n在给定从中读取数据的 file 的情况下创建一个新 filereader。\nfilereader(filedescriptor fd)\n在给定从中读取数据的 filedescriptor 的情况下创建一个新 filereader。\n**方法摘要：和reader基类方法一致：\nabstract void close() 关闭该流并释放与之关联的所有资源。\nint read() 读取单个字符。\nint read(char[] cbuf) 将字符读入数组\nabstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。\nlong skip(long n) 跳过字符。\n(2)bufferedreader:\n**构造方法：\nbufferedreader(reader in)\n创建一个使用默认大小输入缓冲区的缓冲字符输入流。\n**方法摘要：\nint read()\n读取单个字符。\nint read(char[] cbuf, int off, int len)\n将字符读入数组的某一部分。\nstring readline()\n读取一个文本行。\n(3)inputstreamreader：字符通向字节的桥梁：\n**构造方法：\ninputstreamreader(inputstream in)\n创建一个使用默认字符集的 inputstreamreader。\n**方法摘要:\nint read() 读取单个字符。\nint read(char[] cbuf) 将字符读入数组\nabstract int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。\nlong skip(long n) 跳过字符。\n(4)linenumberreader：\n**构造方法：\nlinenumberreader(reader in)\n使用默认输入缓冲区的大小创建新的行编号 reader。\n**方法摘要：\nint read()\n读取单个字符。\nint read(char[] cbuf, int off, int len)\n将字符读入数组中的某一部分。\nstring readline()\n读取文本行。\nlong skip(long n)\n跳过字符。\nint getlinenumber()\n获得当前行号。\nvoid setlinenumber(int linenumber)\n设置当前行号。\n6、io流常见需求：\n****字符流：\n(1)需求1：在硬盘上创建一个文件并写入信息\n用字符写入流：filewriter\nfilewriter fw = new filewriter(\u0026ldquo;g:\\\\filewriter.txt\u0026rdquo;);\nfw.write(\u0026ldquo;输入信息\u0026rdquo;);\nfw.write(\u0026ldquo;也可以写入字符数组\u0026rdquo;.tochararray());\nfw.flush();\nfw.close();\n(2)需求2：在原有文件上续写数据\nfilewriter fw = new filewriter(\u0026ldquo;g:\\\\filewriter.txt\u0026rdquo;,true);\nfw.write(\u0026ldquo;还可以续写信息\u0026rdquo;);\nfw.write(\u0026ldquo;也可以写入字符数组\u0026rdquo;.tochararray());\nfw.flush();\nfw.close();\n(3)需求3：读取硬盘上的文本文件，并将数据打印在控制台\nfilereader fr = new filereader(\u0026ldquo;g:\\\\filewriter.txt\u0026rdquo;);\n**第一种读取方法：一个一个字节的读\nint ch = 0;\nch = fr.read();\nsop((char)ch);\nfr.close();\n**第二种读取方法：利用数组来提高效率\nchar[] buf = new char[1024];\nint len = 0;\nwhile((len = fr.read(buf))!=-1)\n{\nsop(new string(buf,0,len));\n}\nfr.close();\n(4)需求4:拷贝文本文件\n利用缓冲区提高数据读写效率\n(无缓冲区就相当于一滴一滴的喝水，有缓冲区就相当于一杯一杯的喝水)\nbufferedreader bufr = new bufferedreader(new filereader(\u0026ldquo;g:\\\\filewriter.txt\u0026rdquo;));\nbufferedwriter bufw = new bufferedwriter(new filewriter(\u0026ldquo;d:\\\\copyfilewriter.txt\u0026rdquo;));\nstring line = null;\nwhile((line = bufr.readline())!=null)\n{\nburw.write(line);\nbufw.newline();\nbufw.flush();\n}\nbufr.close();\nbufw.close();\n****字节流：字节流写入时没有刷新\n(1)需求1：在硬盘上创建一个文件并写入信息(字节流写入时没有刷新)\nfileoutputstream fos = new fileoutputstream(\u0026ldquo;g:\\\\filestream.txt\u0026rdquo;);\nfos.write(97);//写入一个字节,int：97代表写入char：a\nfos.write(\u0026ldquo;也可以写入字节数组\u0026rdquo;.getbytes());//通常使用此种方式写入，直观！\nfos.close();\n(2)需求2：在硬盘已有文件上续写数据(字节流写入时没有刷新)\nfileoutputstream fos = new fileoutputstream(\u0026ldquo;g:\\\\filestream.txt\u0026rdquo;,true);\nfos.write(\u0026ldquo;创建字节写入流时，传进去一个true参数就可以继续写入信息\u0026rdquo;.getbytes());\nfos.close();\n(3)需求3：读取硬盘上的文件\nfileinputstream fis = new fileinputstream(\u0026ldquo;g:\\\\filestream.txt\u0026rdquo;);\n**第一种读法：一个字节一个字节的读(此种读法慢)\nint ch = 0;\nwhile((ch = fis.read())!=-1)\n{\nsop((char)ch);\n}\n**第一种读法：利用字节数组读(此种读法效率有一定提高)\nbyte[] buf = new byte[1024];\nint len = 0;\nwhile((len = fis.read())!=-1)\n{\nsop(new string(buf,0,len));\n}\n(4)需求4:拷贝字节文件，如图片或者mp3或者电影\n**第一种拷贝：不带缓冲区(慢，还是效率问题)\n1 fileinputstream fis = new fileinputstream(\u0026ldquo;g:\\\\1.mp3\u0026rdquo;); 2 fileoutputstream fos = new fileoutputstream(\u0026ldquo;g:\\\\copy1.mp3\u0026rdquo;); 3 byte[] buf = new byte[1024]; 4 int len = 0; 5 while((len = fis.read(buf))!=-1) 6 { 7 fos.(buf,0,len);//字节流写入无需刷新 8 } 9 fis.close(); 10 fos.close(); 11 **第二种拷贝：带缓冲区，高效 12 bufferedinputstream bufi = new bufferedinputstream(new fileinputstream(\u0026ldquo;g:\\\\1.mp3\u0026rdquo;)); 13 bufferedoutputstream bufo = new bufferedoutputstream(new fileoutputstream(\u0026ldquo;g:\\\\copy1.mp3\u0026rdquo;)); 14 int ch = 0; 15 while((ch = bufi.read())!=-1) 16 { 17 bufo.write(ch); 18 } 19 bufi.close(); 20 bufo.close(); 21 ****转换流： 22 (1)需求1：读取一个键盘录入 23 inputstream in = system.in;//创建一个键盘录入流，流不关则可以一直录入 24 int by1 = in.read();//一次读一个字节 25 int by2 = in.read();//一次读一个字节 26 sop(by1);//假设键盘录入的是abcd,则打印a 27 sop(by2);//假设键盘录入的是abcd,则打印b 28 in.close(); 29 (2)需求2：键盘录入一行数据打印一行数据，如果录入的是over则结束录入 30 inputstream in = system.in; 31 stringbuilder sb = new stringbuilder(); 32 while(true) 33 { 34 int ch = in.read(); 35 if(ch==\u0026rsquo;\\r\u0026rsquo;) 36 continue; 37 if(ch==\u0026rsquo;\\n\u0026rsquo;) 38 { 39 string line = sb.tostring(); 40 if(\u0026ldquo;over\u0026rdquo;.equals(line)) 41 break; 42 sop(line.touppercase());//输出大写 43 sb.delete(0.sb.length());//清除上一行录入的数据 44 45 } 46 else 47 sb.append((char)ch); 48 } 49 in.close();\n(3)需求3：发现需求2中其实就是读一行的原理，故引入字节通向字符的桥梁：inputstreamreader\n为提高效率加入缓冲区：\nbufferedreader bufr = new bufferedreader(new inputstreamreader(system.in)); string line = null; while((line = bufr.readline())!=null) { if(\u0026ldquo;over\u0026rdquo;.equals(line)) break; sop(line.touppercase());//输出大写 }\nbufr.close();\n(4)需求4：键盘录入数据并打印到控制台\n1 bufferedreader bufr = new bufferedreader(new inputstreamreader(system.in)); 2 bufferedwriter bufw = new bufferedwriter(new ontputstreamwriter(system.out)); 3 string line = null; 4 while((line = bufr.readline())!=null) 5 { 6 if(\u0026ldquo;over\u0026rdquo;.equals(line)) 7 break; 8 bufw.write(line.touppercase()); 9 bufw.newline(); 10 bufw.flush(); 11 } 12 bufr.close(); 13 bufw.close();\n(5)需求5:将键盘录入的数据存储到硬盘文件\n则只需将(4)中的\n1 bufferedwriter bufw = new bufferedwriter(new ontputstreamwriter(system.out)); 2 改为： 3 bufferedwriter bufw = new bufferedwriter(new ontputstreamwriter(new filewriter(\u0026ldquo;g:\\\\demo.txt\u0026rdquo;))); 4 即： 5 bufferedreader bufr = new bufferedreader(new inputstreamreader(system.in)); 6 bufferedwriter bufw = new bufferedwriter(new ontputstreamwriter(new filewriter(\u0026ldquo;g:\\\\demo.txt\u0026rdquo;))); 7 string line = null; 8 while((line = bufr.readline())!=null) 9 { 10 if(\u0026ldquo;over\u0026rdquo;.equals(line)) 11 break; 12 bufw.write(line.touppercase()); 13 bufw.newline(); 14 bufw.flush(); 15 } 16 bufr.close(); 17 bufw.close();\n(6)需求6：将硬盘文件的数据打印到控制台\n则只需将(4)中的\n1 bufferedreader bufr = new bufferedreader(new inputstreamreader(system.in)); 2 改为： 3 bufferedreader bufr = new bufferedreader(new inputstreamreader(new filereader(\u0026ldquo;g:\\\\demo.txt\u0026rdquo;))); 4 即： 5 bufferedreader bufr = new bufferedreader(new inputstreamreader(new filereader(\u0026ldquo;g:\\\\demo.txt\u0026rdquo;))); 6 bufferedwriter bufw = new bufferedwriter(new ontputstreamwriter(system.out)); 7 string line = null; 8 while((line = bufr.readline())!=null) 9 { 10 if(\u0026ldquo;over\u0026rdquo;.equals(line)) 11 break; 12 bufw.write(line.touppercase()); 13 bufw.newline(); 14 bufw.flush(); 15 } 16 bufr.close(); 17 bufw.close();\n7、流操作的规律：\n****流操作的难点：流对象很多，不知道具体用哪个\n****规律：\n(1)第一步：先明确源和目的\n源：\n文本：用reader\n字节：用inputstream\n目的：\n文本：用writer\n字节：用outputstream\n(2)第二步：明确是不是纯文本\n是：用字符流；\n不是：用字节流\n(3)第三步：明确流体系后，通过设备来明确具体使用哪个流对象\n源设备：\n键盘：system.in\n硬盘：文件流file\n内存：数组流arraystream\n目的设备：\n键盘：system.out\n硬盘：文件流file\n内存：数组流arraystream\n8、file类\n构造方法：\nfile(string pathname)\n通过将给定路径名字符串转换为抽象路径名来创建一个新 file 实例。\nfile(string parent, string child)\n根据 parent 路径名字符串和 child 路径名字符串创建一个新 file 实例。\nfile(file parent, string child)\n根据 parent 抽象路径名和 child 路径名字符串创建一个新 file 实例。\n方法摘要：\n(1)创建：\nboolean createnewfile()\n当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。\nboolean mkdir()\n创建一级文件夹\nboolean mkdirs()\n创建多级文件夹\n(判断)：\nboolean canexecute()\n测试应用程序是否可以执行此抽象路径名表示的文件。\nboolean canread()\n测试应用程序是否可以读取此抽象路径名表示的文件。\nboolean canwrite()\n测试应用程序是否可以修改此抽象路径名表示的文件。\nint compareto(file pathname)\n按字母顺序比较两个抽象路径名。\nboolean isabsolute()\n测试此抽象路径名是否为绝对路径名。\nboolean isdirectory()\n测试此抽象路径名表示的文件是否是一个目录。\nboolean isfile()\n测试此抽象路径名表示的文件是否是一个标准文件。\nboolean ishidden()\n测试此抽象路径名指定的文件是否是一个隐藏文件。\nboolean exists()\n测试此抽象路径名表示的文件或目录是否存在。\n(3)获取：\nstring getparent()\n返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。\nfile getparentfile()\n返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。\nstring getname()\n返回由此抽象路径名表示的文件或目录的名称。\nstring getpath()\n将此抽象路径名转换为一个路径名字符串。\nstring getabsolutepath()\n返回此抽象路径名的绝对路径名字符串。\nfile getabsolutefile()\n返回此抽象路径名的绝对路径名形式。\n(4)删除：\nboolean delete()\n删除此抽象路径名表示的文件或目录。\noid deleteonexit()\n在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。\n(5)获取全部：(非常重要！！！)\nstring[] list()\n返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。\nstring[] list(filenamefilter filter)\n返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。\nfile[] listfiles()\n返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。\nfile[] listfiles(filefilter filter)\n返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。\n****filenamefilter接口只有一个方法：\nboolean accept(file dir, string name)\n测试指定文件是否应该包含在某一文件列表中。\n****filefilter接口只有一个方法：\nboolean accept(file dir, string name)\n测试指定文件是否应该包含在某一文件列表中。\n8、file类常见需求：\n(1)文件名过滤:列出给定目录的所有.java文件\npublic void showfilename(file file) { string[] filenames = file.list(new filenamefilter()//匿名内部类 { public boolean accept(file dir,string name)//复写唯一方法 { return name.endswith(\u0026quot;.java\u0026quot;);//列出所有.java文件 } }); }\n(2)列出指定目录下的所有文件和文件夹(递归)\n1 **示例1：不带层次递归： 2 public static void showdir(file dir) 3 { 4 file[] files = dir.listfile(); 5 for(int i = 0;i\u0026lt;files.length;i++) 6 { 7 if(files[i].isdirectory\u0026amp;\u0026amp;!files[i].ishidden()) 8 showdir(files[i]); 9 else 10 sop(files[i]); 11 } 12 } 13 **示例2：带层次递归： 14 public static void showdir(file dir,int level) 15 { 16 sop(getlevel(level)+c);//进来先打印层次和目录 17 level++; 18 file[] files = dir.listfile(); 19 for(int i = 0;i\u0026lt;files.length;i++) 20 { 21 if(files[i].isdirectory\u0026amp;\u0026amp;!files[i].ishidden()) 22 showdir(files[i]); 23 else 24 sop(getlevel(level)+files[i]);//是文件就打印层次和目录 25 } 26 } 27 public static string getlevel(int level) 28 { 29 sop(\u0026quot;|\u0026ndash;\u0026quot;); 30 stringbuilder sb = new stringbuilder(); 31 for(int i=0;i\u0026lt;level;i++) 32 { 33 sb.inset(0.\u0026quot;| \u0026ldquo;) 34 } 35 return sb.tostring(); 36 } 37 (3)需求：删除带内容的目录： 38 public static void removedir(file dir) 39 { 40 file[] files = file.listfile(); 41 for(int i = 0;i\u0026lt;files.length;i++) 42 { 43 if(files[i].isdirectory\u0026amp;\u0026amp;!files[i].ishidden()) 44 removedir(files[i]);//如果是文件夹则继续调用函数 45 else//如果是文件则删除。注意删除的时候打印删除的结果，防止误删或者重删的情况 46 sop(files[i].tostring()+\u0026rdquo;::\u0026quot;+files[i].delete()); 47 } 48 sop(dir+\u0026quot;::\u0026quot;+dir.delete()); 49 }\n(4)需求：将制定目录下的java文件的绝对路径存储到文本文件中。\n思路：\n**对指定目录进行递归\n**获取递归过程中所有java文件的路径\n**将这些路径存储到集合中\n**将集合中的数据写入文件中\n//对指定目录进行递归并将所以java文件存储到集合中\npublic static void getfilename(file file,arraylist arraylist){ file[] files = file.listfiles(); for (int i = 0; i \u0026lt; files.length; i++) { if(files[i].isdirectory()\u0026amp;\u0026amp;!files[i].ishidden()){ getfilename(files[i],arraylist); }else{ if(files[i].getname().endswith(\u0026quot;.java\u0026quot;)){ arraylist.add(files[i]); } } } } //将集合中所有数据存储到新文件中 public static void savefiletonewdir(arraylist arraylist,file newdir){ bufferedwriter bufw = null; try { bufw = new bufferedwriter(new filewriter(newdir)); for (file file : arraylist) { string fileabsolutepath = file.getabsolutepath(); bufw.write(fileabsolutepath); bufw.newline(); bufw.flush(); } } catch (exception e) { system.out.println(\u0026ldquo;文件写入失败\u0026rdquo;); }finally{ try { if(bufw!=null) bufw.close(); } catch (exception e2) { system.out.println(\u0026ldquo;文件写入流关闭失败\u0026rdquo;); } } }\n9、properties\n(1)properties是hashtable的子类，具备map集合的特点，里面存储的是键值对\n(2)properties是io流合集合相结合的集合容器\n(3)properties的特点是可以用于存储键值对形式的配置文件\n(4)构造方法：\nproperties()\n创建一个无默认值的空属性列表。\nproperties(properties defaults)\n创建一个带有指定默认值的空属性列表。\n(5)方法摘要：\nobject setproperty(string key, string value)\n调用 hashtable 的方法 put。\nstring getproperty(string key)\n用指定的键在此属性列表中搜索属性。\nvoid load(inputstream instream)\n从输入流中读取属性列表（键和元素对）。\nvoid load(reader reader)\n按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。\nvoid list(printstream out)\n将属性列表输出到指定的输出流。\nvoid list(printwriter out)\n将属性列表输出到指定的输出流。\nvoid store(outputstream out, string comments)\n以适合使用 load(inputstream) 方法加载到 properties 表中的格式，\n将此 properties 表中的属性列表（键和元素对）写入输出流。\nvoid store(writer writer, string comments)\n以适合使用 load(reader) 方法的格式，将此 properties 表中的\n属性列表（键和元素对）写入输出字符。\nset stringpropertynames()\n返回此属性列表中的键集，其中该键及其对应值是字符串，如果在主属性列表中\n未找到同名的键，则还包括默认属性列表中不同的键 1 (6)properties代码示例： 2 public static void show() 3 { 4 properties prop = new properties(); 5 prop.setproperty(\u0026ldquo;张三\u0026rdquo;,\u0026ldquo;26\u0026rdquo;); 6 prop.setproperty(\u0026ldquo;李四\u0026rdquo;,\u0026ldquo;30\u0026rdquo;); 7 prop.setproperty(\u0026ldquo;王五\u0026rdquo;,\u0026ldquo;35\u0026rdquo;); 8 sop(prop); 9 string value = prop.getproperty(\u0026ldquo;张三\u0026rdquo;); 10 11 set keys = prop.stringpropertyname(); 12 for(string key : values) 13 { 14 sop(key+\u0026quot;:\u0026quot;+prop.getpropety(key)); 15 } 16 }\n(7)需求：记录应用程序的使用次数，如果使用次数已到，则提示用户注册。\n思路：\n**第一次使用时建立一个配置文件用于记录使用次数\n**每次使用都加载该配置文件，并先判断已使用次数\n**每次使用完使用次数加1，写入配置文件\n1 public static void main(string[] args) throws ioexception{ 2 properties prop = new properties();//定义properties，用来和io流结合 3 file file = new file(\u0026ldquo;library\\\\time.ini\u0026rdquo;);//配置文件 4 if(!file.exists()) 5 file.createnewfile();//如果文件不存在则创建文件(用于第一次使用时创建文件) 6 fileinputstream fis = new fileinputstream(file);//定义字节读取流，读取配置文件中记录的使用次数 7 prop.load(fis);//载入流，以获取文件中配置的键值对 8 int count = 0;//定义使用次数 9 string countvalue = prop.getproperty(\u0026ldquo;time\u0026rdquo;);//通过键获取值 10 if(countvalue!=null){//第一次时countvalue为null 11 count = integer.parseint(countvalue);//将字符串次数变成数字次数 12 if(count\u0026gt;3){ 13 system.out.println(\u0026ldquo;您使用次数已到，继续使用请注册！\u0026rdquo;); 14 return; 15 } 16 } 17 count++;//如果使用次数未到则次数加1 18 prop.setproperty(\u0026ldquo;time\u0026rdquo;, count+\u0026quot;\u0026quot;);//配置新的键值对 19 filewriter fos = new filewriter(file); 20 prop.store(fos, \u0026ldquo;这是应用程序使用次数的配置文件\u0026rdquo;);//将新的键值对写入文件 21 fis.close(); 22 fos.close(); 23 }\n10、io中的其他流：\n(1)打印流：\n**printwriter:字符打印流\n****构造方法：\nprintwriter(string filename)\n创建具有指定文件名称且不带自动行刷新的新 printwriter。\nprintwriter(file file)\n使用指定文件创建不具有自动行刷新的新 printwriter。\nprintwriter(writer out)\n创建不带自动行刷新的新 printwriter。\nprintwriter(writer out, boolean autoflush)\n自动刷新\nprintwriter(outputstream out)\n根据现有的 outputstream 创建不带自动行刷新的新 printwriter。\nprintwriter(outputstream out, boolean autoflush)\n自动刷新\n****方法摘要：\nprintwriter append(char c)\n将指定字符添加到此 writer。\nvoid close()\n关闭该流并释放与之关联的所有系统资源。\nvoid flush()\n刷新该流的缓冲。\nvoid print(object obj)\n打印对象。\nvoid print(string s)\n打印字符串。\nvoid println()\n通过写入行分隔符字符串终止当前行。\n**printstream:字节打印流\n****构造方法：\nprintstream(string filename)\n创建具有指定文件名称且不带自动行刷新的新打印流。\nprintstream(file file)\n创建具有指定文件且不带自动行刷新的新打印流。\nprintstream(outputstream out)\n创建新的打印流。\nprintstream(outputstream out, boolean autoflush)\n创建新的打印流。\n****方法摘要：\nprintwriter append(char c)\n将指定字符添加到此 writer。\nvoid close()\n关闭该流并释放与之关联的所有系统资源。\nvoid flush()\n刷新该流的缓冲。\nvoid print(object obj)\n打印对象。\nvoid print(string s)\n打印字符串。\nvoid println()\n通过写入行分隔符字符串终止当前行。\n(2)对象系列化：\n**对象实体化：找一个介质，能长期的存储对象。\n**对象的属性在java程序中，都是存在于对内存中，随着对象的消失而消失，\n而objectoutputstream可以将对象实体化\n**serializable接口没有一个方法，也就是说其是一个标记接口。比如盖章的猪肉才是安全的。\n**只有实现serializable接口的子类才能被objectoutputstream系列化写入流，当某个\n类实现该接口后，会被java自动分配uid号，以便编译器识别，区分不同对象。\n**用objectoutputstream系列化的对象存储到文件后，该文件是乱码，也就是不可读的\n的用objectinputstream读取该类对象的属性。\n**由于对象是有java给对象分配相应的uid号，而uid号是根据对象的属性不同而分配的。\n当一个类对象被系列化到文件后，如果该类改动了对象的属性，比如将某个成员变量变成私有\n则该对象再用objectinputstream读取时会报异常，也就是说该系列化到文件的对象不能再被使用了\n那么，要想继续使用属性被改动后的对象，我们可以自定义给对象分配uid号，让uid号不随对象的属性\n变化而变化。\n自定义对象分配uid方法如下：\npublic static final long serialversion uid = 43l;\n**注意：\n静态不能被系列化，因为静态成员变量实在内存的方法区，而objectoutputstream只能\n对对内存里面的数据进行系列化\n被transient修饰的非静态成员变量也不能被系列化\n被系列化的对象存储到文件中，该文件是不可读的，所以该文件的扩展名一般\n不写成.txt，通常后缀名写.object\n**objectoutputstream\n**objectinputstream\n(3)管道流：\npipedinputstream\npipedoutputstream\n(4)随机访问文件：randomaccess(重要！！！)\n**自身具备读写方法(很牛逼！又可以读又可以写)\n**通过skipbyte(int x)和seek(int x)来达到随机访问文件\n**该类不是io体系子类，而是直接继承object，但它是io包中的成员，因为它具备读写方法\n**该类内部封装了数组，而且通过指针对数组的元素进行操作，可以通过getfilepoint获取指针位置\n同时可以通过seek改变指针位置\n**该类完成读写的原理是内部封装了字节输入输出流\n**通过该类的构造看出，该类只能操作文件，而且操作的文件只能有固定模式：\n\u0026ldquo;r\u0026rdquo;:只读\n\u0026ldquo;rw\u0026rdquo;:读写\n\u0026ldquo;rws\u0026rdquo;:\n\u0026ldquo;red\u0026rdquo;:\n**构造方法：\nrandomaccessfile(file file, string mode)\n创建从中读取和向其中写入（可选）的随机访问文件流，该文件由 file 参数指定。\nrandomaccessfile(string name, string mode)\n创建从中读取和向其中写入（可选）的随机访问文件流，该文件具有指定名称。\n**方法摘要：\nvoid write(byte[] b)\n将 b.length 个字节从指定 byte 数组写入到此文件，并从当前文件指针开始。\nvoid write(byte[] b, int off, int len)\n将 len 个字节从指定 byte 数组写入到此文件，并从偏移量 off 处开始。\nvoid write(int b)\n向此文件写入指定的字节。\nint read()\n从此文件中读取一个数据字节。\nint read(byte[] b)\n将最多 b.length 个数据字节从此文件读入 byte 数组。\nint read(byte[] b, int off, int len)\n将最多 len 个数据字节从此文件读入 byte 数组。\nstring readline()\n从此文件读取文本的下一行。\nlong getfilepointer()\n返回此文件中的当前偏移量。\nlong length()\n返回此文件的长度。\nvoid seek(long pos)\n设置到此文件开头测量到的文件指针偏移量，在该位置发生下一个读取或写入操作。\n(4)操作基本数据类型的流对象：datestream\n(5)操作字节数组流：\nbytearrayinputstream\nbytearrayoutputstream\n11、io流转换流的字符编码\n(1)字符流的出现为了方便操作字符，更重要的是加入了编码转换\n(2)通过子类转换流来完成\ninputstreamreander\noutputstreamwriter\n(3)在两个子类对象进行构造的时候可以加入编码表\n(4)编码表：\n将各个国家的文字用二进制数字表示并一一对应，形成一张表，这就是编码表\n(5)常见的编码表：\n**ascii：美国标准信息交换码，用一个字节的七位表示\n**iso8859-1：拉丁码表，欧洲码表，用一个字节的八位表示\n**gb2312：中文编码表，用两个字节表示\n**gbk：中文编码表升级，融合录入更多的中文字符，用两个字节表示，为避免和老美重复\n两字节的最高位都是1，即汉字都是用负数表示\n**unicode：国际标准码，融合了多种文字，所有文字都用两个字节表示\n**utf-8：用一个字节到三个字节表示。\n注：unicode能识别中文，utf-8也能识别中文，但两种编码表示一个汉字所用的字节数不同\nunicode用两个字节，utf-8用三个字节，故涉及到编码转换。\n(6)在流中涉及编码表的转换只有转换流：\ninputstreamreander\noutputstreamwriter\n(7)代码示例：\n1 public static void write() throws ioexception 2 { 3 outputstreamwriter osw1 = new outputstreamwriter(new fileoutputstream(\u0026ldquo;gbk.txt\u0026rdquo;),\u0026ldquo;gbk\u0026rdquo;); 4 osw1.write(\u0026ldquo;你好\u0026rdquo;); 5 osw1.close(); 6 7 outputstreamwriter osw2 = new outputstreamwriter(new fileoutputstream(\u0026ldquo;utf-8.txt\u0026rdquo;),\u0026ldquo;utf-8\u0026rdquo;); 8 osw2.write(\u0026ldquo;你好\u0026rdquo;); 9 osw2.close(); 10 } 11 public static void read() throws ioexception 12 { 13 inputstreamreader isr = new inputstreamreader(new fileinputstream(\u0026ldquo;gbk.txt\u0026rdquo;),\u0026ldquo;gbk\u0026rdquo;); 14 byte[] buf = new byte[1024]; 15 int len = isr.read(buf); 16 sop(new string(buf,0,len)); 17 } 18 (8)\n编码解码\n编码：字符串变成字节数组：string\u0026ndash;\u0026gt;getbytes()\u0026ndash;\u0026gt;byte[]()\n解码：字节数组变成字符串：byte[]\u0026ndash;\u0026gt;new string(byte[],0,len)\u0026ndash;\u0026gt;string\n(9)代码示例：\npublic static void main(string[] args)\n{\n//编码解码1：默认编码\nstring str1 = \u0026ldquo;你好\u0026rdquo;;\nbyte[] buf1 = str1.getbytes();//默认解码：unicode，四个字节\n//编码解码2：指定编码\nstring str2 = \u0026ldquo;你好\u0026rdquo;;\nbyte[] buf2 = str2.getbytes(\u0026ldquo;utf-8\u0026rdquo;);//指定解码：utf-8,六个字节\n//编码解码3：编码正确解码错误\nstring str3 = \u0026ldquo;你好\u0026rdquo;;\nbyte[] buf3 = str3.getbytes(\u0026ldquo;gbk\u0026rdquo;);//指定编码：gbk,四个字节\nstring str3 = new string(buf3,\u0026ldquo;iso8859-1\u0026rdquo;);//错误解码\n//编码解码4：错误编码正确解码\nstring str4 = \u0026ldquo;你好\u0026rdquo;;\nbyte[] buf4 = str4.getbytes(\u0026ldquo;iso8859-1\u0026rdquo;);//错误编码\nstring str4 = new string(buf4,\u0026ldquo;gbk\u0026rdquo;);//正确解码，读不出来\n//编码解码5：编码对了，但是解码错误了，怎么办呢？\n//此时可以将错误的解码再错编回去，载用正确编码解码\nstring str5 = \u0026ldquo;你好\u0026rdquo;;\nbyte[] buf5 = str5.getbytes(\u0026ldquo;gbk\u0026rdquo;);//正确编码\nstring str6 = new string(buf5,\u0026ldquo;iso8859-1\u0026rdquo;);//错误解码，读不出来\nbyte[] buf6 = str6.getbytes(\u0026ldquo;iso8859-1\u0026rdquo;);//再错误编码\nstring str7 = new string(buf6,\u0026ldquo;gbk\u0026rdquo;);//再正确解码，这样就可以读出来了\n}\n六、网络编程：\n1、网络编程概述\n(1)网络模型\nosi参考模型\ntcp/ip参考模型\n(2)网络通讯要素\nip地址\n端口号\n传输协议\n(3)网络通讯前提：\n**找到对方ip\n**数据要发送到指定端口。为了标示不同的应用程序，所以给这些网络应用程序都用数字进行标示\n。这个表示就叫端口。\n**定义通信规则。这个规则称为通信协议，国际组织定义了通用协议tcp/ip\n(4)计算机网络：\n是指将地理位置不同的具有独立功能的多台计算机及其外部设备，\n通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，\n实现资源共享和信息传递的计算机系统。\n(5)ip地址：\nip地址 = 网络号码+主机地址\na类ip地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码\nb类ip地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码\nc类ip地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码\n特殊地址:\n127.0.0.1 回环地址,可用于测试本机的网络是否有问题. ping 127.0.0.1\nipconfig:查看本机ip地址\nxxx.xxx.xxx.0 网络地址\nxxx.xxx.xxx.255 广播地址\na类 1.0.0.1\u0026mdash;127.255.255.254 10.x.x.x是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址) (2)127.x.x.x是保留地址，用做循环测试用的。\nb类 128.0.0.1\u0026mdash;191.255.255.254 172.16.0.0\u0026mdash;172.31.255.255是私有地址。169.254.x.x是保留地址。\nc类 192.0.0.1\u0026mdash;223.255.255.254 192.168.x.x是私有地址\nd类 224.0.0.1\u0026mdash;239.255.255.254\ne类 240.0.0.1\u0026mdash;247.255.255.254\n(6)各种网络分类方式\na:按网络覆盖范围划分\n局域网(几米至10公里以内) 城域网(10~100公里) 广域网(几百公里到几千公里) 国际互联网\nb:按网络拓扑结构划分\n总线型网络 星形网络 环型网络 树状网络 混合型网络\nc:按传输介质划分\n有线网 无线网\nd:按网络使用性质划分\n公用网 专用网\n(7)虚拟专用网络（virtual private network ，简称vpn)指的是在公用网络上建立专用网络的技术。\n其之所以称为虚拟网，主要是因为整个vpn网络的任意两个节点之间的连接并没有传统专网\n所需的端到端的物理链路，而是架构在公用网络服务商所提供的网络平台，如internet、\natm(异步传输模式〉、frame relay （帧中继）等之上的逻辑网络，\n用户数据在逻辑链路中传输。它涵盖了跨共享网络或公共网络的封装、\n加密和身份验证链接的专用网络的扩展。vpn主要采用了隧道技术、加解密技术、\n密钥管理技术和使用者与设备身份认证技术。\n(8)网络模型：\n****osi模型\n应用层\n表示层\n会话层\n传输层\n网络层\n数据连接层\n物理层\n****tcp/ip模型\n应用层\n传输层\n网际层\n主机至网络层\n2、tcp和udp\n(1)udp和tcp的区别：\nudp\n将数据及源和目的封装成数据包中，不需要建立连接\n每个数据报的大小在限制在64k内\n因无连接，是不可靠协议\n不需要建立连接，速度快\ntcp\n建立连接，形成传输数据的通道。\n在连接中进行大数据量传输\n通过三次握手完成连接，是可靠协议\n必须建立连接，效率会稍低\n注：三次握手：\n第一次：我问你在么？\n第二次：你回答在。\n第三次：我反馈哦我知道你在。\n3、socket(udp传输)\n**socket就是为网络服务提供的一种机制。\n**通信的两端都有socket。\n**网络通信其实就是socket间的通信。\n**数据在两个socket间通过io传输。\n**玩socket主要就是记住流程，代码查文档就行\n(1)udp传输：datagramsocket与datagrampacket\n**发送端：\n建立datagramsocket服务；\n提供数据，并将数据封装到字节数组中；\n创建datagrampacket数据包，并把数据封装到包中，同时指定ip和接收端口\n通过socket服务，利用send方法将数据包发送出去；\n关闭datagramsocket和datagrampacket服务。\n**接收端：\n建立datagramsocket服务，并监听一个端口；\n定义一个字节数组和一个数据包，同时将数组封装进数据包；\n通过datagrampacket的receive方法，将接收的数据存入定义好的数据包；\n通过datagrampacke关闭t的方法，获取发送数据包中的信息；\n关闭datagramsocket和datagrampacket服务。\ndatagramsocket与datagrampacket方法摘要：\n*****datagramsocket\n构造方法：\ndatagramsocket()\n构造数据报套接字并将其绑定到本地主机上任何可用的端口。\ndatagramsocket(int port)\n创建数据报套接字并将其绑定到本地主机上的指定端口。\ndatagramsocket(int port, inetaddress laddr)\n创建数据报套接字，将其绑定到指定的本地地址。\n方法摘要:\nvoid close()\n关闭此数据报套接字。\ninetaddress getinetaddress()\n返回此套接字连接的地址。\ninetaddress getlocaladdress()\n获取套接字绑定的本地地址。\nint getport()\n返回此套接字的端口。\nvoid receive(datagrampacket p)\n从此套接字接收数据报包。\nvoid send(datagrampacket p)\n从此套接字发送数据报包。\n****datagrampacket\n构造方法：\ndatagrampacket(byte[] buf, int length)\n构造 datagrampacket，用来接收长度为 length 的数据包。\ndatagrampacket(byte[] buf, int length, inetaddress address, int port)\n构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。\ninetaddress getaddress()\n返回某台机器的 ip 地址，此数据报将要发往该机器或者是从该机器接收到的。\nbyte[] getdata()\n返回数据缓冲区。\nint getlength()\n返回将要发送或接收到的数据的长度。\nint getport()\n返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。\n代码示例：\n****发送端：\n1 ****发送端 2 class udpsend 3 { 4 public static void main(string[] args) throws exception 5 { 6 datagramsocket ds = new datagramsocket(); 7 byte[] buf = \u0026ldquo;这是udp发送端\u0026rdquo;.getbytes(); 8 datagrampacket dp = new datagrampacket( 9 buf,buf.length,inetaddress.getbyname(\u0026ldquo;192.168.1.253\u0026rdquo;),10000); 10 ds.send(dp); 11 ds.close(); 12 } 13 } 14 ****接收端 15 class udprece 16 { 17 public static void main(string[] args) throws exception 18 { 19 datagramsocket ds = new datagramsocket(10000); 20 byte[] buf = new byte[1024]; 21 datagrampacket dp = new datagrampacket(buf,buf.length); 22 ds.receive(dp);//将发送端发送的数据包接收到接收端的数据包中 23 string ip = dp.getaddress().gethosyaddress();//获取发送端的ip 24 string data = new string(dp.getdata(),0,dp.getlength());//获取数据 25 int port = dp.getport();//获取发送端的端口号 26 sop(ip+\u0026quot;:\u0026quot;+data+\u0026quot;:\u0026quot;+port); 27 ds.close(); 28 } 29 } 30 需求1：udp键盘录入数据，并发送给接收端 31 发送端： 32 class udpsend 33 { 34 public static void main(string[] args) throws exception 35 { 36 37 datagramsocket ds = new datagramsocket(); 38 bufferedreader bufr = new bufferedreader(new inputstreamreader(system.in)); 39 string line = null; 40 while((line = bufr.readline())!=null) 41 { 42 if(\u0026ldquo;886\u0026rdquo;.equals(line)) 43 break; 44 byte[] buf = line.getbytes(); 45 datagrampacket dp = new datagrampacket( 46 buf,buf.length,inetaddress.getbyname(\u0026ldquo;192.168.1.253\u0026rdquo;),10000); 47 ds.send(dp); 48 } 49 ds.close(); 50 } 51 52 } 53 接收端： 54 class udprece 55 { 56 public static void main(string[] args) throws exception 57 { 58 datagramsocket ds = new datagramsocket(10000); 59 while(true) 60 { 61 byte[] buf = new byte[1024]; 62 datagrampacket dp = new datagrampacket(buf,buf.length); 63 ds.receive(dp);//将发送端发送的数据包接收到接收端的数据包中 64 string ip = dp.getaddress().gethosyaddress();//获取发送端的ip 65 string data = new string(dp.getdata(),0,dp.getlength());//获取数据 66 int port = dp.getport();//获取发送端的端口号 67 sop(ip+\u0026quot;:\u0026quot;+data+\u0026quot;:\u0026quot;+port); 68 ds.close(); 69 } 70 } 71 72 }\n需求2：编写简单的聊天工具\n思路：\n使用多线程技术\n1 发送端： 2 class udpsend implements runnable 3 { 4 private datagramsocket ds; 5 public udpsend(){} 6 public udpsend(datagramsocket ds) 7 { 8 this.ds=ds; 9 } 10 public void run() 11 { 12 try 13 { 14 bufferedreader bufr = new bufferedreader( 15 new inputstreamreader(system.in)); 16 string line = null; 17 while((line = bufr.readline())!=null) 18 { 19 if(\u0026ldquo;886\u0026rdquo;.equals(line)) 20 break; 21 byte[] buff = line.getbytes(); 22 datagrampacket dp = new datagrampacket( 23 buf,buf.length,inetaddress.getbyname(\u0026ldquo;192.168.1.253\u0026rdquo;),10000); 24 ds.send(dp); 25 } 26 } 27 catch(exception e) 28 { 29 throw new runtimeexception(\u0026ldquo;发送失败\u0026rdquo;); 30 } 31 } 32 } 33 接收端： 34 class udprece implements runnable 35 { 36 private datagramsocket ds; 37 public udpsend(){} 38 public udpsend(datagramsocket ds) 39 { 40 this.ds=ds; 41 } 42 public void run() 43 { 44 try 45 { 46 while(true) 47 { 48 byte[] buf = new byte[1024]; 49 datagrampacket dp = new datagrampacket(buf,buf.length); 50 ds.receive(dp);//将发送端发送的数据包接收到接收端的数据包中 51 string ip = dp.getaddress().gethosyaddress();//获取发送端的ip 52 string data = new string(dp.getdata(),0,dp.getlength());//获取数据 53 int port = dp.getport();//获取发送端的端口号 54 sop(ip+\u0026quot;:\u0026quot;+data+\u0026quot;:\u0026quot;+port); 55 } 56 } 57 catch(exception e) 58 { 59 throw new runtimeexception(\u0026ldquo;接收失败\u0026rdquo;); 60 } 61 } 62 } 63 测试类： 64 class udptest 65 { 66 public static void main(string[] args) 67 { 68 datagramsocket sendsocket = new datagramsocket(); 69 datagramsocket recesocket = new datagramsocket(10000); 70 71 new thread(new udpsend(sendsocket)).start(); 72 new thread(new udprece(recesocket)).start(); 73 } 74 }\n(2)tcp传输\nsocket和serversocket\n建立客户端和服务器端\n建立连接后，通过socket中的io流进行数据的传输\n关闭socket\n同样，客户端与服务器端是两个独立的应用程序。\n****socket\n**构造方法：\nsocket()\n通过系统默认类型的 socketimpl 创建未连接套接字\nsocket(inetaddress address, int port)\n创建一个流套接字并将其连接到指定 ip 地址的指定端口号。\nsocket(string host, int port)\n创建一个流套接字并将其连接到指定主机上的指定端口号。\n**方法摘要：\nvoid close()\n关闭此套接字。\ninetaddress getinetaddress()\n返回套接字连接的地址。\ninputstream getinputstream()\n返回此套接字的输入流。\noutputstream getoutputstream()\n返回此套接字的输出流。\nint getport()\n返回此套接字连接到的远程端口。\nvoid shutdowninput()\n此套接字的输入流置于“流的末尾”。\nvoid shutdownoutput()\n禁用此套接字的输出流。\nstring tostring()\n将此套接字转换为 string。\n****serversocket\n**构造方法：\nserversocket()\n创建非绑定服务器套接字。\nserversocket(int port)\n创建绑定到特定端口的服务器套接字。\n方法摘要：\nsocket accept()\n侦听并接受到此套接字的连接。\nvoid close()\n关闭此套接字。\ninetaddress getinetaddress()\n返回此服务器套接字的本地地址。\n****tcp传输流程：\n**客户端：\n建立socket服务，并制定要连接的主机和端口；\n获取socket流中的输出流outputstream，将数据写入流中，通过网络发送给服务端；\n获取socket流中的输出流inputstream，获取服务端的反馈信息；\n关闭资源。\n**服务端：\n建立serversocket服务，并监听一个端口；\n通过serversocket服务的accept方法，获取socket服务对象；\n使用客户端对象的读取流获取客户端发送过来的数据；\n通过客户端对象的写入流反馈信息给客户端；\n关闭资源；\n****代码示例：\n1 客户端： 2 class tcpclient 3 { 4 public static void main(string[] args) 5 { 6 socket s = new socket(\u0026ldquo;192.168.1.253\u0026rdquo;,10000); 7 outputstream os = s.getoutputstream(); 8 out.write(\u0026ldquo;这是tcp发送的数据\u0026rdquo;.getbytes()); 9 s.close(); 10 } 11 } 12 服务端： 13 class tcpserver 14 { 15 public static void main(string[] args) 16 { 17 serversocket ss = new serversocket(10000); 18 socket s = ss.accept(); 19 20 string ip = s.getinetaddress().gethostaddress(); 21 sop(ip); 22 23 inputstream is = s.getinputstream(); 24 byte[] buf = new byte[1024]; 25 int len = is.read(buf); 26 sop(new string(buf,0,len)); 27 s.close(); 28 ss.close(); 29 } 30 } 31 tcp需求1：客户端给服务端发送数据，服务端接收到后反馈信息给客户端 32 客户端： 33 class tcpclient 34 { 35 public static void main(string[] args) 36 { 37 socket s = new socket(\u0026ldquo;192.168.1.253\u0026rdquo;,10000); 38 outputstream os = s.getoutputstream(); 39 out.write(\u0026ldquo;这是tcp发送的数据\u0026rdquo;.getbytes()); 40 41 inputstream is = s.getinputstream(); 42 byte[] buf = new byte[1024]; 43 int len = is.read(buf); 44 sop(new string(buf,0,len)); 45 s.close(); 46 } 47 } 48 服务端： 49 class tcpserver 50 { 51 public static void main(string[] args) 52 { 53 serversocket ss = new serversocket(10000); 54 socket s = ss.accept(); 55 56 string ip = s.getinetaddress().gethostaddress(); 57 sop(ip); 58 59 inputstream is = s.getinputstream(); 60 byte[] buf = new byte[1024]; 61 int len = is.read(buf); 62 sop(new string(buf,0,len)); 63 64 outputstream os = s.getoutputstream(); 65 out.write(\u0026ldquo;这是tcp发送的数据\u0026rdquo;.getbytes()); 66 67 s.close(); 68 ss.close(); 69 } 70 } 71 tcp需求2：建立一个文本转换服务端，客户给服务端发送文本，服务端将数据转换成大写后返回给客户端 72 当客户端输入over时，转换结束 73 客户端： 74 class tcpclient 75 { 76 public static void main(string[] args) 77 { 78 socket s = new socket(\u0026ldquo;192.168.1.253\u0026rdquo;,10000); 79 bufferedreader bufr = new bufferedreader(new inputstreamreader(system.in)); 80 bufferedwriter bufout = new bufferedwriter(new outputstreamwriter( 81 s.getoutputstream())); 82 bufferedreader bufin = new bufferedreader(new inputstreamreader( 83 s.getinputstream())); 84 string line = null; 85 while((line = bufr.readline())!=null) 86 { 87 if(\u0026ldquo;over\u0026rdquo;.equals(line)) 88 break; 89 bufout.write(line); 90 bufout.newline(); 91 bufout.flush(); 92 string retval = bufin.readline(); 93 sop(\u0026ldquo;server:\u0026quot;+retval); 94 } 95 bufr.close(); 96 s.close(); 97 } 98 } 99 服务端： 100 class tcpserver 101 { 102 public static void main(string[] args) 103 { 104 serversocket ss = new serversocket(10000); 105 socket s = ss.accept(); 106 107 string ip = s.getinetaddress().gethostaddress(); 108 sop(ip); 109 110 bufferedreader bufin = new bufferedreader(new inputstreamreader( 111 s.getinputstream())); 112 bufferedwriter bufout = new bufferedwriter(new outputstreamwriter( 113 s.getoutputstream())); 114 115 while((line = bufin.readline())!=null) 116 { 117 bufout.write(line.touppercase()); 118 bufout.newline(); 119 bufout.flush(); 120 } 121 s.close(); 122 ss.close(); 123 } 124 } 125 **需求3：拷贝文件 126 客户端： 127 class tcpclient 128 { 129 public static void main(string[] args) 130 { 131 socket s = new socket(\u0026ldquo;192.168.1.253\u0026rdquo;,10000); 132 bufferedreader bufr = new bufferedreader(new filereader(\u0026ldquo;g:\\\\demo.txt\u0026rdquo;)); 133 printwriter pw = new printwriter(s.getoutputstream(),true); 134 string line = null; 135 while((line = bufr.readline())!=null) 136 { 137 pw.println(); 138 } 139 s.shutdownoutput(); 140 bufferedreader bufin = new bufferedreader(new inputstreamreader( 141 s.getinputstream())); 142 string retval = bufin.readline(); 143 sop(retval); 144 bufr.close(); 145 s.close(); 146 } 147 } 148 服务端： 149 class tcpserver 150 { 151 public static void main(string[] args) 152 { 153 serversocket ss = new serversocket(10000); 154 socket s = ss.accept(); 155 156 string ip = s.getinetaddress().gethostaddress(); 157 sop(ip); 158 159 bufferedreader bufin = new bufferedreader(new inputstreamreader( 160 s.getinputstream())); 161 printwriter out = new printwriter(new filewriter\u0026quot;copy.txt\u0026rdquo;,true); 162 string line =null; 163 while((line = bufin.readline())!=null) 164 { 165 out.write(line); 166 } 167 printwriter pw = new printwriter(s.getoutputstream(),true); 168 pw.println(\u0026ldquo;上传成功\u0026rdquo;); 169 out.close(); 170 s.close(); 171 ss.close(); 172 } 173 } 174 需求4：上传图片 175 客户端： 176 class tcpclient 177 { 178 public static void main(string[] args) 179 { 180 socket s = new socket(\u0026ldquo;192.168.1.253\u0026rdquo;,10000); 181 fileinputstream fis = new fileinputstream(\u0026ldquo;g:\\\\1.bmp\u0026rdquo;); 182 outputstream out = s.getoutputstream(); 183 byte[] buf = new byte[1024]; 184 int len = 0; 185 while((len = bufr.read())!=-1) 186 { 187 out.write(buf,0,len); 188 } 189 s.shutdownoutput(); 190 191 inputstream in = s.getinputstream(); 192 byte[] bufin = new byte[1024]; 193 int lenin = in.read(bufin); 194 sop(new string(bufin,0,lenin); 195 fis.close(); 196 s.close(); 197 } 198 } 199 服务端： 200 class tcpserver 201 { 202 public static void main(string[] args) 203 { 204 serversocket ss = new serversocket(10000); 205 socket s = ss.accept(); 206 207 string ip = s.getinetaddress().gethostaddress(); 208 sop(ip); 209 fileoutputstream fos = new fileoutputstream(\u0026ldquo;g:\\\\copy.bmp\u0026rdquo;); 210 inputstream in = s.getinputstream(); 211 byte[] bufin = new byte[1024]; 212 int lenin = 0; 213 while((lenin=bufin.read())!=-1) 214 { 215 fos.write(bufin,0,lenin) 216 } 217 218 outputstream outin = s.getoutputstream(); 219 outin.write(\u0026ldquo;上传成功\u0026rdquo;.getbytes()); 220 fos.close(); 221 s.close(); 222 ss.close(); 223 } 224 } 225 需求5：客户端并发登陆 226 客户端通过键盘录入用户名，服务端对这个用户名进行校验 227 如果用户存在，在服务端现实xxx已登录，并在客户端现实欢迎xxx 228 如果用户不存在，在服务端现实xxx正在尝试登陆，并在客户端现实xxx用户不存在 229 最多登陆三次。 230 校验端： 231 class user implements runnable 232 ( 233 private socket s; 234 public user(){} 235 public user(socket s) 236 { 237 this.s=s; 238 } 239 public void run() 240 { 241 try 242 { 243 bufferedreader bufrin = new bufferedreader( 244 new inputstream(s.getinputstream())) 245 string name = bufrin.readline(); 246 if(name==null) 247 { 248 sop(\u0026ldquo;用户名为空\u0026rdquo;); 249 break; 250 } 251 bufferedreader bufr = new bufferedreader( 252 new filereader(\u0026ldquo;user.txt\u0026rdquo;)); 253 printwriter pw = new printwriter(s.getoutputstream(),true); 254 string line = null; 255 boolean flag = false; 256 while((line = bufr.reanline())!=null) 257 { 258 if(line.equals(name)) 259 { 260 flag = true; 261 break; 262 } 263 if(flag) 264 { 265 sop(name+\u0026ldquo;已登陆\u0026rdquo;); 266 pw.println(\u0026ldquo;欢迎\u0026rdquo;+name); 267 break; 268 } 269 else 270 { 271 sop(name+\u0026ldquo;正尝试登陆\u0026rdquo;); 272 pw.println(name+\u0026ldquo;用户不存在\u0026rdquo;); 273 } 274 275 } 276 s.close(); 277 } 278 catch(exception e) 279 { 280 throw new runtimeexception(\u0026ldquo;用户校验失败\u0026rdquo;); 281 } 282 } 283 ) 284 客户端： 285 class loginclient 286 { 287 public static void main(string[] args) 288 { 289 socket s = new socket(\u0026ldquo;192.168.1.253\u0026rdquo;,10000); 290 bufferedreader bufr = new bufferedreader( 291 new inputstreamreader(system.in))); 292 printwriter out = new printwriter(s.getoutputstream(),true); 293 bufferedreader bufin = new bufferedreader( 294 new inputstreamreader(s.getinputstream())); 295 for(int i=0;i\u0026lt;3;i++) 296 { 297 string line = bufr.readline(); 298 if(line == null) 299 { 300 sop(\u0026ldquo;用户名不能为空！\u0026rdquo;); 301 break; 302 } 303 out.write(line); 304 string retval = bufin.readline(); 305 sop(retval); 306 } 307 bufr.close(); 308 s.close(); 309 } 310 } 311 服务端： 312 class loginserver 313 { 314 public static void main(string[] args) 315 { 316 serversocket ss = new serversocket(10000); 317 while(true) 318 { 319 socket s = ss.accept(); 320 new thread(new user()).start(); 321 } 322 } 323 }\n","date":"2021-10-12","permalink":"https://lovemjh.vercel.app/posts/_java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8/","summary":"一、基础知识： 1、JVM、JRE和JDK的区别： JVM(Java Virtual Machine):java虚拟机，用于保证java的跨平台的特性。 java语言是跨平台，jvm不是跨平台的。","title":"java大全"},{"content":"java简介 语言 计算机语言 语言： 交互 获取信息。\n计算机语言：人与计算机进行交互，计算机为我们做事。\n计算机语言发展： 机器语言：二进制 0 1 纸带打点，速度快 汇编语言：助记符， mov add 高级计算机语言：java c c# .net html css python\u0026hellip;\u0026hellip;. \u0026mdash;》翻译\n软件架构 应用软件 和 系统软件 应用软件：解决问题。qq 计算器 画图 word 系统软件：硬件 hp 联想 华硕 系统：windows 苹果\n软件架构 b/s:浏览器/服务器 页游 随时可玩 体验差 c/s:客户端 下客户端 体验好\n前端 后端 前端 ：客户端能展现的。web ui 后台： 需求处理 数据： 数据库\n什么是java语言？ java之父 詹姆斯 高斯林 oak 橡树 java语言的前身\njava 是由 sun microsystems 公司于 1995 年 5 月推出的 java 面向对象程序设计语言和 java 平台的总称。由 james gosling和同事们共同研发，并在 1995 年正式推出。后来 sun 公司被 oracle （甲骨文）公司收购，java 也随之成为 oracle 公司的产品。\njava发展的版本/平台 1.2版本 规定了java的发展方向：j2ee j2se j2me 1.2 确立了java的发展方向。 1.5 1.6 版本 修改java的语法结构 和重命名为： javaee javase javame 1.5 /1.6 改进了java的语法 java 15 版本 sun公司\u0026mdash;》oracle公司\njava 8 版本 1.8 lambda表达式 streamapi lambda streamapi\njava分为三个体系：\njavase（j2se）（java2 platform standard edition，java平台标准版） 标准版：桌面：客户端 。第一阶段\njavaee(j2ee)(java 2 platform,enterprise edition，java平台企业版) 企业版：电商项目、门户网站\njavame(j2me)(java 2 platform micro edition，java平台微型版)。 缩小版：嵌入式。 安卓\n更名：1.6 2005 年 6 月，javaone 大会召开，sun 公司公开 java se 6。此时，java 的各种版本已经更名，以取消其中的数字 \u0026ldquo;2\u0026rdquo;：j2ee 更名为 java ee，j2se 更名为java se，j2me 更名为 java me。\njavaee 更名 ：jakartaee 雅加达\n主要特性 开源 自动的垃圾回收机制 java 语言是简单的： java 语言的语法与 c 语言和 c++ 语言很接近，使得大多数程序员很容易学习和使用。另一方面，java 丢弃了 c++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，java 语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。 java 语言是面向对象的： java 语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。java 语言全面支持动态绑定，而 c++语言只对虚函数使用动态绑定。总之，java语言是一个纯的面向对象程序设计语言。 java语言是分布式的： java 语言支持 internet 应用的开发，在基本的 java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 url、urlconnection、socket、serversocket 等。java 的 rmi（远程方法激活）机制也是开发分布式应用的重要手段。 java 语言是健壮的： java 的强类型机制、异常处理、垃圾的自动收集等是 java 程序健壮性的重要保证。对指针的丢弃是 java 的明智选择。java 的安全检查机制使得 java 更具健壮性。 java语言是安全的： java通常被用在网络环境中，为此，java 提供了一个安全机制以防恶意代码的攻击。除了java 语言具有的许多安全特性以外，java 对通过网络下载的类具有一个安全防范机制（类 classloader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 securitymanager）让 java 应用设置安全哨兵。 java 语言是体系结构中立的： java 程序（后缀为 java 的文件）在 java 平台上被编译为体系结构中立的字节码格式（后缀为 class 的文件），然后可以在实现这个 java 平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。 java 语言是可移植的： 这种可移植性来源于体系结构中立性，另外，java 还严格规定了各个基本数据类型的长度。java 系统本身也具有很强的可移植性，java 编译器是用 java 实现的，java 的运行环境是用 ansi c 实现的。 java 语言是解释型的： 如前所述，java 程序在 java 平台上被编译为字节码格式，然后可以在实现这个 java 平台的任何系统中运行。在运行时，java 平台中的 java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。 java 是高性能的： 与那些解释型的高级脚本语言相比，java 的确是高性能的。事实上，java 的运行速度随着 jit(just-in-time）编译器技术的发展越来越接近于 c++。 java 语言是多线程的： 在 java 语言中，线程是一种特殊的对象，它必须由 thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 thread(runnable) 的构造子类将一个实现了 runnable 接口的对象包装成一个线程，其二，从 thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 thread 类已经实现了 runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。 java 语言是动态的： java 语言的设计目标之一是适应于动态变化的环境。java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查。 发展历程 1995 年 5 月 23 日，java 语言诞生 1996 年 1 月，第一个 jdk-jdk1.0 诞生 1996 年 4 月，10 个最主要的操作系统供应商申明将在其产品中嵌入 java 技术 1996 年 9 月，约 8.3 万个网页应用了 java 技术来制作 1997 年 2 月 18 日，jdk1.1 发布 1997 年 4 月 2 日，javaone 会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997 年 9 月，javadeveloperconnection 社区成员超过十万 1998 年 2 月，jdk1.1 被下载超过 2,000,000次 1998 年 12 月 8 日，java2 企业平台 j2ee 发布 1999 年 6月，sun 公司发布 java 的三个版本：标准版（javase, 以前是 j2se）、企业版（javaee 以前是 j2ee）和微型版（javame，以前是 j2me） sun公司发布了第二代java平台（简称为java2）的3个版本：j2me（java2 micro edition，java2平台的微型版），应用于移动、无线及有限资源的环境；j2se（java 2 standard edition，java 2平台的标准版），应用于桌面环境；j2ee（java 2enterprise edition，java 2平台的企业版），应用于基于java的应用服务器。java 2平台的发布，是java发展过程中最重要的一个里程碑，标志着java的应用开始普及。 2000 年 5 月 8 日，jdk1.3 发布 2000 年 5 月 29 日，jdk1.4 发布 2001 年 6 月 5 日，nokia 宣布，到 2003 年将出售 1 亿部支持 java 的手机 2001 年 9 月 24 日，j2ee1.3 发布 2002 年 2 月 26 日，j2se1.4 发布，自此 java 的计算能力有了大幅提升 2004 年 9 月 30 日 18:00pm，j2se1.5 发布，成为 java 语言发展史上的又一里程碑。为了表示该版本的重要性，j2se1.5 更名为 java se 5.0 2005 年 6 月，javaone 大会召开，sun 公司公开 java se 6。此时，java 的各种版本已经更名，以取消其中的数字 \u0026ldquo;2\u0026rdquo;：j2ee 更名为 java ee，j2se 更名为 java se，j2me 更名为 java me 2006年12月，sun公司发布了jdk1.6(也被称为java ee 6)。2006年11月13日，java技术的发明者sun公司宣布，将java技术作为免费软件对外发布。sun公司正式发布的有关java平台标准版的第一批源代码，以及java迷你版的可执行源代码。从2007年3月起，全世界所有的开发人员均可对java源代码进行修改 。 2009 年 04 月 20 日，甲骨文 74 亿美元收购 sun，取得 java 的版权。 2010 年 11 月，由于甲骨文对于 java 社区的不友善，因此 apache 扬言将退出 jcp。 2011 年 7 月 28 日，甲骨文发布 java7.0 的正式版。 2014 年 3 月 18 日，oracle 公司发表 java se 8。代表性技术包括：lambda表达式、函数式接口、方法引用和构造器调用、stream api、接口中的默认方法和静态方法、optional 类、新时间日期api等。 2017 年 9 月 21 日，oracle 公司发表 java se 9代表性技术包括：java 平台级模块系统，linking，jshell （交互式 java repl），改进的 javadoc，改进的 stream api，集合工厂方法，私有接口方法，http/2，多版本兼容 jar。 2018 年 3 月 21 日，oracle 公司发表 java se 10 2018 年 9 月 25 日，java se 11 发布 2019 年 3 月 20 日，java se 12 ??\njava虚拟机 jvm java虚拟机有自己完善的硬件架构，如处理器、堆栈等，还具有相应的指令系统。\njava虚拟机本质上就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。java语言的可移植性正是建立在java虚拟机的基础上。任何平台只要装有针对于该平台的java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。\njava虚拟机不仅是一种跨平台的软件，而且是一种新的网络计算平台。该平台包括许多相关的技术，如符合开放接口标准的各种api、优化技术等。java技术使同一种应用可以运行在不同的平台上。java平台可分为两部分，即java虚拟机（java virtual machine，jvm）和java api类库。\n编译性 java语言属于高级计算机语言。计算机识别： 机器语言。\njavac命令\n转换成机器能够识别的代码：二进制字节码文件 用.class\njvm: java virtual machine java虚拟机：虚拟的计算机，实质是一个软件。让.class文件\n可以在该软件上运行。\n跨平台 jvm 是一个“桥梁”，是一个“中间件”，是实现跨平台的关键，java 代码首先被编译成字节码文件，再由 jvm 将字节码文件翻译成机器语言，从而达到运行 java 程序的目的。\n注意：编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过 jvm 翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由 jvm 翻译成的机器码却不一样。\n所以，运行 java 程序必须有 jvm 的支持，因为编译的结果不是机器码，必须要经过 jvm 的再次翻译才能执行。即使你将 java 程序打包成可执行文件（例如 .exe），仍然需要jvm的支持。\n注意：跨平台的是 java 程序，不是 jvm。jvm 是用 c/c++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 jvm。\n平台：支撑某种事物运行的环境 短信平台\n计算机平台 ： 计算机系统 windows linux 安卓 mac\n跨：可以在任意平台运行。\n跨平台实质: .class二进制字节码文件依靠jvm可以在任意的平台上运行。但是要求该平台装有jvm。 口号：writeonce run everywhere 一次编译 到处运行\n跨平台的实质：依靠jvm实现。\njre和jdk 定义 jre(java runtime enviroment) 是 java 的运行环境。面向 java 程序的使用者，而不是开发者。如果你仅下载并安装了 jre，那么你的系统只能运行 java 程序。jre 是运行 java 程序所必须环境的集合，包含 jvm 标准实现及 java 核心类库。它包括 java 虚拟机、java 平台核心类和支持文件。它不包含开发工具(编译器、调试器等)。\njdk(java development kit) 又称 j2sdk(java2 software development kit)，是 java 开发工具包，它提供了 java 的开发环境(提供了编译器 javac 等工具，用于将 java 文件编译为 class 文件)和运行环境(提 供了 jvm 和 runtime 辅助包，用于解析 class 文件使其得到运行)。如果你下载并安装了 jdk，那么你不仅可以开发 java 程序，也同时拥有了运行 java 程序的平台。jdk 是整个 java 的核心，包括了 java 运行环境(jre)，一堆 java 工具 tools.jar 和 java 标准类库 (rt.jar)。\n联系 jvm：java虚拟机 。用来运行class文件的。\njre：java runtime environment java运行环境。\njre = jvm + 核心类库。\njdk：java development kit java软件开发工具包。\njdk = jre + java开发工具\njdk包括了jre jre包括了jvm\njdk的下载与安装 下载jdk 首先我们需要下载java开发工具包jdk\n下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html\n在下载页面中你需要选择接受许可，并根据自己的系统选择对应的版本\n安装配置 原因：使想在任意目录运行的代码可以在任意目录运行\n下载后jdk的安装根据提示进行，还有安装jdk的时候也会安装jre，一并安装就可以了\n安装jdk，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 c:\\program files (x86)\\java\\jdk\n安装完成后，右击\u0026quot;我的电脑\u0026quot;，点击\u0026quot;属性\u0026quot;，选择\u0026quot;高级系统设置\u0026quot;；\n选择\u0026quot;高级\u0026quot;选项卡，点击\u0026quot;环境变量\u0026quot;；\n在 \u0026ldquo;系统变量\u0026rdquo; 中设置 3 项属性，java_home、path、classpath(大小写无所谓),若已存在则点击\u0026quot;编辑\u0026quot;，不存在则点击\u0026quot;新建\u0026quot;。\n注意：如果使用 1.5 以上版本的 jdk，不用设置 classpath 环境变量，也可以正常编译和运行 java 程序\n变量设置参数如下：\n变量名：java_home\n变量值：c:\\program files (x86)\\java\\jdk // 要根据自己的实际路径配置\n变量名：classpath\n变量值：.;%java_home%\\lib\\dt.jar;%java_home%\\lib\\tools.jar; //记得前面有个\u0026quot;.\u0026quot;\n变量名：path\n变量值：%java_home%\\bin;%java_home%\\jre\\bin;\n注意：在 windows10 中，path 变量里是分条显示的，我们需要将%java_home%\\bin;``%java_home%\\jre\\bin;分开添加，否则无法识别：\n测试jdk是否安装成功 \u0026ldquo;开始\u0026rdquo;-\u0026gt;\u0026ldquo;运行\u0026rdquo;，键入\u0026quot;cmd\u0026quot;；\n键入命令: java -version、java、javac 几个命令，出现以下信息，说明环境变量配置成功； java程序开发三个步骤 编写，编译，运行\njavac.exe编译器\njava.exe解释器\nhelloworld 工具\n记事本工具：\n记事本工具\n增强记事本: editplus、sublime text、notepad++\n集成开发环境:\nide：\n常用的： eclipse 、myeclipse、idea\njava第一个小案例:\n1.创建一个后缀名为.java的源文件 2.编辑代码\nclass hellworld{ //main：程序的入口main方法。 //public公开的权限修饰符 //static静态的目前的方法一直会带着，直到面向对象就可以去掉了。 //void无返回值的。 //main方法的名称，由于main方法，当前名称不可改变。 //(数据类型参数名称,数据类型参数名称)参数列表 //string类字符串用“”引来的字符,例如：\u0026#34;abc\u0026#34; //数组[] //args表示参数名称可以随便起名 //{}表示方法的范围 public static void main (string[] args){ //输出语句：在控制台上输出内容 //system.out.println(要输出的内容) //system系统的 //out表示输出 //print/ln表示打印加ln表示该行结束后换行。 //.表示调用关系 system.out.println(\u0026#34;helloworld\u0026#34;) } } helloworld注意事项\n​\t如果class前面用public修饰了，要求文件名与类名必须一致。并且一个java文件中，只能有一个public修饰的类，但是一个java文件中，如果都没有public修饰，可以放多个，要是有public修饰，有且只有一个可以用public修饰，并且类名与文件名相同，其它都不能用public。\n总结： ​\t一个java文件中，有且只有一个public修饰的类。 2.书写规则： ①{前面有一个空格，后面有一个换行缩进。 ②}一般跟着层次结构，最下面。 ③不同功能的代码段之间用空行表示。 ④运算符左右两侧会有空格。 1.人机交互 1.人机交互 人和计算机进行交流。方式：\n① 图形化界面：\n② 命令行:\n1\u0026gt; 进入：\na) win + r 调出运行窗口\n在里面输入cmd b)也可以通过在当前目录下 shift+鼠标右键 2\u0026gt;常见命令：\na)切换盘符：\n格式： 盘符 + [:] b)切换路径：\n格式 ：\ncd + 空格 + 路径 cd\\表示返回根目录。\ncd..表示返回上一层目录\n2.环境变量的配置 1.原因\n可以让javac的命令 可以在任意目录下运行。引入了环境变量。\npath：\nwindows系统查找可执行程序时，首先在当前目录下，查找，如果可以找到，直接执行，如果找不到，\n到path路径对应的路径里面查找，如果找到，执行，如果找不到，报异常。\n***3.配置方式：\n3.1直接配置法\n1.找到path环境变量：\n我的电脑右键-\u0026gt;属性\n2.校验：\njavac -version\n3.注意：\n① 配置时，如果有多个jdk，建议把需要当前使用的jdk配置在前面。因为path路径从前向后读\n取。\n② 每个路径需要分号进行路径分隔。\n3.2动态获取法\n1.目的：\n尽量减少对path路径的操作，减少由于对path路径的操作，而引起的问题。\n2.步骤：\n① 新建一个变量：\n变量名称:java_home\n注意：变量名称可以是任意起名，建议叫java_home\n② 动态获取：\n格式：\n%变量名称%\n③ 最终配置：\n4.环境变量配置的原因/好处\n可以让需要在任意目录下运行的命令，在任意目录下可以运行。\n3.helloworld第一个小程序 1.开发工具 1.记事本工具：\n① 记事本工具:notepad\n② 增强型记事本工具:editplus sublimetext3 notepad++\n2.集成开发环境：ide\neclipse idea myeclipse\n2.开发步骤：\n创建.java 后缀名称的源文件。\n编写代码\n编译代码： .class的二进制字节码文件。\n运行代码：将.class的二进制字节码文件 加载到jvm中 运行。\n调试代码： 代码有问题，运行报错。\n2.1 创建.java的源文件 1.注意扩展名必须是java 2.2 编写代码\njava的语法规则：\n① class ：类\n声明一个类：\nclass 类名 {\n}\n2.3 编译代码\n命令 ：javac\n格式：\njavac 文件名称.后缀名称\n注意：\njavac命令使用时，必须是文件的名称并且带后缀名。\n一个java文件中，可以存放多个class文件。\n编译后，编译成的是.class文件，并且以class的类名为名称。\n2.4 运行代码\n命令 ：java\n格式：\njava 类名\n2.5 程序的入口 称为main方法：又叫程序的入口。又叫主方法。\npublic static void main (string[] args) {\n}\n① public 公开的 公共的 :公园\n② static： 静态的。在面向对象学习之前，方法上需要加.\n③ void：无返回值的。\n④ main：规定该方法就叫main\n⑤ () 参数列表\n1》 string：字符串 格式用\u0026quot;\u0026ldquo;引起来的字符，所有的在双引号中的内容都是原样输出。“abc”\n2》[] 表示数组：\n3》 args 表示参数的名称 ，可以改变。\n⑥ 代码\nclass hw {\npublic static void main(string[] args){\n}\n}\n2.6 打印/输出语句\n① system：系统\n② out:输出\n③ print：打印\n三个单词用点进行连接。\n格式：\nsystem.out.print(123)\n注意：\n语句结束之后，用分号分隔表示语句结束。\nprint如果加ln表示在该语句输出之后，换行。\n代码：\nclass hw {\npublic static void main(string[] args){\nsystem.out.println(123);\nsystem.out.println(\u0026ldquo;abc\u0026rdquo;);\n}\n}\n2.7 练习\n**\n****4.书写程序时注意事项\n1.符号\n2.书写规则\n*3.public修饰类\n5.editplus工具\n1.字体\n必须是英文半角。\n① { 前面有一个空格，后面有一个换行 缩进。\n② } 一般跟着层次结构，最下面。\n③ 不同功能的代码段之间用空行表示。\n④ 运算符 左右两侧会有空格。\npublic修饰类：\n一旦public修饰类，类名必须与文件名相同。并且一个java文件中，有且仅有一个类能够被\npublic修饰。\n但是一个java文件中，可以有多个class存在。\n首选项\u0026ndash;》常规\u0026ndash;》字体2.配置编译和运行\n2.1 编译2.2 运行2.3 快捷键/自动补全\n使用缩写 +空格键进行自动补全2.4自定义 快捷键2.5去掉bak 备份\n6.注释\n1.作用\n2.注释的分类(***)\n对代码进行解释说明的文字。3.注释好处：\n关键字与标识符 7.1关键字\n1.关键字\n① 单行注释：对单行有效\n格式:\n//\n② 多行注释:对多行有效，不允许嵌套使用。\n格式：\n/* */\n③ 文档注释:多用于类或方法上进行解释说明。\n格式：\n/**\n*/\n① 解释说明\n② 排错\n③ 梳理思路\njava赋予了特殊含义的单词。\n例如：\nclass public void\n注意：\n(***) 保留字:\ngoto\nconst7.2 标识符\n1.标识符\n2.起名规则：\n起标识作用的符号，程序员为类、方法、变量等成员起的字符序列，用于区分不同的成员的字符序列。\n(***) 1.字母 数字 _ $ 组成，并且数字不能开头。\n2.支持中文，但是不建议用中文。\n3.区分大小写，但是不建议用大小写区分。\n4.不能使用关键字。\n5.不建议使用java中提供的类名。\n","date":"2021-10-12","permalink":"https://lovemjh.vercel.app/posts/java-1/20220430195146/","summary":"java简介 语言 计算机语言 语言： 交互 获取信息。 计算机语言：人与计算机进行交互，计算机为我们做事。 计算机语言发展： 机器语言：二进制 0 1 纸带打点，速度快 汇编语言：助","title":"java简介"},{"content":"","date":"0001-01-01","permalink":"https://lovemjh.vercel.app/posts/_template/","summary":"","title":""},{"content":"java基础 20220430195146 20220430195346 20220430200635 20220430210211 20220430210364 20220430211218 20220430211406 20220430212064 20220430212111 20220430212354 java中级 20220430214030 20220430214135 20220430212581 20220430214286 20220430214272 20220430214372 20220430214396 20220430214484 20220430214426 20220430222140 web部分 20220430214595 20220430214665 20220430214800 20220430214937 20220430214943 20220430214936 20220430215029 20220430215026 20220430225784 javaee 20220430215127 20220430215286 20220430215283 20220430215319 20220430215358 20220430215387 java框架 20220430230955 20220430230666 20220524223082 20220430215722 20220526003427 20220526005077 20220526160511 20220526162071 20220526204358 20220526213257 20220526214937 20220526235888 001 20220430223384 20220430223589 20220430223848 20220524210558 20220524212885 工具和中间件 20220430230003 20220430230448 20220523233691 20220526164948 20220526203627 20220526204447 20220526205691 20220526220934 20220527215246 项目实践 20220430225457 20220518154841 20220522222541 20220528222829 20220528224436 20220528231163 20220528232959 20220528234610 20220529000803 20220529001925 微服务项目实践 20220527220542 20220527221560 20220527222325 20220527224880 20220527231000 20220527231757 20220527233134 20220528162731 20220528165279 20220528170121 20220528171137 20220528172145 20220528172837 20220528173393 20220528174166 blog 20220430231095 20220430231253 20220430231411 20220430231595 20220430231513 20220713223482 20220807155029 20220807155717 %% kanban:settings\n{\u0026#34;kanban-plugin\u0026#34;:\u0026#34;basic\u0026#34;,\u0026#34;metadata-keys\u0026#34;:[{\u0026#34;metadatakey\u0026#34;:\u0026#34;title\u0026#34;,\u0026#34;label\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;shouldhidelabel\u0026#34;:false,\u0026#34;containsmarkdown\u0026#34;:false}],\u0026#34;lane-width\u0026#34;:220} %%\n","date":"0001-01-01","permalink":"https://lovemjh.vercel.app/posts/_%E7%9B%AE%E5%BD%95/","summary":"Java基础 20220430195146 20220430195346 20220430200635 20220430210211 20220430210364 20220430211218 20220430211406 20220430212064 20220430212111 20220430212354 Java中级 20220430214030 20220430214135 20220430212581 20220430214286 20220430214272 20220430214372 20220430214396 20220430214484 20220430214426 20220430222140 web部分 20220430214595 20220430214665 20220430214800 20220430214937 20220430214943 20220430214936 20220430215029 20220430215026 20220430225784 JavaEE 20220430215127 20220430215286 20220430215283 20220430215319 20220430215358 20220430215387 Java框架 20220430230955 20220430230666 20220524223082 20220430215722 20220526003427 20220526005077 20220526160511 20220526162071 20220526204358 20220526213257 20220526214937 20220526235888 001 20220430223384 20220430223589 20220430223848 20220524210558 20220524212885 工具和","title":""},{"content":"","date":"0001-01-01","permalink":"https://lovemjh.vercel.app/posts/java-web/20220430214943/","summary":"","title":"json"},{"content":"jsp 1. 理解 java server page 一种动态页面技术。本质上就是servlet 运行原理：将jsp文件 ----\u0026gt; .java ----\u0026gt; .class 运行 2. jsp的使用策略 1. 可以当成纯粹的页面使用 和 html 使用语法一样(推荐) 2. 可以当成纯粹的java代码使用 \u0026lt;% java代码 %\u0026gt; 3. 可以实现页面中嵌套java代码 jsp和servlet各司其职：将业务处理和页面展示分离 jsp只做页面数据展示 servlet处理业务 3. jsp的核心内容 ① 三大指令 · page 指定页面的初始化配置信息(通常取默认值即可) contenttype=\u0026#34;text/html;charset=utf-8\u0026#34; 内容的类型 language=\u0026#34;java\u0026#34; 支持语言 import=\u0026#34;java.util.arraylist\u0026#34; 引入依赖包 autoflush=\u0026#34;true\u0026#34; 刷新当前页面 session=\u0026#34;true\u0026#34; 是否可用session errorpage=\u0026#34;02-error.jsp\u0026#34; 当前页面异常 指定跳转的错误页 iselignored=\u0026#34;false\u0026#34; 是否忽略el表达式 · taglib 引入第三方标签库 \u0026lt;%@taglib prefix=\u0026#34;c\u0026#34; uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; %\u0026gt; · include 包含其他页面 \u0026lt;%@include file=\u0026#34;02-header.jsp\u0026#34;%\u0026gt; ② 六大动作 1. 转发 \u0026lt;%--动作1：完全转发--%\u0026gt; \u0026lt;%--\u0026lt;jsp:forward page=\u0026#34;02-three.jsp\u0026#34;\u0026gt;\u0026lt;/jsp:forward\u0026gt;--%\u0026gt; \u0026lt;%--动作2：不完全转发--%\u0026gt; \u0026lt;jsp:include page=\u0026#34;02-three.jsp\u0026#34;\u0026gt;\u0026lt;/jsp:include\u0026gt; \u0026lt;%-- 动作3:转发携带参数 --%\u0026gt; \u0026lt;jsp:param name=\u0026#34;xx\u0026#34; value=\u0026#34;王二小\u0026#34;/\u0026gt; 2. 使用对象 \u0026lt;%--动作4：使用对象--%\u0026gt; \u0026lt;jsp:usebean id=\u0026#34;p\u0026#34; class=\u0026#34;com.ujiuye.bean.person\u0026#34;\u0026gt;\u0026lt;/jsp:usebean\u0026gt; \u0026lt;%--动作5：设置对象属性--%\u0026gt; \u0026lt;jsp:setproperty name=\u0026#34;p\u0026#34; property=\u0026#34;name\u0026#34; value=\u0026#34;王二小\u0026#34;\u0026gt;\u0026lt;/jsp:setproperty\u0026gt; \u0026lt;%--动作6：获取对象属性值--%\u0026gt; \u0026lt;jsp:getproperty name=\u0026#34;p\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; ③ 九大内置对象 内置对象 天生自带的对象 out 页面输出对象 exception 异常对象 request 请求对象 response 响应对象 application servletcontext session\t会话 config servlet配置对象 page this pagecontext\t最小共享域对象 范围只在当前页面共享 可以实现操作任何共享域的数据 ④ el表达式 格式： ${} 作用： 获取共享域中的数据 原理：根据属性的get方法名取数据 和属性名没有关系 // map.get(map2); ----\u0026gt; map.map2 // xifu.getname(); ----\u0026gt; xifu.name ⑤ jstl标签库 理解： 便于jsp中对数据展示的一些标签 使用： 1. 下载导包 jstl.jar standard.jar 2. 使用指令引入当前jsp页面中 \u0026lt;%@ taglib prefix=\u0026#34;c\u0026#34; uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; %\u0026gt; 3. 常见标签 \u0026lt;%--1. 遍历集合标签--%\u0026gt; \u0026lt;c:foreach items=\u0026#34;集合\u0026#34; var=\u0026#34;集合每一个元素变量\u0026#34;\u0026gt; \u0026lt;%--2. 普通遍历--%\u0026gt; \u0026lt;c:foreach begin=\u0026#34;起始值\u0026#34; end=\u0026#34;结束值\u0026#34; step=\u0026#34;步长\u0026#34; var=\u0026#34;变量名\u0026#34;\u0026gt; \u0026lt;%--3. 判断--%\u0026gt; \u0026lt;c:if test=\u0026#34;判断条件\u0026#34;\u0026gt; \u0026lt;%--4. 变量操作--%\u0026gt; \u0026lt;%--变量的定义--%\u0026gt; \u0026lt;c:set var=\u0026#34;num\u0026#34; value=\u0026#34;200\u0026#34;\u0026gt;\u0026lt;/c:set\u0026gt; \u0026lt;%--获取变量值--%\u0026gt; \u0026lt;c:out value=\u0026#34;${num }\u0026#34; default=\u0026#34;未定义\u0026#34;\u0026gt;\u0026lt;/c:out\u0026gt; \u0026lt;%--删除变量--%\u0026gt; \u0026lt;%--\u0026lt;c:remove var=\u0026#34;num\u0026#34;\u0026gt;\u0026lt;/c:remove\u0026gt;--%\u0026gt; \u0026lt;%--5. 选择标签--%\u0026gt; \u0026lt;c:choose\u0026gt; \u0026lt;c:when test=\u0026#34;${num \u0026gt; 100 }\u0026#34;\u0026gt; vip老白菜 \u0026lt;/c:when\u0026gt; \u0026lt;c:when test=\u0026#34;${num \u0026gt; 50 }\u0026#34;\u0026gt; vip大白菜 \u0026lt;/c:when\u0026gt; \u0026lt;c:when test=\u0026#34;${num \u0026gt; 20 }\u0026#34;\u0026gt; vip小白菜 \u0026lt;/c:when\u0026gt; \u0026lt;c:otherwise\u0026gt; vip没白菜 \u0026lt;/c:otherwise\u0026gt; \u0026lt;/c:choose\u0026gt; 登录注册 注册 ① 注册页面 register.jsp ② 编写registservlet处理 注册业务 注册成功跳转登录页 ③ 编写登录页面 login.jsp 登录 ① login.jsp ② 编写loginservlet处理登录业务 登录成功跳转到首页的homeservlet ③ 编写 homeservlet ④ 编写 home.jsp ","date":"0001-01-01","permalink":"https://lovemjh.vercel.app/posts/javaee/20220430215319/","summary":"JSP 1. 理解 Java Server Page 一种动态页面技术。本质上就是Servlet 运行原理：将jsp文件 ----\u0026gt; .java ----\u0026gt; .class 运行 2. JSP的使用策略 1. 可以当成纯粹的页面使用 和 html 使用语法一样(推荐) 2. 可","title":"jsp"},{"content":"","date":"0001-01-01","permalink":"https://lovemjh.vercel.app/posts/javaee/20220430215358/","summary":"","title":"mvc"},{"content":"web核心 1. 服务器 理解 web服务器一般是指网站服务器，为软件提供后台服务的软件。相当于远程的一台计算机包含磁盘 cpu 内存和服务器软件等。我们这里的服务器指 服务器软件 常见服务器软件： tomcat(apacha) 目前最流行的javaweb服务器软件。开源免费 jboss weblogic ...... tomcat的使用 1. 下载 解压 apache-tomcat-8.5.20-windows-x64.zip 解压的目录不要过深 不要有中文 2. 配置好jdk 需要配置java_home环境变量 目录： bin：tomcat二进制启动文件 conf：tomcat配置文件 lib: tomcat依赖包 logs: tomcat运行的日志信息 temp：临时文件 webapps: web工程 work：编译文件 2. idea与tomcat整合 servlet 理解： servlet 是运行在 web 服务器中的小型 java 程序。servlet 通常通过 http（超文本传输协议）接收和响应来自 web 客户端的请求。 ① servlet是一个java接口 ② 需要运行在服务器中 ③ 可以处理来自客户端的请求和响应 作用： 处理来自客户端的请求和响应 使用： ① 自定义类实现servlet接口 ② 实现servlet中未实现方法 5 ③ 配置servlet的访问路径 在web.xml文件中配置 \u0026lt;!--声明servlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;myservlet1\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.ujiuye.servlet.myservlet1\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--配置访问路径--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;myservlet1\u0026lt;/servlet-name\u0026gt; \u0026lt;!--http://localhost:8080/javaweb_day11_web/xx--\u0026gt; \u0026lt;url-pattern\u0026gt;/xx\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 使用注意事项 1. servlet是由谁实例化的？ 由tomcat服务器(servlet容器)实例化的 2. servlet实例化几次？只初始化一次 3. servlet什么时候初始化的？第一次请求 4. 一个servlet可以设置多少个访问路径？可以设置多个访问路径 5. 一个路径可以访问多个servlet吗？一个路径只能映射一个servlet 6. 路径多元化 /xx 一层 /xx/xxx/xxxx 多层 /* 除去已经配置过的路径的其他任意路径 *.png 后缀的形式 浏览器请求servlet的过程 1. 当浏览器url中输入http://localhost:8080/javaweb_day11_web/xx 2. 根据/xx 匹配web.xml中的\u0026lt;servlet-mapping\u0026gt;中的\u0026lt;url-pattern\u0026gt; 3. 没有匹配到 报404未找到 如果匹配到 4. 再根据匹配到的\u0026lt;servlet-mapping\u0026gt;中的\u0026lt;servlet-name\u0026gt;,根据这个\u0026lt;servlet-name\u0026gt; 进步匹配 \u0026lt;servlet\u0026gt;中的\u0026lt;servlet-name\u0026gt; 5. 没有匹配到 报404未找到 如果匹配到 6. 根据当前的\u0026lt;servlet-name\u0026gt;找对应的\u0026lt;servlet-class\u0026gt; 7. 反射机制加载当前类 servlet的生命周期方法 init 初始化方法 默认当第一次请求servlet时执行该方法 对servlet做初始化操作。 service 处理客户端请求和响应 实现浏览器和servlet交互 destory 销毁方法 服务器关闭 移出应用 tomcat销毁当前servlet servlet的进化史 1. genericservlet抽象类 实现了servlet接口，并且实现了除service之外的其他方法 2. httpservlet 继承了genericservlet 实现service方法 根据http协议的请求方式执行不同的方法doxx,然后定义自己的service方法。开发者使用只需要重写对应请求方式的doxx 或者重写service方法\t注解的方式使用httpservlet ","date":"0001-01-01","permalink":"https://lovemjh.vercel.app/posts/javaee/20220430215127/","summary":"Web核心 1. 服务器 理解 web服务器一般是指网站服务器，为软件提供后台服务的软件。相当于远程的一台计算机包含磁盘 CPU 内存和服务器软件等。我们这里的服务器指 服务器软件","title":"tomcat"},{"content":"","date":"0001-01-01","permalink":"https://lovemjh.vercel.app/posts/java-2/20220430214484/","summary":"","title":"图形界面"},{"content":"学生管理系统 一、回顾 1. servlet 使用 注意事项 生命周期方法 进化史 注解的形式创建servlet 2. request和response request 获取请求信息 请求行 请求头 请求正文 转发 response 响应信息 响应行 响应头 响应正文(文本、字节) 重定向 3. 共享域：servletcontext session request 4. jsp(三大指令、六大动作、九大内置对象、el、jstl标签库) 5. 会话(cookie/session) 二、mvc和三层结构 mvc设计模式 m model 模型(数据模型 业务模型 数据访问模型...) v view 视图(展示数据 jsp html) c controller 控制器(控制哪些数据 和 哪些页面 响应) 三层结构(项目的三层包) web层与客户端交互 ---- servlet service 业务层 ---- 处理业务的类 dao数据库访问层 ---- 处理数据库数据操作的 1. 上一层可以调用下一层，但是下一层不能调用上一层 2. 不能隔层调用 一个表对应一个dao 对应一个业务类 对应一个实体类 对应一个servlet 三、学生管理系统 1. 功能 1. 学生信息添加 2. 学生信息修改 3. 学生信息删除(单删、多删) 4. 学生展示(分页展示) 2.思路 1. 分析技术、分析库和表 2. 准备jar 工具类 配置文件等 3. 库表 创建 4. 搭建环境 ① 搭建项目结构 ② 引入jar 工具类 配置文件等 5. 编码 3. 优化servlet 目的：实现一个表对应一个servlet 防止servlet创建过多 具体封装： package com.ujiuye.web.servlet; import javax.servlet.servletexception; import javax.servlet.annotation.webservlet; import javax.servlet.http.httpservlet; import javax.servlet.http.httpservletrequest; import javax.servlet.http.httpservletresponse; import java.io.ioexception; import java.lang.reflect.method; @webservlet(name = \u0026#34;baseservlet\u0026#34;) public class baseservlet extends httpservlet { @override protected void service(httpservletrequest req, httpservletresponse resp) throws servletexception, ioexception { // 要么 new 要么 反射 // 1. 获取类对象 获取方法名 // 1.1 获取方法名 string method = req.getparameter(\u0026#34;method\u0026#34;); if(method==null){ method = \u0026#34;home\u0026#34;; } // 1.2 获取类对象 class\u0026lt;? extends baseservlet\u0026gt; clazz = this.getclass(); // 2. 调用方法 try { method m = clazz.getmethod(method, httpservletrequest.class, httpservletresponse.class); m.invoke(this, req, resp); } catch (exception e) { e.printstacktrace(); } } } 使用：自定义类 继承baseservlet即可 4. 入口的处理 index.jsp \u0026lt;%@ page contenttype=\u0026#34;text/html;charset=utf-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;入口页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%--跳转首页之前 从后台获取数据--%\u0026gt; \u0026lt;jsp:forward page=\u0026#34;stu\u0026#34;\u0026gt; \u0026lt;jsp:param name=\u0026#34;method\u0026#34; value=\u0026#34;home\u0026#34;/\u0026gt; \u0026lt;/jsp:forward\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5. 首页展示 index.jsp ----\u0026gt; studentservlet中home方法 获取学生信息 保存到共享域中 ----\u0026gt; 跳转到home.jsp中展示 6. 添加学生 index.jsp 点击添加按钮 ----\u0026gt; studentservlet 中的addstuui方法 ----\u0026gt; 跳转addstu.jsp中 ----\u0026gt; studentservlet中的addstu方法 (----\u0026gt; studentserviceimpl ----\u0026gt; studentdaoimpl ----\u0026gt;) 跳转到首页 ----\u0026gt; studentservlet中home方法 获取学生信息 保存到共享域中 ----\u0026gt; 跳转到home.jsp中展示 文件上传要求： 页面要求： 需要指定：enctype=multipart/form-data 提交方式必须是 post type=file \u0026lt;form action=\u0026#34;stu?method=addstu\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; servlet要求：添加@multipartconfig 在类上 jsp中加载本地路径下的图片需要挂载服务器路径： 7. 修改学生 home.jsp中点击修改按钮 -----\u0026gt; studentservlet的updatestuui方法 获取修改的学生信息 ----\u0026gt; updatestu.jsp 回显老数据 修改 ----\u0026gt; studentservlet的updatestu方法 ----\u0026gt; (studentserviceimpl ----\u0026gt; studentdaoimpl) 跳转到首页获取新的数据 8. 删除学生 单删\thome.jsp中点击删除按钮 ----\u0026gt; studentservlet的delstu方法 ----\u0026gt; (studentserviceimpl ----\u0026gt; studentdaoimpl)跳转到首页获取新的数据 批量删除 home.jsp中选中删除的数据 学生管理之分页 1. 分析 ① 页面需要什么数据 · 当前页的数据 （数据库查询） · 当前页的页码 （页面） · 共多少页 · 一页显示多少条数据 （自己定义） · 共多少条数据 （数据库查询） ② 这些数据都需要保存到共享域中 ，将以上这些数据封装到一个类中 public class pagebean\u0026lt;t\u0026gt; { private int currentpage; // 当前页 页码 private int totalcount; // 数据总数 private int pagesize = 6; // 一页显示多少条数据 private int totalpage; // 一共多少页 private list\u0026lt;t\u0026gt; list; // 当前页显示的数据 2. 编码 studentservlet中 // 分页显示首页数据 public string home(httpservletrequest request, httpservletresponse response){ // 1. 获取请求携带参数 string currentpage = request.getparameter(\u0026#34;currentpage\u0026#34;); if(currentpage==null){ currentpage = \u0026#34;1\u0026#34;; } // 2. 调用业务 获取结果 pagebean\u0026lt;student\u0026gt; pagebean = service.findbypage(currentpage); // 3. 保存共享域 request.setattribute(\u0026#34;pagebean\u0026#34;, pagebean); // 4. 转发 return \u0026#34;home_page.jsp\u0026#34;; } studentserviceimpl中 @override public pagebean\u0026lt;student\u0026gt; findbypage(string currentpage) { // 1. 处理分页业务 pagebean\u0026lt;student\u0026gt; pagebean = new pagebean\u0026lt;\u0026gt;(); // 2. 将需要的数据封装到pagebean中 // 2.1 当前页的页码封装到pagebean中 int cp = integer.parseint(currentpage); pagebean.setcurrentpage(cp); // 2.2 将数据总数封装到pagebean中 int totalcount = dao.findcount(); pagebean.settotalcount(totalcount); // 2.3 共多少页 总个数/一页的数据个数 6 36 37 int pagesize = pagebean.getpagesize(); int totalpage = (int) math.ceil(totalcount*1.0/pagesize); pagebean.settotalpage(totalpage); // 2.4 当前页的数据 s limit (n-1)* list\u0026lt;student\u0026gt; list = dao.findstubypage(cp, pagesize); pagebean.setlist(list); // 2.5 起始页码和 结束页面封装到pagebean if(totalpage \u0026lt;= 10){ pagebean.setstartpage(1); pagebean.setendpage(totalpage); }else{ if(cp \u0026lt;= 6 ){ pagebean.setstartpage(1); pagebean.setendpage(10); }else if(totalpage - cp \u0026lt; 4){ pagebean.setstartpage(totalpage - 9); pagebean.setendpage(totalpage); }else{ pagebean.setstartpage(cp - 5); pagebean.setendpage(cp + 4); } } return pagebean; } home_page.jsp \u0026lt;%-- created by intellij idea. user: junguang date: 2021/12/10 time: 11:22 to change this template use file | settings | file templates. --%\u0026gt; \u0026lt;%@ page contenttype=\u0026#34;text/html;charset=utf-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;%@taglib prefix=\u0026#34;c\u0026#34; uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;c:if test=\u0026#34;${pagebean.list.size() \u0026lt;= 0 }\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;没有学生信息，赶紧\u0026lt;a href=\u0026#34;stu?method=addstuui\u0026#34;\u0026gt;添加\u0026lt;/a\u0026gt;吧！\u0026lt;/h2\u0026gt; \u0026lt;/c:if\u0026gt; \u0026lt;c:if test=\u0026#34;${pagebean.list.size() \u0026gt; 0 }\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;800\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;caption\u0026gt;\u0026lt;a href=\u0026#34;stu?method=addstuui\u0026#34;\u0026gt;添加学生\u0026lt;/a\u0026gt;\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026#34;width: 10%;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; onclick=\u0026#34;delmore()\u0026#34;\u0026gt;批量删除\u0026lt;/a\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026#34;width: 10%;\u0026#34;\u0026gt;学号\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026#34;width: 10%;\u0026#34;\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026#34;width: 10%;\u0026#34;\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026#34;width: 10%;\u0026#34;\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026#34;width: 20%;\u0026#34;\u0026gt;身份证号\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026#34;width: 10%;\u0026#34;\u0026gt;入校日期\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026#34;width: 10%;\u0026#34;\u0026gt;头像\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026#34;width: 10%;\u0026#34;\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;c:foreach items=\u0026#34;${pagebean.list }\u0026#34; var=\u0026#34;stu\u0026#34;\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;${stu.sid }\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.sid }\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.sname }\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.gender==1?\u0026#39;男\u0026#39;:\u0026#39;女\u0026#39; }\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age }\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.cardno }\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.hiredate }\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;img src=\u0026#34;/stuimg/${stu.pic }\u0026#34; width=\u0026#34;50\u0026#34; height=\u0026#34;50\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026#34;stu?method=updatestuui\u0026amp;sid=${stu.sid }\u0026#34;\u0026gt;修改\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34; onclick=\u0026#34;del(\u0026#39;${stu.sid }\u0026#39;)\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/c:foreach\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;%--页码展示--%\u0026gt; \u0026lt;center\u0026gt; \u0026lt;%--首页--%\u0026gt; \u0026lt;a href=\u0026#34;stu?method=home\u0026#34;\u0026gt;首页\u0026lt;/a\u0026gt; \u0026lt;%--上一页--%\u0026gt; \u0026lt;c:if test=\u0026#34;${pagebean.currentpage \u0026gt; 1 }\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;stu?method=home\u0026amp;currentpage=${pagebean.currentpage-1 }\u0026#34;\u0026gt;上一页\u0026lt;/a\u0026gt; \u0026lt;/c:if\u0026gt; \u0026lt;%--每一页页码--%\u0026gt; \u0026lt;c:foreach begin=\u0026#34;${pagebean.startpage }\u0026#34; end=\u0026#34;${pagebean.endpage }\u0026#34; step=\u0026#34;1\u0026#34; var=\u0026#34;i\u0026#34;\u0026gt; \u0026lt;c:if test=\u0026#34;${pagebean.currentpage==i }\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;stu?method=home\u0026amp;currentpage=${i }\u0026#34; style=\u0026#34;display: inline-block; text-decoration: none; width: 20px; height: 20px; background-color: green; border-radius: 5px; color: white\u0026#34;\u0026gt;${i }\u0026lt;/a\u0026gt; \u0026lt;/c:if\u0026gt; \u0026lt;c:if test=\u0026#34;${pagebean.currentpage != i }\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;stu?method=home\u0026amp;currentpage=${i }\u0026#34; style=\u0026#34;display: inline-block; text-decoration: none; width: 20px; height: 20px; background-color: #c3c3c3; border-radius: 5px; color: white\u0026#34;\u0026gt;${i }\u0026lt;/a\u0026gt; \u0026lt;/c:if\u0026gt; \u0026lt;/c:foreach\u0026gt; \u0026lt;%--下一页--%\u0026gt; \u0026lt;c:if test=\u0026#34;${pagebean.currentpage \u0026lt; pagebean.totalpage }\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;stu?method=home\u0026amp;currentpage=${pagebean.currentpage+1 }\u0026#34;\u0026gt;下一页\u0026lt;/a\u0026gt; \u0026lt;/c:if\u0026gt; \u0026lt;%--尾页--%\u0026gt; \u0026lt;a href=\u0026#34;stu?method=home\u0026amp;currentpage=${pagebean.totalpage }\u0026#34;\u0026gt;尾页\u0026lt;/a\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;/c:if\u0026gt; \u0026lt;script src=\u0026#34;jquery/jquery-1.4.2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 单删 function del(sid){ // 弹提示框 if(confirm(\u0026#34;确定删除吗？\u0026#34;)){ window.location.href = \u0026#34;stu?method=delstu\u0026amp;sid=\u0026#34;+sid; } } // 多删 function delmore(){ // 1. 获取选中的复选框 var sids = \u0026#34;\u0026#34;; $.each($(\u0026#34;input:checked\u0026#34;), function(index, eml){ sids += \u0026#34;,\u0026#34;+eml.value }) sidss = sids.substring(1); // 2. sids是否有值 if(sidss==null || \u0026#34;\u0026#34;==sidss){ alert(\u0026#34;请选择要删除的数据\u0026#34;); }else{ if(confirm(\u0026#34;确定删除吗?\u0026#34;)){ window.location.href = \u0026#34;stu?method=delmore\u0026amp;sids=\u0026#34;+sidss; } } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; filter\u0026mdash;\u0026ndash;listener 20220430215387\n","date":"0001-01-01","permalink":"https://lovemjh.vercel.app/posts/project/20220430225457/","summary":"学生管理系统 一、回顾 1. Servlet 使用 注意事项 生命周期方法 进化史 注解的形式创建Servlet 2. request和response request 获取请求信息 请求行 请求头 请求正文 转发 response 响应","title":"学生管理系统"},]
            
        
    </div>

    <div id="search">
        
        <span class="sc-icon"><img src="/imgs/icons/search.svg" width="48"> </span>
        <span id="sc-clear" onclick="clearInputVal()">✖</span>
        <input id="sc-input" oninput="search()" type="text" placeholder="here search search..." />
        <div id="sc-res"></div>
    </div>
    <script src="/js/search.js" defer></script>
</div>

    


    
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    <a href="//beian.miit.gov.cn" target="_blank">
        
        豫ICP备2022002918号
        
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
</div></div>
    </body>
</html>
